Index,code,comment,label
1,"public ActivationDescriptor()
{
_desc = new cudnnActivationDescriptor();
res = CudaDNNNativeMethods.cudnnCreateActivationDescriptor(ref _desc);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cudnnCreateTensorDescriptor"", res));
if (res != cudnnStatus.Success) throw new CudaDNNException(res);
}",An opaque structure holding the description of an activation operation.,1
2,"public void Dispose()
{
Dispose(true);
GC.SuppressFinalize(this);
}",Dispose,1
3,"~ActivationDescriptor()
{
Dispose(false);
}",For dispose,1
4,"public struct BNConstants
{
/// <summary>
/// MinEpsilon = 1e-5
/// </summary>
public const double MinEpsilon = 1e-5;
}",Constant values for BN,0
5,"public struct bsric02Info
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sparse triangular solve information,0
6,"public struct bsrilu02Info
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sparse triangular solve information,0
7,"public struct bsrsm2Info
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sparse triangular solve information,0
8,"public struct bsrsv2Info
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sparse triangular solve information,0
9,"public void Dispose()
{
Dispose(true);
GC.SuppressFinalize(this);
}",Dispose,1
10,"public void Dispose()
{
Dispose(true);
GC.SuppressFinalize(this);
}",Dispose,1
11,"~ConvolutionDescriptor()
{
Dispose(false);
}",For dispose,1
12,"~ConvolutionDescriptor()
{
Dispose(false);
}",For dispose,1
13,"public struct csrgemm2Info
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding sparse gemm information,0
14,"public struct csric02Info
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sparse triangular solve information,0
15,"public struct csrilu02Info
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sparse triangular solve information,0
16,"~CsrQrInfo()
{
Dispose(false);
}",For dispose,1
17,"~CsrQrInfo()
{
Dispose(false);
}",For dispose,1
18,"public struct csrsv2Info
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sparse triangular solve information,0
19,"public struct csru2csrInfo
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sorting information,0
20,"~CTCLossDescriptor()
{
Dispose(false);
}",For dispose,1
21,"public struct CUarray
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",CUDA array,0
22,"public ActivationDescriptor()
{
_desc = new cudnnActivationDescriptor();
res = CudaDNNNativeMethods.cudnnCreateActivationDescriptor(ref _desc);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cudnnCreateTensorDescriptor"", res));
if (res != cudnnStatus.Success) throw new CudaDNNException(res);
}",An opaque structure holding the description of an activation operation.,1
23,"public void Dispose()
{
Dispose(true);
GC.SuppressFinalize(this);
}",Dispose,1
24,"public void Dispose()
{
Dispose(true);
GC.SuppressFinalize(this);
}",Dispose,1
25,"~ActivationDescriptor()
{
Dispose(false);
}",For dispose,1
26,"public struct BNConstants
{
/// <summary>
/// MinEpsilon = 1e-5
/// </summary>
public const double MinEpsilon = 1e-5;
}",Constant values for BN,1
27,"public void Dispose()
{
Dispose(true);
GC.SuppressFinalize(this);
}",Dispose,1
28,"~ConvolutionDescriptor()
{
Dispose(false);
}",For dispose,1
29,"~CsrQrInfo()
{
Dispose(false);
}",For dispose,1
30,"public struct csrsv2Info
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sparse triangular solve information,1
31,"public struct csru2csrInfo
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sorting information,1
32,"~CTCLossDescriptor()
{
Dispose(false);
}",For dispose,1
33,"public struct CUarray
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",CUDA array,0
34,"~CudaFFTPlanMany64()
{
Dispose(false);
}",For dispose,1
35,"~CudaGraph()
{
Dispose(false);
}",For dispose,1
36,"~CudaGraphExec()
{
Dispose(false);
}",For dispose,1
37,"~CudaGraphicsInteropResourceCollection()
{
Dispose(false);
}",For dispose,1
38,"~CudaJitOption()
{
Dispose(false);
}",For dispose,1
39,"~CudaJitOptionCollection()
{
Dispose(false);
}",For dispose,1
40,"public struct CUDA_KERNEL_NODE_PARAMS
{
/// <summary>
/// Kernel to launch
/// </summary>
public CUfunction func;
/// <summary>
/// Width of grid in blocks
/// </summary>
public uint gridDimX;
/// <summary>
/// Height of grid in blocks
/// </summary>
public uint gridDimY;
/// <summary>
/// Depth of grid in blocks
/// </summary>
public uint gridDimZ;
/// <summary>
/// X dimension of each thread block
/// </summary>
public uint blockDimX;
/// <summary>
/// Y dimension of each thread block
/// </summary>
public uint blockDimY;
/// <summary>
/// Z dimension of each thread block
/// </summary>
public uint blockDimZ;
/// <summary>
/// Dynamic shared-memory size per thread block in bytes
/// </summary>
public uint sharedMemBytes;
/// <summary>
/// Array of pointers to kernel parameters
/// </summary>
public IntPtr kernelParams;
/// <summary>
/// Extra options
/// </summary>
public IntPtr extra; }",GPU kernel node parameters,1
41,"public struct CUDA_HOST_NODE_PARAMS
{
/// <summary>
/// The function to call when the node executes
/// </summary>
public CUhostFn fn;
/// <summary>
/// Argument to pass to the function
/// </summary>
public IntPtr userData; }",Host node parameters,1
42,"public void GetrfBatchedS(int n, CudaDeviceVariable<CUdeviceptr> A, int lda, CudaDeviceVariable<int> P,
CudaDeviceVariable<int> INFO, int batchSize)
{
_status = CudaBlasNativeMethods.cublasSgetrfBatched(_blasHandle, n, A.DevicePointer, lda, P.DevicePointer, INFO.DevicePointer, batchSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cublasSgetrfBatched"", _status));
if (_status != CublasStatus.Success) throw new CudaBlasException(_status);
}","If info = i, aii is 0. The factorization has been completed, but U is exactly singular.",1
43,"public void GetrfBatchedD(int n, CudaDeviceVariable<CUdeviceptr> A, int lda, CudaDeviceVariable<int> P,
CudaDeviceVariable<int> INFO, int batchSize)
{
_status = CudaBlasNativeMethods.cublasDgetrfBatched(_blasHandle, n, A.DevicePointer, lda, P.DevicePointer, INFO.DevicePointer, batchSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cublasDgetrfBatched"", _status));
if (_status != CublasStatus.Success) throw new CudaBlasException(_status);
}","If info = i, aii is 0. The factorization has been completed, but U is exactly singular.",1
44,"public void GetrfBatchedC(int n, CudaDeviceVariable<CUdeviceptr> A, int lda,
CudaDeviceVariable<int> P, CudaDeviceVariable<int> INFO, int batchSize)
{
_status = CudaBlasNativeMethods.cublasCgetrfBatched(_blasHandle, n, A.DevicePointer, lda, P.DevicePointer, INFO.DevicePointer, batchSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cublasCgetrfBatched"", _status));
if (_status != CublasStatus.Success) throw new CudaBlasException(_status);
}","If info = i, aii is 0. The factorization has been completed, but U is exactly singular.",1
45,"public void GetrfBatchedZ(int n, CudaDeviceVariable<CUdeviceptr> A, int lda,
CudaDeviceVariable<int> P, CudaDeviceVariable<int> INFO, int batchSize)
{
_status = CudaBlasNativeMethods.cublasZgetrfBatched(_blasHandle, n, A.DevicePointer, lda, P.DevicePointer, INFO.DevicePointer, batchSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cublasZgetrfBatched"", _status));
if (_status != CublasStatus.Success) throw new CudaBlasException(_status);
}","If info = i, aii is 0. The factorization has been completed, but U is exactly singular.",1
46,"public void GetriBatchedS(int n, CudaDeviceVariable<CUdeviceptr> Aarray, int lda, CudaDeviceVariable<int> P,
CudaDeviceVariable<CUdeviceptr> Carray, int ldc, CudaDeviceVariable<int> INFO, int batchSize)
{
_status = CudaBlasNativeMethods.cublasSgetriBatched(_blasHandle, n, Aarray.DevicePointer, lda, P.DevicePointer, Carray.DevicePointer, ldc, INFO.DevicePointer, batchSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cublasSgetriBatched"", _status));
if (_status != CublasStatus.Success) throw new CudaBlasException(_status);
}","If info = k, U(k,k) is 0. The U is exactly singular and the inversion failed.",1
47,"public void GetriBatchedD(int n, CudaDeviceVariable<CUdeviceptr> Aarray, int lda, CudaDeviceVariable<int> P,
CudaDeviceVariable<CUdeviceptr> Carray, int ldc, CudaDeviceVariable<int> INFO, int batchSize)
{
_status = CudaBlasNativeMethods.cublasDgetriBatched(_blasHandle, n, Aarray.DevicePointer, lda, P.DevicePointer, Carray.DevicePointer, ldc, INFO.DevicePointer, batchSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cublasDgetriBatched"", _status));
if (_status != CublasStatus.Success) throw new CudaBlasException(_status);
}","If info = k, U(k,k) is 0. The U is exactly singular and the inversion failed.",1
48,"public void GetriBatchedC(int n, CudaDeviceVariable<CUdeviceptr> Aarray, int lda, CudaDeviceVariable<int> P,
CudaDeviceVariable<CUdeviceptr> Carray, int ldc, CudaDeviceVariable<int> INFO, int batchSize)
{
_status = CudaBlasNativeMethods.cublasCgetriBatched(_blasHandle, n, Aarray.DevicePointer, lda, P.DevicePointer, Carray.DevicePointer, ldc, INFO.DevicePointer, batchSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cublasCgetriBatched"", _status));
if (_status != CublasStatus.Success) throw new CudaBlasException(_status);
}","If info = k, U(k,k) is 0. The U is exactly singular and the inversion failed.",1
49,"public void GetriBatchedZ(int n, CudaDeviceVariable<CUdeviceptr> Aarray, int lda, CudaDeviceVariable<int> P,
CudaDeviceVariable<CUdeviceptr> Carray, int ldc, CudaDeviceVariable<int> INFO, int batchSize)
{
_status = CudaBlasNativeMethods.cublasZgetriBatched(_blasHandle, n, Aarray.DevicePointer, lda, P.DevicePointer, Carray.DevicePointer, ldc, INFO.DevicePointer, batchSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cublasZgetriBatched"", _status));
if (_status != CublasStatus.Success) throw new CudaBlasException(_status);
}","If info = k, U(k,k) is 0. The U is exactly singular and the inversion failed.",1
50,"public CudaJOThreadsPerBlock(int value)
{
_option = CUJITOption.ThreadsPerBlock;
_ptrValue = (IntPtr)(Convert.ToUInt32(value, System.Globalization.CultureInfo.InvariantCulture));
}","IN: Specifies minimum number of threads per block to target compilation for OUT: Returns the number of threads the compiler actually targeted. This restricts the resource utilization fo the compiler (e.g. max registers) such that a block with the given number of threads should be able to launch based on register limitations. Note, this option does not currently take into account any other resource limitations, such as shared memory utilization. Option type: unsigned int Applies to: compiler only",0
51,"public CudaJOOptimizationLevel(uint value)
{
_option = CUJITOption.OptimizationLevel;
_ptrValue = (IntPtr)(Convert.ToUInt32(value, System.Globalization.CultureInfo.InvariantCulture));
}","Level of optimizations to apply to generated code (0 - 4), with 4 being the default and highest level of optimizations. Option type: unsigned int Applies to: compiler only",1
52,"protected byte[] AddZeroToArray(byte[] image)
{
byte[] retArr = new byte[image.LongLength + 1];
Array.Copy(image, retArr, image.LongLength);
retArr[image.LongLength] = 0;
return retArr;
}",Make sure the kernel image arrays are zero terminated by appending a zero,1
53,"public void MapAllResources()
{
MapAllResources(new CUstream());
}","Maps all graphics resources for access by CUDA. The resources may be accessed by CUDA until they are unmapped. The graphics API from which the resource was registered should not access any resources while they are mapped by CUDA. If an application does so, the results are undefined. If any of the resources is presently mapped for access by CUDA then CUResult.ErrorAlreadyMapped exception is thrown.",1
54,"public void UnmapAllResources()
{
UnmapAllResources(new CUstream());
}","Maps all graphics resources for access by CUDA. The resources may be accessed by CUDA until they are unmapped. The graphics API from which the resource was registered should not access any resources while they are mapped by CUDA. If an application does so, the results are undefined. If any of the resources is presently mapped for access by CUDA then CUResult.ErrorAlreadyMapped exception is thrown.",1
55,"public CudaJOMaxRegisters(uint value)
{
_option = CUJITOption.MaxRegisters;
_ptrValue = (IntPtr)(Convert.ToUInt32(value, System.Globalization.CultureInfo.InvariantCulture));
}",Max number of registers that a thread may use. Option type: unsigned int Applies to: compiler only,1
56,"public struct CUDA_MEMSET_NODE_PARAMS
{
/// <summary>
/// Destination device pointer
/// </summary>
public CUdeviceptr dst;
/// <summary>
/// Pitch of destination device pointer. Unused if height is 1
/// </summary>
public SizeT pitch;
/// <summary>
/// Value to be set
/// </summary>
public uint value;
/// <summary>
/// Size of each element in bytes. Must be 1, 2, or 4.
/// </summary>
public uint elementSize;
/// <summary>
/// Width in bytes, of the row
/// </summary>
public SizeT width;
/// <summary>
/// Number of rows
/// </summary>
public SizeT height;
/// <summary>
/// Initialieses the struct
/// </summary>
/// <typeparam name=""T""></typeparam>
/// <param name=""deviceVariable""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static CUDA_MEMSET_NODE_PARAMS init<T>(CudaDeviceVariable<T> deviceVariable, uint value) where T : struct
{
CUDA_MEMSET_NODE_PARAMS para = new CUDA_MEMSET_NODE_PARAMS();
para.dst = deviceVariable.DevicePointer;
para.pitch = deviceVariable.SizeInBytes;
para.value = value;
para.elementSize = deviceVariable.TypeSize;
para.width = deviceVariable.SizeInBytes;
para.height = 1;
return para;
}
/// <summary>
/// Initialieses the struct
/// </summary>
/// <typeparam name=""T""></typeparam>
/// <param name=""deviceVariable""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static CUDA_MEMSET_NODE_PARAMS init<T>(CudaPitchedDeviceVariable<T> deviceVariable, uint value) where T : struct
{
CUDA_MEMSET_NODE_PARAMS para = new CUDA_MEMSET_NODE_PARAMS();
para.dst = deviceVariable.DevicePointer;
para.pitch = deviceVariable.Pitch;
para.value = value;
para.elementSize = deviceVariable.TypeSize;
para.width = deviceVariable.WidthInBytes;
para.height = deviceVariable.Height;
return para;
}
}",Memset node parameters,1
57,"public CudaFFTPlanMany(int rank, int[] n, int batch, cufftType type)
{
_handle = new cufftHandle();
_rank = rank;
_n = n;
_batch = batch;
_type = type;
//optional:
_inembed = null;
_istride = 1;
_idist = 0;
_onembed = null;
_ostride = 1;
_odist = 0;
res = CudaFFTNativeMethods.cufftPlanMany(ref _handle, rank, n, _inembed, _istride, _idist, _onembed, _ostride, _odist, type, batch);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""CudaFFTPlanMany"", res));
if (res != cufftResult.Success)
throw new CudaFFTException(res);
}",n batch,0
58,"public struct CudaBlasHandle
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",Opaque structure holding CUBLAS library context,1
59,"public CudaJOGenerateDebugInfo(bool value)
{
_option = CUJITOption.GenerateDebugInfo;
_ptrValue = (IntPtr)(value ? 1 : 0);
}",Option type: int Applies to: compiler and linker,1
60,"public CudaJOLogVerbose(bool value)
{
_option = CUJITOption.LogVerbose;
_ptrValue = (IntPtr)(value ? 1 : 0);
}",Option type: int Applies to: compiler and linker,1
61,"public CudaJOGenerateLineInfo(bool value)
{
_option = CUJITOption.GenerateLineInfo;
_ptrValue = (IntPtr)(value ? 1 : 0);
}",Option type: int Applies to: compiler only,1
62,"public CudaJOJITCacheMode(CUJITCacheMode value)
{
_option = CUJITOption.GenerateLineInfo;
_ptrValue = (IntPtr)(Convert.ToUInt32(value, System.Globalization.CultureInfo.InvariantCulture));
}",Option type: unsigned int for enumerated type CUJITCacheMode Applies to: compiler only,1
63,"public CudaFFTPlanMany(int rank, int[] n, int batch, cufftType type, CUstream stream)
: this(rank, n, batch, type)
{
SetStream(stream);
}",plans of any dimension may be created. (old API),1
64,"public CudaFFTPlanMany(int rank, int[] n, int batch, cufftType type, int[] inembed, int istride, int idist, int[] onembed, int ostride, int odist)
{
_handle = new cufftHandle();
_rank = rank;
_n = n;
_batch = batch;
_type = type;
//optional:
_inembed = inembed;
_istride = istride;
_idist = idist;
_onembed = onembed;
_ostride = ostride;
_odist = odist;
res = CudaFFTNativeMethods.cufftPlanMany(ref _handle, rank, n, inembed, istride, idist, onembed, ostride, odist, type, batch);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""CudaFFTPlanMany"", res));
if (res != cufftResult.Success)
throw new CudaFFTException(res);
}",plans of any dimension may be created. (old API),1
65,"public CudaFFTPlanMany(int rank, int[] n, int batch, cufftType type, CUstream stream, int[] inembed, int istride, int idist, int[] onembed, int ostride, int odist)
: this(rank, n, batch, type, inembed, istride, idist, onembed, ostride, odist)
{
SetStream(stream);
}",plans of any dimension may be created. (old API),1
66,"public CudaJOErrorLogBuffer(int size)
{
_size = size;
_buffer = new byte[_size];
_handle = GCHandle.Alloc(_buffer, GCHandleType.Pinned);
_ptrValue = _handle.AddrOfPinnedObject();
_option = CUJITOption.ErrorLogBuffer;
_returnedSize = (IntPtr)_size;
}",Pointer to a buffer in which to print any log messages from PTXAS that reflect errors Option type: char* Applies to: compiler and linker,1
67,"public CudaJOInfoLogBuffer(int size)
{
_size = size;
_buffer = new byte[_size];
_handle = GCHandle.Alloc(_buffer, GCHandleType.Pinned);
_ptrValue = _handle.AddrOfPinnedObject();
_option = CUJITOption.InfoLogBuffer;
_returnedSize = (IntPtr)_size;
}",Pointer to a buffer in which to print any log messsages from PTXAS that are informational in nature Option type: char* Applies to: compiler and linker,1
68,"public void PopContext()
{
if (disposed) throw new ObjectDisposedException(this.ToString());
CUResult res;
res = DriverAPINativeMethods.ContextManagement.cuCtxPopCurrent_v2(ref _context);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuCtxPopCurrent"", res));
if (res != CUResult.Success)
throw new CudaException(res);
}",Pop the CUDA context,1
69,"public void PushContext()
{
if (disposed) throw new ObjectDisposedException(this.ToString());
CUResult res;
res = DriverAPINativeMethods.ContextManagement.cuCtxPushCurrent_v2(_context);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuCtxPushCurrent"", res));
if (res != CUResult.Success)
throw new CudaException(res);
}",Push the CUDA context,1
70,"public void Clear()
{
foreach (var elem in _resources)
elem.Dispose();
_resources.Clear();
_CUResources.Clear();
}","Removes all resources in the collection, an disposes every element.",1
71,"public void ResetValues()
{
foreach (var item in _cudaOptions)
{
if (item is CudaJOErrorLogBuffer)
{
(item as CudaJOErrorLogBuffer).Reset();
}
if (item is CudaJOInfoLogBuffer)
{
(item as CudaJOInfoLogBuffer).Reset();
}
}
}",Reset values returned from Cuda API for info and error buffers.,1
72,"public CUsharedconfig GetSharedMemConfig()
{
if (disposed) throw new ObjectDisposedException(this.ToString());
CUResult res;
CUsharedconfig config = new CUsharedconfig();
res = DriverAPINativeMethods.ContextManagement.cuCtxGetSharedMemConfig(ref config);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuCtxGetSharedMemConfig"", res));
if (res != CUResult.Success)
throw new CudaException(res);
return config;
}",Returns the current shared memory configuration for the current context.,1
73,"public CudaJOFallbackStrategy(CUJITFallback value)
{
_option = CUJITOption.FallbackStrategy;
_ptrValue = (IntPtr)(Convert.ToUInt32(value, System.Globalization.CultureInfo.InvariantCulture));
}",Specifies choice of fallback strategy if matching cubin is not found. Choice is based on supplied CUJITFallback. Option type: unsigned int for enumerated type CUJITFallback Applies to: compiler only,1
74,"public enum DirectXVersion
{
/// <summary>
/// DirectX9
/// </summary>
D3D9,
/// <summary>
/// DirectX10
/// </summary>
D3D10,
/// <summary>
/// DirectX11
/// </summary>
D3D11
}","Specifies the directX version to use with a cuda context, if necessary",1
75,"public void Record()
{
CUstream _stream = new CUstream();
res = DriverAPINativeMethods.Events.cuEventRecord(_event, _stream);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuEventRecord"", res));
if (res != CUResult.Success) throw new CudaException(res);
}",stream,0
76,"public void Record(CUstream stream)
{
res = DriverAPINativeMethods.Events.cuEventRecord(_event, stream);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuEventRecord"", res));
if (res != CUResult.Success) throw new CudaException(res);
}",stream,0
77,"public CudaJOTarget(CUJITTarget value)
{
_option = CUJITOption.Target;
_ptrValue = (IntPtr)(Convert.ToUInt32(value, System.Globalization.CultureInfo.InvariantCulture));
}",Target is chosen based on supplied ::CUjit_target_enum. Option type: unsigned int for enumerated type ::CUjit_target_enum Applies to: compiler and linker,1
78,"public void SetConstantVariable<T>(string name, T value) where T : struct
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName));
if (res != CUResult.Success) throw new CudaException(res);
GCHandle handle = GCHandle.Alloc(value, GCHandleType.Pinned);
try
{
IntPtr ptr = handle.AddrOfPinnedObject();
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ptr, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName));
}
finally
{
handle.Free();
}
if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
79,"public void SetConstantVariable<T>(string name, T[] value) where T : struct
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName));
if (res != CUResult.Success) throw new CudaException(res);
GCHandle handle = GCHandle.Alloc(value, GCHandleType.Pinned);
try
{
IntPtr ptr = handle.AddrOfPinnedObject();
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ptr, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName));
}
finally
{
handle.Free();
}
if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
80,"public void SetConstantVariable(string name, byte value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
81,"public void SetConstantVariable(string name, sbyte value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
82,"public void SetConstantVariable(string name, ushort value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
83,"public void SetConstantVariable(string name, short value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
84,"public void SetConstantVariable(string name, uint value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
85,"public void SetConstantVariable(string name, int value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
86,"public void SetConstantVariable(string name, ulong value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
87,"public void SetConstantVariable(string name, long value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
88,"public void SetConstantVariable(string name, float value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
89,"public void SetConstantVariable(string name, double value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
90,"public void SetConstantVariable(string name, dim3 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
91,"public void SetConstantVariable(string name, char1 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
92,"public void SetConstantVariable(string name, char2 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
93,"public void SetConstantVariable(string name, char3 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
94,"public void SetConstantVariable(string name, char4 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
95,"public void SetConstantVariable(string name, uchar1 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
96,"public void SetConstantVariable(string name, uchar2 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
97,"public void SetConstantVariable(string name, uchar3 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
98,"public void SetConstantVariable(string name, uchar4 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
99,"public void SetConstantVariable(string name, short1 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
100,"public void SetConstantVariable(string name, short2 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
101,"public void SetConstantVariable(string name, short3 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
102,"public void SetConstantVariable(string name, short4 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
103,"public void SetConstantVariable(string name, ushort1 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
104,"public void SetConstantVariable(string name, ushort2 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
105,"public void SetConstantVariable(string name, ushort3 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
106,"public void SetConstantVariable(string name, ushort4 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
107,"public void SetConstantVariable(string name, int1 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
108,"public void SetConstantVariable(string name, int2 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
109,"public void SetConstantVariable(string name, int3 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
110,"public void SetConstantVariable(string name, int4 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
111,"public void SetConstantVariable(string name, uint1 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
112,"public void SetConstantVariable(string name, uint2 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
113,"public void SetConstantVariable(string name, uint3 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
114,"public void SetConstantVariable(string name, uint4 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
115,"public void SetConstantVariable(string name, long1 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
116,"public void SetConstantVariable(string name, long2 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
117,"public void SetConstantVariable(string name, long3 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
118,"public void SetConstantVariable(string name, long4 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
119,"public void SetConstantVariable(string name, ulong1 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
120,"public void SetConstantVariable(string name, ulong2 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
121,"public void SetConstantVariable(string name, ulong3 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
122,"public void SetConstantVariable(string name, ulong4 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
123,"public void SetConstantVariable(string name, float1 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
124,"public void SetConstantVariable(string name, float2 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
125,"public void SetConstantVariable(string name, float3 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
126,"public void SetConstantVariable(string name, float4 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
127,"public void SetConstantVariable(string name, double1 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
128,"public void SetConstantVariable(string name, double2 value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
129,"public void SetConstantVariable(string name, cuDoubleComplex value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
130,"public void SetConstantVariable(string name, cuDoubleReal value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
131,"public void SetConstantVariable(string name, cuFloatComplex value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
132,"public void SetConstantVariable(string name, cuFloatReal value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, ref value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
133,"public void SetConstantVariable(string name, byte[] value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
134,"public CudaStream GetStream()
{
CUstream stream = new CUstream();
res = CudaDNNNativeMethods.cudnnGetStream(_handle, ref stream);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cudnnGetStream"", res));
if (res != cudnnStatus.Success) throw new CudaDNNException(res);
return new CudaStream(stream);
}",This function gets the stream to be used by the cudnn library to execute its routines.,1
135,"public SizeT GetDropoutStateSize()
{
SizeT sizeInBytes = new SizeT();
res = CudaDNNNativeMethods.cudnnDropoutGetStatesSize(_handle, ref sizeInBytes);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cudnnDropoutGetStatesSize"", res));
if (res != cudnnStatus.Success) throw new CudaDNNException(res);
return sizeInBytes;
}",This function is used to query the amount of space required to store the states of the random number generators used by cudnnDropoutForward function.,1
136,"public static string cudnnGetErrorString(cudnnStatus status)
{
IntPtr str = cudnnGetErrorStringInternal(status);
return Marshal.PtrToStringAnsi(str);
}",This function returns a human-readable character string describing the cudnnStatus enumerate passed as input parameter.,1
137,"public static Version cudnnGetVersion()
{
SizeT ver = cudnnGetVersionInternal();
SizeT maj = ver / 1000;
SizeT min = (ver % 1000) / 100;
SizeT build = ver % 100;
return new Version(maj, min, build);
}","This function returns the version number of the cuDNN Library. It returns the CUDNN_VERSION define present in the cudnn.h header file. Starting with release R2, the routine can be used to identify dynamically the current cuDNN Library used by the application. The define CUDNN_VERSION can be used to have the same application linked against different cuDNN versions using conditional compilation statements.",1
138,"public void FreeHandle()
{
if (_handle != null)
if (_handle.IsAllocated)
_handle.Free();
}",You must free the buffer manually if the buffer is not needed anymore.,1
139,"public void SetConstantVariable(string name, ushort[] value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
140,"public void SetConstantVariable(string name, short[] value)
{
CUdeviceptr dVarPtr = new CUdeviceptr();
SizeT varSize = 0;
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetGlobal_v2(ref dVarPtr, ref varSize, _module, name);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuModuleGetGlobal"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.SynchronousMemcpy_v2.cuMemcpyHtoD_v2(dVarPtr, value, varSize);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Kernel: {3}"", DateTime.Now, ""cuMemcpyHtoD"", res, _kernelName)); if (res != CUResult.Success) throw new CudaException(res);
}",The constant variable must be defined in the CUDA module.,1
141,"~CudaPageLockedHostMemory3D()
{
Dispose(false);
}",For dispose,1
142,"~CudaPageLockedHostMemory3D_byte()
{
Dispose(false);
}",For dispose,1
143,"~CudaPageLockedHostMemory3D_char1()
{
Dispose(false);
}",For dispose,1
144,"~CudaPageLockedHostMemory3D_char2()
{
Dispose(false);
}",For dispose,1
145,"~CudaPageLockedHostMemory3D_char3()
{
Dispose(false);
}",For dispose,1
146,"~CudaPageLockedHostMemory3D_char4()
{
Dispose(false);
}",For dispose,1
147,"~CudaPageLockedHostMemory3D_cuDoubleComplex()
{
Dispose(false);
}",For dispose,1
148,"~CudaPageLockedHostMemory3D_cuDoubleReal()
{
Dispose(false);
}",For dispose,1
149,"~CudaPageLockedHostMemory3D_cuFloatComplex()
{
Dispose(false);
}",For dispose,1
150,"~CudaPageLockedHostMemory3D_cuFloatReal()
{
Dispose(false);
}",For dispose,1
151,"~CudaPageLockedHostMemory3D_dim3()
{
Dispose(false);
}",For dispose,1
152,"~CudaPageLockedHostMemory3D_double()
{
Dispose(false);
}",For dispose,1
153,"~CudaPageLockedHostMemory3D_double1()
{
Dispose(false);
}",For dispose,1
154,"~CudaPageLockedHostMemory3D_double2()
{
Dispose(false);
}",For dispose,1
155,"~CudaPageLockedHostMemory3D_float()
{
Dispose(false);
}",For dispose,1
156,"~CudaPageLockedHostMemory3D_float1()
{
Dispose(false);
}",For dispose,1
157,"~CudaPageLockedHostMemory3D_float2()
{
Dispose(false);
}",For dispose,1
158,"~CudaPageLockedHostMemory3D_float3()
{
Dispose(false);
}",For dispose,1
159,"~CudaPageLockedHostMemory3D_float4()
{
Dispose(false);
}",For dispose,1
160,"~CudaPageLockedHostMemory3D_int()
{
Dispose(false);
}",For dispose,1
161,"~CudaPageLockedHostMemory3D_int1()
{
Dispose(false);
}",For dispose,1
162,"~CudaPageLockedHostMemory3D_int2()
{
Dispose(false);
}",For dispose,1
163,"~CudaPageLockedHostMemory3D_int3()
{
Dispose(false);
}",For dispose,1
164,"~CudaPageLockedHostMemory3D_int4()
{
Dispose(false);
}",For dispose,1
165,"~CudaPageLockedHostMemory3D_long()
{
Dispose(false);
}",For dispose,1
166,"~CudaPageLockedHostMemory3D_long1()
{
Dispose(false);
}",For dispose,1
167,"~CudaPageLockedHostMemory3D_long2()
{
Dispose(false);
}",For dispose,1
168,"~CudaPageLockedHostMemory3D_sbyte()
{
Dispose(false);
}",For dispose,1
169,"~CudaPageLockedHostMemory3D_short()
{
Dispose(false);
}",For dispose,1
170,"~CudaPageLockedHostMemory3D_short1()
{
Dispose(false);
}",For dispose,1
171,"~CudaPageLockedHostMemory3D_short2()
{
Dispose(false);
}",For dispose,1
172,"~CudaPageLockedHostMemory3D_short3()
{
Dispose(false);
}",For dispose,1
173,"~CudaPageLockedHostMemory3D_short4()
{
Dispose(false);
}",For dispose,1
174,"~CudaPageLockedHostMemory3D_uchar1()
{
Dispose(false);
}",For dispose,1
175,"~CudaPageLockedHostMemory3D_uchar2()
{
Dispose(false);
}",For dispose,1
176,"~CudaPageLockedHostMemory3D_uchar3()
{
Dispose(false);
}",For dispose,1
177,"~CudaPageLockedHostMemory3D_uchar4()
{
Dispose(false);
}",For dispose,1
178,"~CudaPageLockedHostMemory3D_uint()
{
Dispose(false);
}",For dispose,1
179,"~CudaPageLockedHostMemory3D_uint1()
{
Dispose(false);
}",For dispose,1
180,"~CudaPageLockedHostMemory3D_uint2()
{
Dispose(false);
}",For dispose,1
181,"~CudaPageLockedHostMemory3D_uint3()
{
Dispose(false);
}",For dispose,1
182,"~CudaPageLockedHostMemory3D_uint4()
{
Dispose(false);
}",For dispose,1
183,"~CudaPageLockedHostMemory3D_ulong()
{
Dispose(false);
}",For dispose,1
184,"~CudaPageLockedHostMemory3D_ulong1()
{
Dispose(false);
}",For dispose,1
185,"~CudaPageLockedHostMemory3D_ulong2()
{
Dispose(false);
}",For dispose,1
186,"~CudaPageLockedHostMemory3D_ushort()
{
Dispose(false);
}",For dispose,1
187,"~CudaPageLockedHostMemory3D_ushort1()
{
Dispose(false);
}",For dispose,1
188,"~CudaPageLockedHostMemory3D_ushort2()
{
Dispose(false);
}",For dispose,1
189,"~CudaPageLockedHostMemory3D_ushort3()
{
Dispose(false);
}",For dispose,1
190,"~CudaPageLockedHostMemory3D_ushort4()
{
Dispose(false);
}",For dispose,1
191,"~CudaPageLockedHostMemory_byte()
{
Dispose(false);
}",For dispose,1
192,"~CudaPageLockedHostMemory_char1()
{
Dispose(false);
}",For dispose,1
193,"~CudaPageLockedHostMemory_char2()
{
Dispose(false);
}",For dispose,1
194,"~CudaPageLockedHostMemory_char3()
{
Dispose(false);
}",For dispose,1
195,"~CudaPageLockedHostMemory_char4()
{
Dispose(false);
}",For dispose,1
196,"~CudaPageLockedHostMemory_cuDoubleComplex()
{
Dispose(false);
}",For dispose,1
197,"~CudaPageLockedHostMemory_cuDoubleReal()
{
Dispose(false);
}",For dispose,1
198,"~CudaPageLockedHostMemory_cuFloatComplex()
{
Dispose(false);
}",For dispose,1
199,"~CudaPageLockedHostMemory_cuFloatReal()
{
Dispose(false);
}",For dispose,1
200,"~CudaPageLockedHostMemory_dim3()
{
Dispose(false);
}",For dispose,1
201,"~CudaPageLockedHostMemory_double()
{
Dispose(false);
}",For dispose,1
202,"~CudaPageLockedHostMemory_double1()
{
Dispose(false);
}",For dispose,1
203,"~CudaPageLockedHostMemory_double2()
{
Dispose(false);
}",For dispose,1
204,"~CudaPageLockedHostMemory_float()
{
Dispose(false);
}",For dispose,1
205,"~CudaPageLockedHostMemory_float1()
{
Dispose(false);
}",For dispose,1
206,"~CudaPageLockedHostMemory_float2()
{
Dispose(false);
}",For dispose,1
207,"~CudaPageLockedHostMemory_float3()
{
Dispose(false);
}",For dispose,1
208,"~CudaPageLockedHostMemory_float4()
{
Dispose(false);
}",For dispose,1
209,"~CudaPageLockedHostMemory_int()
{
Dispose(false);
}",For dispose,1
210,"~CudaPageLockedHostMemory_int1()
{
Dispose(false);
}",For dispose,1
211,"~CudaPageLockedHostMemory_int2()
{
Dispose(false);
}",For dispose,1
212,"~CudaPageLockedHostMemory_int3()
{
Dispose(false);
}",For dispose,1
213,"~CudaPageLockedHostMemory_int4()
{
Dispose(false);
}",For dispose,1
214,"~CudaPageLockedHostMemory_long()
{
Dispose(false);
}",For dispose,1
215,"~CudaPageLockedHostMemory_long1()
{
Dispose(false);
}",For dispose,1
216,"~CudaPageLockedHostMemory_long2()
{
Dispose(false);
}",For dispose,1
217,"~CudaPageLockedHostMemory_sbyte()
{
Dispose(false);
}",For dispose,1
218,"~CudaPageLockedHostMemory_short()
{
Dispose(false);
}",For dispose,1
219,"~CudaPageLockedHostMemory_short1()
{
Dispose(false);
}",For dispose,1
220,"~CudaPageLockedHostMemory_short2()
{
Dispose(false);
}",For dispose,1
221,"~CudaPageLockedHostMemory_short3()
{
Dispose(false);
}",For dispose,1
222,"~CudaPageLockedHostMemory_short4()
{
Dispose(false);
}",For dispose,1
223,"~CudaPageLockedHostMemory_uchar1()
{
Dispose(false);
}",For dispose,1
224,"~CudaPageLockedHostMemory_uchar2()
{
Dispose(false);
}",For dispose,1
225,"~CudaPageLockedHostMemory_uchar3()
{
Dispose(false);
}",For dispose,1
226,"~CudaPageLockedHostMemory_uchar4()
{
Dispose(false);
}",For dispose,1
227,"~CudaPageLockedHostMemory_uint()
{
Dispose(false);
}",For dispose,1
228,"~CudaPageLockedHostMemory_uint1()
{
Dispose(false);
}",For dispose,1
229,"~CudaPageLockedHostMemory_uint2()
{
Dispose(false);
}",For dispose,1
230,"~CudaPageLockedHostMemory_uint3()
{
Dispose(false);
}",For dispose,1
231,"~CudaPageLockedHostMemory_uint4()
{
Dispose(false);
}",For dispose,1
232,"~CudaPageLockedHostMemory_ulong()
{
Dispose(false);
}",For dispose,1
233,"~CudaPageLockedHostMemory_ulong1()
{
Dispose(false);
}",For dispose,1
234,"~CudaPageLockedHostMemory_ulong2()
{
Dispose(false);
}",For dispose,1
235,"~CudaPageLockedHostMemory_ushort()
{
Dispose(false);
}",For dispose,1
236,"~CudaPageLockedHostMemory_ushort1()
{
Dispose(false);
}",For dispose,1
237,"~CudaPageLockedHostMemory_ushort2()
{
Dispose(false);
}",For dispose,1
238,"~CudaPageLockedHostMemory_ushort3()
{
Dispose(false);
}",For dispose,1
239,"~CudaPageLockedHostMemory_ushort4()
{
Dispose(false);
}",For dispose,1
240,"~CudaPitchedDeviceVariable()
{
Dispose (false);
}",For dispose,1
241,"public struct CudaPointerAttributeP2PTokens
{
/// <summary>
/// /// </summary>
ulong p2pToken;
/// <summary>
/// /// </summary>
uint vaSpaceToken;
}",GPU Direct v3 tokens,1
242,"public void SetGeneratorOrdering(Ordering order)
{
_status = CudaRandNativeMethods.curandSetGeneratorOrdering(_generator, order);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""curandSetGeneratorOrdering"", _status));
if (_status != CurandStatus.Success) throw new CudaRandException(_status);
}",Set the ordering of results of the pseudo or quasirandom number generator. Legal values of order for pseudorandom generators are: Legal values of order for quasirandom generators are:,1
243,"public void GenerateSeeds()
{
_status = CudaRandNativeMethods.curandGenerateSeeds(_generator);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""curandGenerateSeeds"", _status));
if (_status != CurandStatus.Success) throw new CudaRandException(_status);
}",Generate the starting state of the generator. This function is automatically called by generation functions such as Generate(CudaDeviceVariable) and GenerateUniform(CudaDeviceVariable). It can be called manually for performance testing reasons to separate timings for starting state generation and random number generation.,1
244,"~CudaRandDevice()
{
Dispose(false);
}",For dispose,1
245,"public static Version GetVersion()
{
int version = 0;
CurandStatus _status = CudaRandNativeMethods.curandGetVersion(ref version);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""curandGetVersion"", _status));
if (_status != CurandStatus.Success) throw new CudaRandException(_status);
return new Version((int)version / 1000, (int)version % 100);
}",Returns the version number of the dynamically linked CURAND library.,1
246,"~CudaRandHost()
{
Dispose(false);
}",For dispose,1
247,"public void Unregister()
{
if (disposed) throw new ObjectDisposedException(this.ToString());
res = DriverAPINativeMethods.MemoryManagement.cuMemHostUnregister(_intPtr);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuMemHostUnregister"", res));
if (res != CUResult.Success) throw new CudaException(res);
_registered = false;
}",p,0
248,"~CudaRegisteredHostMemory()
{
Dispose(false);
}",For dispose,1
249,"~CudaRegisteredHostMemory_byte()
{
Dispose(false);
}",For dispose,1
250,"~CudaRegisteredHostMemory_char1()
{
Dispose(false);
}",For dispose,1
251,"~CudaRegisteredHostMemory_char2()
{
Dispose(false);
}",For dispose,1
252,"~CudaRegisteredHostMemory_char3()
{
Dispose(false);
}",For dispose,1
253,"~CudaRegisteredHostMemory_char4()
{
Dispose(false);
}",For dispose,1
254,"~CudaRegisteredHostMemory_cuDoubleComplex()
{
Dispose(false);
}",For dispose,1
255,"~CudaRegisteredHostMemory_cuDoubleReal()
{
Dispose(false);
}",For dispose,1
256,"~CudaRegisteredHostMemory_cuFloatComplex()
{
Dispose(false);
}",For dispose,1
257,"~CudaRegisteredHostMemory_cuFloatReal()
{
Dispose(false);
}",For dispose,1
258,"~CudaRegisteredHostMemory_dim3()
{
Dispose(false);
}",For dispose,1
259,"~CudaRegisteredHostMemory_double()
{
Dispose(false);
}",For dispose,1
260,"~CudaRegisteredHostMemory_double1()
{
Dispose(false);
}",For dispose,1
261,"~CudaRegisteredHostMemory_double2()
{
Dispose(false);
}",For dispose,1
262,"~CudaRegisteredHostMemory_float()
{
Dispose(false);
}",For dispose,1
263,"~CudaRegisteredHostMemory_float1()
{
Dispose(false);
}",For dispose,1
264,"~CudaRegisteredHostMemory_float2()
{
Dispose(false);
}",For dispose,1
265,"~CudaRegisteredHostMemory_float3()
{
Dispose(false);
}",For dispose,1
266,"~CudaRegisteredHostMemory_float4()
{
Dispose(false);
}",For dispose,1
267,"~CudaRegisteredHostMemory_int()
{
Dispose(false);
}",For dispose,1
268,"~CudaRegisteredHostMemory_int1()
{
Dispose(false);
}",For dispose,1
269,"~CudaRegisteredHostMemory_int2()
{
Dispose(false);
}",For dispose,1
270,"~CudaRegisteredHostMemory_int3()
{
Dispose(false);
}",For dispose,1
271,"~CudaRegisteredHostMemory_int4()
{
Dispose(false);
}",For dispose,1
272,"~CudaRegisteredHostMemory_long()
{
Dispose(false);
}",For dispose,1
273,"~CudaRegisteredHostMemory_long1()
{
Dispose(false);
}",For dispose,1
274,"~CudaRegisteredHostMemory_long2()
{
Dispose(false);
}",For dispose,1
275,"~CudaRegisteredHostMemory_sbyte()
{
Dispose(false);
}",For dispose,1
276,"~CudaRegisteredHostMemory_short()
{
Dispose(false);
}",For dispose,1
277,"~CudaRegisteredHostMemory_short1()
{
Dispose(false);
}",For dispose,1
278,"~CudaRegisteredHostMemory_short2()
{
Dispose(false);
}",For dispose,1
279,"~CudaRegisteredHostMemory_short3()
{
Dispose(false);
}",For dispose,1
280,"~CudaRegisteredHostMemory_short4()
{
Dispose(false);
}",For dispose,1
281,"~CudaRegisteredHostMemory_uchar1()
{
Dispose(false);
}",For dispose,1
282,"~CudaRegisteredHostMemory_uchar2()
{
Dispose(false);
}",For dispose,1
283,"~CudaRegisteredHostMemory_uchar3()
{
Dispose(false);
}",For dispose,1
284,"~CudaRegisteredHostMemory_uchar4()
{
Dispose(false);
}",For dispose,1
285,"~CudaRegisteredHostMemory_uint()
{
Dispose(false);
}",For dispose,1
286,"~CudaRegisteredHostMemory_uint1()
{
Dispose(false);
}",For dispose,1
287,"~CudaRegisteredHostMemory_uint2()
{
Dispose(false);
}",For dispose,1
288,"~CudaRegisteredHostMemory_uint3()
{
Dispose(false);
}",For dispose,1
289,"~CudaRegisteredHostMemory_uint4()
{
Dispose(false);
}",For dispose,1
290,"~CudaRegisteredHostMemory_ulong()
{
Dispose(false);
}",For dispose,1
291,"~CudaRegisteredHostMemory_ulong1()
{
Dispose(false);
}",For dispose,1
292,"~CudaRegisteredHostMemory_ulong2()
{
Dispose(false);
}",For dispose,1
293,"~CudaRegisteredHostMemory_ushort()
{
Dispose(false);
}",For dispose,1
294,"~CudaRegisteredHostMemory_ushort1()
{
Dispose(false);
}",For dispose,1
295,"~CudaRegisteredHostMemory_ushort2()
{
Dispose(false);
}",For dispose,1
296,"~CudaRegisteredHostMemory_ushort3()
{
Dispose(false);
}",For dispose,1
297,"~CudaRegisteredHostMemory_ushort4()
{
Dispose(false);
}",For dispose,1
298,"public struct CudaResourceDesc
{
#region Constructors
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaArray1D var)
{
resType = CUResourceType.Array;
flags = 0;
res = new CudaResourceDescUnion();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.hArray = var.CUArray;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaArray2D var)
{
resType = CUResourceType.Array;
flags = 0;
res = new CudaResourceDescUnion();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.hArray = var.CUArray;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaArray3D var)
{
resType = CUResourceType.Array;
flags = 0;
res = new CudaResourceDescUnion();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.hArray = var.CUArray;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaMipmappedArray var)
{
resType = CUResourceType.MipmappedArray;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.hMipmappedArray = var.CUMipmappedArray; ;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<float> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.Float;
res.linear.numChannels = 1;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.float2> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.Float;
res.linear.numChannels = 2;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.float4> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.Float;
res.linear.numChannels = 4;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<int> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.SignedInt32;
res.linear.numChannels = 1;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.int2> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.SignedInt32;
res.linear.numChannels = 2;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.int4> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.SignedInt16;
res.linear.numChannels = 4;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<short> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.SignedInt16;
res.linear.numChannels = 1;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.short2> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.SignedInt16;
res.linear.numChannels = 2;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.short4> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.SignedInt32;
res.linear.numChannels = 4;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<sbyte> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.SignedInt8;
res.linear.numChannels = 1;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.char2> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.SignedInt8;
res.linear.numChannels = 2;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.char4> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.SignedInt8;
res.linear.numChannels = 4;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<byte> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.UnsignedInt8;
res.linear.numChannels = 1;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.uchar2> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.UnsignedInt8;
res.linear.numChannels = 2;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.uchar4> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.UnsignedInt8;
res.linear.numChannels = 4;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<ushort> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.UnsignedInt16;
res.linear.numChannels = 1;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.ushort2> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.UnsignedInt16;
res.linear.numChannels = 2;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.ushort4> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.UnsignedInt16;
res.linear.numChannels = 4;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<uint> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.UnsignedInt32;
res.linear.numChannels = 1;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.uint2> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.UnsignedInt32;
res.linear.numChannels = 2;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaDeviceVariable<VectorTypes.uint4> var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = new CudaResourceDescLinear();
res.linear.devPtr = var.DevicePointer;
res.linear.format = CUArrayFormat.UnsignedInt32;
res.linear.numChannels = 4;
res.linear.sizeInBytes = var.SizeInBytes;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaResourceDescLinear var)
{
resType = CUResourceType.Linear;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.pitch2D = new CudaResourceDescPitch2D();
res.linear = var;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaResourceDescPitch2D var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = var;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<float> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.Float;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 1;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<int> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.SignedInt32;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 1;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<short> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.SignedInt16;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 1;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<sbyte> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.SignedInt8;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 1;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<byte> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.UnsignedInt8;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 1;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<ushort> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.UnsignedInt16;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 1;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<uint> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.UnsignedInt32;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 1;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.float2> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.Float;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 2;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.int2> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.SignedInt32;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 2;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.short2> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.SignedInt16;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 2;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.char2> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.SignedInt8;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 2;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.uchar2> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.UnsignedInt8;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 2;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.ushort2> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.UnsignedInt16;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 2;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.uint2> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.UnsignedInt32;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 2;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.float4> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.Float;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 4;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.int4> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.SignedInt32;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 4;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.short4> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.SignedInt16;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 4;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.char4> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.SignedInt8;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 4;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.uchar4> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.UnsignedInt8;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 4;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.ushort4> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.UnsignedInt16;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 4;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
/// <summary>
/// /// </summary>
/// <param name=""var""></param>
public CudaResourceDesc(CudaPitchedDeviceVariable<VectorTypes.uint4> var)
{
resType = CUResourceType.Pitch2D;
flags = 0;
res = new CudaResourceDescUnion();
res.hArray = new CUarray();
res.hMipmappedArray = new CUmipmappedArray();
res.linear = new CudaResourceDescLinear();
res.pitch2D = new CudaResourceDescPitch2D();
res.pitch2D.devPtr = var.DevicePointer;
res.pitch2D.format = CUArrayFormat.UnsignedInt32;
res.pitch2D.height = var.Height;
res.pitch2D.numChannels = 4;
res.pitch2D.pitchInBytes = var.Pitch;
res.pitch2D.width = var.Width;
}
#endregion
/// <summary>
/// Resource type
/// </summary>
public CUResourceType resType;
/// <summary>
/// Mimics the union in C++
/// </summary>
public CudaResourceDescUnion res;
/// <summary>
/// Flags (must be zero)
/// </summary>
public uint flags;
}",CUDA Resource descriptor,1
299,"public struct CudaResourceDescUnion
{
/// <summary>
/// CUDA array
/// </summary>
[FieldOffset(0)]
public CUarray hArray;
/// <summary>
/// CUDA mipmapped array
/// </summary>
[FieldOffset(0)]
public CUmipmappedArray hMipmappedArray;
/// <summary>
/// Linear memory
/// </summary>
[FieldOffset(0)]
public CudaResourceDescLinear linear;
/// <summary>
/// Linear pitched 2D memory
/// </summary>
[FieldOffset(0)]
public CudaResourceDescPitch2D pitch2D;
//In cuda header, an int[32] fixes the union size to 128 bytes, we
//achieve the same in C# if we set at offset 124 an simple int
[FieldOffset(31*4)]
private int reserved;
}","Mimics the union ""CUDA_RESOURCE_DESC.res"" in cuda.h",1
300,"public struct CudaResourceViewDesc
{
/// <summary>
/// Resource view format
/// </summary>
public CUresourceViewFormat format;
/// <summary>
/// Width of the resource view
/// </summary>
public SizeT width;
/// <summary>
/// Height of the resource view
/// </summary>
public SizeT height;
/// <summary>
/// Depth of the resource view
/// </summary>
public SizeT depth;
/// <summary>
/// First defined mipmap level
/// </summary>
public uint firstMipmapLevel;
/// <summary>
/// Last defined mipmap level
/// </summary>
public uint lastMipmapLevel;
/// <summary>
/// First layer index
/// </summary>
public uint firstLayer;
/// <summary>
/// Last layer index
/// </summary>
public uint lastLayer; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I4)]
private int[] _reserved;
}",Resource view descriptor,1
301,"~CudaRuntimeCompiler()
{
Dispose(false);
}",For dispose,1
302,"public CudaSolveDense()
{
_handle = new cusolverDnHandle();
res = CudaSolveNativeMethods.Dense.cusolverDnCreate(ref _handle);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusolverDnDestroy"", res));
if (res != cusolverStatus.Success) throw new CudaSolveException(res);
}",Create new dense solve instance,1
303,"public CudaStream GetStream()
{
CUstream stream = new CUstream();
res = CudaSolveNativeMethods.Dense.cusolverDnGetStream(_handle, ref stream);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusolverDnGetStream"", res));
if (res != cusolverStatus.Success) throw new CudaSolveException(res);
return new CudaStream(stream);
}",This function gets the stream to be used by the cuSolverDN library to execute its routines.,1
304,"~CudaSolveDense()
{
Dispose(false);
}",For dispose,1
305,"public CudaSolveRefactorization()
{
_handle = new cusolverRfHandle();
res = CudaSolveNativeMethods.Refactorization.cusolverRfCreate(ref _handle);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusolverRfCreate"", res));
if (res != cusolverStatus.Success) throw new CudaSolveException(res);
}",Create new refactorization solve instance,1
306,"public void Analyze()
{
res = CudaSolveNativeMethods.Refactorization.cusolverRfAnalyze(_handle);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusolverRfAnalyze"", res));
if (res != cusolverStatus.Success) throw new CudaSolveException(res);
}",This routine performs the appropriate analysis of parallelism available in the LU refactorization depending upon the algorithm chosen by the user.,1
307,"public void Refactor(cusolverRfHandle handle)
{
res = CudaSolveNativeMethods.Refactorization.cusolverRfRefactor(_handle);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusolverRfRefactor"", res));
if (res != cusolverStatus.Success) throw new CudaSolveException(res);
}",This routine performs the LU re-factorization,1
308,"public void BatchAnalyze()
{
res = CudaSolveNativeMethods.Refactorization.cusolverRfBatchAnalyze( _handle);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusolverRfBatchAnalyze"", res));
if (res != cusolverStatus.Success) throw new CudaSolveException(res);
}",This routine performs the appropriate analysis of parallelism available in the batched LU re-factorization.,1
309,"public void BatchRefactor()
{
res = CudaSolveNativeMethods.Refactorization.cusolverRfBatchRefactor(_handle);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusolverRfBatchRefactor"", res));
if (res != cusolverStatus.Success) throw new CudaSolveException(res);
}",This routine performs the LU re-factorization,1
310,"~CudaSolveRefactorization()
{
Dispose(false);
}",For dispose,1
311,"public CudaSolveSparse()
{
_handle = new cusolverSpHandle();
res = CudaSolveNativeMethods.Sparse.cusolverSpCreate(ref _handle);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusolverSpDestroy"", res));
if (res != cusolverStatus.Success) throw new CudaSolveException(res);
}",Create new sparse solve instance,1
312,"public CudaStream GetStream()
{
CUstream stream = new CUstream();
res = CudaSolveNativeMethods.Sparse.cusolverSpGetStream(_handle, ref stream);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusolverSpGetStream"", res));
if (res != cusolverStatus.Success) throw new CudaSolveException(res);
return new CudaStream(stream);
}",This function gets the stream to be used by the cuSolverSP library to execute its routines.,1
313,"~CudaSolveSparse()
{
Dispose(false);
}",For dispose,1
314,"~CudaSparseBsric02Info()
{
Dispose(false);
}",For dispose,1
315,"~CudaSparseBsrilu02Info()
{
Dispose(false);
}",For dispose,1
316,"~CudaSparseBsrsm2Info()
{
Dispose(false);
}",For dispose,1
317,"~CudaSparseBsrsv2Info()
{
Dispose(false);
}",For dispose,1
318,"public void SetColorAlgs(cusparseColorAlg alg)
{
res = CudaSparseNativeMethods.cusparseSetColorAlgs(_info, alg);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseSetColorAlgs"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",SetColorAlgs,1
319,"public cusparseColorAlg GetColorAlgs()
{
cusparseColorAlg retVal = new cusparseColorAlg();
res = CudaSparseNativeMethods.cusparseGetColorAlgs(_info, ref retVal);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseGetColorAlgs"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
return retVal;
}",GetColorAlgs,1
320,"~CudaSparseColorInfo()
{
Dispose(false);
}",For dispose,1
321,"public void SetStream(CUstream stream)
{
res = CudaSparseNativeMethods.cusparseSetStream(_handle, stream);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseSetStream"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",Sets the cuda stream to use,1
322,"public CUstream GetStream()
{
CUstream stream = new CUstream();
res = CudaSparseNativeMethods.cusparseGetStream(_handle, ref stream);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseGetStream"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
return stream;
}",Gets the cuda stream to use,1
323,"public Version GetVersion()
{
int version = 0;
res = CudaSparseNativeMethods.cusparseGetVersion(_handle, ref version);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseGetVersion"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
return new Version((int)version / 1000, (int)version % 100);
}",Returns the version of the underlying CUSPARSE library,1
324,"public void Gemmi(int m, int n, int k, int nnz, float alpha, CudaDeviceVariable<float> A, int lda, CudaDeviceVariable<float> cscValB, CudaDeviceVariable<int> cscColPtrB, CudaDeviceVariable<int> cscRowIndB, float beta, CudaDeviceVariable<float> C, int ldc)
{
res = CudaSparseNativeMethods.cusparseSgemmi(_handle, m, n, k, nnz, ref alpha, A.DevicePointer, lda, cscValB.DevicePointer, cscColPtrB.DevicePointer, cscRowIndB.DevicePointer, ref beta, C.DevicePointer, ldc);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseSgemmi"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}","Description: dense - sparse matrix multiplication C = alpha * A * B + beta * C, where A is column-major dense matrix, B is a sparse matrix in CSC format, and C is column-major dense matrix.",1
325,"public void Gemmi(int m, int n, int k, int nnz, double alpha, CudaDeviceVariable<double> A, int lda, CudaDeviceVariable<double> cscValB, CudaDeviceVariable<int> cscColPtrB, CudaDeviceVariable<int> cscRowIndB, double beta, CudaDeviceVariable<double> C, int ldc)
{
res = CudaSparseNativeMethods.cusparseDgemmi(_handle, m, n, k, nnz, ref alpha, A.DevicePointer, lda, cscValB.DevicePointer, cscColPtrB.DevicePointer, cscRowIndB.DevicePointer, ref beta, C.DevicePointer, ldc);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseDgemmi"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}","Description: dense - sparse matrix multiplication C = alpha * A * B + beta * C, where A is column-major dense matrix, B is a sparse matrix in CSC format, and C is column-major dense matrix.",1
326,"public void Gemmi(int m, int n, int k, int nnz, cuFloatComplex alpha, CudaDeviceVariable<cuFloatComplex> A, int lda, CudaDeviceVariable<cuFloatComplex> cscValB, CudaDeviceVariable<int> cscColPtrB, CudaDeviceVariable<int> cscRowIndB, cuFloatComplex beta, CudaDeviceVariable<cuFloatComplex> C, int ldc)
{
res = CudaSparseNativeMethods.cusparseCgemmi(_handle, m, n, k, nnz, ref alpha, A.DevicePointer, lda, cscValB.DevicePointer, cscColPtrB.DevicePointer, cscRowIndB.DevicePointer, ref beta, C.DevicePointer, ldc);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseCgemmi"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}","Description: dense - sparse matrix multiplication C = alpha * A * B + beta * C, where A is column-major dense matrix, B is a sparse matrix in CSC format, and C is column-major dense matrix.",1
327,"public void Gemmi(int m, int n, int k, int nnz, cuDoubleComplex alpha, CudaDeviceVariable<cuDoubleComplex> A, int lda, CudaDeviceVariable<cuDoubleComplex> cscValB, CudaDeviceVariable<int> cscColPtrB, CudaDeviceVariable<int> cscRowIndB, cuDoubleComplex beta, CudaDeviceVariable<cuDoubleComplex> C, int ldc)
{
res = CudaSparseNativeMethods.cusparseZgemmi(_handle, m, n, k, nnz, ref alpha, A.DevicePointer, lda, cscValB.DevicePointer, cscColPtrB.DevicePointer, cscRowIndB.DevicePointer, ref beta, C.DevicePointer, ldc);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseZgemmi"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}","Description: dense - sparse matrix multiplication C = alpha * A * B + beta * C, where A is column-major dense matrix, B is a sparse matrix in CSC format, and C is column-major dense matrix.",1
328,"public void Gemmi(int m, int n, int k, int nnz, CudaDeviceVariable<float> alpha, CudaDeviceVariable<float> A, int lda, CudaDeviceVariable<float> cscValB, CudaDeviceVariable<int> cscColPtrB,
CudaDeviceVariable<int> cscRowIndB, CudaDeviceVariable<float> beta, CudaDeviceVariable<float> C, int ldc)
{
res = CudaSparseNativeMethods.cusparseSgemmi(_handle, m, n, k, nnz, alpha.DevicePointer, A.DevicePointer, lda, cscValB.DevicePointer, cscColPtrB.DevicePointer, cscRowIndB.DevicePointer, beta.DevicePointer, C.DevicePointer, ldc);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseSgemmi"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}","Description: dense - sparse matrix multiplication C = alpha * A * B + beta * C, where A is column-major dense matrix, B is a sparse matrix in CSC format, and C is column-major dense matrix.",1
329,"public void Gemmi(int m, int n, int k, int nnz, CudaDeviceVariable<double> alpha, CudaDeviceVariable<double> A, int lda, CudaDeviceVariable<double> cscValB, CudaDeviceVariable<int> cscColPtrB,
CudaDeviceVariable<int> cscRowIndB, CudaDeviceVariable<double> beta, CudaDeviceVariable<double> C, int ldc)
{
res = CudaSparseNativeMethods.cusparseDgemmi(_handle, m, n, k, nnz, alpha.DevicePointer, A.DevicePointer, lda, cscValB.DevicePointer, cscColPtrB.DevicePointer, cscRowIndB.DevicePointer, beta.DevicePointer, C.DevicePointer, ldc);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseDgemmi"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}","Description: dense - sparse matrix multiplication C = alpha * A * B + beta * C, where A is column-major dense matrix, B is a sparse matrix in CSC format, and C is column-major dense matrix.",1
330,"public void Gemmi(int m, int n, int k, int nnz, CudaDeviceVariable<cuFloatComplex> alpha, CudaDeviceVariable<cuFloatComplex> A, int lda, CudaDeviceVariable<cuFloatComplex> cscValB, CudaDeviceVariable<int> cscColPtrB, CudaDeviceVariable<int> cscRowIndB, CudaDeviceVariable<cuFloatComplex> beta, CudaDeviceVariable<cuFloatComplex> C, int ldc)
{
res = CudaSparseNativeMethods.cusparseCgemmi(_handle, m, n, k, nnz, alpha.DevicePointer, A.DevicePointer, lda, cscValB.DevicePointer, cscColPtrB.DevicePointer, cscRowIndB.DevicePointer, beta.DevicePointer, C.DevicePointer, ldc);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseCgemmi"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}","Description: dense - sparse matrix multiplication C = alpha * A * B + beta * C, where A is column-major dense matrix, B is a sparse matrix in CSC format, and C is column-major dense matrix.",1
331,"public void Gemmi(int m, int n, int k, int nnz, CudaDeviceVariable<cuDoubleComplex> alpha, CudaDeviceVariable<cuDoubleComplex> A, int lda, CudaDeviceVariable<cuDoubleComplex> cscValB,
CudaDeviceVariable<int> cscColPtrB, CudaDeviceVariable<int> cscRowIndB, CudaDeviceVariable<cuDoubleComplex> beta, CudaDeviceVariable<cuDoubleComplex> C, int ldc)
{
res = CudaSparseNativeMethods.cusparseZgemmi(_handle, m, n, k, nnz, alpha.DevicePointer, A.DevicePointer, lda, cscValB.DevicePointer, cscColPtrB.DevicePointer, cscRowIndB.DevicePointer, beta.DevicePointer, C.DevicePointer, ldc);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseZgemmi"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}","Description: dense - sparse matrix multiplication C = alpha * A * B + beta * C, where A is column-major dense matrix, B is a sparse matrix in CSC format, and C is column-major dense matrix.",1
332,"public void Nnz_compress(int m, CudaSparseMatrixDescriptor descr, CudaDeviceVariable<float> values, CudaDeviceVariable<int> rowPtr, CudaDeviceVariable<int> nnzPerRow, CudaDeviceVariable<int> nnzTotal, float tol)
{
res = CudaSparseNativeMethods.cusparseSnnz_compress(_handle, m, descr.Descriptor, values.DevicePointer, rowPtr.DevicePointer, nnzPerRow.DevicePointer, nnzTotal.DevicePointer, tol);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseSnnz_compress"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",This routine finds the total number of non-zero elements and the number of non-zero elements per row in a noncompressed csr matrix A.,1
333,"public void Nnz_compress(int m, CudaSparseMatrixDescriptor descr, CudaDeviceVariable<double> values, CudaDeviceVariable<int> rowPtr, CudaDeviceVariable<int> nnzPerRow, CudaDeviceVariable<int> nnzTotal, double tol)
{
res = CudaSparseNativeMethods.cusparseDnnz_compress(_handle, m, descr.Descriptor, values.DevicePointer, rowPtr.DevicePointer, nnzPerRow.DevicePointer, nnzTotal.DevicePointer, tol);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseDnnz_compress"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",This routine finds the total number of non-zero elements and the number of non-zero elements per row in a noncompressed csr matrix A.,1
334,"public void Nnz_compress(int m, CudaSparseMatrixDescriptor descr, CudaDeviceVariable<cuFloatComplex> values, CudaDeviceVariable<int> rowPtr, CudaDeviceVariable<int> nnzPerRow, CudaDeviceVariable<int> nnzTotal, cuFloatComplex tol)
{
res = CudaSparseNativeMethods.cusparseCnnz_compress(_handle, m, descr.Descriptor, values.DevicePointer, rowPtr.DevicePointer, nnzPerRow.DevicePointer, nnzTotal.DevicePointer, tol);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseCnnz_compress"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",This routine finds the total number of non-zero elements and the number of non-zero elements per row in a noncompressed csr matrix A.,1
335,"public void Nnz_compress(int m, CudaSparseMatrixDescriptor descr, CudaDeviceVariable<cuDoubleComplex> values, CudaDeviceVariable<int> rowPtr, CudaDeviceVariable<int> nnzPerRow, CudaDeviceVariable<int> nnzTotal, cuDoubleComplex tol)
{
res = CudaSparseNativeMethods.cusparseZnnz_compress(_handle, m, descr.Descriptor, values.DevicePointer, rowPtr.DevicePointer, nnzPerRow.DevicePointer, nnzTotal.DevicePointer, tol);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseZnnz_compress"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",This routine finds the total number of non-zero elements and the number of non-zero elements per row in a noncompressed csr matrix A.,1
336,"public void Csr2csr_compress(int m, int n, CudaSparseMatrixDescriptor descra, CudaDeviceVariable<float> inVal, CudaDeviceVariable<int> inColInd, CudaDeviceVariable<int> inRowPtr,
int inNnz, CudaDeviceVariable<int> nnzPerRow, CudaDeviceVariable<float> outVal, CudaDeviceVariable<int> outColInd, CudaDeviceVariable<int> outRowPtr, float tol)
{
res = CudaSparseNativeMethods.cusparseScsr2csr_compress(_handle, m, n, descra.Descriptor, inVal.DevicePointer, inColInd.DevicePointer, inRowPtr.DevicePointer, inNnz,
nnzPerRow.DevicePointer, outVal.DevicePointer, outColInd.DevicePointer, outRowPtr.DevicePointer, tol);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseScsr2csr_compress"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",This routine takes as input a csr form where the values may have 0 elements and compresses it to return a csr form with no zeros.,1
337,"public void Csr2csr_compress(int m, int n, CudaSparseMatrixDescriptor descra, CudaDeviceVariable<double> inVal, CudaDeviceVariable<int> inColInd, CudaDeviceVariable<int> inRowPtr,
int inNnz, CudaDeviceVariable<int> nnzPerRow, CudaDeviceVariable<double> outVal, CudaDeviceVariable<int> outColInd, CudaDeviceVariable<int> outRowPtr, double tol)
{
res = CudaSparseNativeMethods.cusparseDcsr2csr_compress(_handle, m, n, descra.Descriptor, inVal.DevicePointer, inColInd.DevicePointer, inRowPtr.DevicePointer, inNnz,
nnzPerRow.DevicePointer, outVal.DevicePointer, outColInd.DevicePointer, outRowPtr.DevicePointer, tol);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseDcsr2csr_compress"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",This routine takes as input a csr form where the values may have 0 elements and compresses it to return a csr form with no zeros.,1
338,"public void Csr2csr_compress(int m, int n, CudaSparseMatrixDescriptor descra, CudaDeviceVariable<cuFloatComplex> inVal, CudaDeviceVariable<int> inColInd, CudaDeviceVariable<int> inRowPtr,
int inNnz, CudaDeviceVariable<int> nnzPerRow, CudaDeviceVariable<cuFloatComplex> outVal, CudaDeviceVariable<int> outColInd, CudaDeviceVariable<int> outRowPtr, cuFloatComplex tol)
{
res = CudaSparseNativeMethods.cusparseCcsr2csr_compress(_handle, m, n, descra.Descriptor, inVal.DevicePointer, inColInd.DevicePointer, inRowPtr.DevicePointer, inNnz,
nnzPerRow.DevicePointer, outVal.DevicePointer, outColInd.DevicePointer, outRowPtr.DevicePointer, tol);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseCcsr2csr_compress"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",This routine takes as input a csr form where the values may have 0 elements and compresses it to return a csr form with no zeros.,1
339,"public void Csr2csr_compress(int m, int n, CudaSparseMatrixDescriptor descra, CudaDeviceVariable<cuDoubleComplex> inVal, CudaDeviceVariable<int> inColInd, CudaDeviceVariable<int> inRowPtr,
int inNnz, CudaDeviceVariable<int> nnzPerRow, CudaDeviceVariable<cuDoubleComplex> outVal, CudaDeviceVariable<int> outColInd, CudaDeviceVariable<int> outRowPtr, cuDoubleComplex tol)
{
res = CudaSparseNativeMethods.cusparseZcsr2csr_compress(_handle, m, n, descra.Descriptor, inVal.DevicePointer, inColInd.DevicePointer, inRowPtr.DevicePointer, inNnz,
nnzPerRow.DevicePointer, outVal.DevicePointer, outColInd.DevicePointer, outRowPtr.DevicePointer, tol);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseZcsr2csr_compress"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",This routine takes as input a csr form where the values may have 0 elements and compresses it to return a csr form with no zeros.,1
340,"~CudaSparseContext()
{
Dispose(false);
}",For dispose,1
341,"~CudaSparseCsrgemm2Info()
{
Dispose(false);
}",For dispose,1
342,"public struct Luid
{
/// <summary>
/// /// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
public byte[] bytes;
}",8-byte locally unique identifier. Value is undefined on TCC and non-Windows platforms,1
343,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorProcessing.nppiColorTwist32f_16s_C1IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_16s_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
344,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorProcessing.nppiColorTwist32f_16s_C2IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_16s_C2IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
345,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorProcessing.nppiColorTwist32f_16u_C1IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_16u_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
346,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorProcessing.nppiColorTwist32f_16u_C2IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_16u_C2IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
347,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorTwist.nppiColorTwist32f_16s_C3IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_16s_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
348,"public void ColorTwistA(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorTwist.nppiColorTwist32f_16s_AC4IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_16sA_C4IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
349,"public void WarpAffine(NPPImage_16uC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_16u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_16u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
350,"public void WarpAffine(NPPImage_16uC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_16u_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_16u_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
351,"public void WarpAffineBack(NPPImage_16uC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_16u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_16u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
352,"public void WarpAffineBack(NPPImage_16uC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_16u_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_16u_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
353,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_16uC1 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_16u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_16u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
354,"public void WarpPerspective(NPPImage_16uC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_16u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_16u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
355,"public void WarpPerspectiveBack(NPPImage_16uC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_16u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_16u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
356,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_16uC1 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_16u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_16u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
357,"public struct DirectionVectors32
{
/// <summary>
/// Inner data array
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
public uint[] Array;
}",Array of 32-bit direction vectors,1
358,"public struct DirectionVectors64
{
/// <summary>
/// Inner data array
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
public ulong[] Array;
}",Array of 64-bit direction vectors,1
359,"public interface ICudaGraphicsInteropResource : IDisposable
{ /// <summary>
/// /// </summary>
/// <param name=""stream""></param>
void Map(CUstream stream);
/// <summary>
/// /// </summary>
void Map();
/// <summary>
/// /// </summary>
/// <param name=""stream""></param>
void UnMap(CUstream stream);
/// <summary>
/// /// </summary>
void UnMap();
/// <summary>
/// /// </summary>
/// <param name=""flags""></param>
void SetMapFlags(CUGraphicsMapResourceFlags flags);
/// <summary>
/// /// </summary>
void Unregister();
/// <summary>
/// /// </summary>
/// <typeparam name=""T""></typeparam>
/// <returns></returns>
CudaDeviceVariable<T> GetMappedPointer<T>() where T : struct;
/// <summary>
/// /// </summary>
/// <param name=""devicePtr""></param>
/// <param name=""size""></param>
void GetMappedPointer(out CUdeviceptr devicePtr, out SizeT size);
/// <summary>
/// /// </summary>
/// <returns></returns>
CUdeviceptr GetMappedPointer();
/// <summary>
/// /// </summary>
/// <param name=""arrayIndex""></param>
/// <param name=""mipLevel""></param>
/// <returns></returns>
CudaArray1D GetMappedArray1D(uint arrayIndex, uint mipLevel);
/// <summary>
/// /// </summary>
/// <param name=""arrayIndex""></param>
/// <param name=""mipLevel""></param>
/// <returns></returns>
CudaArray2D GetMappedArray2D(uint arrayIndex, uint mipLevel);
/// <summary>
/// /// </summary>
/// <param name=""arrayIndex""></param>
/// <param name=""mipLevel""></param>
/// <returns></returns>
CudaArray3D GetMappedArray3D(uint arrayIndex, uint mipLevel);
/// <summary>
/// /// </summary>
/// <returns></returns>
CudaMipmappedArray GetMappedMipmappedArray(CUArrayFormat format, CudaMipmappedArrayNumChannels numChannels);
/// <summary>
/// /// </summary>
/// <param name=""arrayIndex""></param>
/// <param name=""mipLevel""></param>
/// <returns></returns>
CUarray GetMappedCUArray(uint arrayIndex, uint mipLevel);
/// <summary>
/// /// </summary>
/// <returns></returns>
CUmipmappedArray GetMappedCUMipmappedArray();
/// <summary>
/// /// </summary>
/// <returns></returns>
CUgraphicsResource GetCUgraphicsResource();
/// <summary>
/// /// </summary>
void SetIsMapped();
/// <summary>
/// /// </summary>
void SetIsUnmapped();
}",Common interface for OpenGL and DirectX graphics interop resources,1
360,"public struct Npp64fc
{
/// <summary>
/// Real part
/// </summary>
public double re;
/// <summary>
/// Imaginary part
/// </summary>
public double im;
/// <summary>
/// Non-default constructor
/// </summary>
/// <param name=""aRe""></param>
/// <param name=""aIm""></param>
public Npp64fc(double aRe, double aIm)
{
re = aRe;
im = aIm;
}
/// <summary>
/// Overrides ToString(): ""re + im i""
/// </summary>
/// <returns></returns>
public override string ToString()
{
return string.Format(CultureInfo.CurrentCulture, ""({0} + {1} i)"", this.re, this.im);
}
}",Complex Number. This struct represents a double floating-point complex number.,1
361,"public struct Npp64sc
{
/// <summary>
/// Real part
/// </summary>
public long re;
/// <summary>
/// Imaginary part
/// </summary>
public long im;
/// <summary>
/// Non-default constructor
/// </summary>
/// <param name=""aRe""></param>
/// <param name=""aIm""></param>
public Npp64sc(long aRe, long aIm)
{
re = aRe;
im = aIm;
}
/// <summary>
/// Overrides ToString(): ""re + im i""
/// </summary>
/// <returns></returns>
public override string ToString()
{
return string.Format(CultureInfo.CurrentCulture, ""({0} + {1} i)"", this.re, this.im);
}
}",Complex Number. This struct represents a long long complex number.,1
362,"public struct Npp16sc
{
/// <summary>
/// Real part
/// </summary>
public short re;
/// <summary>
/// Imaginary part
/// </summary>
public short im;
/// <summary>
/// Non-default constructor
/// </summary>
/// <param name=""aRe""></param>
/// <param name=""aIm""></param>
public Npp16sc(short aRe, short aIm)
{
re = aRe;
im = aIm;
}
/// <summary>
/// Overrides ToString(): ""re + im i""
/// </summary>
/// <returns></returns>
public override string ToString()
{
return string.Format(CultureInfo.CurrentCulture, ""({0} + {1} i)"", this.re, this.im);
}
}",Complex Number. This struct represents a short complex number.,1
363,"public struct Npp32sc
{
/// <summary>
/// Real part
/// </summary>
public int re;
/// <summary>
/// Imaginary part
/// </summary>
public int im;
/// <summary>
/// Non-default constructor
/// </summary>
/// <param name=""aRe""></param>
/// <param name=""aIm""></param>
public Npp32sc(int aRe, int aIm)
{
re = aRe;
im = aIm;
}
/// <summary>
/// Overrides ToString(): ""re + im i""
/// </summary>
/// <returns></returns>
public override string ToString()
{
return string.Format(CultureInfo.CurrentCulture, ""({0} + {1} i)"", this.re, this.im);
}
}",Complex Number. This struct represents a signed int complex number.,1
364,"public struct Npp32fc
{
/// <summary>
/// Real part
/// </summary>
public float re;
/// <summary>
/// Imaginary part
/// </summary>
public float im;
/// <summary>
/// Non-default constructor
/// </summary>
/// <param name=""aRe""></param>
/// <param name=""aIm""></param>
public Npp32fc(float aRe, float aIm)
{
re = aRe;
im = aIm;
}
/// <summary>
/// Overrides ToString(): ""re + im i""
/// </summary>
/// <returns></returns>
public override string ToString()
{
return string.Format(CultureInfo.CurrentCulture, ""({0} + {1} i)"", this.re, this.im);
}
}",Complex Number. This struct represents a single floating-point complex number.,1
365,"public struct LRNConstants
{
/// <summary>
/// minimum allowed lrnN
/// </summary>
public const double MinN = 1;
/// <summary>
/// maximum allowed lrnN
/// </summary>
public const double MaxN = 16;
/// <summary>
/// minimum allowed lrnK
/// </summary>
public const double MinK = 1e-5;
/// <summary>
/// minimum allowed lrnBeta
/// </summary>
public const double MinBeta = 0.01;
}","Constants for LRN, #define in cudnn.h",1
366,"public CudaTextureMipmappedArray(CudaKernel kernel, string texName, CUAddressMode addressMode0, CUAddressMode addressMode1, CUAddressMode addressMode2,
CUFilterMode filterMode, CUTexRefSetFlags flags, CudaMipmappedArray array,
uint maxAniso, CUFilterMode mipmapFilterMode, float mipmapLevelBias, float minMipmapLevelClamp, float maxMipmapLevelClamp)
{
_maxAniso = maxAniso;
_mipmapFilterMode = mipmapFilterMode;
_mipmapLevelBias = mipmapLevelBias;
_minMipmapLevelClamp = minMipmapLevelClamp;
_maxMipmapLevelClamp = maxMipmapLevelClamp;
_texref = new CUtexref();
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetTexRef(ref _texref, kernel.CUModule, texName);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Texture name: {3}"", DateTime.Now, ""cuModuleGetTexRef"", res, texName));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetAddressMode(_texref, 0, addressMode0);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetAddressMode"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetAddressMode(_texref, 1, addressMode1);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetAddressMode"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetAddressMode(_texref, 2, addressMode2);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetAddressMode"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetFilterMode(_texref, filterMode);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetFilterMode"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetFlags(_texref, flags);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetFlags"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetFormat(_texref, array.Array3DDescriptor.Format, (int)array.Array3DDescriptor.NumChannels);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetFormat"", res));
if (res != CUResult.Success) throw new CudaException(res);
_filtermode = filterMode;
_flags = flags;
_addressMode0 = addressMode0;
_addressMode1 = addressMode1;
_addressMode2 = addressMode2;
_name = texName;
_module = kernel.CUModule;
_cufunction = kernel.CUFunction;
_array = array;
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetMipmappedArray(_texref, _array.CUMipmappedArray, CUTexRefSetArrayFlags.OverrideFormat);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetMipmappedArray"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetMaxAnisotropy(_texref, maxAniso);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetMaxAnisotropy"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetMipmapFilterMode(_texref, mipmapFilterMode);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetMipmapFilterMode"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetMipmapLevelBias(_texref, mipmapLevelBias);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetMipmapLevelBias"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetMipmapLevelClamp(_texref, minMipmapLevelClamp, maxMipmapLevelClamp);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetMipmapLevelClamp"", res));
if (res != CUResult.Success) throw new CudaException(res);
}",Creates a new mipmapped texture from array memory,1
367,"public CudaTextureMipmappedArray(CudaKernel kernel, string texName, CUAddressMode addressModeForAllDimensions, CUFilterMode filterMode, CUTexRefSetFlags flags, CudaMipmappedArray array,
uint maxAniso, CUFilterMode mipmapFilterMode, float mipmapLevelBias, float minMipmapLevelClamp, float maxMipmapLevelClamp)
: this(kernel, texName, addressModeForAllDimensions, addressModeForAllDimensions, addressModeForAllDimensions, filterMode, flags, array,
maxAniso, mipmapFilterMode, mipmapLevelBias, minMipmapLevelClamp, maxMipmapLevelClamp)
{
}",Creates a new mipmapped texture from array memory,1
368,"public CudaTextureMipmappedArray(CudaKernel kernel, string texName, CUAddressMode addressMode0, CUAddressMode addressMode1, CUAddressMode addressMode2,
CUFilterMode filterMode, CUTexRefSetFlags flags, CUDAArray3DDescriptor descriptor, uint numMipmapLevels, uint maxAniso, CUFilterMode mipmapFilterMode, float mipmapLevelBias, float minMipmapLevelClamp, float maxMipmapLevelClamp)
{
_maxAniso = maxAniso;
_mipmapFilterMode = mipmapFilterMode;
_mipmapLevelBias = mipmapLevelBias;
_minMipmapLevelClamp = minMipmapLevelClamp;
_maxMipmapLevelClamp = maxMipmapLevelClamp;
_texref = new CUtexref();
res = DriverAPINativeMethods.ModuleManagement.cuModuleGetTexRef(ref _texref, kernel.CUModule, texName);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}, Texture name: {3}"", DateTime.Now, ""cuModuleGetTexRef"", res, texName));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetAddressMode(_texref, 0, addressMode0);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetAddressMode"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetAddressMode(_texref, 1, addressMode1);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetAddressMode"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetAddressMode(_texref, 2, addressMode2);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetAddressMode"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetFilterMode(_texref, filterMode);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetFilterMode"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetFlags(_texref, flags);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetFlags"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetFormat(_texref, descriptor.Format, (int)descriptor.NumChannels);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetFormat"", res));
if (res != CUResult.Success) throw new CudaException(res);
_filtermode = filterMode;
_flags = flags;
_addressMode0 = addressMode0;
_addressMode1 = addressMode1;
_addressMode2 = addressMode2;
_arrayDescriptor = descriptor;
_name = texName;
_module = kernel.CUModule;
_cufunction = kernel.CUFunction;
_array = new CudaMipmappedArray(descriptor, numMipmapLevels);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetMipmappedArray(_texref, _array.CUMipmappedArray, CUTexRefSetArrayFlags.OverrideFormat);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetMipmappedArray"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetMaxAnisotropy(_texref, maxAniso);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetMaxAnisotropy"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetMipmapFilterMode(_texref, mipmapFilterMode);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetMipmapFilterMode"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetMipmapLevelBias(_texref, mipmapLevelBias);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetMipmapLevelBias"", res));
if (res != CUResult.Success) throw new CudaException(res);
res = DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetMipmapLevelClamp(_texref, minMipmapLevelClamp, maxMipmapLevelClamp);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuTexRefSetMipmapLevelClamp"", res));
if (res != CUResult.Success) throw new CudaException(res);
}",Creates a new mipmapped texture from array memory. Allocates a new mipmapped array.,1
369,"public CudaTextureMipmappedArray(CudaKernel kernel, string texName, CUAddressMode addressModeForAllDimensions,
CUFilterMode filterMode, CUTexRefSetFlags flags, CUDAArray3DDescriptor descriptor, uint numMipmapLevels,
uint maxAniso, CUFilterMode mipmapFilterMode, float mipmapLevelBias, float minMipmapLevelClamp, float maxMipmapLevelClamp)
: this(kernel, texName, addressModeForAllDimensions, addressModeForAllDimensions, addressModeForAllDimensions, filterMode, flags, descriptor,
numMipmapLevels, maxAniso, mipmapFilterMode, mipmapLevelBias, minMipmapLevelClamp, maxMipmapLevelClamp)
{
}",Creates a new mipmapped texture from array memory. Allocates a new mipmapped array.,1
370,"public CudaStream()
: this(CUStreamFlags.None)
{
}",Creates a new Stream using CUStreamFlags.None,1
371,"public CudaStream(int priority)
: this(priority, CUStreamFlags.None)
{
}",Creates a new Stream using CUStreamFlags.None and with the given priority This API alters the scheduler priority of work in the stream. Work in a higher priority stream may preempt work already executing in a low priority stream. '0' represents default priority.,1
372,"public struct CUuuid
{
/// <summary>
/// /// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
public byte[] bytes;
}",CUDA definition of UUID,1
373,"public struct CUdevice
{
/// <summary>
/// /// </summary>
public int Pointer;
/// <summary>
/// Device that represents the CPU
/// </summary>
static CUdevice CPU
{
get {
CUdevice cpu = new CUdevice();
cpu.Pointer = -1;
return cpu; }
}
/// <summary>
/// Device that represents an invalid device
/// </summary>
static CUdevice Invalid
{
get {
CUdevice invalid = new CUdevice();
invalid.Pointer = -2;
return invalid; }
}
}",Cuda device,1
374,"public struct CUgraphExec
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",CUDA executable graph,1
375,"public struct CUexternalMemory
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",CUDA external memory,1
376,"public struct CUexternalSemaphore
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",CUDA external semaphore,1
377,"public struct CUgraph
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",CUDA graph,1
378,"public struct CUgraphNode
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
#region Properties
/// <summary>
/// Returns the type of the Node
/// </summary>
public CUgraphNodeType Type
{
get
{
CUgraphNodeType type = new CUgraphNodeType();
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphNodeGetType(this, ref type);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphNodeGetType"", res));
if (res != CUResult.Success) throw new CudaException(res);
return type;
}
}
#endregion
#region Methods
/// <summary>
/// Sets the parameters of host node nodeParams.
/// </summary>
/// <param name=""nodeParams""></param>
public void SetParameters(CUDA_HOST_NODE_PARAMS nodeParams)
{
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphHostNodeSetParams(this, ref nodeParams);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphHostNodeSetParams"", res));
if (res != CUResult.Success) throw new CudaException(res);
}
/// <summary>
/// Sets the parameters of kernel node nodeParams.
/// </summary>
/// <param name=""nodeParams""></param>
public void SetParameters(CUDA_KERNEL_NODE_PARAMS nodeParams)
{
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphKernelNodeSetParams(this, ref nodeParams);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphKernelNodeSetParams"", res));
if (res != CUResult.Success) throw new CudaException(res);
}
/// <summary>
/// Sets the parameters of memcpy node nodeParams.
/// </summary>
/// <param name=""nodeParams""></param>
public void SetParameters(CUDAMemCpy3D nodeParams)
{
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphMemcpyNodeSetParams(this, ref nodeParams);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphMemcpyNodeSetParams"", res));
if (res != CUResult.Success) throw new CudaException(res);
}
/// <summary>
/// Sets the parameters of memset node nodeParams.
/// </summary>
/// <param name=""nodeParams""></param>
public void SetParameters(CUDA_MEMSET_NODE_PARAMS nodeParams)
{
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphMemsetNodeSetParams(this, ref nodeParams);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphMemsetNodeSetParams"", res));
if (res != CUResult.Success) throw new CudaException(res);
}
/// <summary>
/// Gets the parameters of host node.
/// </summary>
/// <param name=""nodeParams""></param>
public void GetParameters(ref CUDA_HOST_NODE_PARAMS nodeParams)
{
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphHostNodeGetParams(this, ref nodeParams);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphHostNodeGetParams"", res));
if (res != CUResult.Success) throw new CudaException(res);
}
/// <summary>
/// Gets the parameters of kernel node.
/// </summary>
/// <param name=""nodeParams""></param>
public void GetParameters(ref CUDA_KERNEL_NODE_PARAMS nodeParams)
{
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphKernelNodeGetParams(this, ref nodeParams);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphKernelNodeGetParams"", res));
if (res != CUResult.Success) throw new CudaException(res);
}
/// <summary>
/// Gets the parameters of memcpy node.
/// </summary>
/// <param name=""nodeParams""></param>
public void GetParameters(ref CUDAMemCpy3D nodeParams)
{
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphMemcpyNodeGetParams(this, ref nodeParams);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphMemcpyNodeGetParams"", res));
if (res != CUResult.Success) throw new CudaException(res);
}
/// <summary>
/// Gets the parameters of memset node.
/// </summary>
/// <param name=""nodeParams""></param>
public void GetParameters(ref CUDA_MEMSET_NODE_PARAMS nodeParams)
{
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphMemsetNodeGetParams(this, ref nodeParams);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphMemsetNodeGetParams"", res));
if (res != CUResult.Success) throw new CudaException(res);
}
/// <summary>
/// Only for ChildGraphNodes
/// </summary>
/// <returns></returns>
public CudaGraph GetGraph()
{
CUgraph graph = new CUgraph();
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphChildGraphNodeGetGraph(this, ref graph);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphChildGraphNodeGetGraph"", res));
if (res != CUResult.Success) throw new CudaException(res);
return new CudaGraph(graph);
}
/// <summary>
/// Returns a node's dependencies.
/// </summary>
/// <returns></returns>
public CUgraphNode[] GetDependencies()
{
SizeT numNodes = new SizeT();
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphNodeGetDependencies(this, null, ref numNodes);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphNodeGetDependencies"", res));
if (res != CUResult.Success) throw new CudaException(res);
if (numNodes > 0)
{
CUgraphNode[] nodes = new CUgraphNode[numNodes];
res = DriverAPINativeMethods.GraphManagment.cuGraphNodeGetDependencies(this, nodes, ref numNodes);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphNodeGetDependencies"", res));
if (res != CUResult.Success) throw new CudaException(res);
return nodes;
}
return null;
}
/// <summary>
/// Returns a node's dependent nodes
/// </summary>
public CUgraphNode[] GetDependentNodes()
{
SizeT numNodes = new SizeT();
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphNodeGetDependentNodes(this, null, ref numNodes);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphNodeGetDependentNodes"", res));
if (res != CUResult.Success) throw new CudaException(res);
if (numNodes > 0)
{
CUgraphNode[] nodes = new CUgraphNode[numNodes];
res = DriverAPINativeMethods.GraphManagment.cuGraphNodeGetDependentNodes(this, nodes, ref numNodes);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphNodeGetDependentNodes"", res));
if (res != CUResult.Success) throw new CudaException(res);
return nodes;
}
return null;
}
#endregion
}",CUDA graph node,1
379,"public struct CUgraphicsResource
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",CUDA graphics interop resource (DirectX / OpenGL),1
380,"public struct CUmipmappedArray
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",CUDA mipmapped array,1
381,"public struct CUstream
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
/// <summary>
/// Returns the CUDA NULL stream (0)
/// </summary>
public static CUstream NullStream
{
get
{
CUstream s = new CUstream();
s.Pointer = (IntPtr)0;
return s;
}
}
/// <summary>
/// Stream handle that can be passed as a CUstream to use an implicit stream
/// with legacy synchronization behavior.
/// </summary>
public static CUstream LegacyStream
{
get {
CUstream s = new CUstream();
s.Pointer = (IntPtr)1;
return s; }
}
/// <summary>
/// Stream handle that can be passed as a CUstream to use an implicit stream
/// with per-thread synchronization behavior.
/// </summary>
public static CUstream StreamPerThread
{
get
{
CUstream s = new CUstream();
s.Pointer = (IntPtr)2;
return s;
}
}
}",Cuda stream,1
382,"public struct CurandGenerator
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",CURAND generator,1
383,"public CudaSparseMatrixDescriptor(cusparseFillMode fillMode, cusparseDiagType diagType)
{
_descr = new cusparseMatDescr();
res = CudaSparseNativeMethods.cusparseCreateMatDescr(ref _descr);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseCreateMatDescr"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
SetMatFillMode(fillMode);
SetMatDiagType(diagType);
}",CUSPARSE_MATRIXYPE_GENERAL CUSPARSE_INDEX_BASE_ZERO,0
384,"public CudaSparseMatrixDescriptor()
{
_descr = new cusparseMatDescr();
res = CudaSparseNativeMethods.cusparseCreateMatDescr(ref _descr);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cusparseCreateMatDescr"", res));
if (res != cusparseStatus.Success)
throw new CudaSparseException(res);
}",CUSPARSE_MATRIXYPE_GENERAL CUSPARSE_INDEX_BASE_ZERO All other fields are uninitialized,0
385,"public interface ICudaVectorTypeForArray
{
/// <summary>
/// Returns the Channel number from vector type, e.g. 3 for float3
/// </summary>
/// <returns></returns>
uint GetChannelNumber();
/// <summary>
/// Returns a matching CUArrayFormat. If none is availabe a CudaException is thrown.
/// </summary>
/// <returns></returns>
CUArrayFormat GetCUArrayFormat();
}",Define a common interface for all CUDA vector types supported by CudaArrays,1
386,"public struct DiscreteDistribution
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",Discrete Distribution,1
387,"public virtual void Dispose()
{
Dispose(true);
GC.SuppressFinalize(this);
}",Dispose,1
388,"public void SwapChannels(int[] aDstOrder)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_16s_C3IR(_devPtrRoi, _pitch, _sizeRoi, aDstOrder);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_16s_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [2,1,0] converts this to BGR channel order.",1
389,"public void SwapChannels(NPPImage_16sC3 dest, int[] aDstOrder)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_16s_C3R(_devPtrRoi, _pitch, dest.DevicePointerRoi, dest.Pitch, _sizeRoi, aDstOrder);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_16s_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [2,1,0] converts this to BGR channel order.",1
390,"public void SwapChannels(NPPImage_16sC4 dest, int[] aDstOrder, short nValue)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_16s_C3C4R(_devPtrRoi, _pitch, dest.DevicePointerRoi, dest.Pitch, _sizeRoi, aDstOrder, nValue);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_16s_C3C4R"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [3,2,1,0] converts this to VBGR channel order. An aDstOrder value of 3 will output nValue to that channel, an aDstOrder value greater than 3 will leave that particular destination channel value unmodified.",1
391,"private void InitializeComponent()
{
this.txt_info = new System.Windows.Forms.TextBox();
this.pictureBox_src = new System.Windows.Forms.PictureBox();
this.pictureBox_dest = new System.Windows.Forms.PictureBox();
this.btn_open = new System.Windows.Forms.Button();
this.btn_calc = new System.Windows.Forms.Button();
this.label1 = new System.Windows.Forms.Label();
this.label2 = new System.Windows.Forms.Label();
this.btn_Save = new System.Windows.Forms.Button();
this.hist_rb_src = new System.Windows.Forms.PictureBox();
this.hist_g_src = new System.Windows.Forms.PictureBox();
this.hist_b_src = new System.Windows.Forms.PictureBox();
this.hist_rb_dest = new System.Windows.Forms.PictureBox();
this.hist_g_dest = new System.Windows.Forms.PictureBox();
this.hist_b_dest = new System.Windows.Forms.PictureBox();
this.label3 = new System.Windows.Forms.Label();
this.label4 = new System.Windows.Forms.Label();
this.label5 = new System.Windows.Forms.Label();
this.label6 = new System.Windows.Forms.Label();
this.label7 = new System.Windows.Forms.Label();
this.label8 = new System.Windows.Forms.Label();
this.label9 = new System.Windows.Forms.Label();
this.label10 = new System.Windows.Forms.Label();
this.label11 = new System.Windows.Forms.Label();
this.label12 = new System.Windows.Forms.Label();
this.label13 = new System.Windows.Forms.Label();
this.label14 = new System.Windows.Forms.Label();
this.label15 = new System.Windows.Forms.Label();
this.lbl_max = new System.Windows.Forms.Label();
((System.ComponentModel.ISupportInitialize)(this.pictureBox_src)).BeginInit();
((System.ComponentModel.ISupportInitialize)(this.pictureBox_dest)).BeginInit();
((System.ComponentModel.ISupportInitialize)(this.hist_rb_src)).BeginInit();
((System.ComponentModel.ISupportInitialize)(this.hist_g_src)).BeginInit();
((System.ComponentModel.ISupportInitialize)(this.hist_b_src)).BeginInit();
((System.ComponentModel.ISupportInitialize)(this.hist_rb_dest)).BeginInit();
((System.ComponentModel.ISupportInitialize)(this.hist_g_dest)).BeginInit();
((System.ComponentModel.ISupportInitialize)(this.hist_b_dest)).BeginInit();
this.SuspendLayout();
// // txt_info
// this.txt_info.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this.txt_info.Location = new System.Drawing.Point(12, 12);
this.txt_info.Multiline = true;
this.txt_info.Name = ""txt_info"";
this.txt_info.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
this.txt_info.Size = new System.Drawing.Size(1536, 64);
this.txt_info.TabIndex = 0;
// // pictureBox_src
// this.pictureBox_src.Location = new System.Drawing.Point(12, 111);
this.pictureBox_src.Name = ""pictureBox_src"";
this.pictureBox_src.Size = new System.Drawing.Size(768, 576);
this.pictureBox_src.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
this.pictureBox_src.TabIndex = 1;
this.pictureBox_src.TabStop = false;
// // pictureBox_dest
// this.pictureBox_dest.Location = new System.Drawing.Point(786, 111);
this.pictureBox_dest.Name = ""pictureBox_dest"";
this.pictureBox_dest.Size = new System.Drawing.Size(768, 576);
this.pictureBox_dest.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
this.pictureBox_dest.TabIndex = 1;
this.pictureBox_dest.TabStop = false;
// // btn_open
// this.btn_open.Location = new System.Drawing.Point(637, 82);
this.btn_open.Name = ""btn_open"";
this.btn_open.Size = new System.Drawing.Size(93, 23);
this.btn_open.TabIndex = 2;
this.btn_open.Text = ""Open Image"";
this.btn_open.UseVisualStyleBackColor = true;
this.btn_open.Click += new System.EventHandler(this.btn_open_Click);
// // btn_calc
// this.btn_calc.Location = new System.Drawing.Point(736, 82);
this.btn_calc.Name = ""btn_calc"";
this.btn_calc.Size = new System.Drawing.Size(93, 23);
this.btn_calc.TabIndex = 3;
this.btn_calc.Text = ""Calculate!"";
this.btn_calc.UseVisualStyleBackColor = true;
this.btn_calc.Click += new System.EventHandler(this.btn_calc_Click);
// // label1
// this.label1.AutoSize = true;
this.label1.Location = new System.Drawing.Point(12, 92);
this.label1.Name = ""label1"";
this.label1.Size = new System.Drawing.Size(42, 13);
this.label1.TabIndex = 4;
this.label1.Text = ""Original"";
// // label2
// this.label2.AutoSize = true;
this.label2.Location = new System.Drawing.Point(1517, 92);
this.label2.Name = ""label2"";
this.label2.Size = new System.Drawing.Size(37, 13);
this.label2.TabIndex = 4;
this.label2.Text = ""Result"";
// // btn_Save
// this.btn_Save.Location = new System.Drawing.Point(835, 82);
this.btn_Save.Name = ""btn_Save"";
this.btn_Save.Size = new System.Drawing.Size(93, 23);
this.btn_Save.TabIndex = 5;
this.btn_Save.Text = ""Save image"";
this.btn_Save.UseVisualStyleBackColor = true;
this.btn_Save.Click += new System.EventHandler(this.btn_Save_Click);
// // hist_rb_src
// this.hist_rb_src.Location = new System.Drawing.Point(12, 695);
this.hist_rb_src.Name = ""hist_rb_src"";
this.hist_rb_src.Size = new System.Drawing.Size(256, 256);
this.hist_rb_src.TabIndex = 6;
this.hist_rb_src.TabStop = false;
// // hist_g_src
// this.hist_g_src.Location = new System.Drawing.Point(268, 695);
this.hist_g_src.Name = ""hist_g_src"";
this.hist_g_src.Size = new System.Drawing.Size(256, 256);
this.hist_g_src.TabIndex = 6;
this.hist_g_src.TabStop = false;
// // hist_b_src
// this.hist_b_src.Location = new System.Drawing.Point(524, 695);
this.hist_b_src.Name = ""hist_b_src"";
this.hist_b_src.Size = new System.Drawing.Size(256, 256);
this.hist_b_src.TabIndex = 6;
this.hist_b_src.TabStop = false;
// // hist_rb_dest
// this.hist_rb_dest.Location = new System.Drawing.Point(786, 695);
this.hist_rb_dest.Name = ""hist_rb_dest"";
this.hist_rb_dest.Size = new System.Drawing.Size(256, 256);
this.hist_rb_dest.TabIndex = 6;
this.hist_rb_dest.TabStop = false;
// // hist_g_dest
// this.hist_g_dest.Location = new System.Drawing.Point(1042, 695);
this.hist_g_dest.Name = ""hist_g_dest"";
this.hist_g_dest.Size = new System.Drawing.Size(256, 256);
this.hist_g_dest.TabIndex = 6;
this.hist_g_dest.TabStop = false;
// // hist_b_dest
// this.hist_b_dest.Location = new System.Drawing.Point(1298, 695);
this.hist_b_dest.Name = ""hist_b_dest"";
this.hist_b_dest.Size = new System.Drawing.Size(256, 256);
this.hist_b_dest.TabIndex = 6;
this.hist_b_dest.TabStop = false;
// // label3
// this.label3.AutoSize = true;
this.label3.Location = new System.Drawing.Point(755, 954);
this.label3.Name = ""label3"";
this.label3.Size = new System.Drawing.Size(25, 13);
this.label3.TabIndex = 7;
this.label3.Text = ""255"";
// // label4
// this.label4.AutoSize = true;
this.label4.Location = new System.Drawing.Point(499, 954);
this.label4.Name = ""label4"";
this.label4.Size = new System.Drawing.Size(25, 13);
this.label4.TabIndex = 7;
this.label4.Text = ""255"";
// // label5
// this.label5.AutoSize = true;
this.label5.Location = new System.Drawing.Point(243, 954);
this.label5.Name = ""label5"";
this.label5.Size = new System.Drawing.Size(25, 13);
this.label5.TabIndex = 7;
this.label5.Text = ""255"";
// // label6
// this.label6.AutoSize = true;
this.label6.Location = new System.Drawing.Point(1017, 954);
this.label6.Name = ""label6"";
this.label6.Size = new System.Drawing.Size(25, 13);
this.label6.TabIndex = 7;
this.label6.Text = ""255"";
// // label7
// this.label7.AutoSize = true;
this.label7.Location = new System.Drawing.Point(1273, 954);
this.label7.Name = ""label7"";
this.label7.Size = new System.Drawing.Size(25, 13);
this.label7.TabIndex = 7;
this.label7.Text = ""255"";
// // label8
// this.label8.AutoSize = true;
this.label8.Location = new System.Drawing.Point(1527, 954);
this.label8.Name = ""label8"";
this.label8.Size = new System.Drawing.Size(25, 13);
this.label8.TabIndex = 7;
this.label8.Text = ""255"";
// // label9
// this.label9.AutoSize = true;
this.label9.Location = new System.Drawing.Point(1295, 954);
this.label9.Name = ""label9"";
this.label9.Size = new System.Drawing.Size(13, 13);
this.label9.TabIndex = 7;
this.label9.Text = ""0"";
// // label10
// this.label10.AutoSize = true;
this.label10.Location = new System.Drawing.Point(1039, 954);
this.label10.Name = ""label10"";
this.label10.Size = new System.Drawing.Size(13, 13);
this.label10.TabIndex = 7;
this.label10.Text = ""0"";
// // label11
// this.label11.AutoSize = true;
this.label11.Location = new System.Drawing.Point(783, 954);
this.label11.Name = ""label11"";
this.label11.Size = new System.Drawing.Size(13, 13);
this.label11.TabIndex = 7;
this.label11.Text = ""0"";
// // label12
// this.label12.AutoSize = true;
this.label12.Location = new System.Drawing.Point(521, 954);
this.label12.Name = ""label12"";
this.label12.Size = new System.Drawing.Size(13, 13);
this.label12.TabIndex = 7;
this.label12.Text = ""0"";
// // label13
// this.label13.AutoSize = true;
this.label13.Location = new System.Drawing.Point(265, 954);
this.label13.Name = ""label13"";
this.label13.Size = new System.Drawing.Size(13, 13);
this.label13.TabIndex = 7;
this.label13.Text = ""0"";
// // label14
// this.label14.AutoSize = true;
this.label14.Location = new System.Drawing.Point(9, 954);
this.label14.Name = ""label14"";
this.label14.Size = new System.Drawing.Size(13, 13);
this.label14.TabIndex = 7;
this.label14.Text = ""0"";
// // label15
// this.label15.AutoSize = true;
this.label15.Location = new System.Drawing.Point(0, 938);
this.label15.Name = ""label15"";
this.label15.Size = new System.Drawing.Size(13, 13);
this.label15.TabIndex = 7;
this.label15.Text = ""0"";
// // lbl_max
// this.lbl_max.AutoSize = true;
this.lbl_max.Location = new System.Drawing.Point(0, 695);
this.lbl_max.Name = ""lbl_max"";
this.lbl_max.Size = new System.Drawing.Size(13, 13);
this.lbl_max.TabIndex = 7;
this.lbl_max.Text = ""0"";
// // Form1
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(1560, 970);
this.Controls.Add(this.lbl_max);
this.Controls.Add(this.label5);
this.Controls.Add(this.label4);
this.Controls.Add(this.label14);
this.Controls.Add(this.label13);
this.Controls.Add(this.label12);
this.Controls.Add(this.label11);
this.Controls.Add(this.label10);
this.Controls.Add(this.label9);
this.Controls.Add(this.label8);
this.Controls.Add(this.label7);
this.Controls.Add(this.label6);
this.Controls.Add(this.label3);
this.Controls.Add(this.hist_b_dest);
this.Controls.Add(this.hist_g_dest);
this.Controls.Add(this.hist_rb_dest);
this.Controls.Add(this.hist_b_src);
this.Controls.Add(this.hist_g_src);
this.Controls.Add(this.hist_rb_src);
this.Controls.Add(this.btn_Save);
this.Controls.Add(this.label2);
this.Controls.Add(this.label1);
this.Controls.Add(this.btn_calc);
this.Controls.Add(this.btn_open);
this.Controls.Add(this.pictureBox_dest);
this.Controls.Add(this.pictureBox_src);
this.Controls.Add(this.txt_info);
this.Controls.Add(this.label15);
this.Name = ""Form1"";
this.Text = ""NPP Histogram equalization"";
this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.Form1_FormClosing);
this.Load += new System.EventHandler(this.Form1_Load);
((System.ComponentModel.ISupportInitialize)(this.pictureBox_src)).EndInit();
((System.ComponentModel.ISupportInitialize)(this.pictureBox_dest)).EndInit();
((System.ComponentModel.ISupportInitialize)(this.hist_rb_src)).EndInit();
((System.ComponentModel.ISupportInitialize)(this.hist_g_src)).EndInit();
((System.ComponentModel.ISupportInitialize)(this.hist_b_src)).EndInit();
((System.ComponentModel.ISupportInitialize)(this.hist_rb_dest)).EndInit();
((System.ComponentModel.ISupportInitialize)(this.hist_g_dest)).EndInit();
((System.ComponentModel.ISupportInitialize)(this.hist_b_dest)).EndInit();
this.ResumeLayout(false);
this.PerformLayout();
}",Erforderliche Methode fr die Designeruntersttzung. Der Inhalt der Methode darf nicht mit dem Code-Editor gendert werden.,0
392,"private void InitializeComponent()
{
this.panel1 = new System.Windows.Forms.Panel();
this.SuspendLayout();
// // panel1
// this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this.panel1.Location = new System.Drawing.Point(0, 0);
this.panel1.Name = ""panel1"";
this.panel1.Size = new System.Drawing.Size(512, 512);
this.panel1.TabIndex = 0;
this.panel1.MouseMove += new System.Windows.Forms.MouseEventHandler(this.panel1_MouseMove);
// // Form1
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(512, 512);
this.Controls.Add(this.panel1);
this.Name = ""Form1"";
this.Text = ""Form1"";
this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.Form1_FormClosing);
this.Load += new System.EventHandler(this.Form1_Load);
this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.Form1_KeyDown);
this.ResumeLayout(false);
}",Erforderliche Methode fr die Designeruntersttzung. Der Inhalt der Methode darf nicht mit dem Code-Editor gendert werden.,1
393,"private void InitializeComponent()
{
this.panel1 = new System.Windows.Forms.Panel();
this.SuspendLayout();
// // panel1
// this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this.panel1.Location = new System.Drawing.Point(0, 0);
this.panel1.Name = ""panel1"";
this.panel1.Size = new System.Drawing.Size(512, 512);
this.panel1.TabIndex = 1;
// // Form1
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(512, 512);
this.Controls.Add(this.panel1);
this.Name = ""Form1"";
this.Text = ""Form1"";
this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.Form1_FormClosing);
this.Load += new System.EventHandler(this.Form1_Load);
this.ResumeLayout(false);
}",Erforderliche Methode fr die Designeruntersttzung. Der Inhalt der Methode darf nicht mit dem Code-Editor gendert werden.,1
394,"~CudaSparseCsric02Info()
{
Dispose(false);
}",For dispose,1
395,"~CudaSparseCsrilu02Info()
{
Dispose(false);
}",For dispose,1
396,"~CudaSparseCsrsv2Info()
{
Dispose(false);
}",For dispose,1
397,"~CudaSparseCsru2csrInfo()
{
Dispose(false);
}",For dispose,1
398,"~CudaSparseHybMat()
{
Dispose(false);
}",For dispose,1
399,"~CudaSparseMatrixDescriptor()
{
Dispose(false);
}",For dispose,1
400,"~CudaSparseSolveAnalysisInfo()
{
Dispose(false);
}",For dispose,1
401,"~CudaSurface()
{
Dispose(false);
}",For dispose,1
402,"~CudaSurfObject()
{
Dispose(false);
}",For dispose,1
403,"~CudaTexObject()
{
Dispose(false);
}",For dispose,1
404,"~CudaTextureMipmappedArray()
{
Dispose(false);
}",For dispose,1
405,"~FilterDescriptor()
{
Dispose(false);
}",For dispose,1
406,"~GraphContext()
{
Dispose(false);
}",For dispose,1
407,"~GraphDescriptor()
{
Dispose(false);
}",For dispose,1
408,"~LRNDescriptor()
{
Dispose(false);
}",For dispose,1
409,"~NPPImage_16sC1()
{
Dispose (false);
}",For dispose,1
410,"~NPPImage_16sC2()
{
Dispose (false);
}",For dispose,1
411,"~NPPImage_16sC3()
{
Dispose (false);
}",For dispose,1
412,"~NPPImage_16sC4()
{
Dispose (false);
}",For dispose,1
413,"~NPPImage_16scC1()
{
Dispose (false);
}",For dispose,1
414,"~NPPImage_16scC2()
{
Dispose (false);
}",For dispose,1
415,"~NPPImage_16scC3()
{
Dispose (false);
}",For dispose,1
416,"~NPPImage_16scC4()
{
Dispose (false);
}",For dispose,1
417,"~NPPImage_16uC1()
{
Dispose (false);
}",For dispose,1
418,"~NPPImage_16uC2()
{
Dispose (false);
}",For dispose,1
419,"~CudaSparseCsrsm2Info()
{
Dispose(false);
}",For dispose,1
420,"~CudaSparsePruneInfo()
{
Dispose(false);
}",For dispose,1
421,"~CudaStopWatch()
{
Dispose (false); }",For dispose,1
422,"~CudaStream()
{
Dispose(false);
}",For dispose,1
423,"~CudaTextureArray1D()
{
Dispose(false);
}",For dispose,1
424,"~CudaTextureArray2D()
{
Dispose(false);
}",For dispose,1
425,"~CudaTextureArray3D()
{
Dispose(false);
}",For dispose,1
426,"~CudaTextureLinear1D()
{
Dispose(false);
}",For dispose,1
427,"~CudaTextureLinearPitched2D()
{
Dispose(false);
}",For dispose,1
428,"~DropoutDescriptor()
{
Dispose(false);
}",For dispose,1
429,"public struct NppiImageDescriptor
{
/// <summary>
/// device memory pointer to the image
/// </summary>
public CUdeviceptr pData;
/// <summary>
/// step size
/// </summary>
public int nStep;
/// <summary>
/// width and height of the image
/// </summary>
public NppiSize oSize;
/// <summary>
/// Creates a new NppiImageDescriptor from a NPPImage
/// </summary>
public NppiImageDescriptor(NPPImageBase img)
{
pData = img.DevicePointer;
nStep = img.Pitch;
oSize = img.SizeRoi;
}
}","General image descriptor. Defines the basic parameters of an image, including data pointer, step size and size information. This can be used by both source and destination sides.",1
430,"public void Abs()
{
status = NPPNativeMethods.NPPi.Abs.nppiAbs_16s_C1IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiAbsDiffC_16s_C1R"", status));
NPPException.CheckNppStatus(status, this);
}",Image absolute value. In place.,1
431,"public void Abs()
{
status = NPPNativeMethods.NPPi.Abs.nppiAbs_16s_C3IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiAbsDiffC_16s_C3R"", status));
NPPException.CheckNppStatus(status, this);
}",Image absolute value. In place.,1
432,"public void Abs()
{
status = NPPNativeMethods.NPPi.Abs.nppiAbs_16s_C4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiAbsDiffC_16s_C4R"", status));
NPPException.CheckNppStatus(status, this);
}",Image absolute value. In place.,1
433,"public void AbsA()
{
status = NPPNativeMethods.NPPi.Abs.nppiAbs_16s_AC4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiAbsDiffC_16s_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}",Image absolute value. In place. Not affecting Alpha channel.,1
434,"public NppiJpegDecodeJob JobCreateMemzero()
{
NppiJpegDecodeJob ret = new NppiJpegDecodeJob();
status = NPPNativeMethods.NPPi.CompressionDCT.nppiJpegDecodeJobCreateMemzero(ref ret);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiJpegDecodeJobCreateMemzero"", status));
NPPException.CheckNppStatus(status, this);
return ret;
}",Initializes a job that has to be called at the beginning of decoding.,1
435,"public JPEGCompression()
{
_state = new NppiDCTState();
status = NPPNativeMethods.NPPi.CompressionDCT.nppiDCTInitAlloc(ref _state);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiDCTInitAlloc"", status));
NPPException.CheckNppStatus(status, this);
}",Initializes DCT state structure and allocates additional resources,1
436,"public struct CUipcEventHandle
{
/// <summary>
/// /// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
public byte[] reserved;
}",Interprocess Handle for Events,1
437,"public struct CUipcMemHandle
{
/// <summary>
/// /// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
public byte[] reserved;
}",Interprocess Handle for Memory,1
438,"public struct NppiJpegDecodeJob
{
/// <summary>
/// This field and its contents are never written
/// </summary>
public IntPtr pFrame; //NppiJpegFrameDescr
/// <summary>
/// This field is never written. `*pScan` is written only by ...Create... functions
/// </summary>
public IntPtr pScan; //NppiJpegScanDescr
/// <summary>
/// /// </summary>
public NppiJpegDecodeJobKind eKind;
}",JPEG decode job used by nppiJpegDecodeJob (see that for more documentation) The job describes piece of computation to be done.,1
439,"public struct NppiJpegFrameDescr
{
/// <summary>
/// Number of components in frame
/// </summary>
public byte nComponents;
/// <summary>
/// Size of component with 1x1 subsampling (usually luma) in DCT blocks.
/// </summary>
public NppiSize oSizeInBlocks;
/// <summary>
/// Subsampling factors of component, as described in frame header
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
public NppiSize[] aComponentSubsampling;
/// <summary>
/// Buffer containing DCT coefficients. Use \ref nppiJpegDecodeGetDCTBufferSize to
/// determine size of this buffer.After decoding, coefficients will be stored in
/// zig-zag order, block by block.So the c-th coeffient of block `(x, y)` will
/// be stored at `buffer [64 * (y * interleavedComponentWidthInBlocks + x) + c]`.
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
public CUdeviceptr[] apComponentBuffer;
}",JPEG frame descriptor. Can hold from 1 to 4 components.,1
440,"public struct NppiJpegScanDescr
{
/// <summary>
/// Number of components present in scan
/// </summary>
public byte nComponents;
/// <summary>
/// Frame-indexes of components. These values will be used to index arrays in \ref NppiJpegFrameDescr
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
public byte[] aComponentIdx;
/// <summary>
/// DC Huffman table selector per component
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
public byte[] aComponentDcHtSel;
/// <summary>
/// AC Huffman table selector per component
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
public byte[] aComponentAcHtSel;
/// <summary>
/// Pointers to DC Huffman table description in the raw format (the same format as used in JPEG header).
/// This array will be indexed by \ref aComponentDcHtSel. Pointers for
/// tables unused in scan may be set to NULL.
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
public IntPtr[] apRawDcHtTable;
/// <summary>
/// See \ref apRawDcHtTable
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
public IntPtr[] apRawAcHtTable;
/// <summary>
/// Start of spectral selection (index of first coefficient), 0-63
/// </summary>
public byte nSs;
/// <summary>
/// End of spectral selection (index of first coefficient), 0-63
/// </summary>
public byte nSe;
/// <summary>
/// Successive approximation bit position high
/// </summary>
public byte nAh;
/// <summary>
/// Successive approximation bit position low
/// </summary>
public byte nAl;
/// <summary>
/// Restart interval in MCUs. Use 0 or -1 when none
/// </summary>
public int restartInterval;
/// <summary>
/// Length of compressed (encoded) scan data
/// </summary>
public int length;
}",JPEG scan descriptor,1
441,"public struct CUDeviceProperties
{
/// <summary>
/// Maximum number of threads per block
/// </summary>
public int maxThreadsPerBlock;
/// <summary>
/// Maximum size of each dimension of a block
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I4)]
public int[] maxThreadsDim;
/// <summary>
/// Maximum size of each dimension of a grid
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I4)]
public int[] maxGridSize;
/// <summary>
/// Shared memory available per block in bytes
/// </summary>
public int sharedMemPerBlock;
/// <summary>
/// Constant memory available on device in bytes
/// </summary>
public int totalConstantMemory;
/// <summary>
/// Warp size in threads. Also called SIMD width.
/// </summary>
public int SIMDWidth;
/// <summary>
/// Maximum pitch in bytes allowed by the memory copy functions that involve memory regions allocated through
/// <see cref=""DriverAPINativeMethods.MemoryManagement.cuMemAllocPitch_v2""/>.
/// </summary>
public int memPitch;
/// <summary>
/// 32-bit registers available per block
/// </summary>
public int regsPerBlock;
/// <summary>
/// Clock frequency in kilohertz
/// </summary>
public int clockRate;
/// <summary>
/// Alignment requirement for textures. texture base addresses that are aligned to textureAlign bytes do not
/// need an offset applied to texture fetches.
/// </summary>
public int textureAlign;
}",Legacy device properties,1
442,"public struct NppiJpegDecodeJobMemory
{
/// <summary>
/// Number of additional buffers that may be used by JPEG decode jobs.
/// This number may change in the future, but it remain small.
/// </summary>
public const int NPPI_JPEG_DECODE_N_BUFFERS = 3;
/// <summary>
/// Pointer to host memory containing compressed scan data.
/// Should be allocated with additional \ref nppiJpegDecodeGetScanDeadzoneSize
/// bytes of usable memory after the end of compressed scan data.
/// Should be filled by caller.
/// </summary>
public IntPtr pCpuScan;
/// <summary>
/// Pointer to device memory used for compressed scan data.
/// Should be allocated with additional \ref nppiJpegDecodeGetScanDeadzoneSize
/// bytes of usable memory after the end of compressed scan data.
/// Should be filled by caller.
/// This buffer may be overwritten by the decoder.
/// Could be NULL for \ref NPPI_JPEG_DECODE_CPU.
/// </summary>
public CUdeviceptr pGpuScan;
/// <summary>
/// Pointers to additional host buffers used by job. Call \ref nppiJpegDecodeJobMemorySize
/// to query sizes of these buffers. `apCpuBuffer[i]` should point to
/// at least `aSize[i]` bytes.If `aSize[i] == 0`, the pointer should be set to NULL.
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = NPPI_JPEG_DECODE_N_BUFFERS)]
public IntPtr[] apCpuBuffer;
/// <summary>
/// Pointers to additional device buffers used by job. Minimal sizes of buffers should be the same as the sizes of \ref apCpuBuffer.
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = NPPI_JPEG_DECODE_N_BUFFERS)]
public CUdeviceptr[] apGpuBuffer;
}",Memory buffers used by one decode job.,1
443,"public void Normalize()
{
this = this / Length;
}",Normalize vector,0
444,"public struct cusparseContext
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding CUSPARSE library context,1
445,"public struct cusparseColorInfo
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the coloring information,1
446,"public struct cusparseHybMat
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the hybrid (HYB) storage information,1
447,"public struct cusparseMatDescr
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the matrix descriptor,1
448,"public struct cusparseSolveAnalysisInfo
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the sparse triangular solve information,1
449,"public SizeT GetScanDeadzoneSize()
{
return NPPNativeMethods.NPPi.CompressionDCT.nppiJpegDecodeGetScanDeadzoneSize();
}",pCpuScan pGpuScan pScan->length + nppiJpegDecodeGetScanDeadzoneSize(),0
450,"public struct cuuint3264_union
{
/// <summary/>
[FieldOffset(0)]
public uint value;
/// <summary/>
[FieldOffset(0)]
public ulong value64;
}",Per-operation parameters for ::cuStreamBatchMemOp,1
451,"public struct CUdeviceptr
{
/// <summary>
/// /// </summary>
public SizeT Pointer;
#region operators
/// <summary>
/// /// </summary>
/// <param name=""src""></param>
/// <returns></returns>
public static implicit operator ulong(CUdeviceptr src)
{
return src.Pointer;
}
/// <summary>
/// /// </summary>
/// <param name=""src""></param>
/// <returns></returns>
public static explicit operator CUdeviceptr(SizeT src)
{
CUdeviceptr udeviceptr = new CUdeviceptr();
udeviceptr.Pointer = src;
return udeviceptr;
}
/// <summary>
/// /// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static CUdeviceptr operator +(CUdeviceptr src, SizeT value)
{
CUdeviceptr udeviceptr = new CUdeviceptr();
udeviceptr.Pointer = src.Pointer + value;
return udeviceptr;
}
/// <summary>
/// /// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static CUdeviceptr operator -(CUdeviceptr src, SizeT value)
{
CUdeviceptr udeviceptr = new CUdeviceptr();
udeviceptr.Pointer = src.Pointer - value;
return udeviceptr;
}
/// <summary>
/// /// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static bool operator ==(CUdeviceptr src, CUdeviceptr value)
{
return src.Pointer == value.Pointer;
}
/// <summary>
/// /// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static bool operator !=(CUdeviceptr src, CUdeviceptr value)
{
return src.Pointer != value.Pointer;
}
#endregion
#region Override Methods
/// <summary>
/// Returns true if both objects are of type CUdeviceptr and if both Pointer member is equal.
/// </summary>
/// <param name=""obj""></param>
/// <returns></returns>
public override bool Equals(object obj)
{
if (!(obj is CUdeviceptr)) return false;
CUdeviceptr value = (CUdeviceptr)obj;
return this.Pointer.Equals(value.Pointer);
}
/// <summary>
/// Overrides object.GetHashCode()
/// </summary>
/// <returns></returns>
public override int GetHashCode()
{
return base.GetHashCode();
}
/// <summary>
/// override ToString()
/// </summary>
/// <returns></returns>
public override string ToString()
{
return Pointer.ToString();
}
#endregion
#region constructors
/// <summary>
/// /// </summary>
/// <param name=""pointer""></param>
public CUdeviceptr(SizeT pointer)
{
Pointer = pointer;
}
#endregion
#region GetAttributeMethods
/// <summary>
/// The <see cref=""CUcontext""/> on which a pointer was allocated or registered
/// </summary>
public CUcontext AttributeContext
{
get {
CUcontext ret = new CUcontext();
CUResult res = DriverAPINativeMethods.MemoryManagement.cuPointerGetAttribute(ref ret, CUPointerAttribute.Context, this);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuPointerGetAttribute"", res));
if (res != CUResult.Success) throw new CudaException(res);
return ret;
}
}
/// <summary>
/// The <see cref=""CUMemoryType""/> describing the physical location of a pointer /// </summary>
public CUMemoryType AttributeMemoryType
{
get
{
CUMemoryType ret = new CUMemoryType();
CUResult res = DriverAPINativeMethods.MemoryManagement.cuPointerGetAttribute(ref ret, CUPointerAttribute.MemoryType, this);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuPointerGetAttribute"", res));
if (res != CUResult.Success) throw new CudaException(res);
return ret;
}
}
/// <summary>
/// The address at which a pointer's memory may be accessed on the device <para/>
/// Except in the exceptional disjoint addressing cases, the value returned will equal the input value.
/// </summary>
public CUdeviceptr AttributeDevicePointer
{
get
{
CUdeviceptr ret = new CUdeviceptr();
CUResult res = DriverAPINativeMethods.MemoryManagement.cuPointerGetAttribute(ref ret, CUPointerAttribute.DevicePointer, this);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuPointerGetAttribute"", res));
if (res != CUResult.Success) throw new CudaException(res);
return ret;
}
}
/// <summary>
/// The address at which a pointer's memory may be accessed on the host /// </summary>
public IntPtr AttributeHostPointer
{
get
{
IntPtr ret = new IntPtr();
CUResult res = DriverAPINativeMethods.MemoryManagement.cuPointerGetAttribute(ref ret, CUPointerAttribute.HostPointer, this);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuPointerGetAttribute"", res));
if (res != CUResult.Success) throw new CudaException(res);
return ret;
}
}
/// <summary>
/// A pair of tokens for use with the nv-p2p.h Linux kernel interface
/// </summary>
public CudaPointerAttributeP2PTokens AttributeP2PTokens
{
get
{
CudaPointerAttributeP2PTokens ret = new CudaPointerAttributeP2PTokens();
CUResult res = DriverAPINativeMethods.MemoryManagement.cuPointerGetAttribute(ref ret, CUPointerAttribute.P2PTokens, this);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuPointerGetAttribute"", res));
if (res != CUResult.Success) throw new CudaException(res);
return ret;
}
}
/// <summary>
/// Synchronize every synchronous memory operation initiated on this region
/// </summary>
public bool AttributeSyncMemops
{
get
{
int ret = 0;
CUResult res = DriverAPINativeMethods.MemoryManagement.cuPointerGetAttribute(ref ret, CUPointerAttribute.SyncMemops, this);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuPointerGetAttribute"", res));
if (res != CUResult.Success) throw new CudaException(res);
return ret != 0;
}
set {
int val = value ? 1 : 0;
CUResult res = DriverAPINativeMethods.MemoryManagement.cuPointerSetAttribute(ref val, CUPointerAttribute.SyncMemops, this);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuPointerSetAttribute"", res));
if (res != CUResult.Success) throw new CudaException(res);
}
}
/// <summary>
/// A process-wide unique ID for an allocated memory region
/// </summary>
public ulong AttributeBufferID
{
get
{
ulong ret = 0;
CUResult res = DriverAPINativeMethods.MemoryManagement.cuPointerGetAttribute(ref ret, CUPointerAttribute.BufferID, this);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuPointerGetAttribute"", res));
if (res != CUResult.Success) throw new CudaException(res);
return ret;
}
}
/// <summary>
/// Indicates if the pointer points to managed memory
/// </summary>
public bool AttributeIsManaged
{
get
{
int ret = 0;
CUResult res = DriverAPINativeMethods.MemoryManagement.cuPointerGetAttribute(ref ret, CUPointerAttribute.IsManaged, this);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuPointerGetAttribute"", res));
if (res != CUResult.Success) throw new CudaException(res);
return ret != 0;
}
}
#endregion
}",Pointer to CUDA device memory,1
452,"private void InitializeComponent()
{
this.btn_OpenNPP = new System.Windows.Forms.Button();
this.btn_openImageNet = new System.Windows.Forms.Button();
this.btn_SaveJpegNPP = new System.Windows.Forms.Button();
this.trk_JpegQuality = new System.Windows.Forms.TrackBar();
this.txt_JpegQuality = new System.Windows.Forms.TextBox();
this.label1 = new System.Windows.Forms.Label();
this.pic_Image = new System.Windows.Forms.PictureBox();
this.trk_Size = new System.Windows.Forms.TrackBar();
this.label2 = new System.Windows.Forms.Label();
this.txt_Resize = new System.Windows.Forms.TextBox();
this.btn_Resize = new System.Windows.Forms.Button();
((System.ComponentModel.ISupportInitialize)(this.trk_JpegQuality)).BeginInit();
((System.ComponentModel.ISupportInitialize)(this.pic_Image)).BeginInit();
((System.ComponentModel.ISupportInitialize)(this.trk_Size)).BeginInit();
this.SuspendLayout();
// // btn_OpenNPP
// this.btn_OpenNPP.Location = new System.Drawing.Point(12, 12);
this.btn_OpenNPP.Name = ""btn_OpenNPP"";
this.btn_OpenNPP.Size = new System.Drawing.Size(137, 23);
this.btn_OpenNPP.TabIndex = 0;
this.btn_OpenNPP.Text = ""Open Jpeg with NPP"";
this.btn_OpenNPP.UseVisualStyleBackColor = true;
this.btn_OpenNPP.Click += new System.EventHandler(this.btn_OpenNPP_Click);
// // btn_openImageNet
// this.btn_openImageNet.Location = new System.Drawing.Point(12, 41);
this.btn_openImageNet.Name = ""btn_openImageNet"";
this.btn_openImageNet.Size = new System.Drawing.Size(137, 23);
this.btn_openImageNet.TabIndex = 1;
this.btn_openImageNet.Text = ""Open image with .net"";
this.btn_openImageNet.UseVisualStyleBackColor = true;
this.btn_openImageNet.Click += new System.EventHandler(this.btn_openImageNet_Click);
// // btn_SaveJpegNPP
// this.btn_SaveJpegNPP.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.btn_SaveJpegNPP.Location = new System.Drawing.Point(694, 12);
this.btn_SaveJpegNPP.Name = ""btn_SaveJpegNPP"";
this.btn_SaveJpegNPP.Size = new System.Drawing.Size(137, 23);
this.btn_SaveJpegNPP.TabIndex = 2;
this.btn_SaveJpegNPP.Text = ""Save Jpeg NPP"";
this.btn_SaveJpegNPP.UseVisualStyleBackColor = true;
this.btn_SaveJpegNPP.Click += new System.EventHandler(this.btn_SaveJpegNPP_Click);
// // trk_JpegQuality
// this.trk_JpegQuality.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.trk_JpegQuality.Location = new System.Drawing.Point(643, 41);
this.trk_JpegQuality.Maximum = 100;
this.trk_JpegQuality.Minimum = 1;
this.trk_JpegQuality.Name = ""trk_JpegQuality"";
this.trk_JpegQuality.Size = new System.Drawing.Size(188, 45);
this.trk_JpegQuality.TabIndex = 3;
this.trk_JpegQuality.Value = 75;
this.trk_JpegQuality.Scroll += new System.EventHandler(this.trk_JpegQuality_Scroll);
// // txt_JpegQuality
// this.txt_JpegQuality.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.txt_JpegQuality.Location = new System.Drawing.Point(643, 15);
this.txt_JpegQuality.Name = ""txt_JpegQuality"";
this.txt_JpegQuality.ReadOnly = true;
this.txt_JpegQuality.Size = new System.Drawing.Size(45, 20);
this.txt_JpegQuality.TabIndex = 4;
this.txt_JpegQuality.Text = ""75"";
this.txt_JpegQuality.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
// // label1
// this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.label1.AutoSize = true;
this.label1.Location = new System.Drawing.Point(595, 50);
this.label1.Name = ""label1"";
this.label1.Size = new System.Drawing.Size(42, 13);
this.label1.TabIndex = 5;
this.label1.Text = ""Quality:"";
// // pic_Image
// this.pic_Image.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.pic_Image.Location = new System.Drawing.Point(12, 83);
this.pic_Image.Name = ""pic_Image"";
this.pic_Image.Size = new System.Drawing.Size(819, 542);
this.pic_Image.TabIndex = 6;
this.pic_Image.TabStop = false;
// // trk_Size
// this.trk_Size.Location = new System.Drawing.Point(205, 41);
this.trk_Size.Maximum = 200;
this.trk_Size.Minimum = 10;
this.trk_Size.Name = ""trk_Size"";
this.trk_Size.Size = new System.Drawing.Size(152, 45);
this.trk_Size.TabIndex = 7;
this.trk_Size.Value = 100;
this.trk_Size.Scroll += new System.EventHandler(this.trk_Size_Scroll);
// // label2
// this.label2.AutoSize = true;
this.label2.Location = new System.Drawing.Point(169, 50);
this.label2.Name = ""label2"";
this.label2.Size = new System.Drawing.Size(30, 13);
this.label2.TabIndex = 8;
this.label2.Text = ""Size:"";
// // txt_Resize
// this.txt_Resize.Location = new System.Drawing.Point(172, 14);
this.txt_Resize.Name = ""txt_Resize"";
this.txt_Resize.ReadOnly = true;
this.txt_Resize.Size = new System.Drawing.Size(45, 20);
this.txt_Resize.TabIndex = 9;
this.txt_Resize.Text = ""100 %"";
this.txt_Resize.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
// // btn_Resize
// this.btn_Resize.Location = new System.Drawing.Point(223, 12);
this.btn_Resize.Name = ""btn_Resize"";
this.btn_Resize.Size = new System.Drawing.Size(134, 23);
this.btn_Resize.TabIndex = 10;
this.btn_Resize.Text = ""Resize"";
this.btn_Resize.UseVisualStyleBackColor = true;
this.btn_Resize.Click += new System.EventHandler(this.btn_Resize_Click);
// // Form1
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(843, 637);
this.Controls.Add(this.pic_Image);
this.Controls.Add(this.btn_Resize);
this.Controls.Add(this.txt_Resize);
this.Controls.Add(this.label2);
this.Controls.Add(this.trk_Size);
this.Controls.Add(this.label1);
this.Controls.Add(this.txt_JpegQuality);
this.Controls.Add(this.trk_JpegQuality);
this.Controls.Add(this.btn_SaveJpegNPP);
this.Controls.Add(this.btn_openImageNet);
this.Controls.Add(this.btn_OpenNPP);
this.Name = ""Form1"";
this.Text = ""Form1"";
((System.ComponentModel.ISupportInitialize)(this.trk_JpegQuality)).EndInit();
((System.ComponentModel.ISupportInitialize)(this.pic_Image)).EndInit();
((System.ComponentModel.ISupportInitialize)(this.trk_Size)).EndInit();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
453,"public CUgraphNode[] GetDependentNodes()
{
SizeT numNodes = new SizeT();
CUResult res = DriverAPINativeMethods.GraphManagment.cuGraphNodeGetDependentNodes(this, null, ref numNodes);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphNodeGetDependentNodes"", res));
if (res != CUResult.Success) throw new CudaException(res);
if (numNodes > 0)
{
CUgraphNode[] nodes = new CUgraphNode[numNodes];
res = DriverAPINativeMethods.GraphManagment.cuGraphNodeGetDependentNodes(this, nodes, ref numNodes);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuGraphNodeGetDependentNodes"", res));
if (res != CUResult.Success) throw new CudaException(res);
return nodes;
}
return null;
}",Returns a node's dependent nodes,1
454,"public void Start()
{
if (disposed) throw new ObjectDisposedException(this.ToString());
_start.Record(_stream);
}",Start measurement,1
455,"public void Stop()
{
if (disposed) throw new ObjectDisposedException(this.ToString());
_stop.Record(_stream);
}",Stop measurement,1
456,"public struct CudaTextureDescriptor
{
/// <summary>
/// Creates a new CudaTextureDescriptor
/// </summary>
/// <param name=""aAddressMode"">Address modes for all dimensions</param>
/// <param name=""aFilterMode"">Filter mode</param>
/// <param name=""aFlags"">Flags</param>
public CudaTextureDescriptor(CUAddressMode aAddressMode, CUFilterMode aFilterMode, CUTexRefSetFlags aFlags)
{
addressMode = new CUAddressMode[3];
addressMode[0] = aAddressMode;
addressMode[1] = aAddressMode;
addressMode[2] = aAddressMode;
filterMode = aFilterMode;
flags = aFlags;
maxAnisotropy = 0;
mipmapFilterMode = CUFilterMode.Point;
mipmapLevelBias = 0;
minMipmapLevelClamp = 0;
maxMipmapLevelClamp = 0;
borderColor = new float[4];
_reserved = new int[12];
}
/// <summary>
/// Creates a new CudaTextureDescriptor
/// </summary>
/// <param name=""aAddressMode"">Address modes for all dimensions</param>
/// <param name=""aFilterMode"">Filter mode</param>
/// <param name=""aFlags"">Flags</param>
/// <param name=""aBorderColor"">borderColor (array of size 4)</param>
public CudaTextureDescriptor(CUAddressMode aAddressMode, CUFilterMode aFilterMode, CUTexRefSetFlags aFlags, float[] aBorderColor)
{
addressMode = new CUAddressMode[3];
addressMode[0] = aAddressMode;
addressMode[1] = aAddressMode;
addressMode[2] = aAddressMode;
filterMode = aFilterMode;
flags = aFlags;
maxAnisotropy = 0;
mipmapFilterMode = CUFilterMode.Point;
mipmapLevelBias = 0;
minMipmapLevelClamp = 0;
maxMipmapLevelClamp = 0;
borderColor = new float[4];
borderColor[0] = aBorderColor[0];
borderColor[1] = aBorderColor[1];
borderColor[2] = aBorderColor[2];
borderColor[3] = aBorderColor[3];
_reserved = new int[12];
}
/// <summary>
/// Creates a new CudaTextureDescriptor
/// </summary>
/// <param name=""aAddressMode0"">Address modes for dimension 0</param>
/// <param name=""aAddressMode1"">Address modes for dimension 1</param>
/// <param name=""aAddressMode2"">Address modes for dimension 2</param>
/// <param name=""aFilterMode"">Filter mode</param>
/// <param name=""aFlags"">Flags</param>
public CudaTextureDescriptor(CUAddressMode aAddressMode0, CUAddressMode aAddressMode1, CUAddressMode aAddressMode2, CUFilterMode aFilterMode, CUTexRefSetFlags aFlags)
{
addressMode = new CUAddressMode[3];
addressMode[0] = aAddressMode0;
addressMode[1] = aAddressMode1;
addressMode[2] = aAddressMode2;
filterMode = aFilterMode;
flags = aFlags;
maxAnisotropy = 0;
mipmapFilterMode = CUFilterMode.Point;
mipmapLevelBias = 0;
minMipmapLevelClamp = 0;
maxMipmapLevelClamp = 0;
borderColor = new float[4];
_reserved = new int[12];
}
/// <summary>
/// Creates a new CudaTextureDescriptor
/// </summary>
/// <param name=""aAddressMode0"">Address modes for dimension 0</param>
/// <param name=""aAddressMode1"">Address modes for dimension 1</param>
/// <param name=""aAddressMode2"">Address modes for dimension 2</param>
/// <param name=""aFilterMode"">Filter mode</param>
/// <param name=""aFlags"">Flags</param>
/// <param name=""aBorderColor"">borderColor (array of size 4)</param>
public CudaTextureDescriptor(CUAddressMode aAddressMode0, CUAddressMode aAddressMode1, CUAddressMode aAddressMode2, CUFilterMode aFilterMode, CUTexRefSetFlags aFlags, float[] aBorderColor)
{
addressMode = new CUAddressMode[3];
addressMode[0] = aAddressMode0;
addressMode[1] = aAddressMode1;
addressMode[2] = aAddressMode2;
filterMode = aFilterMode;
flags = aFlags;
maxAnisotropy = 0;
mipmapFilterMode = CUFilterMode.Point;
mipmapLevelBias = 0;
minMipmapLevelClamp = 0;
maxMipmapLevelClamp = 0;
borderColor = new float[4];
borderColor[0] = aBorderColor[0];
borderColor[1] = aBorderColor[1];
borderColor[2] = aBorderColor[2];
borderColor[3] = aBorderColor[3];
_reserved = new int[12];
}
/// <summary>
/// Creates a new CudaTextureDescriptor
/// </summary>
/// <param name=""aAddressMode"">Address modes for all dimensions</param>
/// <param name=""aFilterMode"">Filter mode</param>
/// <param name=""aFlags"">Flags</param>
/// <param name=""aMaxAnisotropy"">Maximum anisotropy ratio. Specifies the maximum anistropy ratio to be used when doing anisotropic
/// filtering. This value will be clamped to the range [1,16].</param>
/// <param name=""aMipmapFilterMode"">Mipmap filter mode. Specifies the filter mode when the calculated mipmap level lies between
/// two defined mipmap levels.</param>
/// <param name=""aMipmapLevelBias"">Mipmap level bias. Specifies the offset to be applied to the calculated mipmap level.</param>
/// <param name=""aMinMipmapLevelClamp"">Mipmap minimum level clamp. Specifies the lower end of the mipmap level range to clamp access to.</param>
/// <param name=""aMaxMipmapLevelClamp"">Mipmap maximum level clamp. Specifies the upper end of the mipmap level range to clamp access to.</param>
public CudaTextureDescriptor(CUAddressMode aAddressMode, CUFilterMode aFilterMode, CUTexRefSetFlags aFlags, uint aMaxAnisotropy, CUFilterMode aMipmapFilterMode,
float aMipmapLevelBias, float aMinMipmapLevelClamp, float aMaxMipmapLevelClamp)
{
addressMode = new CUAddressMode[3];
addressMode[0] = aAddressMode;
addressMode[1] = aAddressMode;
addressMode[2] = aAddressMode;
filterMode = aFilterMode;
flags = aFlags;
maxAnisotropy = aMaxAnisotropy;
mipmapFilterMode = aMipmapFilterMode;
mipmapLevelBias = aMipmapLevelBias;
minMipmapLevelClamp = aMinMipmapLevelClamp;
maxMipmapLevelClamp = aMaxMipmapLevelClamp;
borderColor = new float[4];
_reserved = new int[12];
}
/// <summary>
/// Creates a new CudaTextureDescriptor
/// </summary>
/// <param name=""aAddressMode"">Address modes for all dimensions</param>
/// <param name=""aFilterMode"">Filter mode</param>
/// <param name=""aFlags"">Flags</param>
/// <param name=""aMaxAnisotropy"">Maximum anisotropy ratio. Specifies the maximum anistropy ratio to be used when doing anisotropic
/// filtering. This value will be clamped to the range [1,16].</param>
/// <param name=""aMipmapFilterMode"">Mipmap filter mode. Specifies the filter mode when the calculated mipmap level lies between
/// two defined mipmap levels.</param>
/// <param name=""aMipmapLevelBias"">Mipmap level bias. Specifies the offset to be applied to the calculated mipmap level.</param>
/// <param name=""aMinMipmapLevelClamp"">Mipmap minimum level clamp. Specifies the lower end of the mipmap level range to clamp access to.</param>
/// <param name=""aMaxMipmapLevelClamp"">Mipmap maximum level clamp. Specifies the upper end of the mipmap level range to clamp access to.</param>
/// <param name=""aBorderColor"">borderColor (array of size 4)</param>
public CudaTextureDescriptor(CUAddressMode aAddressMode, CUFilterMode aFilterMode, CUTexRefSetFlags aFlags, uint aMaxAnisotropy, CUFilterMode aMipmapFilterMode,
float aMipmapLevelBias, float aMinMipmapLevelClamp, float aMaxMipmapLevelClamp, float[] aBorderColor)
{
addressMode = new CUAddressMode[3];
addressMode[0] = aAddressMode;
addressMode[1] = aAddressMode;
addressMode[2] = aAddressMode;
filterMode = aFilterMode;
flags = aFlags;
maxAnisotropy = aMaxAnisotropy;
mipmapFilterMode = aMipmapFilterMode;
mipmapLevelBias = aMipmapLevelBias;
minMipmapLevelClamp = aMinMipmapLevelClamp;
maxMipmapLevelClamp = aMaxMipmapLevelClamp;
borderColor = new float[4];
borderColor[0] = aBorderColor[0];
borderColor[1] = aBorderColor[1];
borderColor[2] = aBorderColor[2];
borderColor[3] = aBorderColor[3];
_reserved = new int[12];
}
/// <summary>
/// Creates a new CudaTextureDescriptor
/// </summary>
/// <param name=""aAddressMode0"">Address modes for dimension 0</param>
/// <param name=""aAddressMode1"">Address modes for dimension 1</param>
/// <param name=""aAddressMode2"">Address modes for dimension 2</param>
/// <param name=""aFilterMode"">Filter mode</param>
/// <param name=""aFlags"">Flags</param>
/// <param name=""aMaxAnisotropy"">Maximum anisotropy ratio. Specifies the maximum anistropy ratio to be used when doing anisotropic
/// filtering. This value will be clamped to the range [1,16].</param>
/// <param name=""aMipmapFilterMode"">Mipmap filter mode. Specifies the filter mode when the calculated mipmap level lies between
/// two defined mipmap levels.</param>
/// <param name=""aMipmapLevelBias"">Mipmap level bias. Specifies the offset to be applied to the calculated mipmap level.</param>
/// <param name=""aMinMipmapLevelClamp"">Mipmap minimum level clamp. Specifies the lower end of the mipmap level range to clamp access to.</param>
/// <param name=""aMaxMipmapLevelClamp"">Mipmap maximum level clamp. Specifies the upper end of the mipmap level range to clamp access to.</param>
public CudaTextureDescriptor(CUAddressMode aAddressMode0, CUAddressMode aAddressMode1, CUAddressMode aAddressMode2, CUFilterMode aFilterMode, CUTexRefSetFlags aFlags, uint aMaxAnisotropy, CUFilterMode aMipmapFilterMode,
float aMipmapLevelBias, float aMinMipmapLevelClamp, float aMaxMipmapLevelClamp)
{
addressMode = new CUAddressMode[3];
addressMode[0] = aAddressMode0;
addressMode[1] = aAddressMode1;
addressMode[2] = aAddressMode2;
filterMode = aFilterMode;
flags = aFlags;
maxAnisotropy = aMaxAnisotropy;
mipmapFilterMode = aMipmapFilterMode;
mipmapLevelBias = aMipmapLevelBias;
minMipmapLevelClamp = aMinMipmapLevelClamp;
maxMipmapLevelClamp = aMaxMipmapLevelClamp;
borderColor = new float[4];
_reserved = new int[12];
}
/// <summary>
/// Creates a new CudaTextureDescriptor
/// </summary>
/// <param name=""aAddressMode0"">Address modes for dimension 0</param>
/// <param name=""aAddressMode1"">Address modes for dimension 1</param>
/// <param name=""aAddressMode2"">Address modes for dimension 2</param>
/// <param name=""aFilterMode"">Filter mode</param>
/// <param name=""aFlags"">Flags</param>
/// <param name=""aMaxAnisotropy"">Maximum anisotropy ratio. Specifies the maximum anistropy ratio to be used when doing anisotropic
/// filtering. This value will be clamped to the range [1,16].</param>
/// <param name=""aMipmapFilterMode"">Mipmap filter mode. Specifies the filter mode when the calculated mipmap level lies between
/// two defined mipmap levels.</param>
/// <param name=""aMipmapLevelBias"">Mipmap level bias. Specifies the offset to be applied to the calculated mipmap level.</param>
/// <param name=""aMinMipmapLevelClamp"">Mipmap minimum level clamp. Specifies the lower end of the mipmap level range to clamp access to.</param>
/// <param name=""aMaxMipmapLevelClamp"">Mipmap maximum level clamp. Specifies the upper end of the mipmap level range to clamp access to.</param>
/// <param name=""aBorderColor"">borderColor (array of size 4)</param>
public CudaTextureDescriptor(CUAddressMode aAddressMode0, CUAddressMode aAddressMode1, CUAddressMode aAddressMode2, CUFilterMode aFilterMode, CUTexRefSetFlags aFlags, uint aMaxAnisotropy, CUFilterMode aMipmapFilterMode,
float aMipmapLevelBias, float aMinMipmapLevelClamp, float aMaxMipmapLevelClamp, float[] aBorderColor)
{
addressMode = new CUAddressMode[3];
addressMode[0] = aAddressMode0;
addressMode[1] = aAddressMode1;
addressMode[2] = aAddressMode2;
filterMode = aFilterMode;
flags = aFlags;
maxAnisotropy = aMaxAnisotropy;
mipmapFilterMode = aMipmapFilterMode;
mipmapLevelBias = aMipmapLevelBias;
minMipmapLevelClamp = aMinMipmapLevelClamp;
maxMipmapLevelClamp = aMaxMipmapLevelClamp;
borderColor = new float[4];
borderColor[0] = aBorderColor[0];
borderColor[1] = aBorderColor[1];
borderColor[2] = aBorderColor[2];
borderColor[3] = aBorderColor[3];
_reserved = new int[12];
}
/// <summary>
/// Address modes
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I4)]
public CUAddressMode[] addressMode;
/// <summary>
/// Filter mode
/// </summary>
public CUFilterMode filterMode;
/// <summary>
/// Flags
/// </summary>
public CUTexRefSetFlags flags;
/// <summary>
/// Maximum anisotropy ratio. Specifies the maximum anistropy ratio to be used when doing anisotropic
/// filtering. This value will be clamped to the range [1,16].
/// </summary>
public uint maxAnisotropy;
/// <summary>
/// Mipmap filter mode. Specifies the filter mode when the calculated mipmap level lies between
/// two defined mipmap levels.
/// </summary>
public CUFilterMode mipmapFilterMode;
/// <summary>
/// Mipmap level bias. Specifies the offset to be applied to the calculated mipmap level.
/// </summary>
public float mipmapLevelBias;
/// <summary>
/// Mipmap minimum level clamp. Specifies the lower end of the mipmap level range to clamp access to.
/// </summary>
public float minMipmapLevelClamp;
/// <summary>
/// Mipmap maximum level clamp. Specifies the upper end of the mipmap level range to clamp access to.
/// </summary>
public float maxMipmapLevelClamp; /// <summary>
/// Border Color
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.R4)]
public float[] borderColor;
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I4)]
private int[] _reserved;
}",Texture descriptor,1
457,"public struct cusolverDnHandle
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",This is a pointer type to an opaque cuSolverDN context,1
458,"public struct cusolverRfHandle
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",This is a pointer type to an opaque cuSolverRF context,1
459,"public struct cusolverSpHandle
{
/// <summary>
/// /// </summary>
public IntPtr Pointer;
}",This is a pointer type to an opaque cuSolverSP context,1
460,"public struct Fence
{
/// <summary>
/// Value of fence to be signaled
/// </summary>
public ulong value;
}",Value of fence to be signaled,1
461,"public struct Fence
{
/// <summary>
/// Value of fence to be waited on
/// </summary>
public ulong value;
}",Value of fence to be waited on,1
462,"public void Synchronize()
{
if (disposed) throw new ObjectDisposedException(this.ToString());
res = DriverAPINativeMethods.Streams.cuStreamSynchronize(_stream);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""cuStreamSynchronize"", res));
if (res != CUResult.Success) throw new CudaException(res);
}","Waits until the device has completed all operations in the stream. If the context was created with the CUCtxFlags.BlockingSync flag, the CPU thread will block until the stream is finished with all of its tasks.",1
463,"public static void WarpAffine(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_16u_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_16u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
464,"public static void WarpAffineBack(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_16u_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_16u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
465,"public static void WarpAffineQuad(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, double[,] srcQuad, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_16u_P3R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_16u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
466,"public static void WarpPerspective(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_16u_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_16u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
467,"public static void WarpPerspectiveBack(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_16u_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_16u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
468,"public static void WarpPerspectiveQuad(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, double[,] srcQuad, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_16u_P3R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_16u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
469,"public void WarpAffine(NPPImage_16uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_16u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_16u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
470,"public void WarpAffineA(NPPImage_16uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_16u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_16u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
471,"public void WarpAffineBack(NPPImage_16uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_16u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_16u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
472,"public void WarpAffineBackA(NPPImage_16uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_16u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_16u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
473,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_16uC4 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_16u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_16u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
474,"public void WarpAffineQuadA(double[,] srcQuad, NPPImage_16uC4 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_16u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_16u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
475,"public void WarpPerspective(NPPImage_16uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_16u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_16u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
476,"public void WarpPerspectiveA(NPPImage_16uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_16u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_16u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
477,"public void WarpPerspectiveBack(NPPImage_16uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_16u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_16u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
478,"public void WarpPerspectiveBackA(NPPImage_16uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_16u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_16u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
479,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_16uC4 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_16u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_16u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
480,"public void WarpPerspectiveQuadA(double[,] srcQuad, NPPImage_16uC4 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_16u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_16u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
481,"public void AlphaPremulA()
{
status = NPPNativeMethods.NPPi.AlphaPremul.nppiAlphaPremul_16u_AC4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiAlphaPremul_16u_AC4IR"", status));
NPPException.CheckNppStatus(status, this);
}",Four 8-bit unsigned char channel in place image premultiplication with pixel alpha (0 - max channel pixel value).,1
482,"public void ColorTwistA(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorTwist.nppiColorTwist32f_16u_AC4IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_16uA_C4IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
483,"public static void WarpAffine(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_16u_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_16u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
484,"public static void WarpAffineBack(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_16u_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_16u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
485,"public static void WarpAffineQuad(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, double[,] srcQuad, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_16u_P4R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_16u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
486,"public static void WarpPerspective(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_16u_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_16u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
487,"public static void WarpPerspectiveBack(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_16u_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_16u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
488,"public static void WarpPerspectiveQuad(NPPImage_16uC1 src0, NPPImage_16uC1 src1, NPPImage_16uC1 src2, double[,] srcQuad, NPPImage_16uC1 dest0, NPPImage_16uC1 dest1, NPPImage_16uC1 dest2, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_16u_P4R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_16u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
489,"public void Exp()
{
status = NPPNativeMethods.NPPi.Exp.nppiExp_32f_C1IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiExp_32f_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace exponential.,0
490,"public void Ln()
{
status = NPPNativeMethods.NPPi.Ln.nppiLn_32f_C1IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiLn_32f_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",Natural logarithm.,0
491,"public void Sqr()
{
status = NPPNativeMethods.NPPi.Sqr.nppiSqr_32f_C1IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSqr_32f_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image squared.,1
492,"public void Sqrt()
{
status = NPPNativeMethods.NPPi.Sqrt.nppiSqrt_32f_C1IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSqrt_32f_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image square root.,1
493,"public void WarpAffine(NPPImage_32fC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32f_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32f_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
494,"public void WarpAffineBack(NPPImage_32fC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32f_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32f_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
495,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_32fC1 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32f_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32f_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
496,"public void WarpPerspective(NPPImage_32fC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32f_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32f_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
497,"public void WarpPerspectiveBack(NPPImage_32fC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32f_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32f_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
498,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_32fC1 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32f_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32f_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
499,"public void Abs()
{
status = NPPNativeMethods.NPPi.Abs.nppiAbs_32f_C1IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiAbs_32f_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",Image absolute value. In place.,1
500,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorProcessing.nppiColorTwist_32f_C1IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist_32f_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
501,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorProcessing.nppiColorTwist_32f_C2IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist_32f_C2IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
502,"public void Abs()
{
status = NPPNativeMethods.NPPi.Abs.nppiAbs_32f_C3IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiAbs_32f_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",Image absolute value. In place.,1
503,"public void Exp()
{
status = NPPNativeMethods.NPPi.Exp.nppiExp_32f_C3IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiExp_32f_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace exponential.,0
504,"public void Ln()
{
status = NPPNativeMethods.NPPi.Ln.nppiLn_32f_C3IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiLn_32f_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",Natural logarithm.,0
505,"public void Sqr()
{
status = NPPNativeMethods.NPPi.Sqr.nppiSqr_32f_C3IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSqr_32f_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image squared.,1
506,"public void Sqrt()
{
status = NPPNativeMethods.NPPi.Sqrt.nppiSqrt_32f_C3IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSqrt_32f_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image square root.,1
507,"public void WarpAffine(NPPImage_32fC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32f_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32f_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
508,"public void WarpAffineBack(NPPImage_32fC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32f_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32f_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
509,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_32fC3 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32f_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32f_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
510,"public void WarpPerspective(NPPImage_32fC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32f_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32f_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
511,"public void WarpPerspectiveBack(NPPImage_32fC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32f_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32f_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
512,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_32fC3 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32f_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32f_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
513,"public void SwapChannels(NPPImage_32fC3 dest, int[] aDstOrder)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_32f_C3R(_devPtrRoi, _pitch, dest.DevicePointerRoi, dest.Pitch, _sizeRoi, aDstOrder);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_32f_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [2,1,0] converts this to BGR channel order.",1
514,"public void SwapChannels(NPPImage_32fC4 dest, int[] aDstOrder, byte nValue)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_32f_C3C4R(_devPtrRoi, _pitch, dest.DevicePointerRoi, dest.Pitch, _sizeRoi, aDstOrder, nValue);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_32f_C3C4R"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [3,2,1,0] converts this to VBGR channel order. An aDstOrder value of 3 will output nValue to that channel, an aDstOrder value greater than 3 will leave that particular destination channel value unmodified.",1
515,"public void SwapChannels(int[] aDstOrder)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_32f_C3IR(_devPtrRoi, _pitch, _sizeRoi, aDstOrder);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_32f_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [2,1,0] converts this to BGR channel order.",1
516,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorTwist.nppiColorTwist_32f_C3IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist_32f_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
517,"public static void WarpAffine(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32f_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32f_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
518,"public static void WarpAffineBack(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32f_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32f_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
519,"public static void WarpAffineQuad(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, double[,] srcQuad, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32f_P3R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32f_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
520,"public static void WarpPerspective(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32f_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32f_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
521,"public static void WarpPerspectiveBack(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32f_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32f_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
522,"public static void WarpPerspectiveQuad(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, double[,] srcQuad, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32f_P3R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32f_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
523,"public void Sqr()
{
status = NPPNativeMethods.NPPi.Sqr.nppiSqr_32f_C4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSqr_32f_C4IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image squared.,1
524,"public void SqrA()
{
status = NPPNativeMethods.NPPi.Sqr.nppiSqr_32f_AC4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSqr_32f_AC4IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image squared. Unchanged Alpha.,1
525,"public void Sqrt()
{
status = NPPNativeMethods.NPPi.Sqrt.nppiSqrt_32f_C4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSqrt_32f_C4IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image square root.,1
526,"public void SqrtA()
{
status = NPPNativeMethods.NPPi.Sqrt.nppiSqrt_32f_AC4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSqrt_32f_AC4IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image square root. Unchanged Alpha.,1
527,"public void WarpAffine(NPPImage_32fC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32f_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32f_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
528,"public void WarpAffineA(NPPImage_32fC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32f_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32f_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
529,"public void WarpAffineBack(NPPImage_32fC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32f_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32f_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
530,"public void WarpAffineBackA(NPPImage_32fC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32f_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32f_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
531,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_32fC4 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32f_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32f_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
532,"public void WarpAffineQuadA(double[,] srcQuad, NPPImage_32fC4 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32f_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32f_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
533,"public void WarpPerspective(NPPImage_32fC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32f_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32f_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
534,"public void WarpPerspectiveA(NPPImage_32fC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32f_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32f_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
535,"public void WarpPerspectiveBack(NPPImage_32fC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32f_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32f_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
536,"public void WarpPerspectiveBackA(NPPImage_32fC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32f_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32f_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
537,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_32fC4 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32f_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32f_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
538,"public void WarpPerspectiveQuadA(double[,] srcQuad, NPPImage_32fC4 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32f_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32f_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
539,"public void Abs()
{
status = NPPNativeMethods.NPPi.Abs.nppiAbs_32f_C4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiAbs_32f_C4IR"", status));
NPPException.CheckNppStatus(status, this);
}",Image absolute value. In place.,1
540,"public void AbsA()
{
status = NPPNativeMethods.NPPi.Abs.nppiAbs_32f_AC4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiAbs_32f_AC4IR"", status));
NPPException.CheckNppStatus(status, this);
}",Image absolute value. In place. Not affecting Alpha value.,1
541,"public void ColorTwistA(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorTwist.nppiColorTwist_32f_AC4IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist_32fA_C4IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
542,"public static void WarpAffine(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32f_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32f_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
543,"public static void WarpAffineBack(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32f_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32f_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
544,"public static void WarpAffineQuad(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, double[,] srcQuad, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32f_P4R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32f_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
545,"public static void WarpPerspective(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32f_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32f_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
546,"public static void WarpPerspectiveBack(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32f_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32f_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
547,"public static void WarpPerspectiveQuad(NPPImage_32fC1 src0, NPPImage_32fC1 src1, NPPImage_32fC1 src2, double[,] srcQuad, NPPImage_32fC1 dest0, NPPImage_32fC1 dest1, NPPImage_32fC1 dest2, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32f_P4R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32f_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
548,"public void WarpAffine(NPPImage_32sC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32s_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32s_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
549,"public void WarpAffineBack(NPPImage_32sC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32s_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32s_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
550,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_32sC1 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32s_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32s_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
551,"public void WarpPerspective(NPPImage_32sC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32s_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32s_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
552,"public void WarpPerspectiveBack(NPPImage_32sC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32s_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32s_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
553,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_32sC1 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32s_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32s_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
554,"public void WarpAffine(NPPImage_32sC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32s_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32s_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
555,"public void WarpAffineBack(NPPImage_32sC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32s_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32s_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
556,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_32sC3 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32s_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32s_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
557,"public void WarpPerspective(NPPImage_32sC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32s_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32s_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
558,"public void WarpPerspectiveBack(NPPImage_32sC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32s_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32s_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
559,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_32sC3 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32s_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32s_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
560,"public void SwapChannels(NPPImage_32sC3 dest, int[] aDstOrder)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_32s_C3R(_devPtrRoi, _pitch, dest.DevicePointerRoi, dest.Pitch, _sizeRoi, aDstOrder);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_32s_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [2,1,0] converts this to BGR channel order.",1
561,"public void SwapChannels(NPPImage_32sC4 dest, int[] aDstOrder, int nValue)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_32s_C3C4R(_devPtrRoi, _pitch, dest.DevicePointerRoi, dest.Pitch, _sizeRoi, aDstOrder, nValue);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_32s_C3C4R"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [3,2,1,0] converts this to VBGR channel order. An aDstOrder value of 3 will output nValue to that channel, an aDstOrder value greater than 3 will leave that particular destination channel value unmodified.",1
562,"public void SwapChannels(int[] aDstOrder)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_32s_C3IR(_devPtrRoi, _pitch, _sizeRoi, aDstOrder);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_32s_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [2,1,0] converts this to BGR channel order.",1
563,"public static void WarpAffine(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32s_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32s_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
564,"public static void WarpAffineBack(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32s_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32s_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
565,"public static void WarpAffineQuad(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, double[,] srcQuad, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32s_P3R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32s_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
566,"public static void WarpPerspective(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32s_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32s_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
567,"public static void WarpPerspectiveBack(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32s_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32s_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
568,"public static void WarpPerspectiveQuad(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, double[,] srcQuad, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32s_P3R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32s_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
569,"public void WarpAffine(NPPImage_32sC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32s_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32s_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
570,"public void WarpAffineA(NPPImage_32sC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32s_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32s_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
571,"public void WarpAffineBack(NPPImage_32sC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32s_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32s_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
572,"public void WarpAffineBackA(NPPImage_32sC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32s_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32s_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
573,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_32sC4 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32s_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32s_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
574,"public void WarpAffineQuadA(double[,] srcQuad, NPPImage_32sC4 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32s_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32s_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
575,"public void WarpPerspective(NPPImage_32sC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32s_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32s_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
576,"public void WarpPerspectiveA(NPPImage_32sC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32s_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32s_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
577,"public void WarpPerspectiveBack(NPPImage_32sC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32s_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32s_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
578,"public void WarpPerspectiveBackA(NPPImage_32sC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32s_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32s_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
579,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_32sC4 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32s_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32s_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
580,"public void WarpPerspectiveQuadA(double[,] srcQuad, NPPImage_32sC4 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32s_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32s_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
581,"public static void WarpAffine(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_32s_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_32s_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
582,"public static void WarpAffineBack(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_32s_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_32s_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
583,"public static void WarpAffineQuad(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, double[,] srcQuad, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_32s_P4R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_32s_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
584,"public static void WarpPerspective(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_32s_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_32s_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
585,"public static void WarpPerspectiveBack(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_32s_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_32s_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
586,"public static void WarpPerspectiveQuad(NPPImage_32sC1 src0, NPPImage_32sC1 src1, NPPImage_32sC1 src2, double[,] srcQuad, NPPImage_32sC1 dest0, NPPImage_32sC1 dest1, NPPImage_32sC1 dest2, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_32s_P4R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_32s_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
587,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorProcessing.nppiColorTwist32f_8s_C1IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_8s_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
588,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorProcessing.nppiColorTwist32f_8s_C2IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_8s_C2IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
589,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorTwist.nppiColorTwist32f_8s_C3IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_8s_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
590,"public void ColorTwistA(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorTwist.nppiColorTwist32f_8s_AC4IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_8sA_C4IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
591,"public void Not()
{
status = NPPNativeMethods.NPPi.Not.nppiNot_8u_C1IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiNot_8u_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",In place image logical Not.,1
592,"public void WarpAffine(NPPImage_8uC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_8u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_8u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
593,"public void WarpAffineBack(NPPImage_8uC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_8u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_8u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
594,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_8uC1 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_8u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_8u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
595,"public void WarpPerspective(NPPImage_8uC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_8u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_8u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
596,"public void WarpPerspectiveBack(NPPImage_8uC1 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_8u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_8u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
597,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_8uC1 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_8u_C1R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_8u_C1R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
598,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorProcessing.nppiColorTwist32f_8u_C1IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_8u_C1IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
599,"public int MSEGetBufferHostSize()
{
int ret = 0;
status = NPPNativeMethods.NPPi.IQA.nppiMSEGetBufferHostSize_8u_C1R(_sizeRoi, ref ret);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiMSEGetBufferHostSize_8u_C1R"", status));
NPPException.CheckNppStatus(status, this);
return ret;
}",Buffer size for nppiMSE_8u_C1R.,1
600,"public int PSNRGetBufferHostSize()
{
int ret = 0;
status = NPPNativeMethods.NPPi.IQA.nppiPSNRGetBufferHostSize_8u_C1R(_sizeRoi, ref ret);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiPSNRGetBufferHostSize_8u_C1R"", status));
NPPException.CheckNppStatus(status, this);
return ret;
}",Buffer size for nppiPSNR_8u_C1R.,1
601,"public int SSIMGetBufferHostSize()
{
int ret = 0;
status = NPPNativeMethods.NPPi.IQA.nppiSSIMGetBufferHostSize_8u_C1R(_sizeRoi, ref ret);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSSIMGetBufferHostSize_8u_C1R"", status));
NPPException.CheckNppStatus(status, this);
return ret;
}",Buffer size for nppiSSIM_8u_C1R.,1
602,"public int MSSSIMGetBufferHostSize()
{
int ret = 0;
status = NPPNativeMethods.NPPi.IQA.nppiMSSSIMGetBufferHostSize_8u_C1R(_sizeRoi, ref ret);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiMSSSIMGetBufferHostSize_8u_C1R"", status));
NPPException.CheckNppStatus(status, this);
return ret;
}",Buffer size for nppiMSSSIM_8u_C1R.,1
603,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorProcessing.nppiColorTwist32f_8u_C2IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_8u_C2IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
604,"public void Not()
{
status = NPPNativeMethods.NPPi.Not.nppiNot_8u_C3IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiNot_8u_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",In place image logical Not.,1
605,"public void WarpAffine(NPPImage_8uC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_8u_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_8u_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
606,"public void WarpAffineBack(NPPImage_8uC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_8u_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_8u_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
607,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_8uC3 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_8u_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_8u_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
608,"public void WarpPerspective(NPPImage_8uC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_8u_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_8u_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
609,"public void WarpPerspectiveBack(NPPImage_8uC3 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_8u_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_8u_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
610,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_8uC3 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_8u_C3R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_8u_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
611,"public void Gamma()
{
status = NPPNativeMethods.NPPi.Gamma.nppiGammaFwd_8u_C3IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiGammaFwd_8u_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image forward gamma correction.,1
612,"public void GammaInv()
{
status = NPPNativeMethods.NPPi.Gamma.nppiGammaInv_8u_C3IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiGammaInv_8u_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image inverse gamma correction.,1
613,"public void SwapChannels(NPPImage_8uC3 dest, int[] aDstOrder)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_8u_C3R(_devPtrRoi, _pitch, dest.DevicePointerRoi, dest.Pitch, _sizeRoi, aDstOrder);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_8u_C3R"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [2,1,0] converts this to BGR channel order.",1
614,"public void SwapChannels(NPPImage_8uC4 dest, int[] aDstOrder, byte nValue)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_8u_C3C4R(_devPtrRoi, _pitch, dest.DevicePointerRoi, dest.Pitch, _sizeRoi, aDstOrder, nValue);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_8u_C3C4R"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [3,2,1,0] converts this to VBGR channel order. An aDstOrder value of 3 will output nValue to that channel, an aDstOrder value greater than 3 will leave that particular destination channel value unmodified.",1
615,"public void SwapChannels(int[] aDstOrder)
{
status = NPPNativeMethods.NPPi.SwapChannel.nppiSwapChannels_8u_C3IR(_devPtrRoi, _pitch, _sizeRoi, aDstOrder);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiSwapChannels_8u_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}","E.g. Given an RGB image, aDstOrder = [2,1,0] converts this to BGR channel order.",1
616,"public void ColorTwist(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorTwist.nppiColorTwist32f_8u_C3IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_8u_C3IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
617,"public static void WarpAffine(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_8u_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_8u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
618,"public static void WarpAffineBack(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_8u_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_8u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
619,"public static void WarpAffineQuad(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, double[,] srcQuad, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_8u_P3R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_8u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
620,"public static void WarpPerspective(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_8u_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_8u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
621,"public static void WarpPerspectiveBack(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_8u_P3R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_8u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
622,"public static void WarpPerspectiveQuad(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, double[,] srcQuad, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_8u_P3R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_8u_P3R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
623,"public void Not()
{
status = NPPNativeMethods.NPPi.Not.nppiNot_8u_C4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiNot_8u_C4IR"", status));
NPPException.CheckNppStatus(status, this);
}",In place image logical Not.,1
624,"public void NotA()
{
status = NPPNativeMethods.NPPi.Not.nppiNot_8u_AC4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiNot_8u_AC4IR"", status));
NPPException.CheckNppStatus(status, this);
}",In place image logical Not. Unchanged Alpha.,1
625,"public void WarpAffine(NPPImage_8uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_8u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_8u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
626,"public void WarpAffineA(NPPImage_8uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_8u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_8u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
627,"public void WarpAffineBack(NPPImage_8uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_8u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_8u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
628,"public void WarpAffineBackA(NPPImage_8uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_8u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_8u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
629,"public void WarpAffineQuad(double[,] srcQuad, NPPImage_8uC4 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_8u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_8u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
630,"public void WarpAffineQuadA(double[,] srcQuad, NPPImage_8uC4 dest, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_8u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_8u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
631,"public void WarpPerspective(NPPImage_8uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_8u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_8u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
632,"public void WarpPerspectiveA(NPPImage_8uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_8u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_8u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
633,"public void WarpPerspectiveBack(NPPImage_8uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_8u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_8u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
634,"public void WarpPerspectiveBackA(NPPImage_8uC4 dest, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_8u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, dest.DevicePointer, dest.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_8u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
635,"public void WarpPerspectiveQuad(double[,] srcQuad, NPPImage_8uC4 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_8u_C4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_8u_C4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
636,"public void WarpPerspectiveQuadA(double[,] srcQuad, NPPImage_8uC4 dest, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(_pointRoi, _sizeRoi);
NppiRect rectOut = new NppiRect(dest.PointRoi, dest.SizeRoi);
status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_8u_AC4R(_devPtr, _sizeOriginal, _pitch, rectIn, srcQuad, dest.DevicePointer, dest.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_8u_AC4R"", status));
NPPException.CheckNppStatus(status, this);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
637,"public void AlphaPremulA()
{
status = NPPNativeMethods.NPPi.AlphaPremul.nppiAlphaPremul_8u_AC4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiAlphaPremul_8u_AC4IR"", status));
NPPException.CheckNppStatus(status, this);
}",Four 8-bit unsigned char channel in place image premultiplication with pixel alpha (0 - max channel pixel value).,1
638,"public void GammaA()
{
status = NPPNativeMethods.NPPi.Gamma.nppiGammaFwd_8u_AC4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiGammaFwd_8u_AC4IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image forward gamma correction. Not affecting alpha.,1
639,"public void GammaInvA()
{
status = NPPNativeMethods.NPPi.Gamma.nppiGammaInv_8u_AC4IR(_devPtrRoi, _pitch, _sizeRoi);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiGammaInv_8u_AC4IR"", status));
NPPException.CheckNppStatus(status, this);
}",Inplace image inverse gamma correction. Not affecting alpha.,1
640,"public void ColorTwistA(float[,] aTwist)
{
status = NPPNativeMethods.NPPi.ColorTwist.nppiColorTwist32f_8u_AC4IR(_devPtr, _pitch, _sizeRoi, aTwist);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiColorTwist32f_8uA_C4IR"", status));
NPPException.CheckNppStatus(status, this);
}",An input color twist matrix with floating-point coefficient values is applied within ROI.,1
641,"public static void WarpAffine(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffine_8u_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffine_8u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
642,"public static void WarpAffineBack(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineBack_8u_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineBack_8u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
643,"public static void WarpAffineQuad(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, double[,] srcQuad, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] dstQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.AffinTransforms.nppiWarpAffineQuad_8u_P4R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, dstQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpAffineQuad_8u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
644,"public static void WarpPerspective(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspective_8u_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspective_8u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
645,"public static void WarpPerspectiveBack(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] coeffs, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveBack_8u_P4R(src, src0.Size, src0.Pitch, rectIn, dst, dest0.Pitch, rectOut, coeffs, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveBack_8u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
646,"public static void WarpPerspectiveQuad(NPPImage_8uC1 src0, NPPImage_8uC1 src1, NPPImage_8uC1 src2, double[,] srcQuad, NPPImage_8uC1 dest0, NPPImage_8uC1 dest1, NPPImage_8uC1 dest2, double[,] destQuad, InterpolationMode eInterpolation)
{
NppiRect rectIn = new NppiRect(src0.PointRoi, src0.SizeRoi);
NppiRect rectOut = new NppiRect(dest0.PointRoi, dest0.SizeRoi);
CUdeviceptr[] src = new CUdeviceptr[] { src0.DevicePointer, src1.DevicePointer, src2.DevicePointer };
CUdeviceptr[] dst = new CUdeviceptr[] { dest0.DevicePointer, dest1.DevicePointer, dest2.DevicePointer };
NppStatus status = NPPNativeMethods.NPPi.PerspectiveTransforms.nppiWarpPerspectiveQuad_8u_P4R(src, src0.Size, src0.Pitch, rectIn, srcQuad, dst, dest0.Pitch, rectOut, destQuad, eInterpolation);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiWarpPerspectiveQuad_8u_P4R"", status));
NPPException.CheckNppStatus(status, null);
}","are multiples of 64. Another rule of thumb is to specify destination ROI in such way that left and right sides of the projected image are separated from the ROI by at least 63 bytes from each side. However, this requires the whole ROI to be part of allocated memory. In case when the conditions above are not satisfied, the function may decrease in speed slightly and will return NPP_MISALIGNED_DST_ROI_WARNING warning.",1
647,"public void ResetRoi()
{
_devPtrRoi = _devPtr;
_pointRoi = new NppiPoint(0, 0);
_sizeRoi = _sizeOriginal;
}",Resets the ROI to the full image,1
648,"public struct NppiPoint
{
/// <summary>
/// x-coordinate.
/// </summary>
public int x;
/// <summary>
/// y-coordinate.
/// </summary>
public int y;
/// <summary>
/// Non-default constructor
/// </summary>
/// <param name=""aX""></param>
/// <param name=""aY""></param>
public NppiPoint(int aX, int aY)
{
x = aX;
y = aY;
}
#region Operator Methods
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Add(NppiPoint src, NppiPoint value)
{
NppiPoint ret = new NppiPoint(src.x + value.x, src.y + value.y);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Add(NppiPoint src, NppiSize value)
{
NppiPoint ret = new NppiPoint(src.x + value.width, src.y + value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Add(NppiPoint src, int value)
{
NppiPoint ret = new NppiPoint(src.x + value, src.y + value);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Add(int src, NppiPoint value)
{
NppiPoint ret = new NppiPoint(src + value.x, src + value.y);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Subtract(NppiPoint src, NppiPoint value)
{
NppiPoint ret = new NppiPoint(src.x - value.x, src.y - value.y);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Subtract(NppiPoint src, NppiSize value)
{
NppiPoint ret = new NppiPoint(src.x - value.width, src.y - value.height);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Subtract(NppiPoint src, int value)
{
NppiPoint ret = new NppiPoint(src.x - value, src.y - value);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Subtract(int src, NppiPoint value)
{
NppiPoint ret = new NppiPoint(src - value.x, src - value.y);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Multiply(NppiPoint src, NppiPoint value)
{
NppiPoint ret = new NppiPoint(src.x * value.x, src.y * value.y);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Multiply(NppiPoint src, NppiSize value)
{
NppiPoint ret = new NppiPoint(src.x * value.width, src.y * value.height);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Multiply(NppiPoint src, int value)
{
NppiPoint ret = new NppiPoint(src.x * value, src.y * value);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Multiply(int src, NppiPoint value)
{
NppiPoint ret = new NppiPoint(src * value.x, src * value.y);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Divide(NppiPoint src, NppiPoint value)
{
NppiPoint ret = new NppiPoint(src.x / value.x, src.y / value.y);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Divide(NppiPoint src, NppiSize value)
{
NppiPoint ret = new NppiPoint(src.x / value.width, src.y / value.height);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Divide(NppiPoint src, int value)
{
NppiPoint ret = new NppiPoint(src.x / value, src.y / value);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint Divide(int src, NppiPoint value)
{
NppiPoint ret = new NppiPoint(src / value.x, src / value.y);
return ret;
}
#endregion
#region operators
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator +(NppiPoint src, NppiPoint value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator +(NppiPoint src, NppiSize value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator +(NppiPoint src, int value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator +(int src, NppiPoint value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator -(NppiPoint src, NppiPoint value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator -(NppiPoint src, NppiSize value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator -(NppiPoint src, int value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator -(int src, NppiPoint value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator *(NppiPoint src, NppiPoint value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator *(NppiPoint src, NppiSize value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator *(NppiPoint src, int value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator *(int src, NppiPoint value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator /(NppiPoint src, NppiPoint value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator /(NppiPoint src, NppiSize value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator /(NppiPoint src, int value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiPoint operator /(int src, NppiPoint value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static bool operator ==(NppiPoint src, NppiPoint value)
{
if (object.ReferenceEquals(src, value)) return true;
return src.Equals(value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static bool operator !=(NppiPoint src, NppiPoint value)
{
return !(src == value);
}
#endregion
#region Override Methods
/// <summary>
/// /// </summary>
/// <param name=""obj""></param>
/// <returns></returns>
public override bool Equals(object obj)
{
if (obj == null) return false;
if (!(obj is NppiPoint)) return false;
NppiPoint value = (NppiPoint)obj;
bool ret = true;
ret &= this.x == value.x;
ret &= this.y == value.y;
return ret;
}
/// <summary>
/// /// </summary>
/// <param name=""value""></param>
/// <returns></returns>
public bool Equals(NppiPoint value)
{
bool ret = true;
ret &= this.x == value.x;
ret &= this.y == value.y;
return ret;
}
/// <summary>
/// /// </summary>
/// <returns></returns>
public override int GetHashCode()
{
return x.GetHashCode() ^ y.GetHashCode();
}
/// <summary>
/// /// </summary>
/// <returns></returns>
public override string ToString()
{
return string.Format(CultureInfo.CurrentCulture, ""({0}; {1})"", this.x, this.y);
}
#endregion
}",2D Point.,0
649,"public struct NppiRect
{
/// <summary>
/// x-coordinate of upper left corner.
/// </summary>
public int x;
/// <summary>
/// y-coordinate of upper left corner.
/// </summary>
public int y;
/// <summary>
/// Rectangle width.
/// </summary>
public int width;
/// <summary>
/// Rectangle height.
/// </summary>
public int height;
/// <summary>
/// Non-default constructor
/// </summary>
/// <param name=""aX""></param>
/// <param name=""aY""></param>
/// <param name=""aWidth""></param>
/// <param name=""aHeight""></param>
public NppiRect(int aX, int aY, int aWidth, int aHeight)
{
x = aX;
y = aY;
width = aWidth;
height = aHeight;
}
/// <summary>
/// Non-default constructor
/// </summary>
/// <param name=""aPoint""></param>
/// <param name=""aSize""></param>
public NppiRect(NppiPoint aPoint, NppiSize aSize)
{
x = aPoint.x;
y = aPoint.y;
width = aSize.width;
height = aSize.height;
}
/// <summary>
/// Returns the x and y component as NppiPoint
/// </summary>
/// <returns></returns>
public NppiPoint Location
{
get { return new NppiPoint(x, y); }
set { x = value.x; y = value.y; }
}
/// <summary>
/// Returns the width and height component as NppiSize
/// </summary>
/// <returns></returns>
public NppiSize Size
{
get { return new NppiSize(width, height); }
set { width = value.width; height = value.height; }
}
/// <summary>
/// Gets the y-coordinate that is the sum of the y and height values - 1.
/// </summary>
public int Bottom
{
get { return y + height - 1; }
}
/// <summary>
/// Gets the x-coordinate of the left edge.
/// </summary>
public int Left
{
get { return x; }
}
/// <summary>
/// Gets the x-coordinate that is the sum of x and width values - 1.
/// </summary>
public int Right
{
get { return x + width - 1; }
}
/// <summary>
/// Gets the y-coordinate of the top edge.
/// </summary>
public int Top
{
get { return y; }
}
/// <summary>
/// Tests whether all numeric properties of this Rectangle have values of zero.
/// </summary>
public bool IsEmtpy
{
get { return x == 0 && y == 0 && width == 0 && height == 0; }
}
///// <summary>
///// Returns the pointer shift for this roi and a given memory pitch
///// </summary>
///// <param name=""aPitch""></param>
///// <param name=""channels""></param>
///// <param name=""typeSize""></param>
///// <returns></returns>
//public SizeT GetPointerShift(SizeT aPitch, int channels, int typeSize)
//{
// return typeSize * channels * x + aPitch * y;
//}
#region Operator Methods
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Add(NppiRect src, NppiRect value)
{
NppiRect ret = new NppiRect(src.x + value.x, src.y + value.y, src.width + value.width, src.height + value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Add(NppiRect src, int value)
{
NppiRect ret = new NppiRect(src.x + value, src.y + value, src.width + value, src.height + value);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Add(int src, NppiRect value)
{
NppiRect ret = new NppiRect(src + value.x, src + value.y, src + value.width, src + value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Add(NppiRect src, NppiPoint value)
{
NppiRect ret = new NppiRect(src.x + value.x, src.y + value.y, src.width, src.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Add(NppiPoint src, NppiRect value)
{
NppiRect ret = new NppiRect(src.x + value.x, src.y + value.y, value.width, value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Add(NppiRect src, NppiSize value)
{
NppiRect ret = new NppiRect(src.x, src.y, src.width + value.width, src.height + value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Add(NppiSize src, NppiRect value)
{
NppiRect ret = new NppiRect(value.x, value.y, src.width + value.width, src.height + value.height);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Subtract(NppiRect src, NppiRect value)
{
NppiRect ret = new NppiRect(src.x - value.x, src.y - value.y, src.width - value.width, src.height - value.height);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Subtract(NppiRect src, int value)
{
NppiRect ret = new NppiRect(src.x - value, src.y - value, src.width - value, src.height - value);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Subtract(int src, NppiRect value)
{
NppiRect ret = new NppiRect(src - value.x, src - value.y, src - value.width, src - value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Subtract(NppiRect src, NppiPoint value)
{
NppiRect ret = new NppiRect(src.x - value.x, src.y - value.y, src.width, src.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Subtract(NppiPoint src, NppiRect value)
{
NppiRect ret = new NppiRect(src.x - value.x, src.y - value.y, value.width, value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Subtract(NppiRect src, NppiSize value)
{
NppiRect ret = new NppiRect(src.x, src.y, src.width - value.width, src.height - value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Subtract(NppiSize src, NppiRect value)
{
NppiRect ret = new NppiRect(value.x, value.y, src.width - value.width, src.height - value.height);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Multiply(NppiRect src, NppiRect value)
{
NppiRect ret = new NppiRect(src.x * value.x, src.y * value.y, src.width * value.width, src.height * value.height);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Multiply(NppiRect src, int value)
{
NppiRect ret = new NppiRect(src.x * value, src.y * value, src.width * value, src.height * value);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Multiply(int src, NppiRect value)
{
NppiRect ret = new NppiRect(src * value.x, src * value.y, src * value.width, src * value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Multiply(NppiRect src, NppiPoint value)
{
NppiRect ret = new NppiRect(src.x * value.x, src.y * value.y, src.width, src.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Multiply(NppiPoint src, NppiRect value)
{
NppiRect ret = new NppiRect(src.x * value.x, src.y * value.y, value.width, value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Multiply(NppiRect src, NppiSize value)
{
NppiRect ret = new NppiRect(src.x, src.y, src.width * value.width, src.height * value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Multiply(NppiSize src, NppiRect value)
{
NppiRect ret = new NppiRect(value.x, value.y, src.width * value.width, src.height * value.height);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Divide(NppiRect src, NppiRect value)
{
NppiRect ret = new NppiRect(src.x / value.x, src.y / value.y, src.width / value.width, src.height / value.height);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Divide(NppiRect src, int value)
{
NppiRect ret = new NppiRect(src.x / value, src.y / value, src.width / value, src.height / value);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Divide(int src, NppiRect value)
{
NppiRect ret = new NppiRect(src / value.x, src / value.y, src / value.width, src / value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Divide(NppiRect src, NppiPoint value)
{
NppiRect ret = new NppiRect(src.x / value.x, src.y / value.y, src.width, src.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Divide(NppiPoint src, NppiRect value)
{
NppiRect ret = new NppiRect(src.x / value.x, src.y / value.y, value.width, value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Divide(NppiRect src, NppiSize value)
{
NppiRect ret = new NppiRect(src.x, src.y, src.width / value.width, src.height / value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect Divide(NppiSize src, NppiRect value)
{
NppiRect ret = new NppiRect(value.x, value.y, src.width / value.width, src.height / value.height);
return ret;
}
#endregion
#region operators
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator +(NppiRect src, NppiRect value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator +(NppiRect src, int value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator +(int src, NppiRect value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator +(NppiRect src, NppiPoint value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator +(NppiPoint src, NppiRect value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator +(NppiRect src, NppiSize value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator +(NppiSize src, NppiRect value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator -(NppiRect src, NppiRect value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator -(NppiRect src, int value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator -(int src, NppiRect value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator -(NppiRect src, NppiPoint value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator -(NppiPoint src, NppiRect value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator -(NppiRect src, NppiSize value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator -(NppiSize src, NppiRect value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator *(NppiRect src, NppiRect value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator *(NppiRect src, int value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator *(int src, NppiRect value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator *(NppiRect src, NppiPoint value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator *(NppiPoint src, NppiRect value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator *(NppiRect src, NppiSize value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator *(NppiSize src, NppiRect value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator /(NppiRect src, NppiRect value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator /(NppiRect src, int value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator /(int src, NppiRect value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator /(NppiRect src, NppiPoint value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator /(NppiPoint src, NppiRect value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator /(NppiRect src, NppiSize value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiRect operator /(NppiSize src, NppiRect value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static bool operator ==(NppiRect src, NppiRect value)
{
if (object.ReferenceEquals(src, value)) return true;
return src.Equals(value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static bool operator !=(NppiRect src, NppiRect value)
{
return !(src == value);
}
#endregion
#region Override Methods
/// <summary>
/// /// </summary>
/// <param name=""obj""></param>
/// <returns></returns>
public override bool Equals(object obj)
{
if (obj == null) return false;
if (!(obj is NppiRect)) return false;
NppiRect value = (NppiRect)obj;
bool ret = true;
ret &= this.x == value.x;
ret &= this.width == value.width;
ret &= this.y == value.y;
ret &= this.height == value.height;
return ret;
}
/// <summary>
/// /// </summary>
/// <param name=""value""></param>
/// <returns></returns>
public bool Equals(NppiRect value)
{
bool ret = true;
ret &= this.x == value.x;
ret &= this.width == value.width;
ret &= this.y == value.y;
ret &= this.height == value.height;
return ret;
}
/// <summary>
/// /// </summary>
/// <returns></returns>
public override int GetHashCode()
{
return x.GetHashCode() ^ width.GetHashCode() ^ y.GetHashCode() ^ height.GetHashCode();
}
/// <summary>
/// /// </summary>
/// <returns></returns>
public override string ToString()
{
return string.Format(CultureInfo.CurrentCulture, ""({0} + {1}; {2} + {3})"", this.x, this.width, this.y, this.height);
}
#endregion
#region Usefull methods
/// <summary>
/// Determines if the specified point is contained within this Rectangle structure.
/// </summary>
/// <param name=""point""></param>
/// <returns></returns>
public bool Contains(NppiPoint point)
{ return (point.x >= Left) && (point.x <= Right) && (point.y >= Top) && (point.y <= Bottom);
}
/// <summary>
/// Determines if the specified point is contained within this Rectangle structure.
/// </summary>
/// <param name=""px""></param>
/// <param name=""py""></param>
/// <returns></returns>
public bool Contains(int px, int py)
{
return (px >= Left) && (px <= Right) && (py >= Top) && (py <= Bottom);
}
/// <summary>
/// Determines if the rectangular region represented by rect is entirely contained within this Rectangle structure.
/// </summary>
/// <param name=""rect""></param>
/// <returns></returns>
public bool Contains(NppiRect rect)
{
return Contains(rect.Location) && Contains(rect.Location + rect.Size);
}
/// <summary>
/// Enlarges this Rectangle by the specified amount.
/// </summary>
/// <param name=""val""></param>
public void Inflate(int val)
{
x -= val;
y -= val;
width += 2 * val;
height += 2 * val;
}
/// <summary>
/// Reduces this Rectangle by the specified amount.
/// </summary>
/// <param name=""val""></param>
public void Deflate(int val)
{
x += val;
y += val;
width -= 2 * val;
height -= 2 * val;
}
/// <summary>
/// Enlarges this Rectangle by the specified amount.
/// </summary>
/// <param name=""valX""></param>
/// <param name=""valY""></param>
public void Inflate(int valX, int valY)
{
x -= valX;
y -= valY;
width += 2 * valX;
height += 2 * valY;
}
/// <summary>
/// Reduces this Rectangle by the specified amount.
/// </summary>
/// <param name=""valX""></param>
/// <param name=""valY""></param>
public void Deflate(int valX, int valY)
{
x += valX;
y += valY;
width -= 2 * valX;
height -= 2 * valY;
}
/// <summary>
/// Enlarges this Rectangle by the specified amount.
/// </summary>
/// <param name=""val""></param>
public void Inflate(NppiSize val)
{
Inflate(val.width, val.height);
}
/// <summary>
/// Reduces this Rectangle by the specified amount.
/// </summary>
/// <param name=""val""></param>
public void Deflate(NppiSize val)
{
Deflate(val.width, val.height);
}
/// <summary>
/// Replaces this Rectangle with the intersection of itself and the specified Rectangle.
/// </summary>
/// <param name=""rect""></param>
public void Intersect(NppiRect rect)
{
int iX = Left;
if (iX < rect.Left)
{
iX = rect.Left;
}
int iY = Top;
if (iY < rect.Top)
{
iY = rect.Top;
}
int iX2 = Right;
if (iX2 > rect.Right)
{
iX2 = rect.Right;
}
int iY2 = Bottom;
if (iY2 > rect.Bottom)
{
iY2 = rect.Bottom;
}
int iWidth = iX2 - iX + 1;
int iHeight = iY2 - iY + 1;
if (iWidth <= 0 || iHeight <= 0)
{
iX = 0;
iY = 0;
iWidth = 0;
iHeight = 0;
}
x = iX;
y = iY;
width = iWidth;
height = iHeight;
}
/// <summary>
/// Returns a third Rectangle structure that represents the intersection of two other Rectangle structures.If there is no intersection, an empty Rectangle is returned. /// </summary>
/// <param name=""rectA""></param>
/// <param name=""rectB""></param>
/// <returns></returns>
public static NppiRect Intersect(NppiRect rectA, NppiRect rectB)
{
int iX = rectA.Left;
if (iX < rectB.Left)
{
iX = rectB.Left;
}
int iY = rectA.Top;
if (iY < rectB.Top)
{
iY = rectB.Top;
}
int iX2 = rectA.Right;
if (iX2 > rectB.Right)
{
iX2 = rectB.Right;
}
int iY2 = rectA.Bottom;
if (iY2 > rectB.Bottom)
{
iY2 = rectB.Bottom;
}
int iWidth = iX2 - iX + 1;
int iHeight = iY2 - iY + 1;
if (iWidth <= 0 || iHeight <= 0)
{
iX = 0;
iY = 0;
iWidth = 0;
iHeight = 0;
}
return new NppiRect(iX, iY, iWidth, iHeight);
}
/// <summary>
/// Determines if this rectangle intersects with rect.
/// </summary>
/// <param name=""rect""></param>
/// <returns></returns>
public bool IntersectsWith(NppiRect rect)
{
int iX = Left;
if (iX < rect.Left)
{
iX = rect.Left;
}
int iY = Top;
if (iY < rect.Top)
{
iY = rect.Top;
}
int iX2 = Right;
if (iX2 > rect.Right)
{
iX2 = rect.Right;
}
int iY2 = Bottom;
if (iY2 > rect.Bottom)
{
iY2 = rect.Bottom;
}
int iWidth = iX2 - iX + 1;
int iHeight = iY2 - iY + 1;
if (iWidth <= 0 || iHeight <= 0)
{
return false;
}
return true;
}
#endregion
#region New in Cuda 9.0
/// <summary>
/// Helper function that can be used when tiling a destination image with a source image using multiple Resize calls.
/// oSrcRectROI and oDstRectROI widths and heights should remain unmodified even if they will overlap source and destination
/// image sizes.oDstRectROI offsets should be set to the destination offset of the new tile.
/// Resize function processing will stop when source or destination image sizes are reached, any unavailable source image pixels
/// beyond source image size will be border replicated.There is no particular association assumed between source and destination image locations.
/// The values of oSrcRectROI.x and oSrcRectROI.y are ignored during this function call.
/// </summary>
/// <param name=""oDstRectROI"">Region of interest in the destination image (may overlap destination image size width and height)</param>
/// <returns>NppiPoint object that will contain the new source image ROI offset to be used in the nppiResize call to generate that tile.</returns>
public NppiPoint GetResizeTiledSourceOffset(NppiRect oDstRectROI)
{
NppiPoint pNewSrcRectOffset = new NppiPoint();
NppStatus status = NPPNativeMethods.NPPi.GeometricTransforms.nppiGetResizeTiledSourceOffset(this, oDstRectROI, ref pNewSrcRectOffset);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppiGetResizeTiledSourceOffset"", status));
NPPException.CheckNppStatus(status, this);
return pNewSrcRectOffset;
}
#endregion
}",2D Rectangle This struct contains position and size information of a rectangle in two space. The rectangle's position is usually signified by the coordinate of its upper-left corner.,1
650,"public struct NppiSize
{
/// <summary>
/// Rectangle width.
/// </summary>
public int width;
/// <summary>
/// Rectangle height.
/// </summary>
public int height;
/// <summary>
/// Non-default constructor
/// </summary>
/// <param name=""aWidth""></param>
/// <param name=""aHeight""></param>
public NppiSize(int aWidth, int aHeight)
{
width = aWidth;
height = aHeight;
}
#region Operator Methods
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Add(NppiSize src, NppiSize value)
{
NppiSize ret = new NppiSize(src.width + value.width, src.height + value.height);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Add(NppiSize src, int value)
{
NppiSize ret = new NppiSize(src.width + value, src.height + value);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Add(int src, NppiSize value)
{
NppiSize ret = new NppiSize(src + value.width, src + value.height);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Subtract(NppiSize src, NppiSize value)
{
NppiSize ret = new NppiSize(src.width - value.width, src.height - value.height);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Subtract(NppiSize src, int value)
{
NppiSize ret = new NppiSize(src.width - value, src.height - value);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Subtract(int src, NppiSize value)
{
NppiSize ret = new NppiSize(src - value.width, src - value.height);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Multiply(NppiSize src, NppiSize value)
{
NppiSize ret = new NppiSize(src.width * value.width, src.height * value.height);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Multiply(NppiSize src, int value)
{
NppiSize ret = new NppiSize(src.width * value, src.height * value);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Multiply(int src, NppiSize value)
{
NppiSize ret = new NppiSize(src * value.width, src * value.height);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Divide(NppiSize src, NppiSize value)
{
NppiSize ret = new NppiSize(src.width / value.width, src.height / value.height);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Divide(NppiSize src, int value)
{
NppiSize ret = new NppiSize(src.width / value, src.height / value);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize Divide(int src, NppiSize value)
{
NppiSize ret = new NppiSize(src / value.width, src / value.height);
return ret;
}
#endregion
#region operators
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator +(NppiSize src, NppiSize value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator +(NppiSize src, int value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator +(int src, NppiSize value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator -(NppiSize src, NppiSize value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator -(NppiSize src, int value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator -(int src, NppiSize value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator *(NppiSize src, NppiSize value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator *(NppiSize src, int value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator *(int src, NppiSize value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator /(NppiSize src, NppiSize value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator /(NppiSize src, int value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppiSize operator /(int src, NppiSize value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static bool operator ==(NppiSize src, NppiSize value)
{
if (object.ReferenceEquals(src, value)) return true;
return src.Equals(value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static bool operator !=(NppiSize src, NppiSize value)
{
return !(src == value);
}
#endregion
#region Override Methods
/// <summary>
/// /// </summary>
/// <param name=""obj""></param>
/// <returns></returns>
public override bool Equals(object obj)
{
if (obj == null) return false;
if (!(obj is NppiSize)) return false;
NppiSize value = (NppiSize)obj;
bool ret = true;
ret &= this.width == value.width;
ret &= this.height == value.height;
return ret;
}
/// <summary>
/// /// </summary>
/// <param name=""value""></param>
/// <returns></returns>
public bool Equals(NppiSize value)
{
bool ret = true;
ret &= this.width == value.width;
ret &= this.height == value.height;
return ret;
}
/// <summary>
/// /// </summary>
/// <returns></returns>
public override int GetHashCode()
{
return width.GetHashCode() ^ height.GetHashCode();
}
/// <summary>
/// /// </summary>
/// <returns></returns>
public override string ToString()
{
return string.Format(CultureInfo.CurrentCulture, ""({0}; {1})"", this.width, this.height);
}
#endregion
}",2D Size This struct typically represents the size of a a rectangular region in two space.,1
651,"public struct NppLibraryVersion
{
/// <summary>
/// Major version number
/// </summary>
public int major;
/// <summary>
/// Minor version number
/// </summary>
public int minor;
/// <summary>
/// Build number. This reflects the nightly build this release was made from.
/// </summary>
public int build;
/// <summary>
/// /// </summary>
public override string ToString()
{
return string.Format(CultureInfo.CurrentCulture, ""{0}.{1}.{2}"", this.major, this.minor, this.build);
}
}",Npp Library Version.,0
652,"public struct NppPointPolar
{
/// <summary>
/// rho-coordinate.
/// </summary>
public float rho;
/// <summary>
/// theta-coordinate.
/// </summary>
public float theta;
/// <summary>
/// Non-default constructor
/// </summary>
/// <param name=""aRho""></param>
/// <param name=""aTheta""></param>
public NppPointPolar(float aRho, float aTheta)
{
rho = aRho;
theta = aTheta;
}
#region Operator Methods
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Add(NppPointPolar src, NppPointPolar value)
{
NppPointPolar ret = new NppPointPolar(src.rho + value.rho, src.theta + value.theta);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Add(NppPointPolar src, float value)
{
NppPointPolar ret = new NppPointPolar(src.rho + value, src.theta + value);
return ret;
}
/// <summary>
/// per element Add
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Add(float src, NppPointPolar value)
{
NppPointPolar ret = new NppPointPolar(src + value.rho, src + value.theta);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Subtract(NppPointPolar src, NppPointPolar value)
{
NppPointPolar ret = new NppPointPolar(src.rho - value.rho, src.theta - value.theta);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Subtract(NppPointPolar src, float value)
{
NppPointPolar ret = new NppPointPolar(src.rho - value, src.theta - value);
return ret;
}
/// <summary>
/// per element Substract
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Subtract(float src, NppPointPolar value)
{
NppPointPolar ret = new NppPointPolar(src - value.rho, src - value.theta);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Multiply(NppPointPolar src, NppPointPolar value)
{
NppPointPolar ret = new NppPointPolar(src.rho * value.rho, src.theta * value.theta);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Multiply(NppPointPolar src, float value)
{
NppPointPolar ret = new NppPointPolar(src.rho * value, src.theta * value);
return ret;
}
/// <summary>
/// per element Multiply
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Multiply(float src, NppPointPolar value)
{
NppPointPolar ret = new NppPointPolar(src * value.rho, src * value.theta);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Divide(NppPointPolar src, NppPointPolar value)
{
NppPointPolar ret = new NppPointPolar(src.rho / value.rho, src.theta / value.theta);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Divide(NppPointPolar src, float value)
{
NppPointPolar ret = new NppPointPolar(src.rho / value, src.theta / value);
return ret;
}
/// <summary>
/// per element Divide
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar Divide(float src, NppPointPolar value)
{
NppPointPolar ret = new NppPointPolar(src / value.rho, src / value.theta);
return ret;
}
#endregion
#region operators
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator +(NppPointPolar src, NppPointPolar value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator +(NppPointPolar src, float value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator +(float src, NppPointPolar value)
{
return Add(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator -(NppPointPolar src, NppPointPolar value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator -(NppPointPolar src, float value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator -(float src, NppPointPolar value)
{
return Subtract(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator *(NppPointPolar src, NppPointPolar value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator *(NppPointPolar src, float value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator *(float src, NppPointPolar value)
{
return Multiply(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator /(NppPointPolar src, NppPointPolar value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator /(NppPointPolar src, float value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static NppPointPolar operator /(float src, NppPointPolar value)
{
return Divide(src, value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static bool operator ==(NppPointPolar src, NppPointPolar value)
{
if (object.ReferenceEquals(src, value)) return true;
return src.Equals(value);
}
/// <summary>
/// per element
/// </summary>
/// <param name=""src""></param>
/// <param name=""value""></param>
/// <returns></returns>
public static bool operator !=(NppPointPolar src, NppPointPolar value)
{
return !(src == value);
}
#endregion
#region Override Methods
/// <summary>
/// /// </summary>
/// <param name=""obj""></param>
/// <returns></returns>
public override bool Equals(object obj)
{
if (obj == null) return false;
if (!(obj is NppPointPolar)) return false;
NppPointPolar value = (NppPointPolar)obj;
bool ret = true;
ret &= this.rho == value.rho;
ret &= this.theta == value.theta;
return ret;
}
/// <summary>
/// /// </summary>
/// <param name=""value""></param>
/// <returns></returns>
public bool Equals(NppPointPolar value)
{
bool ret = true;
ret &= this.rho == value.rho;
ret &= this.theta == value.theta;
return ret;
}
/// <summary>
/// /// </summary>
/// <returns></returns>
public override int GetHashCode()
{
return rho.GetHashCode() ^ theta.GetHashCode();
}
/// <summary>
/// /// </summary>
/// <returns></returns>
public override string ToString()
{
return string.Format(CultureInfo.CurrentCulture, ""({0}; {1})"", this.rho, this.theta);
}
#endregion
}",2D Polar Point.,0
653,"public static int SumLnGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.SumLn.nppsSumLnGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumLnGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for 32f SumLn. This primitive provides the correct buffer size for nppsSumLn_32f.,1
654,"public static int SumLnGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.SumLn.nppsSumLnGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumLnGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for 64f SumLn. This primitive provides the correct buffer size for nppsSumLn_64f.,1
655,"public static int SumLnGetBufferSize64f(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.SumLn.nppsSumLnGetBufferSize_32f64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumLnGetBufferSize_32f64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for 32f64f SumLn. This primitive provides the correct buffer size for nppsSumLn_32f64f.,1
656,"public static int SumLnGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.SumLn.nppsSumLnGetBufferSize_16s32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumLnGetBufferSize_16s32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for 16s32f SumLn. This primitive provides the correct buffer size for nppsSumLn_16s32f.,1
657,"public static int IntegralGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.FilteringFunctions.nppsIntegralGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsIntegralGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",IntegralGetBufferSize,1
658,"public static void Integral(this CudaDeviceVariable<int> pSrc, CudaDeviceVariable<int> pDst, CudaDeviceVariable<byte> pDeviceBuffer)
{
NppStatus status = NPPNativeMethods.NPPs.FilteringFunctions.nppsIntegral_32s(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, pDeviceBuffer.DevicePointer);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsIntegral_32s"", status));
NPPException.CheckNppStatus(status, pSrc);
}",Integral,0
659,"public static void Convert(this CudaDeviceVariable<sbyte> pSrc, CudaDeviceVariable<short> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_8s16s(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_8s16s"", status));
NPPException.CheckNppStatus(status, pSrc);
}",8-bit signed byte signal to 16-bit signed short.,1
660,"public static void Convert(this CudaDeviceVariable<sbyte> pSrc, CudaDeviceVariable<float> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_8s32f(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_8s32f"", status));
NPPException.CheckNppStatus(status, pSrc);
}",8-bit signed byte signal to 32-bit float.,1
661,"public static void Convert(this CudaDeviceVariable<byte> pSrc, CudaDeviceVariable<float> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_8u32f(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_8u32f"", status));
NPPException.CheckNppStatus(status, pSrc);
}",8-bit unsigned byte signal to 32-bit float.,1
662,"public static void Convert(this CudaDeviceVariable<short> pSrc, CudaDeviceVariable<sbyte> pDst, NppRoundMode eRoundMode, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_16s8s_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, eRoundMode, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_16s8s_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",16-bit signed short signal to 8-bit signed byte.,1
663,"public static void Convert(this CudaDeviceVariable<short> pSrc, CudaDeviceVariable<int> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_16s32s(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_16s32s"", status));
NPPException.CheckNppStatus(status, pSrc);
}",16-bit signed short signal to 32-bit signed int.,1
664,"public static void Convert(this CudaDeviceVariable<short> pSrc, CudaDeviceVariable<float> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_16s32f(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_16s32f"", status));
NPPException.CheckNppStatus(status, pSrc);
}",16-bit signed short signal to 32-bit float.,1
665,"public static void Convert(this CudaDeviceVariable<ushort> pSrc, CudaDeviceVariable<float> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_16u32f(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_16u32f"", status));
NPPException.CheckNppStatus(status, pSrc);
}",16-bit unsigned short signal to 32-bit float.,1
666,"public static void Convert(this CudaDeviceVariable<int> pSrc, CudaDeviceVariable<short> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32s16s(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32s16s"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit signed int signal to 16-bit signed short.,1
667,"public static void Convert(this CudaDeviceVariable<int> pSrc, CudaDeviceVariable<float> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32s32f(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32s32f"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit signed int signal to 32-bit float.,1
668,"public static void Convert(this CudaDeviceVariable<int> pSrc, CudaDeviceVariable<double> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32s64f(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32s64f"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit signed int signal to 64-bit double.,1
669,"public static void Convert(this CudaDeviceVariable<float> pSrc, CudaDeviceVariable<double> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32f64f(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32f64f"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit float signal to 64-bit double.,1
670,"public static void Convert(this CudaDeviceVariable<long> pSrc, CudaDeviceVariable<double> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_64s64f(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_64s64f"", status));
NPPException.CheckNppStatus(status, pSrc);
}",64-bit signed long signal to 64-bit double.,1
671,"public static void Convert(this CudaDeviceVariable<double> pSrc, CudaDeviceVariable<float> pDst)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_64f32f(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_64f32f"", status));
NPPException.CheckNppStatus(status, pSrc);
}",64-bit double signal to 32-bit float.,1
672,"public static void Convert(this CudaDeviceVariable<short> pSrc, CudaDeviceVariable<float> pDst, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_16s32f_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_16s32f_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",16-bit signed short signal to 32-bit float.,1
673,"public static void Convert(this CudaDeviceVariable<short> pSrc, CudaDeviceVariable<double> pDst, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_16s64f_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_16s64f_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",16-bit signed short signal to 64-bit double.,1
674,"public static void Convert(this CudaDeviceVariable<int> pSrc, CudaDeviceVariable<short> pDst, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32s16s_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32s16s_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit signed int signal to 16-bit signed short.,1
675,"public static void Convert(this CudaDeviceVariable<int> pSrc, CudaDeviceVariable<float> pDst, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32s32f_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32s32f_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit signed int signal to 32-bit float.,1
676,"public static void Convert(this CudaDeviceVariable<int> pSrc, CudaDeviceVariable<double> pDst, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32s64f_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32s64f_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit signed int signal to 64-bit double.,1
677,"public static void Convert(this CudaDeviceVariable<float> pSrc, CudaDeviceVariable<sbyte> pDst, NppRoundMode eRoundMode, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32f8s_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, eRoundMode, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32f8s_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit float signal to 8-bit signed byte.,1
678,"public static void Convert(this CudaDeviceVariable<float> pSrc, CudaDeviceVariable<byte> pDst, NppRoundMode eRoundMode, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32f8u_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, eRoundMode, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32f8u_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit float signal to 8-bit unsigned byte.,1
679,"public static void Convert(this CudaDeviceVariable<float> pSrc, CudaDeviceVariable<short> pDst, NppRoundMode eRoundMode, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32f16s_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, eRoundMode, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32f16s_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit float signal to 16-bit signed short.,1
680,"public static void Convert(this CudaDeviceVariable<float> pSrc, CudaDeviceVariable<ushort> pDst, NppRoundMode eRoundMode, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32f16u_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, eRoundMode, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32f16u_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit float signal to 16-bit unsigned short.,1
681,"public static void Convert(this CudaDeviceVariable<float> pSrc, CudaDeviceVariable<int> pDst, NppRoundMode eRoundMode, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_32f32s_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, eRoundMode, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_32f32s_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",32-bit float signal to 32-bit signed int.,1
682,"public static void Convert(this CudaDeviceVariable<long> pSrc, CudaDeviceVariable<int> pDst, NppRoundMode eRoundMode, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_64s32s_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, eRoundMode, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_64s32s_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",64-bit signed long signal to 32-bit signed int.,1
683,"public static void Convert(this CudaDeviceVariable<double> pSrc, CudaDeviceVariable<short> pDst, NppRoundMode eRoundMode, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_64f16s_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, eRoundMode, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_64f16s_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",64-bit double signal to 16-bit signed short.,1
684,"public static void Convert(this CudaDeviceVariable<double> pSrc, CudaDeviceVariable<int> pDst, NppRoundMode eRoundMode, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_64f32s_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, eRoundMode, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_64f32s_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",64-bit double signal to 32-bit signed int.,1
685,"public static void Convert(this CudaDeviceVariable<double> pSrc, CudaDeviceVariable<long> pDst, NppRoundMode eRoundMode, int nScaleFactor)
{
NppStatus status = NPPNativeMethods.NPPs.Convert.nppsConvert_64f64s_Sfs(pSrc.DevicePointer, pDst.DevicePointer, pSrc.Size, eRoundMode, nScaleFactor);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsConvert_64f64s_Sfs"", status));
NPPException.CheckNppStatus(status, pSrc);
}",64-bit double signal to 64-bit signed long.,1
686,"public static int SumGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Sum.nppsSumGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsSum_32f.,1
687,"public static int SumGetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Sum.nppsSumGetBufferSize_32fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumGetBufferSize_32fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsSum_32fc.,1
688,"public static int SumGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Sum.nppsSumGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsSum_64f.,1
689,"public static int SumGetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Sum.nppsSumGetBufferSize_64fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumGetBufferSize_64fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsSum_64fc.,1
690,"public static int SumGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Sum.nppsSumGetBufferSize_16s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumGetBufferSize_16s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsSum_16s_Sfs.,1
691,"public static int SumGetBufferSize(this CudaDeviceVariable<Npp16sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Sum.nppsSumGetBufferSize_16sc_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumGetBufferSize_16sc_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsSum_16sc_Sfs.,1
692,"public static int SumGetBufferSize32sc(this CudaDeviceVariable<Npp16sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Sum.nppsSumGetBufferSize_16sc32sc_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumGetBufferSize_16sc32sc_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsSum_16sc32sc_Sfs.,1
693,"public static int SumGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Sum.nppsSumGetBufferSize_32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumGetBufferSize_32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsSum_32s_Sfs.,1
694,"public static int SumGetBufferSize32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Sum.nppsSumGetBufferSize_16s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsSumGetBufferSize_16s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsSum_16s32s_Sfs.,1
695,"public static int MaxGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMax_16s.,1
696,"public static int MaxGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMax_32s.,1
697,"public static int MaxGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMax_32f.,1
698,"public static int MaxGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMax_64f.,1
699,"public static int MaxIndxGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxIndxGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxIndxGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMaxIndx_16s.,1
700,"public static int MaxIndxGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxIndxGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxIndxGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMaxIndx_32s.,1
701,"public static int MaxIndxGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxIndxGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxIndxGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMaxIndx_32f.,1
702,"public static int MaxIndxGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxIndxGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxIndxGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMaxIndx_64f.,1
703,"public static int MaxAbsGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxAbsGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxAbsGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMaxAbs_16s.,1
704,"public static int MaxAbsGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxAbsGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxAbsGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMaxAbs_32s.,1
705,"public static int MaxAbsIndxGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxAbsIndxGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxAbsIndxGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMaxAbsIndx_16s.,1
706,"public static int MaxAbsIndxGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Max.nppsMaxAbsIndxGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaxAbsIndxGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMaxAbsIndx_32s.,1
707,"public static int MinGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMin_16s.,1
708,"public static int MinGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMin_32s.,1
709,"public static int MinGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMin_32f.,1
710,"public static int MinGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMin_64f.,1
711,"public static int MinIndxGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinIndxGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinIndxGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMinIndx_16s.,1
712,"public static int MinIndxGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinIndxGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinIndxGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMinIndx_32s.,1
713,"public static int MinIndxGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinIndxGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinIndxGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMinIndx_32f.,1
714,"public static int MinIndxGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinIndxGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinIndxGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMinIndx_64f.,1
715,"public static int MinAbsGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinAbsGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinAbsGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMinAbs_16s.,1
716,"public static int MinAbsGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinAbsGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinAbsGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMinAbs_32s.,1
717,"public static int MinAbsIndxGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinAbsIndxGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinAbsIndxGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMinAbsIndx_16s.,1
718,"public static int MinAbsIndxGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Min.nppsMinAbsIndxGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinAbsIndxGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMinAbsIndx_32s.,1
719,"public static int MeanGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMean_32f.,1
720,"public static int MeanGetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanGetBufferSize_32fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanGetBufferSize_32fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMean_32fc.,1
721,"public static int MeanGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMean_64f.,1
722,"public static int MeanGetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanGetBufferSize_64fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanGetBufferSize_64fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMean_64fc.,1
723,"public static int MeanGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanGetBufferSize_16s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanGetBufferSize_16s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMean_16s_Sfs.,1
724,"public static int MeanGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanGetBufferSize_32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanGetBufferSize_32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMean_32s_Sfs.,1
725,"public static int MeanGetBufferSize(this CudaDeviceVariable<Npp16sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanGetBufferSize_16sc_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanGetBufferSize_16sc_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMean_16sc_Sfs.,1
726,"public static int StdDevGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsStdDevGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsStdDevGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsStdDev_32f.,1
727,"public static int StdDevGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsStdDevGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsStdDevGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsStdDev_64f.,1
728,"public static int StdDevGetBufferSize32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsStdDevGetBufferSize_16s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsStdDevGetBufferSize_16s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsStdDev_16s32s_Sfs.,1
729,"public static int StdDevGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsStdDevGetBufferSize_16s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsStdDevGetBufferSize_16s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsStdDev_16s_Sfs.,1
730,"public static int MeanStdDevGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanStdDevGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanStdDevGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMeanStdDev_32f.,1
731,"public static int MeanStdDevGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanStdDevGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanStdDevGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMeanStdDev_64f.,1
732,"public static int MeanStdDevGetBufferSize32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanStdDevGetBufferSize_16s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanStdDevGetBufferSize_16s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMeanStdDev_16s32s_Sfs.,1
733,"public static int MeanStdDevGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MeanStdDev.nppsMeanStdDevGetBufferSize_16s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMeanStdDevGetBufferSize_16s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device scratch buffer size (in bytes) for nppsMeanStdDev_16s_Sfs.,1
734,"public static int MinMaxGetBufferSize(this CudaDeviceVariable<byte> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxGetBufferSize_8u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxGetBufferSize_8u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMax_8u.,1
735,"public static int MinMaxGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMax_16s.,1
736,"public static int MinMaxGetBufferSize(this CudaDeviceVariable<ushort> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxGetBufferSize_16u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxGetBufferSize_16u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMax_16u.,1
737,"public static int MinMaxGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMax_32s.,1
738,"public static int MinMaxGetBufferSize(this CudaDeviceVariable<uint> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxGetBufferSize_32u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxGetBufferSize_32u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMax_32u.,1
739,"public static int MinMaxGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMax_32f.,1
740,"public static int MinMaxGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMax_64f.,1
741,"public static int MinMaxIndxGetBufferSize(this CudaDeviceVariable<byte> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxIndxGetBufferSize_8u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxIndxGetBufferSize_8u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMaxIndx_8u.,1
742,"public static int MinMaxIndxGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxIndxGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxIndxGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMaxIndx_16s.,1
743,"public static int MinMaxIndxGetBufferSize(this CudaDeviceVariable<ushort> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxIndxGetBufferSize_16u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxIndxGetBufferSize_16u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMaxIndx_16u.,1
744,"public static int MinMaxIndxGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxIndxGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxIndxGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMaxIndx_32s.,1
745,"public static int MinMaxIndxGetBufferSize(this CudaDeviceVariable<uint> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxIndxGetBufferSize_32u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxIndxGetBufferSize_32u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMaxIndx_32u.,1
746,"public static int MinMaxIndxGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxIndxGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxIndxGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMaxIndx_32f.,1
747,"public static int MinMaxIndxGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MinMaxIndex.nppsMinMaxIndxGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMinMaxIndxGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMinMaxIndx_64f.,1
748,"public static int NormInfGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormInfGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormInfGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_Inf_32f.,1
749,"public static int NormInfGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormInfGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormInfGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_Inf_64f.,1
750,"public static int NormInfGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormInfGetBufferSize_16s32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormInfGetBufferSize_16s32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_Inf_16s32f.,1
751,"public static int NormInfGetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormInfGetBufferSize_32fc32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormInfGetBufferSize_32fc32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_Inf_32fc32f.,1
752,"public static int NormInfGetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormInfGetBufferSize_64fc64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormInfGetBufferSize_64fc64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_Inf_64fc64f.,1
753,"public static int NormInfGetBufferSize32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormInfGetBufferSize_16s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormInfGetBufferSize_16s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_Inf_16s32s_Sfs.,1
754,"public static int NormL1GetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL1GetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL1GetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L1_32f.,1
755,"public static int NormL1GetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL1GetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL1GetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L1_64f.,1
756,"public static int NormL1GetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL1GetBufferSize_16s32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL1GetBufferSize_16s32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L1_16s32f.,1
757,"public static int NormL1GetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL1GetBufferSize_32fc64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL1GetBufferSize_32fc64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L1_32fc64f.,1
758,"public static int NormL1GetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL1GetBufferSize_64fc64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL1GetBufferSize_64fc64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L1_64fc64f.,1
759,"public static int NormL1GetBufferSize32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL1GetBufferSize_16s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL1GetBufferSize_16s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L1_16s32s_Sfs.,1
760,"public static int NormL1GetBufferSize64s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL1GetBufferSize_16s64s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL1GetBufferSize_16s64s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L1_16s64s_Sfs.,1
761,"public static int NormL2GetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL2GetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL2GetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L2_32f.,1
762,"public static int NormL2GetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL2GetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL2GetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L2_64f.,1
763,"public static int NormL2GetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL2GetBufferSize_16s32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL2GetBufferSize_16s32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L2_16s32f.,1
764,"public static int NormL2GetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL2GetBufferSize_32fc64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL2GetBufferSize_32fc64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L2_32fc64f.,1
765,"public static int NormL2GetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL2GetBufferSize_64fc64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL2GetBufferSize_64fc64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L2_64fc64f.,1
766,"public static int NormL2GetBufferSize32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL2GetBufferSize_16s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL2GetBufferSize_16s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L2_16s32s_Sfs.,1
767,"public static int NormL2SqrGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.Norm.nppsNormL2SqrGetBufferSize_16s64s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormL2SqrGetBufferSize_16s64s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNorm_L2Sqr_16s64s_Sfs.,1
768,"public static int NormDiffInfGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffInfGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffInfGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_Inf_32f.,1
769,"public static int NormDiffInfGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffInfGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffInfGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_Inf_64f.,1
770,"public static int NormDiffInfGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffInfGetBufferSize_16s32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffInfGetBufferSize_16s32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_Inf_16s32f.,1
771,"public static int NormDiffInfGetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffInfGetBufferSize_32fc32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffInfGetBufferSize_32fc32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_Inf_32fc32f.,1
772,"public static int NormDiffInfGetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffInfGetBufferSize_64fc64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffInfGetBufferSize_64fc64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_Inf_64fc64f.,1
773,"public static int NormDiffInfGetBufferSize32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffInfGetBufferSize_16s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffInfGetBufferSize_16s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_Inf_16s32s_Sfs.,1
774,"public static int NormDiffL1GetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL1GetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL1GetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L1_32f.,1
775,"public static int NormDiffL1GetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL1GetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL1GetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L1_64f.,1
776,"public static int NormDiffL1GetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL1GetBufferSize_16s32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL1GetBufferSize_16s32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L1_16s32f.,1
777,"public static int NormDiffL1GetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL1GetBufferSize_32fc64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL1GetBufferSize_32fc64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L1_32fc64f.,1
778,"public static int NormDiffL1GetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL1GetBufferSize_64fc64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL1GetBufferSize_64fc64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L1_64fc64f.,1
779,"public static int NormDiffL1GetBufferSize32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL1GetBufferSize_16s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL1GetBufferSize_16s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L1_16s32s_Sfs.,1
780,"public static int NormDiffL1GetBufferSize64s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL1GetBufferSize_16s64s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL1GetBufferSize_16s64s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L1_16s64s_Sfs.,1
781,"public static int NormDiffL2GetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL2GetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL2GetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L2_32f.,1
782,"public static int NormDiffL2GetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL2GetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL2GetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L2_64f.,1
783,"public static int NormDiffL2GetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL2GetBufferSize_16s32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL2GetBufferSize_16s32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L2_16s32f.,1
784,"public static int NormDiffL2GetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL2GetBufferSize_32fc64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL2GetBufferSize_32fc64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L2_32fc64f.,1
785,"public static int NormDiffL2GetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL2GetBufferSize_64fc64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL2GetBufferSize_64fc64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L2_64fc64f.,1
786,"public static int NormDiffL2GetBufferSize32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL2GetBufferSize_16s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL2GetBufferSize_16s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L2_16s32s_Sfs.,1
787,"public static int NormDiffL2SqrGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.NormDiff.nppsNormDiffL2SqrGetBufferSize_16s64s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsNormDiffL2SqrGetBufferSize_16s64s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsNormDiff_L2Sqr_16s64s_Sfs.,1
788,"public static int DotProdGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_32f.,1
789,"public static int DotProdGetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_32fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_32fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_32fc.,1
790,"public static int DotProdGetBufferSize32fc(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_32f32fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_32f32fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_32f32fc.,1
791,"public static int DotProdGetBufferSize64f(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_32f64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_32f64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_32f64f.,1
792,"public static int DotProdGetBufferSize64fc(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_32fc64fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_32fc64fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_32fc64fc.,1
793,"public static int DotProdGetBufferSize64fc(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_32f32fc64fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_32f32fc64fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_32f32fc64fc.,1
794,"public static int DotProdGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_64f.,1
795,"public static int DotProdGetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_64fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_64fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_64fc.,1
796,"public static int DotProdGetBufferSize64fc(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_64f64fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_64f64fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_64f64fc.,1
797,"public static int DotProdGetBufferSize64s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16s64s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16s64s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16s64s.,1
798,"public static int DotProdGetBufferSize64sc(this CudaDeviceVariable<Npp16sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16sc64sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16sc64sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16sc64sc.,1
799,"public static int DotProdGetBufferSize16sc64sc(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16s16sc64sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16s16sc64sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16s16sc64sc.,1
800,"public static int DotProdGetBufferSize32f(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16s32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16s32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16s32f.,1
801,"public static int DotProdGetBufferSize32fc(this CudaDeviceVariable<Npp16sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16sc32fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16sc32fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16sc32fc.,1
802,"public static int DotProdGetBufferSize32fc(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16s16sc32fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16s16sc32fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16s16sc32fc.,1
803,"public static int DotProdGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16s_Sfs.,1
804,"public static int DotProdGetBufferSize(this CudaDeviceVariable<Npp16sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16sc_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16sc_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16sc_Sfs.,1
805,"public static int DotProdGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_32s_Sfs.,1
806,"public static int DotProdGetBufferSize(this CudaDeviceVariable<Npp32sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_32sc_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_32sc_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_32sc_Sfs.,1
807,"public static int DotProdGetBufferSize32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16s32s_Sfs.,1
808,"public static int DotProdGetBufferSize32sc(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16s16sc32sc_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16s16sc32sc_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16s16sc32sc_Sfs.,1
809,"public static int DotProdGetBufferSize32s32s(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16s32s32s_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16s32s32s_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16s32s32s_Sfs.,1
810,"public static int DotProdGetBufferSize16sc(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16s16sc_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16s16sc_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16s16sc_Sfs.,1
811,"public static int DotProdGetBufferSize32sc(this CudaDeviceVariable<Npp16sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_16sc32sc_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_16sc32sc_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_16sc32sc_Sfs.,1
812,"public static int DotProdGetBufferSize32sc(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.DotProduct.nppsDotProdGetBufferSize_32s32sc_Sfs(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsDotProdGetBufferSize_32s32sc_Sfs"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsDotProd_32s32sc_Sfs.,1
813,"public static int CountInRangeGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.CountInRange.nppsCountInRangeGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsCountInRangeGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsCountInRange_32s.,1
814,"public static int ZeroCrossingGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.ZeroCrossing.nppsZeroCrossingGetBufferSize_16s32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsZeroCrossingGetBufferSize_16s32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsZeroCrossing_16s32f.,1
815,"public static int ZeroCrossingGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.ZeroCrossing.nppsZeroCrossingGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsZeroCrossingGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsZeroCrossing_32f.,1
816,"public static void MaximumError(this CudaDeviceVariable<byte> pSrc1, CudaDeviceVariable<byte> pSrc2, CudaDeviceVariable<double> pDst, CudaDeviceVariable<byte> pDeviceBuffer)
{
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumError_8u(pSrc1.DevicePointer, pSrc2.DevicePointer, pSrc1.Size, pDst.DevicePointer, pDeviceBuffer.DevicePointer);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumError_8u"", status));
NPPException.CheckNppStatus(status, pSrc1);
}",8-bit unsigned char maximum method.,1
817,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<byte> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_8u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_8u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_8u.,1
818,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<sbyte> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_8s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_8s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_8s.,1
819,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<ushort> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_16u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_16u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_16u.,1
820,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_16s.,1
821,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<Npp16sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_16sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_16sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_16sc.,1
822,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<uint> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_32u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_32u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_32u.,1
823,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_32s.,1
824,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<Npp32sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_32sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_32sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_32sc.,1
825,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<long> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_64s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_64s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_64s.,1
826,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<Npp64sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_64sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_64sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_64sc.,1
827,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_32f.,1
828,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_32fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_32fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_32fc.,1
829,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_64f.,1
830,"public static int MaximumErrorGetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumError.nppsMaximumErrorGetBufferSize_64fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumErrorGetBufferSize_64fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumError_64fc.,1
831,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<byte> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_8u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_8u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_8u.,1
832,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<sbyte> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_8s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_8s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_8s.,1
833,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<ushort> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_16u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_16u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_16u.,1
834,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_16s.,1
835,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<Npp16sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_16sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_16sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_16sc.,1
836,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<uint> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_32u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_32u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_32u.,1
837,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_32s.,1
838,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<Npp32sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_32sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_32sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_32sc.,1
839,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<long> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_64s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_64s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_64s.,1
840,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<Npp64sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_64sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_64sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_64sc.,1
841,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_32f.,1
842,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_32fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_32fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_32fc.,1
843,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_64f.,1
844,"public static int AverageErrorGetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageError.nppsAverageErrorGetBufferSize_64fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageErrorGetBufferSize_64fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageError_64fc.,1
845,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<byte> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_8u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_8u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_8u.,1
846,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<sbyte> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_8s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_8s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_8s.,1
847,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<ushort> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_16u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_16u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_16u.,1
848,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<short> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_16s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_16s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_16s.,1
849,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<Npp16sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_16sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_16sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_16sc.,1
850,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<uint> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_32u(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_32u"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_32u.,1
851,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<int> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_32s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_32s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_32s.,1
852,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<Npp32sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_32sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_32sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_32sc.,1
853,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<long> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_64s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_64s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_64s.,1
854,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<Npp64sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_64sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_64sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_64sc.,1
855,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_32f.,1
856,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_32fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_32fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_32fc.,1
857,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_64f.,1
858,"public static int MaximumRelativeErrorGetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.MaximumRelativeError.nppsMaximumRelativeErrorGetBufferSize_64fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsMaximumRelativeErrorGetBufferSize_64fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsMaximumRelativeError_64fc.,1
859,"public static int AverageRelativeErrorGetBufferSize(this CudaDeviceVariable<Npp32sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageRelativeError.nppsAverageRelativeErrorGetBufferSize_32sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageRelativeErrorGetBufferSize_32sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageRelativeError_32sc.,1
860,"public static int AverageRelativeErrorGetBufferSize(this CudaDeviceVariable<long> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageRelativeError.nppsAverageRelativeErrorGetBufferSize_64s(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageRelativeErrorGetBufferSize_64s"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageRelativeError_64s.,1
861,"public static int AverageRelativeErrorGetBufferSize(this CudaDeviceVariable<Npp64sc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageRelativeError.nppsAverageRelativeErrorGetBufferSize_64sc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageRelativeErrorGetBufferSize_64sc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageRelativeError_64sc.,1
862,"public static int AverageRelativeErrorGetBufferSize(this CudaDeviceVariable<float> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageRelativeError.nppsAverageRelativeErrorGetBufferSize_32f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageRelativeErrorGetBufferSize_32f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageRelativeError_32f.,1
863,"public static int AverageRelativeErrorGetBufferSize(this CudaDeviceVariable<Npp32fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageRelativeError.nppsAverageRelativeErrorGetBufferSize_32fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageRelativeErrorGetBufferSize_32fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageRelativeError_32fc.,1
864,"public static int AverageRelativeErrorGetBufferSize(this CudaDeviceVariable<double> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageRelativeError.nppsAverageRelativeErrorGetBufferSize_64f(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageRelativeErrorGetBufferSize_64f"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageRelativeError_64f.,1
865,"public static int AverageRelativeErrorGetBufferSize(this CudaDeviceVariable<Npp64fc> devVar)
{
int size = 0;
NppStatus status = NPPNativeMethods.NPPs.AverageRelativeError.nppsAverageRelativeErrorGetBufferSize_64fc(devVar.Size, ref size);
Debug.WriteLine(String.Format(""{0:G}, {1}: {2}"", DateTime.Now, ""nppsAverageRelativeErrorGetBufferSize_64fc"", status));
NPPException.CheckNppStatus(status, devVar);
return size;
}",Device-buffer size (in bytes) for nppsAverageRelativeError_64fc.,1
866,"public struct nvgraphContext
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding nvGRAPH library context,1
867,"public struct nvgraphGraphDescr
{
/// <summary>
/// /// </summary>
public IntPtr Handle;
}",Opaque structure holding the graph descriptor,1
868,"public struct nvmlAccountingStats {
/// <summary>
/// Percent of time over the process's lifetime during which one or more kernels was executing on the GPU. /// Utilization stats just like returned by \ref nvmlDeviceGetUtilizationRates but for the life time of a /// process (not just the last sample period). Set to NVML_VALUE_NOT_AVAILABLE if nvmlDeviceGetUtilizationRates is not supported
/// </summary>
public uint gpuUtilization; /// <summary>
/// Percent of time over the process's lifetime during which global (device) memory was being read or written. Set to NVML_VALUE_NOT_AVAILABLE if nvmlDeviceGetUtilizationRates is not supported
/// </summary>
public uint memoryUtilization; /// <summary>
/// Maximum total memory in bytes that was ever allocated by the process. Set to NVML_VALUE_NOT_AVAILABLE if nvmlProcessInfo->usedGpuMemory is not supported
/// </summary>
public ulong maxMemoryUsage; /// <summary>
/// Amount of time in ms during which the compute context was active. The time is reported as 0 if the process is not terminated
/// </summary>
public ulong time; /// <summary>
/// CPU Timestamp in usec representing start time for the process
/// </summary>
public ulong startTime; /// <summary>
/// Flag to represent if the process is running (1 for running, 0 for terminated)
/// </summary>
public uint isRunning; /// <summary>
/// Reserved for future use
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.U4)]
public uint[] reserved; }",Describes accounting statistics of a process.,1
869,"public struct nvmlBAR1Memory
{
/// <summary>
/// Total BAR1 Memory (in bytes)
/// </summary>
public ulong bar1Total; /// <summary>
/// Unallocated BAR1 Memory (in bytes)
/// </summary>
public ulong bar1Free; /// <summary>
/// Allocated Used Memory (in bytes)
/// </summary>
public ulong bar1Used; }",BAR1 Memory allocation Information for a device,1
870,"public struct nvmlBridgeChipHierarchy
{
/// <summary>
/// Number of Bridge Chips on the Board
/// </summary>
public byte bridgeCount; /// <summary>
/// Hierarchy of Bridge Chips on the board
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.U8)]
public nvmlBridgeChipInfo[] bridgeChipInfo; }","This structure stores the complete Hierarchy of the Bridge Chip within the board. The immediate bridge is stored at index 0 of bridgeInfoList, parent to immediate bridge is at index 1 and so forth.",1
871,"public struct nvmlBridgeChipInfo
{
/// <summary>
/// Type of Bridge Chip /// </summary>
public nvmlBridgeChipType type; /// <summary>
/// Firmware Version. 0=Version is unavailable
/// </summary>
public uint fwVersion; }",Information about the Bridge Chip Firmware,1
872,"public struct nvmlEventData
{
/// <summary>
/// Specific device where the event occurred
/// </summary>
public nvmlDevice device; /// <summary>
/// Information about what specific event occurred
/// </summary>
public ulong eventType; /// <summary>
/// Stores last XID error for the device in the event of nvmlEventTypeXidCriticalError, eventData is 0 for any other event. eventData is set as 999 for unknown xid error.
/// </summary>
public ulong eventData;
}",Information about occurred event,1
873,"public struct nvmlHwbcEntry {
public uint hwbcId;
[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
public string firmwareVersion;
}",Description of HWBC entry,1
874,"public struct nvmlLedState {
/// <summary>
/// If amber, a text description of the cause
/// </summary>
[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
public string cause; /// <summary>
/// GREEN or AMBER
/// </summary>
public nvmlLedColor color; }",LED states for an S-class unit.,1
875,"public struct nvmlMemory {
/// <summary>
/// Total installed FB memory (in bytes)
/// </summary>
public ulong total; /// <summary>
/// Unallocated FB memory (in bytes)
/// </summary>
public ulong free; /// <summary>
/// Allocated FB memory (in bytes). Note that the driver/GPU always sets aside a small amount of memory for bookkeeping
/// </summary>
public ulong used; }",Memory allocation information for a device.,1
876,"public static nvmlReturn nvmlSystemGetDriverVersion(out string name)
{
byte[] temp = new byte[NVMLConstants.SystemDriverVersionBufferSize];
nvmlReturn ret = nvmlSystemGetDriverVersionInternal(temp, NVMLConstants.SystemDriverVersionBufferSize);
name = string.Empty;
if (ret == nvmlReturn.Success)
{
name = ASCIIEncoding.ASCII.GetString(temp).Replace(""\0"", """");
}
return ret;
}",For all products. The version identifier is an alphanumeric string. It will not exceed 80 characters in length (including the NULL terminator). See nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE.,1
877,"public static nvmlReturn nvmlSystemGetNVMLVersion(out string name)
{
byte[] temp = new byte[NVMLConstants.SystemNVMLVersionBufferSize];
nvmlReturn ret = nvmlSystemGetNVMLVersionInternal(temp, NVMLConstants.SystemNVMLVersionBufferSize);
name = string.Empty;
if (ret == nvmlReturn.Success)
{
name = ASCIIEncoding.ASCII.GetString(temp).Replace(""\0"", """");
}
return ret;
}",For all products. The version identifier is an alphanumeric string. It will not exceed 80 characters in length (including the NULL terminator). See nvmlConstants::NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE.,1
878,"public static nvmlReturn nvmlDeviceGetName(nvmlDevice device, out string name)
{
byte[] temp = new byte[NVMLConstants.DeviceNameBufferSize];
nvmlReturn ret = nvmlDeviceGetNameInternal(device, temp, NVMLConstants.DeviceNameBufferSize);
name = string.Empty;
if (ret == nvmlReturn.Success)
{
name = ASCIIEncoding.ASCII.GetString(temp).Replace(""\0"", """");
}
return ret;
}","For all products. The name is an alphanumeric string that denotes a particular product, e.g. Tesla C2070. It will not exceed 64 characters in length (including the NULL terminator). See nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.",1
879,"public struct nvmlNvLinkUtilizationControl
{
public nvmlNvLinkUtilizationCountUnits units;
public nvmlNvLinkUtilizationCountPktTypes pktfilter;
}",struct to define the NVLINK counter controls,1
880,"public struct nvmlPciInfo {
/// <summary>
/// The tuple domain:bus:device.function PCI identifier (&amp; NULL terminator)
/// </summary>
[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
public string busId; /// <summary>
/// The PCI domain on which the device's bus resides, 0 to 0xffff /// </summary>
public uint domain; /// <summary>
/// The bus on which the device resides, 0 to 0xff
/// </summary>
public uint bus; /// <summary>
/// The device's id on the bus, 0 to 31
/// </summary>
public uint device; /// <summary>
/// The combined 16-bit device id and 16-bit vendor id
/// </summary>
public uint pciDeviceId; /// <summary>
/// The 32-bit Sub System Device ID. Added in NVML 2.285 API
/// </summary>
public uint pciSubSystemId; /// <summary>
/// NVIDIA reserved for internal use only
/// </summary>
public uint reserved0;
public uint reserved1;
public uint reserved2;
public uint reserved3;
}",PCI information about a GPU device.,1
881,"public struct nvmlProcessInfo
{
/// <summary>
/// Process ID
/// </summary>
public uint pid; /// <summary>
/// Amount of used GPU memory in bytes.
/// </summary>
public ulong usedGpuMemory; }",Information about running compute processes on the GPU,1
882,"public struct nvmlSample {
/// <summary>
/// CPU Timestamp in microseconds
/// </summary>
public ulong timeStamp; /// <summary>
/// Sample Value
/// </summary>
public nvmlValue sampleValue; }",Information for Sample,1
883,"public struct nvmlUnitFanInfo {
/// <summary>
/// Fan speed (RPM)
/// </summary>
public uint speed; /// <summary>
/// Flag that indicates whether fan is working properly
/// </summary>
public nvmlFanState state; }",Fan speed reading for a single fan in an S-class unit.,1
884,"public struct nvmlUnitFanSpeeds {
/// <summary>
/// Fan speed data for each fan
/// </summary>
[MarshalAs(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.U8)]
public nvmlUnitFanInfo[] fans; /// <summary>
/// Number of fans in unit
/// </summary>
public uint count; }",Fan speed readings for an entire S-class unit.,1
885,"public struct nvmlUnitInfo {
/// <summary>
/// Product name
/// </summary>
[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 96)]
public string name; /// <summary>
/// Product identifier
/// </summary>
[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 96)]
public string id; /// <summary>
/// Product serial number
/// </summary>
[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 96)]
public string serial; /// <summary>
/// Firmware version
/// </summary>
[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 96)]
public string firmwareVersion; }",Static S-class unit info.,1
886,"public struct nvmlUtilization {
/// <summary>
/// Percent of time over the past sample period during which one or more kernels was executing on the GPU
/// </summary>
public uint gpu; /// <summary>
/// Percent of time over the past sample period during which global (device) memory was being read or written
/// </summary>
public uint memory; }","Utilization information for a device. Each sample period may be between 1 second and 1/6 second, depending on the product being queried.",1
887,"public struct nvmlValue
{
/// <summary>
/// If the value is double
/// </summary>
[FieldOffset(0)]
public double dVal; /// <summary>
/// If the value is uint
/// </summary>
[FieldOffset(0)]
public uint uiVal; /// <summary>
/// If the value is unsigned long
/// </summary>
[FieldOffset(0)]
public uint ulVal; /// <summary>
/// If the value is ulong
/// </summary>
[FieldOffset(0)]
public ulong ullVal; }",Union to represent different types of Value,1
888,"public struct nvmlViolationTime
{
/// <summary>
/// referenceTime represents CPU timestamp in microseconds
/// </summary>
public ulong referenceTime; /// <summary>
/// violationTime in Nanoseconds
/// </summary>
public ulong violationTime; }",struct to hold perf policy violation status data,0
889,"public struct Occupancy
{
/// <summary>
/// minimum grid size needed to achieve the maximum occupancy
/// </summary>
public int minGridSize;
/// <summary>
/// maximum block size that can achieve the maximum occupancy
/// </summary>
public int blockSize;
}",Small struct to simplify occupancy calculations,1
890,"~OpTensorDescriptor()
{
Dispose(false);
}",For dispose,1
891,"~PersistentRNNPlan()
{
Dispose(false);
}",For dispose,1
892,"~PoissonDistribution()
{
Dispose(false);
}",For dispose,1
893,"~PoolingDescriptor()
{
Dispose(false);
}",For dispose,1
894,"~PrimaryContext()
{
Dispose(false);
}",For dispose,1
895,"static void Main()
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new Form1());
}",Der Haupteinstiegspunkt fr die Anwendung.,1
896,"static void Main()
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new Form1());
}",The main entry point for the application.,1
897,"static void Main()
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new Form1());
}",Der Haupteinstiegspunkt fr die Anwendung.,1
898,"static void Main()
{
Console.WriteLine(""["" + System.AppDomain.CurrentDomain.FriendlyName + ""] starting..."");
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new Form1());
}",Der Haupteinstiegspunkt fr die Anwendung.,1
899,"~ReduceTensorDescriptor()
{
Dispose(false);
}",For dispose,1
900,"~RNNDescriptor()
{
Dispose(false);
}",For dispose,1
901,"~SpatialTransformerDescriptor()
{
Dispose(false);
}",For dispose,1
902,"protected struct sSMtoCores
{
/// <summary>
/// 0xMm (hexidecimal notation), M = SM Major version, and m = SM minor version
/// </summary>
public int SM;
/// <summary/>
public int Cores;
/// <summary/>
public sSMtoCores(int sm, int cores)
{
SM = sm;
Cores = cores;
}
}",Defines for GPU Architecture types (using the SM version to determine the # of cores per SM,1
903,"~TensorDescriptor()
{
Dispose(false);
}",For dispose,1
904,"public struct Win32Handle
{
/// <summary>
/// Valid NT handle. Must be NULL if 'name' is non-NULL
/// </summary>
public IntPtr handle;
/// <summary>
/// Name of a valid memory object. Must be NULL if 'handle' is non-NULL.
/// </summary>
[MarshalAs(UnmanagedType.LPStr)]
string name;
}",Exactly one of 'handle' and 'name' must be non-NULL. If type is ::CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT then 'name' must be NULL.,1
905,"public enum CudaArray1DNumChannels { /// <summary>
/// One channel, e.g. float1, int1, float, int
/// </summary>
One = 1,
/// <summary>
/// Two channels, e.g. float2, int2
/// </summary>
Two = 2,
/// <summary>
/// Four channels, e.g. float4, int4
/// </summary>
Four = 4
}",Number of channels in array,1
906,"public enum CudaArray2DNumChannels { /// <summary>
/// One channel, e.g. float1, int1, float, int
/// </summary>
One = 1,
/// <summary>
/// Two channels, e.g. float2, int2
/// </summary>
Two = 2,
/// <summary>
/// Four channels, e.g. float4, int4
/// </summary>
Four = 4
}",Number of channels in array,1
907,"public enum CudaArray3DNumChannels {
/// <summary>
/// One channel, e.g. float1, int1, float, int
/// </summary>
One = 1,
/// <summary>
/// Two channels, e.g. float2, int2
/// </summary>
Two = 2,
/// <summary>
/// Four channels, e.g. float4, int4
/// </summary>
Four = 4
}",Number of channels in array,1
908,"public enum CudaMipmappedArrayNumChannels
{
/// <summary>
/// One channel, e.g. float1, int1, float, int
/// </summary>
One = 1,
/// <summary>
/// Two channels, e.g. float2, int2
/// </summary>
Two = 2,
/// <summary>
/// Four channels, e.g. float4, int4
/// </summary>
Four = 4
}",Number of channels in array,1
909,"public enum CUAddressMode
{
/// <summary>
/// Wrapping address mode
/// </summary>
Wrap = 0,
/// <summary>
/// Clamp to edge address mode
/// </summary>
Clamp = 1,
/// <summary>
/// Mirror address mode
/// </summary>
Mirror = 2,
/// <summary>
/// Border address mode
/// </summary>
Border = 3
}",Texture reference addressing modes,1
910,"public enum CUArrayFormat
{
/// <summary>
/// Unsigned 8-bit integers
/// </summary>
UnsignedInt8 = 0x01,
/// <summary>
/// Unsigned 16-bit integers
/// </summary>
UnsignedInt16 = 0x02,
/// <summary>
/// Unsigned 32-bit integers
/// </summary>
UnsignedInt32 = 0x03,
/// <summary>
/// Signed 8-bit integers
/// </summary>
SignedInt8 = 0x08,
/// <summary>
/// Signed 16-bit integers
/// </summary>
SignedInt16 = 0x09,
/// <summary>
/// Signed 32-bit integers
/// </summary>
SignedInt32 = 0x0a,
/// <summary>
/// 16-bit floating point
/// </summary>
Half = 0x10,
/// <summary>
/// 32-bit floating point
/// </summary>
Float = 0x20,
}",Array formats,1
911,"public enum CUComputeMode
{
/// <summary>
/// Default mode - Device is not restricted and can have multiple CUDA
/// contexts present at a single time.
/// </summary>
Default = 0,
///// <summary>
///// Compute-exclusive mode - Device can have only one CUDA context
///// present on it at a time.
///// </summary>
//Exclusive = 1,
/// <summary>
/// Compute-prohibited mode - Device is prohibited from creating
/// new CUDA contexts.
/// </summary>
Prohibited = 2,
/// <summary>
/// Compute-exclusive-process mode (Only one context used by a /// single process can be present on this device at a time)
/// </summary>
ExclusiveProcess = 2
}",Compute mode that device is currently in.,1
912,"public enum CUmemAdvise
{
/// <summary>
/// Data will mostly be read and only occassionally be written to
/// </summary>
SetReadMostly = 1,
/// <summary>
/// Undo the effect of ::CU_MEM_ADVISE_SET_READ_MOSTLY
/// </summary>
UnsetReadMostly = 2, /// <summary>
/// Set the preferred location for the data as the specified device
/// </summary>
SetPreferredLocation = 3, /// <summary>
/// Clear the preferred location for the data
/// </summary>
UnsetPreferredLocation = 4, /// <summary>
/// Data will be accessed by the specified device, so prevent page faults as much as possible
/// </summary>
SetAccessedBy = 5, /// <summary>
/// Let the Unified Memory subsystem decide on the page faulting policy for the specified device
/// </summary>
UnsetAccessedBy = 6
}",Memory advise values,1
913,"public enum CUDeviceAttribute
{
/// <summary>
/// Maximum number of threads per block
/// </summary>
MaxThreadsPerBlock = 1,
/// <summary>
/// Maximum block dimension X
/// </summary>
MaxBlockDimX = 2,
/// <summary>
/// Maximum block dimension Y
/// </summary>
MaxBlockDimY = 3,
/// <summary>
/// Maximum block dimension Z
/// </summary>
MaxBlockDimZ = 4,
/// <summary>
/// Maximum grid dimension X
/// </summary>
MaxGridDimX = 5,
/// <summary>
/// Maximum grid dimension Y
/// </summary>
MaxGridDimY = 6,
/// <summary>
/// Maximum grid dimension Z
/// </summary>
MaxGridDimZ = 7,
/// <summary>
/// Maximum amount of shared memory
/// available to a thread block in bytes; this amount is shared by all thread blocks simultaneously resident on a
/// multiprocessor
/// </summary>
MaxSharedMemoryPerBlock = 8,
/// <summary>
/// Deprecated, use MaxSharedMemoryPerBlock
/// </summary>
[Obsolete(""Use MaxSharedMemoryPerBlock"")]
SharedMemoryPerBlock = 8,
/// <summary>
/// Memory available on device for __constant__ variables in a CUDA C kernel in bytes
/// </summary>
TotalConstantMemory = 9,
/// <summary>
/// Warp size in threads
/// </summary>
WarpSize = 10,
/// <summary>
/// Maximum pitch in bytes allowed by the memory copy functions
/// that involve memory regions allocated through <see cref=""DriverAPINativeMethods.MemoryManagement.cuMemAllocPitch_v2""/>
/// </summary>
MaxPitch = 11,
/// <summary>
/// Deprecated, use MaxRegistersPerBlock
/// </summary>
[Obsolete(""Use MaxRegistersPerBlock"")]
RegistersPerBlock = 12,
/// <summary>
/// Maximum number of 32-bit registers available
/// to a thread block; this number is shared by all thread blocks simultaneously resident on a multiprocessor
/// </summary>
MaxRegistersPerBlock = 12,
/// <summary>
/// Typical clock frequency in kilohertz
/// </summary>
ClockRate = 13,
/// <summary>
/// Alignment requirement; texture base addresses
/// aligned to textureAlign bytes do not need an offset applied to texture fetches
/// </summary>
TextureAlignment = 14,
/// <summary>
/// 1 if the device can concurrently copy memory between host
/// and device while executing a kernel, or 0 if not
/// </summary>
GPUOverlap = 15,
/// <summary>
/// Number of multiprocessors on device
/// </summary>
MultiProcessorCount = 0x10,
/// <summary>
/// Specifies whether there is a run time limit on kernels. <para/>
/// 1 if there is a run time limit for kernels executed on the device, or 0 if not
/// </summary>
KernelExecTimeout = 0x11,
/// <summary>
/// Device is integrated with host memory. 1 if the device is integrated with the memory subsystem, or 0 if not
/// </summary>
Integrated = 0x12,
/// <summary>
/// Device can map host memory into CUDA address space. 1 if the device can map host memory into the
/// CUDA address space, or 0 if not
/// </summary>
CanMapHostMemory = 0x13,
/// <summary>
/// Compute mode (See <see cref=""CUComputeMode""/> for details)
/// </summary>
ComputeMode = 20,
/// <summary>
/// Maximum 1D texture width
/// </summary>
MaximumTexture1DWidth = 21, /// <summary>
/// Maximum 2D texture width
/// </summary>
MaximumTexture2DWidth = 22, /// <summary>
/// Maximum 2D texture height
/// </summary>
MaximumTexture2DHeight = 23,
/// <summary>
/// Maximum 3D texture width
/// </summary>
MaximumTexture3DWidth = 24, /// <summary>
/// Maximum 3D texture height
/// </summary>
MaximumTexture3DHeight = 25,
/// <summary>
/// Maximum 3D texture depth
/// </summary>
MaximumTexture3DDepth = 26, /// <summary>
/// Maximum texture array width
/// </summary>
MaximumTexture2DArray_Width = 27, /// <summary>
/// Maximum texture array height
/// </summary>
MaximumTexture2DArray_Height = 28,
/// <summary>
/// Maximum slices in a texture array
/// </summary>
MaximumTexture2DArray_NumSlices = 29, /// <summary>
/// Alignment requirement for surfaces
/// </summary>
SurfaceAllignment = 30, /// <summary>
/// Device can possibly execute multiple kernels concurrently. <para/>
/// 1 if the device supports executing multiple kernels
/// within the same context simultaneously, or 0 if not. It is not guaranteed that multiple kernels will be resident on
/// the device concurrently so this feature should not be relied upon for correctness.
/// </summary>
ConcurrentKernels = 31, /// <summary>
/// Device has ECC support enabled. 1 if error correction is enabled on the device, 0 if error correction
/// is disabled or not supported by the device.
/// </summary>
ECCEnabled = 32, /// <summary>
/// PCI bus ID of the device
/// </summary>
PCIBusID = 33, /// <summary>
/// PCI device ID of the device
/// </summary>
PCIDeviceID = 34,
/// <summary>
/// Device is using TCC driver model
/// </summary>
TCCDriver = 35,
/// <summary>
/// Peak memory clock frequency in kilohertz
/// </summary>
MemoryClockRate = 36,
/// <summary>
/// Global memory bus width in bits
/// </summary>
GlobalMemoryBusWidth = 37,
/// <summary>
/// Size of L2 cache in bytes
/// </summary>
L2CacheSize = 38,
/// <summary>
/// Maximum resident threads per multiprocessor
/// </summary>
MaxThreadsPerMultiProcessor = 39,
/// <summary>
/// Number of asynchronous engines
/// </summary>
AsyncEngineCount = 40,
/// <summary>
/// Device shares a unified address space with the host
/// </summary>
UnifiedAddressing = 41,
/// <summary>
/// Maximum 1D layered texture width
/// </summary>
MaximumTexture1DLayeredWidth = 42,
/// <summary>
/// Maximum layers in a 1D layered texture
/// </summary>
MaximumTexture1DLayeredLayers = 43,
/// <summary>
/// PCI domain ID of the device
/// </summary>
PCIDomainID = 50,
/// <summary>
/// Pitch alignment requirement for textures
/// </summary>
TexturePitchAlignment = 51,
/// <summary>
/// Maximum cubemap texture width/height
/// </summary>
MaximumTextureCubeMapWidth = 52, /// <summary>
/// Maximum cubemap layered texture width/height
/// </summary>
MaximumTextureCubeMapLayeredWidth = 53, /// <summary>
/// Maximum layers in a cubemap layered texture
/// </summary>
MaximumTextureCubeMapLayeredLayers = 54, /// <summary>
/// Maximum 1D surface width
/// </summary>
MaximumSurface1DWidth = 55, /// <summary>
/// Maximum 2D surface width
/// </summary>
MaximumSurface2DWidth = 56, /// <summary>
/// Maximum 2D surface height
/// </summary>
MaximumSurface2DHeight = 57, /// <summary>
/// Maximum 3D surface width
/// </summary>
MaximumSurface3DWidth = 58, /// <summary>
/// Maximum 3D surface height
/// </summary>
MaximumSurface3DHeight = 59, /// <summary>
/// Maximum 3D surface depth
/// </summary>
MaximumSurface3DDepth = 60, /// <summary>
/// Maximum 1D layered surface width
/// </summary>
MaximumSurface1DLayeredWidth = 61, /// <summary>
/// Maximum layers in a 1D layered surface
/// </summary>
MaximumSurface1DLayeredLayers = 62, /// <summary>
/// Maximum 2D layered surface width
/// </summary>
MaximumSurface2DLayeredWidth = 63, /// <summary>
/// Maximum 2D layered surface height
/// </summary>
MaximumSurface2DLayeredHeight = 64, /// <summary>
/// Maximum layers in a 2D layered surface
/// </summary>
MaximumSurface2DLayeredLayers = 65, /// <summary>
/// Maximum cubemap surface width
/// </summary>
MaximumSurfaceCubemapWidth = 66, /// <summary>
/// Maximum cubemap layered surface width
/// </summary>
MaximumSurfaceCubemapLayeredWidth = 67, /// <summary>
/// Maximum layers in a cubemap layered surface
/// </summary>
MaximumSurfaceCubemapLayeredLayers = 68, /// <summary>
/// Maximum 1D linear texture width
/// </summary>
MaximumTexture1DLinearWidth = 69, /// <summary>
/// Maximum 2D linear texture width
/// </summary>
MaximumTexture2DLinearWidth = 70, /// <summary>
/// Maximum 2D linear texture height
/// </summary>
MaximumTexture2DLinearHeight = 71, /// <summary>
/// Maximum 2D linear texture pitch in bytes
/// </summary>
MaximumTexture2DLinearPitch = 72,
/// <summary>
/// Maximum mipmapped 2D texture width
/// </summary>
MaximumTexture2DMipmappedWidth = 73,
/// <summary>
/// Maximum mipmapped 2D texture height
/// </summary>
MaximumTexture2DMipmappedHeight = 74,
/// <summary>
/// Major compute capability version number
/// </summary>
ComputeCapabilityMajor = 75, /// <summary>
/// Minor compute capability version number
/// </summary>
ComputeCapabilityMinor = 76, /// <summary>
/// Maximum mipmapped 1D texture width
/// </summary>
MaximumTexture1DMipmappedWidth = 77,
/// <summary>
/// Device supports stream priorities
/// </summary>
StreamPrioritiesSupported = 78,
/// <summary>
/// Device supports caching globals in L1
/// </summary>
GlobalL1CacheSupported = 79,
/// <summary>
/// Device supports caching locals in L1
/// </summary>
LocalL1CacheSupported = 80,
/// <summary>
/// Maximum shared memory available per multiprocessor in bytes
/// </summary>
MaxSharedMemoryPerMultiprocessor = 81,
/// <summary>
/// Maximum number of 32-bit registers available per multiprocessor
/// </summary>
MaxRegistersPerMultiprocessor = 82,
/// <summary>
/// Device can allocate managed memory on this system
/// </summary>
ManagedMemory = 83,
/// <summary>
/// Device is on a multi-GPU board
/// </summary>
MultiGpuBoard = 84,
/// <summary>
/// Unique id for a group of devices on the same multi-GPU board
/// </summary>
MultiGpuBoardGroupID = 85,
/// <summary>
/// Link between the device and the host supports native atomic operations (this is a placeholder attribute, and is not supported on any current hardware)
/// </summary>
HostNativeAtomicSupported = 86,
/// <summary>
/// Ratio of single precision performance (in floating-point operations per second) to double precision performance
/// </summary>
SingleToDoublePrecisionPerfRatio = 87,
/// <summary>
/// Device supports coherently accessing pageable memory without calling cudaHostRegister on it
/// </summary>
PageableMemoryAccess = 88,
/// <summary>
/// Device can coherently access managed memory concurrently with the CPU
/// </summary>
ConcurrentManagedAccess = 89,
/// <summary>
/// Device supports compute preemption.
/// </summary>
ComputePreemptionSupported = 90,
/// <summary>
/// Device can access host registered memory at the same virtual address as the CPU.
/// </summary>
CanUseHostPointerForRegisteredMem = 91,
/// <summary>
/// ::cuStreamBatchMemOp and related APIs are supported.
/// </summary>
CanUseStreamMemOps = 92,
/// <summary>
/// 64-bit operations are supported in ::cuStreamBatchMemOp and related APIs.
/// </summary>
CanUse64BitStreamMemOps = 93,
/// <summary>
/// ::CU_STREAM_WAIT_VALUE_NOR is supported.
/// </summary>
CanUseStreamWaitValueNOr = 94,
/// <summary>
/// Device supports launching cooperative kernels via ::cuLaunchCooperativeKernel
/// </summary>
CooperativeLaunch = 95,
/// <summary>
/// Device can participate in cooperative kernels launched via ::cuLaunchCooperativeKernelMultiDevice
/// </summary>
CooperativeMultiDeviceLaunch = 96,
/// <summary>
/// Maximum optin shared memory per block
/// </summary>
MaxSharedMemoryPerBlockOptin = 97,
/// <summary>
/// Both the ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the device. See \ref CUDA_MEMOP for additional details.
/// </summary>
CanFlushRemoteWrites = 98,
/// <summary>
/// Device supports host memory registration via ::cudaHostRegister.
/// </summary>
HostRegisterSupported = 99,
/// <summary>
/// Device accesses pageable memory via the host's page tables.
/// </summary>
PageableMemoryAccessUsesHostPageTables = 100, /// <summary>
/// The host can directly access managed memory on the device without migration.
/// </summary>
DirectManagedMemoryAccessFromHost = 101,
/// <summary>
/// Max elems...
/// </summary>
MAX
}",Device properties,1
914,"public enum CUFilterMode
{
/// <summary>
/// Point filter mode
/// </summary>
Point = 0,
/// <summary>
/// Linear filter mode
/// </summary>
Linear = 1
}",Texture reference filtering modes,1
915,"public enum CUFunctionAttribute
{
/// <summary>
/// <para>The number of threads beyond which a launch of the function would fail.</para>
/// <para>This number depends on both the function and the device on which the
/// function is currently loaded.</para>
/// </summary>
MaxThreadsPerBlock = 0,
/// <summary>
/// <para>The size in bytes of statically-allocated shared memory required by
/// this function. </para><para>This does not include dynamically-allocated shared
/// memory requested by the user at runtime.</para>
/// </summary>
SharedSizeBytes = 1,
/// <summary>
/// <para>The size in bytes of statically-allocated shared memory required by
/// this function. </para><para>This does not include dynamically-allocated shared
/// memory requested by the user at runtime.</para>
/// </summary>
ConstSizeBytes = 2,
/// <summary>
/// The size in bytes of thread local memory used by this function.
/// </summary>
LocalSizeBytes = 3,
/// <summary>
/// The number of registers used by each thread of this function.
/// </summary>
NumRegs = 4,
/// <summary>
/// The PTX virtual architecture version for which the function was
/// compiled. This value is the major PTX version * 10 + the minor PTX version, so a PTX version 1.3 function
/// would return the value 13. Note that this may return the undefined value of 0 for cubins compiled prior to CUDA
/// 3.0.
/// </summary>
PTXVersion = 5,
/// <summary>
/// The binary version for which the function was compiled. This
/// value is the major binary version * 10 + the minor binary version, so a binary version 1.3 function would return
/// the value 13. Note that this will return a value of 10 for legacy cubins that do not have a properly-encoded binary
/// architecture version.
/// </summary>
BinaryVersion = 6,
/// <summary>
/// The attribute to indicate whether the function has been compiled with /// user specified option ""-Xptxas --dlcm=ca"" set.
/// </summary>
CacheModeCA = 7,
/// <summary>
/// The maximum size in bytes of dynamically-allocated shared memory that can be used by
/// this function. If the user-specified dynamic shared memory size is larger than this
/// value, the launch will fail.
/// </summary>
MaxDynamicSharedSizeBytes = 8,
/// <summary>
/// On devices where the L1 cache and shared memory use the same hardware resources, /// this sets the shared memory carveout preference, in percent of the total resources. /// This is only a hint, and the driver can choose a different ratio if required to execute the function.
/// </summary>
PreferredSharedMemoryCarveout = 9,
/// <summary>
/// No descritption found...
/// </summary>
Max
}",Function properties,1
916,"public enum CUFuncCache
{
/// <summary>
/// No preference for shared memory or L1 (default)
/// </summary>
PreferNone = 0x00,
/// <summary>
/// Function prefers larger shared memory and smaller L1 cache.
/// </summary>
PreferShared = 0x01,
/// <summary>
/// Function prefers larger L1 cache and smaller shared memory.
/// </summary>
PreferL1 = 0x02,
/// <summary>
/// Function prefers equal sized L1 cache and shared memory.
/// </summary>
PreferEqual = 0x03
}",Function cache configurations,1
917,"public enum CUJITFallback
{
/// <summary>
/// Prefer to compile ptx if exact binary match not found
/// </summary>
PTX = 0,
/// <summary>
/// Prefer to fall back to compatible binary code if exact binary match not found
/// </summary>
Binary
}",Cubin matching fallback strategies,1
918,"public enum CUJITOption
{
/// <summary>
/// <para>Max number of registers that a thread may use.</para>
/// <para>Option type: unsigned int</para>
/// <para>Applies to: compiler only</para>
/// </summary>
MaxRegisters = 0,
/// <summary>
/// <para>IN: Specifies minimum number of threads per block to target compilation
/// for</para>
/// <para>OUT: Returns the number of threads the compiler actually targeted.
/// This restricts the resource utilization fo the compiler (e.g. max
/// registers) such that a block with the given number of threads should be
/// able to launch based on register limitations. Note, this option does not
/// currently take into account any other resource limitations, such as
/// shared memory utilization.</para>
/// <para>Option type: unsigned int</para>
/// <para>Applies to: compiler only</para>
/// </summary>
ThreadsPerBlock,
/// <summary>
/// Returns a float value in the option of the wall clock time, in
/// milliseconds, spent creating the cubin<para/>
/// Option type: float
/// <para>Applies to: compiler and linker</para>
/// </summary>
WallTime,
/// <summary>
/// <para>Pointer to a buffer in which to print any log messsages from PTXAS
/// that are informational in nature (the buffer size is specified via
/// option ::CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES)</para>
/// <para>Option type: char*</para>
/// <para>Applies to: compiler and linker</para>
/// </summary>
InfoLogBuffer,
/// <summary>
/// <para>IN: Log buffer size in bytes. Log messages will be capped at this size
/// (including null terminator)</para>
/// <para>OUT: Amount of log buffer filled with messages</para>
/// <para>Option type: unsigned int</para>
/// <para>Applies to: compiler and linker</para>
/// </summary>
InfoLogBufferSizeBytes,
/// <summary>
/// <para>Pointer to a buffer in which to print any log messages from PTXAS that
/// reflect errors (the buffer size is specified via option
/// ::CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES)</para>
/// <para>Option type: char*</para>
/// <para>Applies to: compiler and linker</para>
/// </summary>
ErrorLogBuffer,
/// <summary>
/// <para>IN: Log buffer size in bytes. Log messages will be capped at this size
/// (including null terminator)</para>
/// <para>OUT: Amount of log buffer filled with messages</para>
/// <para>Option type: unsigned int</para>
/// <para>Applies to: compiler and linker</para>
/// </summary>
ErrorLogBufferSizeBytes,
/// <summary>
/// <para>Level of optimizations to apply to generated code (0 - 4), with 4
/// being the default and highest level of optimizations.</para>
/// <para>Option type: unsigned int</para>
/// <para>Applies to: compiler only</para>
/// </summary>
OptimizationLevel,
/// <summary>
/// <para>No option value required. Determines the target based on the current
/// attached context (default)</para>
/// <para>Option type: No option value needed</para>
/// <para>Applies to: compiler and linker</para>
/// </summary>
TargetFromContext,
/// <summary>
/// <para>Target is chosen based on supplied ::CUjit_target_enum. This option cannot be
/// used with cuLink* APIs as the linker requires exact matches.</para>
/// <para>Option type: unsigned int for enumerated type ::CUjit_target_enum</para>
/// <para>Applies to: compiler and linker</para>
/// </summary>
Target,
/// <summary>
/// <para>Specifies choice of fallback strategy if matching cubin is not found.
/// Choice is based on supplied ::CUjit_fallback_enum.</para>
/// <para>Option type: unsigned int for enumerated type ::CUjit_fallback_enum</para>
/// <para>Applies to: compiler only</para>
/// </summary>
FallbackStrategy,
/// <summary>
/// Specifies whether to create debug information in output (-g) <para/> (0: false, default)
/// <para>Option type: int</para>
/// <para>Applies to: compiler and linker</para>
/// </summary>
GenerateDebugInfo,
/// <summary>
/// Generate verbose log messages <para/> (0: false, default)
/// <para>Option type: int</para>
/// <para>Applies to: compiler and linker</para>
/// </summary>
LogVerbose,
/// <summary>
/// Generate line number information (-lineinfo) <para/> (0: false, default)
/// <para>Option type: int</para>
/// <para>Applies to: compiler only</para>
/// </summary>
GenerateLineInfo,
/// <summary>
/// Specifies whether to enable caching explicitly (-dlcm)<para/>
/// Choice is based on supplied ::CUjit_cacheMode_enum.
/// <para>Option type: unsigned int for enumerated type ::CUjit_cacheMode_enum</para>
/// <para>Applies to: compiler only</para>
/// </summary>
JITCacheMode,
/// <summary>
/// The below jit options are used for internal purposes only, in this version of CUDA
/// </summary>
NewSM3XOpt,
/// <summary>
/// The below jit options are used for internal purposes only, in this version of CUDA
/// </summary>
FastCompile,
/// <summary>
/// Array of device symbol names that will be relocated to the corresponing
/// host addresses stored in ::CU_JIT_GLOBAL_SYMBOL_ADDRESSES.<para/>
/// Must contain ::CU_JIT_GLOBAL_SYMBOL_COUNT entries.<para/>
/// When loding a device module, driver will relocate all encountered
/// unresolved symbols to the host addresses.<para/>
/// It is only allowed to register symbols that correspond to unresolved
/// global variables.<para/>
/// It is illegal to register the same device symbol at multiple addresses.<para/>
/// Option type: const char **<para/>
/// Applies to: dynamic linker only
/// </summary>
GlobalSymbolNames,
/// <summary>
/// Array of host addresses that will be used to relocate corresponding
/// device symbols stored in ::CU_JIT_GLOBAL_SYMBOL_NAMES.<para/>
/// Must contain ::CU_JIT_GLOBAL_SYMBOL_COUNT entries.<para/>
/// Option type: void **<para/>
/// Applies to: dynamic linker only
/// </summary>
GlobalSymbolAddresses,
/// <summary>
/// Number of entries in ::CU_JIT_GLOBAL_SYMBOL_NAMES and
/// ::CU_JIT_GLOBAL_SYMBOL_ADDRESSES arrays.<para/>
/// Option type: unsigned int<para/>
/// Applies to: dynamic linker only
/// </summary>
GlobalSymbolCount
}",Online compiler options,1
919,"public enum CUJITOptimizationLevel
{
/// <summary>
/// No optimization
/// </summary>
ZERO = 0,
/// <summary>
/// Optimization level 1
/// </summary>
ONE = 1,
/// <summary>
/// Optimization level 2
/// </summary>
TWO = 2,
/// <summary>
/// Optimization level 3
/// </summary>
THREE = 3,
/// <summary>
/// Best, Default
/// </summary>
FOUR = 4,
}",Online compilation optimization levels,1
920,"public enum CUJITCacheMode
{
/// <summary>
/// Compile with no -dlcm flag specified
/// </summary>
None = 0,
/// <summary>
/// Compile with L1 cache disabled
/// </summary>
Cg,
/// <summary>
/// Compile with L1 cache enabled
/// </summary>
Ca }",Caching modes for dlcm,1
921,"public enum CUArrayCubemapFace
{
/// <summary>
/// Positive X face of cubemap
/// </summary>
PositiveX = 0x00, /// <summary>
/// Negative X face of cubemap
/// </summary>
NegativeX = 0x01,
/// <summary>
/// Positive Y face of cubemap /// </summary>
PositiveY = 0x02,
/// <summary>
/// Negative Y face of cubemap
/// </summary>
NegativeY = 0x03,
/// <summary>
/// Positive Z face of cubemap
/// </summary>
PositiveZ = 0x04, /// <summary>
/// Negative Z face of cubemap
/// </summary>
NegativeZ = 0x05 }",Array indices for cube faces,1
922,"public enum CULimit
{
/// <summary>
/// GPU thread stack size
/// </summary>
StackSize = 0,
/// <summary>
/// GPU printf FIFO size
/// </summary>
PrintfFIFOSize = 1,
/// <summary>
/// GPU malloc heap size
/// </summary>
MallocHeapSize = 2,
/// <summary>
/// GPU device runtime launch synchronize depth
/// </summary>
DevRuntimeSyncDepth = 3,
/// <summary>
/// GPU device runtime pending launch count
/// </summary>
DevRuntimePendingLaunchCount = 4,
/// <summary>
/// A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint
/// </summary>
MaxL2FetchGranularity = 0x05
}",Limits,0
923,"public enum CUMemoryType : uint
{
/// <summary>
/// Host memory
/// </summary>
Host = 0x01,
/// <summary>
/// Device memory
/// </summary>
Device = 0x02,
/// <summary>
/// Array memory
/// </summary>
Array = 0x03,
/// <summary>
/// Unified device or host memory
/// </summary>
Unified = 4
}",Memory types,1
924,"public enum CUResourceType {
/// <summary>
/// Array resoure
/// </summary>
Array = 0x00,
/// <summary>
/// Mipmapped array resource
/// </summary>
MipmappedArray = 0x01,
/// <summary>
/// Linear resource
/// </summary>
Linear = 0x02,
/// <summary>
/// Pitch 2D resource
/// </summary>
Pitch2D = 0x03
}",Resource types,1
925,"public enum CUResult
{
/// <summary>
/// No errors
/// </summary>
Success = 0,
/// <summary>
/// Invalid value
/// </summary>
ErrorInvalidValue = 1,
/// <summary>
/// Out of memory
/// </summary>
ErrorOutOfMemory = 2,
/// <summary>
/// Driver not initialized
/// </summary>
ErrorNotInitialized = 3,
/// <summary>
/// Driver deinitialized
/// </summary>
ErrorDeinitialized = 4,
/// <summary>
/// This indicates profiler is not initialized for this run. This can happen when the application is running with external profiling tools
/// like visual profiler.
/// </summary>
ErrorProfilerDisabled = 5,
/// <summary>
/// This error return is deprecated as of CUDA 5.0. It is no longer an error
/// to attempt to enable/disable the profiling via ::cuProfilerStart or
/// ::cuProfilerStop without initialization.
/// </summary>
[Obsolete(""deprecated as of CUDA 5.0"")]
ErrorProfilerNotInitialized = 6,
/// <summary>
/// This error return is deprecated as of CUDA 5.0. It is no longer an error
/// to call cuProfilerStart() when profiling is already enabled.
/// </summary>
[Obsolete(""deprecated as of CUDA 5.0"")]
ErrorProfilerAlreadyStarted = 7,
/// <summary>
/// This error return is deprecated as of CUDA 5.0. It is no longer an error
/// to call cuProfilerStop() when profiling is already disabled.
/// </summary>
[Obsolete(""deprecated as of CUDA 5.0"")]
ErrorProfilerAlreadyStopped = 8,
/// <summary>
/// No CUDA-capable device available
/// </summary>
ErrorNoDevice = 100,
/// <summary>
/// Invalid device
/// </summary>
ErrorInvalidDevice = 101,
/// <summary>
/// Invalid kernel image
/// </summary>
ErrorInvalidImage = 200,
/// <summary>
/// Invalid context
/// </summary>
ErrorInvalidContext = 201,
/// <summary>
/// Context already current
/// </summary>
[Obsolete(""This error return is deprecated as of CUDA 3.2. It is no longer an error to attempt to push the active context via cuCtxPushCurrent()."")]
ErrorContextAlreadyCurrent = 202,
/// <summary>
/// Map failed
/// </summary>
ErrorMapFailed = 205,
/// <summary>
/// Unmap failed
/// </summary>
ErrorUnmapFailed = 206,
/// <summary>
/// Array is mapped
/// </summary>
ErrorArrayIsMapped = 207,
/// <summary>
/// Already mapped
/// </summary>
ErrorAlreadyMapped = 208,
/// <summary>
/// No binary for GPU
/// </summary>
ErrorNoBinaryForGPU = 209,
/// <summary>
/// Already acquired
/// </summary>
ErrorAlreadyAcquired = 210,
/// <summary>
/// Not mapped
/// </summary>
ErrorNotMapped = 211,
/// <summary>
/// Mapped resource not available for access as an array
/// </summary>
ErrorNotMappedAsArray = 212,
/// <summary>
/// Mapped resource not available for access as a pointer
/// </summary>
ErrorNotMappedAsPointer = 213,
/// <summary>
/// Uncorrectable ECC error detected
/// </summary>
ErrorECCUncorrectable = 214,
/// <summary>
/// CULimit not supported by device
/// </summary>
ErrorUnsupportedLimit = 215,
/// <summary>
/// This indicates that the <see cref=""CUcontext""/> passed to the API call can
/// only be bound to a single CPU thread at a time but is already /// bound to a CPU thread.
/// </summary>
ErrorContextAlreadyInUse = 216,
/// <summary>
/// This indicates that peer access is not supported across the given devices.
/// </summary>
ErrorPeerAccessUnsupported = 217,
/// <summary>
/// This indicates that a PTX JIT compilation failed.
/// </summary>
ErrorInvalidPtx = 218,
/// <summary>
/// This indicates an error with OpenGL or DirectX context.
/// </summary>
ErrorInvalidGraphicsContext = 219,
/// <summary>
/// This indicates that an uncorrectable NVLink error was detected during the execution.
/// </summary>
NVLinkUncorrectable = 220,
/// <summary>
/// This indicates that the PTX JIT compiler library was not found.
/// </summary>
JITCompilerNotFound = 221,
/// <summary>
/// Invalid source
/// </summary>
ErrorInvalidSource = 300,
/// <summary>
/// File not found
/// </summary>
ErrorFileNotFound = 301,
/// <summary>
/// Link to a shared object failed to resolve
/// </summary>
ErrorSharedObjectSymbolNotFound = 302,
/// <summary>
/// Shared object initialization failed
/// </summary>
ErrorSharedObjectInitFailed = 303,
/// <summary>
/// OS call failed
/// </summary>
ErrorOperatingSystem = 304,
/// <summary>
/// Invalid handle
/// </summary>
ErrorInvalidHandle = 400,
/// <summary>
/// This indicates that a resource required by the API call is not in a
/// valid state to perform the requested operation.
/// </summary>
ErrorIllegalState = 401,
/// <summary>
/// Not found
/// </summary>
ErrorNotFound = 500,
/// <summary>
/// CUDA not ready
/// </summary>
ErrorNotReady = 600,
/// <summary>
/// While executing a kernel, the device encountered a
/// load or store instruction on an invalid memory address.
/// This leaves the process in an inconsistent state and any further CUDA work
/// will return the same error. To continue using CUDA, the process must be terminated
/// and relaunched.
/// </summary>
ErrorIllegalAddress = 700,
/// <summary>
/// Launch exceeded resources
/// </summary>
ErrorLaunchOutOfResources = 701,
/// <summary>
/// This indicates that the device kernel took too long to execute. This can
/// only occur if timeouts are enabled - see the device attribute
/// ::CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT for more information.
/// This leaves the process in an inconsistent state and any further CUDA work
/// will return the same error. To continue using CUDA, the process must be terminated
/// and relaunched.
/// </summary>
ErrorLaunchTimeout = 702,
/// <summary>
/// Launch with incompatible texturing
/// </summary>
ErrorLaunchIncompatibleTexturing = 703,
/// <summary>
/// This error indicates that a call to <see cref=""DriverAPINativeMethods.CudaPeerAccess.cuCtxEnablePeerAccess""/> is
/// trying to re-enable peer access to a context which has already
/// had peer access to it enabled.
/// </summary>
ErrorPeerAccessAlreadyEnabled = 704,
/// <summary>
/// This error indicates that <see cref=""DriverAPINativeMethods.CudaPeerAccess.cuCtxDisablePeerAccess""/> is /// trying to disable peer access which has not been enabled yet /// via <see cref=""DriverAPINativeMethods.CudaPeerAccess.cuCtxEnablePeerAccess""/>. /// </summary>
ErrorPeerAccessNotEnabled = 705,
/// <summary>
/// This error indicates that the primary context for the specified device
/// has already been initialized.
/// </summary>
ErrorPrimaryContextActice = 708,
/// <summary>
/// This error indicates that the context current to the calling thread
/// has been destroyed using <see cref=""DriverAPINativeMethods.ContextManagement.cuCtxDestroy""/>, or is a primary context which
/// has not yet been initialized. /// </summary>
ErrorContextIsDestroyed = 709,
/// <summary>
/// A device-side assert triggered during kernel execution. The context
/// cannot be used anymore, and must be destroyed. All existing device /// memory allocations from this context are invalid and must be /// reconstructed if the program is to continue using CUDA.
/// </summary>
ErrorAssert = 710,
/// <summary>
/// This error indicates that the hardware resources required to enable
/// peer access have been exhausted for one or more of the devices /// passed to ::cuCtxEnablePeerAccess().
/// </summary>
ErrorTooManyPeers = 711,
/// <summary>
/// This error indicates that the memory range passed to ::cuMemHostRegister()
/// has already been registered.
/// </summary>
ErrorHostMemoryAlreadyRegistered = 712,
/// <summary>
/// This error indicates that the pointer passed to ::cuMemHostUnregister()
/// does not correspond to any currently registered memory region.
/// </summary>
ErrorHostMemoryNotRegistered = 713,
/// <summary>
/// While executing a kernel, the device encountered a stack error.
/// This can be due to stack corruption or exceeding the stack size limit.
/// This leaves the process in an inconsistent state and any further CUDA work
/// will return the same error. To continue using CUDA, the process must be terminated
/// and relaunched.
/// </summary>
ErrorHardwareStackError = 714,
/// <summary>
/// While executing a kernel, the device encountered an illegal instruction.
/// This leaves the process in an inconsistent state and any further CUDA work
/// will return the same error. To continue using CUDA, the process must be terminated
/// and relaunched.
/// </summary>
ErrorIllegalInstruction = 715,
/// <summary>
/// While executing a kernel, the device encountered a load or store instruction
/// on a memory address which is not aligned.
/// This leaves the process in an inconsistent state and any further CUDA work
/// will return the same error. To continue using CUDA, the process must be terminated
/// and relaunched.
/// </summary>
ErrorMisalignedAddress = 716,
/// <summary>
/// While executing a kernel, the device encountered an instruction
/// which can only operate on memory locations in certain address spaces
/// (global, shared, or local), but was supplied a memory address not
/// belonging to an allowed address space.
/// This leaves the process in an inconsistent state and any further CUDA work
/// will return the same error. To continue using CUDA, the process must be terminated
/// and relaunched.
/// </summary>
ErrorInvalidAddressSpace = 717,
/// <summary>
/// While executing a kernel, the device program counter wrapped its address space.
/// This leaves the process in an inconsistent state and any further CUDA work
/// will return the same error. To continue using CUDA, the process must be terminated
/// and relaunched.
/// </summary>
ErrorInvalidPC = 718,
/// <summary>
/// An exception occurred on the device while executing a kernel. Common
/// causes include dereferencing an invalid device pointer and accessing
/// out of bounds shared memory. This leaves the process in an inconsistent state and any further CUDA work
/// will return the same error. To continue using CUDA, the process must be terminated
/// and relaunched.
/// </summary>
ErrorLaunchFailed = 719,
/// <summary>
/// This error indicates that the number of blocks launched per grid for a kernel that was
/// launched via either ::cuLaunchCooperativeKernel or ::cuLaunchCooperativeKernelMultiDevice
/// exceeds the maximum number of blocks as allowed by ::cuOccupancyMaxActiveBlocksPerMultiprocessor
/// or ::cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags times the number of multiprocessors
/// as specified by the device attribute ::CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT.
/// </summary>
ErrorCooperativeLaunchTooLarge = 720,
//Removed in update CUDA version 3.1 -> 3.2
///// <summary>
///// Attempted to retrieve 64-bit pointer via 32-bit API function
///// </summary>
//ErrorPointerIs64Bit = 800,
///// <summary>
///// Attempted to retrieve 64-bit size via 32-bit API function
///// </summary>
//ErrorSizeIs64Bit = 801, /// <summary>
/// This error indicates that the attempted operation is not permitted.
/// </summary>
ErrorNotPermitted = 800,
/// <summary>
/// This error indicates that the attempted operation is not supported
/// on the current system or device.
/// </summary>
ErrorNotSupported = 801,
/// <summary>
/// This error indicates that the system is not yet ready to start any CUDA
/// work. To continue using CUDA, verify the system configuration is in a
/// valid state and all required driver daemons are actively running.
/// </summary>
CUDA_ERROR_SYSTEM_NOT_READY = 802,
/// <summary>
/// This error indicates that the operation is not permitted when the stream is capturing.
/// </summary>
CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = 900,
/// <summary>
/// This error indicates that the current capture sequence on the stream
/// has been invalidated due to a previous error.
/// </summary>
CUDA_ERROR_STREAM_CAPTURE_INVALIDATED = 901,
/// <summary>
/// This error indicates that the operation would have resulted in a merge of two independent capture sequences.
/// </summary>
CUDA_ERROR_STREAM_CAPTURE_MERGE = 902,
/// <summary>
/// This error indicates that the capture was not initiated in this stream.
/// </summary>
CUDA_ERROR_STREAM_CAPTURE_UNMATCHED = 903,
/// <summary>
/// This error indicates that the capture sequence contains a fork that was not joined to the primary stream.
/// </summary>
CUDA_ERROR_STREAM_CAPTURE_UNJOINED = 904,
/// <summary>
/// This error indicates that a dependency would have been created which
/// crosses the capture sequence boundary. Only implicit in-stream ordering
/// dependencies are allowed to cross the boundary.
/// </summary>
CUDA_ERROR_STREAM_CAPTURE_ISOLATION = 905,
/// <summary>
/// This error indicates a disallowed implicit dependency on a current capture sequence from cudaStreamLegacy.
/// </summary>
CUDA_ERROR_STREAM_CAPTURE_IMPLICIT = 906,
/**
* This error indicates that the operation is not permitted on an event which
* was last recorded in a capturing stream.
*/
/// <summary>
/// /// </summary>
CUDA_ERROR_CAPTURED_EVENT = 907,
/// <summary>
/// Unknown error
/// </summary>
ErrorUnknown = 999,
}",Error codes returned by CUDA driver API calls,1
926,"public enum CUdevice_P2PAttribute
{
/// <summary>
/// A relative value indicating the performance of the link between two devices
/// </summary>
PerformanceRank = 0x01,
/// <summary>
/// P2P Access is enable
/// </summary>
AccessSupported = 0x02, /// <summary>
/// Atomic operation over the link supported
/// </summary>
NativeAtomicSupported = 0x03 ,
/// <summary>
/// \deprecated use CudaArrayAccessAccessSupported instead
/// </summary>
[Obsolete(""use CudaArrayAccessAccessSupported instead"")]
ArrayAccessAccessSupported = 0x04,
/// <summary>
/// Accessing CUDA arrays over the link supported
/// </summary>
CudaArrayAccessAccessSupported = 0x04
}",P2P Attributes,0
927,"public enum CUTexRefSetArrayFlags
{
/// <summary>
/// /// </summary>
None = 0,
/// <summary>
/// Override the texref format with a format inferred from the array.
/// <para/>Flag for <see cref=""DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetArray""/>.
/// </summary>
OverrideFormat = 1
}",CUTexRefSetArrayFlags,0
928,"public enum CUParameterTexRef
{
/// <summary>
/// For texture references loaded into the module, use default texunit from texture reference.
/// </summary>
Default = -1
}",CUParameterTexRef,0
929,"public enum CUSurfRefSetFlags
{
/// <summary>
/// Currently no CUSurfRefSetFlags flags are defined.
/// </summary>
None = 0
}",CUSurfRefSetFlags,0
930,"public enum CUPointerAttribute
{
/// <summary>
/// The <see cref=""CUcontext""/> on which a pointer was allocated or registered
/// </summary>
Context = 1, /// <summary>
/// The <see cref=""CUMemoryType""/> describing the physical location of a pointer /// </summary>
MemoryType = 2, /// <summary>
/// The address at which a pointer's memory may be accessed on the device /// </summary>
DevicePointer = 3, /// <summary>
/// The address at which a pointer's memory may be accessed on the host /// </summary>
HostPointer = 4,
/// <summary>
/// A pair of tokens for use with the nv-p2p.h Linux kernel interface
/// </summary>
P2PTokens = 5,
/// <summary>
/// Synchronize every synchronous memory operation initiated on this region
/// </summary>
SyncMemops = 6,
/// <summary>
/// A process-wide unique ID for an allocated memory region
/// </summary>
BufferID = 7,
/// <summary>
/// Indicates if the pointer points to managed memory
/// </summary>
IsManaged = 8,
/// <summary>
/// A device ordinal of a device on which a pointer was allocated or registered
/// </summary>
DeviceOrdinal = 9
}",Pointer information,0
931,"public enum CUd3dXDeviceList
{
/// <summary>
/// The CUDA devices for all GPUs used by a D3D11 device.
/// </summary>
All = 0x01,
/// <summary>
/// The CUDA devices for the GPUs used by a D3D11 device in its currently rendering frame (in SLI).
/// </summary>
CurrentFrame = 0x02,
/// <summary>
/// The CUDA devices for the GPUs to be used by a D3D11 device in the next frame (in SLI).
/// </summary>
NextFrame = 0x03
}","CUDA devices corresponding to a D3D11, D3D10 or D3D9 device",1
932,"public enum CUGLDeviceList
{
/// <summary>
/// The CUDA devices for all GPUs used by the current OpenGL context
/// </summary>
All = 0x01,
/// <summary>
/// The CUDA devices for the GPUs used by the current OpenGL context in its currently rendering frame
/// </summary>
CurrentFrame = 0x02,
/// <summary>
/// The CUDA devices for the GPUs to be used by the current OpenGL context in the next frame
/// </summary>
NextFrame = 0x03,
}",CUDA devices corresponding to an OpenGL device.,1
933,"public enum CUsharedconfig {
/// <summary>
/// set default shared memory bank size /// </summary>
DefaultBankSize = 0x00,
/// <summary>
/// set shared memory bank width to four bytes
/// </summary>
FourByteBankSize = 0x01,
/// <summary>
/// set shared memory bank width to eight bytes
/// </summary>
EightByteBankSize = 0x02
}",Shared memory configurations,1
934,"public enum CUipcMem_flags
{
/// <summary>
/// Automatically enable peer access between remote devices as needed
/// </summary>
LazyEnablePeerAccess = 0x1
}",CUipcMem_flags,0
935,"public enum CUresourceViewFormat
{
/// <summary>
/// No resource view format (use underlying resource format)
/// </summary>
None = 0x00,
/// <summary>
/// 1 channel unsigned 8-bit integers
/// </summary>
Uint1X8 = 0x01,
/// <summary>
/// 2 channel unsigned 8-bit integers
/// </summary>
Uint2X8 = 0x02,
/// <summary>
/// 4 channel unsigned 8-bit integers
/// </summary>
Uint4X8 = 0x03,
/// <summary>
/// 1 channel signed 8-bit integers
/// </summary>
Sint1X8 = 0x04,
/// <summary>
/// 2 channel signed 8-bit integers
/// </summary>
Sint2X8 = 0x05,
/// <summary>
/// 4 channel signed 8-bit integers
/// </summary>
Sint4X8 = 0x06,
/// <summary>
/// 1 channel unsigned 16-bit integers
/// </summary>
Uint1X16 = 0x07,
/// <summary>
/// 2 channel unsigned 16-bit integers
/// </summary>
Uint2X16 = 0x08,
/// <summary>
/// 4 channel unsigned 16-bit integers
/// </summary>
Uint4X16 = 0x09,
/// <summary>
/// 1 channel signed 16-bit integers
/// </summary>
Sint1X16 = 0x0a,
/// <summary>
/// 2 channel signed 16-bit integers
/// </summary>
Sint2X16 = 0x0b,
/// <summary>
/// 4 channel signed 16-bit integers
/// </summary>
Sint4X16 = 0x0c,
/// <summary>
/// 1 channel unsigned 32-bit integers
/// </summary>
Uint1X32 = 0x0d,
/// <summary>
/// 2 channel unsigned 32-bit integers
/// </summary>
Uint2X32 = 0x0e,
/// <summary>
/// 4 channel unsigned 32-bit integers /// </summary>
Uint4X32 = 0x0f,
/// <summary>
/// 1 channel signed 32-bit integers
/// </summary>
Sint1X32 = 0x10,
/// <summary>
/// 2 channel signed 32-bit integers
/// </summary>
Sint2X32 = 0x11,
/// <summary>
/// 4 channel signed 32-bit integers
/// </summary>
Sint4X32 = 0x12,
/// <summary>
/// 1 channel 16-bit floating point
/// </summary>
Float1X16 = 0x13,
/// <summary>
/// 2 channel 16-bit floating point
/// </summary>
Float2X16 = 0x14,
/// <summary>
/// 4 channel 16-bit floating point
/// </summary>
Float4X16 = 0x15,
/// <summary>
/// 1 channel 32-bit floating point
/// </summary>
Float1X32 = 0x16,
/// <summary>
/// 2 channel 32-bit floating point
/// </summary>
Float2X32 = 0x17,
/// <summary>
/// 4 channel 32-bit floating point
/// </summary>
Float4X32 = 0x18,
/// <summary>
/// Block compressed 1 /// </summary>
UnsignedBC1 = 0x19,
/// <summary>
/// Block compressed 2
/// </summary>
UnsignedBC2 = 0x1a,
/// <summary>
/// Block compressed 3 /// </summary>
UnsignedBC3 = 0x1b,
/// <summary>
/// Block compressed 4 unsigned
/// </summary>
UnsignedBC4 = 0x1c,
/// <summary>
/// Block compressed 4 signed /// </summary>
SignedBC4 = 0x1d,
/// <summary>
/// Block compressed 5 unsigned
/// </summary>
UnsignedBC5 = 0x1e,
/// <summary>
/// Block compressed 5 signed
/// </summary>
SignedBC5 = 0x1f,
/// <summary>
/// Block compressed 6 unsigned half-float
/// </summary>
UnsignedBC6H = 0x20,
/// <summary>
/// Block compressed 6 signed half-float
/// </summary>
SignedBC6H = 0x21,
/// <summary>
/// Block compressed 7 /// </summary>
UnsignedBC7 = 0x22 }",Resource view format,1
936,"public enum CUoutputMode
{
/// <summary>
/// Output mode Key-Value pair format.
/// </summary>
KeyValuePair = 0x00, /// <summary>
/// Output mode Comma separated values format.
/// </summary>
CSV = 0x01
}",Profiler Output Modes,1
937,"public enum CUmemAttach_flags
{
/// <summary>
/// Memory can be accessed by any stream on any device
/// </summary>
Global = 1,
/// <summary>
/// Memory cannot be accessed by any stream on any device
/// </summary>
Host = 2,
/// <summary>
/// Memory can only be accessed by a single stream on the associated device
/// </summary>
Single = 4
}",CUDA Mem Attach Flags,0
938,"public enum CUoccupancy_flags
{
/// <summary>
/// Default behavior
/// </summary>
Default = 0,
/// <summary>
/// Assume global caching is enabled and cannot be automatically turned off
/// </summary>
DisableCachingOverride = 1
}",Occupancy calculator flag,1
939,"public enum cudaDataType
{
/// <summary>
/// 16 bit real /// </summary>
CUDA_R_16F = 2,
/// <summary>
/// 16 bit complex
/// </summary>
CUDA_C_16F = 6,
/// <summary>
/// 32 bit real
/// </summary>
CUDA_R_32F = 0,
/// <summary>
/// 32 bit complex
/// </summary>
CUDA_C_32F = 4,
/// <summary>
/// 64 bit real
/// </summary>
CUDA_R_64F = 1,
/// <summary>
/// 64 bit complex
/// </summary>
CUDA_C_64F = 5,
/// <summary>
/// 8 bit real as a signed integer /// </summary>
CUDA_R_8I = 3,
/// <summary>
/// 8 bit complex as a pair of signed integers
/// </summary>
CUDA_C_8I = 7,
/// <summary>
/// 8 bit real as a signed integer /// </summary>
CUDA_R_8U = 8,
/// <summary>
/// 8 bit complex as a pair of signed integers
/// </summary>
CUDA_C_8U= 9
}",cudaDataType,1
940,"public enum CUstreamBatchMemOpType
{
/// <summary>
/// Represents a ::cuStreamWaitValue32 operation
/// </summary>
WaitValue32 = 1,
/// <summary>
/// Represents a ::cuStreamWriteValue32 operation
/// </summary>
WriteValue32 = 2,
/// <summary>
/// Represents a ::cuStreamWaitValue64 operation
/// </summary>
WaitValue64 = 4,
/// <summary>
/// Represents a ::cuStreamWriteValue64 operation
/// </summary>
WriteValue64 = 5,
/// <summary>
/// This has the same effect as ::CU_STREAM_WAIT_VALUE_FLUSH, but as a standalone operation.
/// </summary>
FlushRemoteWrites = 3 }",Operations for ::cuStreamBatchMemOp,1
941,"public enum CUshared_carveout
{
/// <summary>
/// no preference for shared memory or L1 (default)
/// </summary>
Default = -1,
/// <summary>
/// prefer maximum available shared memory, minimum L1 cache
/// </summary>
MaxShared = 100,
/// <summary>
/// prefer maximum available L1 cache, minimum shared memory
/// </summary>
MaxL1 = 0
}",Shared memory carveout configurations,1
942,"public enum CUgraphNodeType
{
/// <summary>
/// GPU kernel node
/// </summary>
CU_GRAPH_NODE_TYPE_KERNEL = 0, /// <summary>
/// Memcpy node
/// </summary>
CU_GRAPH_NODE_TYPE_MEMCPY = 1, /// <summary>
/// Memset node
/// </summary>
CU_GRAPH_NODE_TYPE_MEMSET = 2, /// <summary>
/// Host (executable) node
/// </summary>
CU_GRAPH_NODE_TYPE_HOST = 3, /// <summary>
/// Node which executes an embedded graph
/// </summary>
CU_GRAPH_NODE_TYPE_GRAPH = 4,
/// <summary>
/// Empty (no-op) node
/// </summary>
CU_GRAPH_NODE_TYPE_EMPTY = 5, /// <summary>
/// /// </summary>
CU_GRAPH_NODE_TYPE_COUNT
}",Graph node types,1
943,"public enum CUstreamCaptureStatus
{
/// <summary>
/// Stream is not capturing
/// </summary>
CU_STREAM_CAPTURE_STATUS_NONE = 0,
/// <summary>
/// Stream is actively capturing
/// </summary>
CU_STREAM_CAPTURE_STATUS_ACTIVE = 1, /// <summary>
/// Stream is part of a capture sequence that has been invalidated, but not terminated
/// </summary>
CU_STREAM_CAPTURE_STATUS_INVALIDATED = 2
}",Possible stream capture statuses returned by ::cuStreamIsCapturing,1
944,"public enum CUexternalMemoryHandleType
{
/// <summary>
/// Handle is an opaque file descriptor
/// </summary>
OpaqueFD = 1,
/// <summary>
/// Handle is an opaque shared NT handle
/// </summary>
OpaqueWin32 = 2,
/// <summary>
/// Handle is an opaque, globally shared handle
/// </summary>
OpaqueWin32KMT = 3,
/// <summary>
/// Handle is a D3D12 heap object
/// </summary>
D3D12Heap = 4,
/// <summary>
/// Handle is a D3D12 committed resource
/// </summary>
D3D12Resource = 5
}",External memory handle types,1
945,"public enum CUexternalSemaphoreHandleType
{
/// <summary>
/// Handle is an opaque file descriptor
/// </summary>
OpaqueFD = 1,
/// <summary>
/// Handle is an opaque shared NT handle
/// </summary>
OpaqueWin32 = 2,
/// <summary>
/// Handle is an opaque, globally shared handle
/// </summary>
OpaqueWin32KMT = 3,
/// <summary>
/// Handle is a shared NT handle referencing a D3D12 fence object
/// </summary>
D3D12Dence = 4
}",External semaphore handle types,1
946,"public enum CUGraphicsRegisterFlags
{
/// <summary>
/// Specifies no hints about how this resource will be used. /// It is therefore assumed that this resource will be read /// from and written to by CUDA. This is the default value.
/// </summary>
None = 0x00,
/// <summary>
/// Specifies that CUDA will not write to this resource.
/// </summary>
ReadOnly = 0x01,
/// <summary>
/// Specifies that CUDA will not read from this resource and /// will write over the entire contents of the resource, so /// none of the data previously stored in the resource will /// be preserved.
/// </summary>
WriteDiscard = 0x02,
/// <summary>
/// Specifies that CUDA will bind this resource to a surface reference.
/// </summary>
SurfaceLDST = 0x04,
/// <summary>
/// /// </summary>
TextureGather = 0x08
}",Flags to register a graphics resource,1
947,"public enum CUGraphicsMapResourceFlags
{
/// <summary>
/// Specifies no hints about how this resource will be used.
/// It is therefore assumed that this resource will be read from and written to by CUDA. This is the default value.
/// </summary>
None = 0,
/// <summary>
/// Specifies that CUDA will not write to this resource.
/// </summary>
ReadOnly = 1,
/// <summary>
/// Specifies that CUDA will not read from
/// this resource and will write over the entire contents of the resource, so none of the data previously stored in the
/// resource will be preserved.
/// </summary>
WriteDiscard = 2
}",Flags for mapping and unmapping graphics interop resources,1
948,"public enum CUTexRefSetFlags
{
/// <summary>
/// /// </summary>
None = 0,
/// <summary>
/// Read the texture as integers rather than promoting the values to floats in the range [0,1].
/// <para/>Flag for <see cref=""DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetFlags""/>
/// </summary>
ReadAsInteger = 1,
/// <summary>
/// Use normalized texture coordinates in the range [0,1) instead of [0,dim).
/// <para/>Flag for <see cref=""DriverAPINativeMethods.TextureReferenceManagement.cuTexRefSetFlags""/>
/// </summary>
NormalizedCoordinates = 2,
/// <summary>
/// Perform sRGB -> linear conversion during texture read.
/// </summary>
sRGB = 0x10
}",CUTexRefSetFlags,0
949,"public enum CUInitializationFlags : uint
{
/// <summary>
/// Currently no initialization flags are defined.
/// </summary>
None = 0
}",CUDA driver API initialization flags,1
950,"public enum CtxEnablePeerAccessFlags : uint
{
/// <summary>
/// Currently no flags are defined.
/// </summary>
None = 0
}",CUDA driver API Context Enable Peer Access flags,1
951,"public enum CUStreamFlags : uint
{
/// <summary>
/// For compatibilty with pre Cuda 5.0, equal to Default
/// </summary>
None = 0,
/// <summary>
/// Default stream flag
/// </summary>
Default = 0x0,
/// <summary>
/// Stream does not synchronize with stream 0 (the NULL stream)
/// </summary>
NonBlocking = 0x1,
}",CUDA stream flags,0
952,"public enum CudaCooperativeLaunchMultiDeviceFlags
{
/// <summary>
/// No flags
/// </summary>
None = 0,
/// <summary>
/// If set, each kernel launched as part of ::cuLaunchCooperativeKernelMultiDevice only
/// waits for prior work in the stream corresponding to that GPU to complete before the
/// kernel begins execution.
/// </summary>
NoPreLaunchSync = 0x01,
/// <summary>
/// If set, any subsequent work pushed in a stream that participated in a call to
/// ::cuLaunchCooperativeKernelMultiDevice will only wait for the kernel launched on
/// the GPU corresponding to that stream to complete before it begins execution.
/// </summary>
NoPostLaunchSync = 0x02,
}",CudaCooperativeLaunchMultiDeviceFlags,0
953,"public enum CUDAArray3DFlags
{
/// <summary>
/// No flags
/// </summary>
None = 0,
/// <summary>
/// if set, the CUDA array contains an array of 2D slices and
/// the Depth member of CUDA_ARRAY3D_DESCRIPTOR specifies the
/// number of slices, not the depth of a 3D array.
/// </summary>
[Obsolete(""Since CUDA Version 4.0. Use <Layered> instead"")]
Array2D = 1,
/// <summary>
/// if set, the CUDA array contains an array of layers where each layer is either a 1D
/// or a 2D array and the Depth member of CUDA_ARRAY3D_DESCRIPTOR specifies the number
/// of layers, not the depth of a 3D array.
/// </summary>
Layered = 1,
/// <summary>
/// this flag must be set in order to bind a surface reference
/// to the CUDA array
/// </summary>
SurfaceLDST = 2,
/// <summary>
/// If set, the CUDA array is a collection of six 2D arrays, representing faces of a cube. The
/// width of such a CUDA array must be equal to its height, and Depth must be six.
/// If ::CUDA_ARRAY3D_LAYERED flag is also set, then the CUDA array is a collection of cubemaps
/// and Depth must be a multiple of six.
/// </summary>
Cubemap = 4,
/// <summary>
/// This flag must be set in order to perform texture gather operations on a CUDA array.
/// </summary>
TextureGather = 8,
/// <summary>
/// This flag if set indicates that the CUDA array is a DEPTH_TEXTURE.
/// </summary>
DepthTexture = 0x10,
/// <summary>
/// This flag indicates that the CUDA array may be bound as a color target in an external graphics API
/// </summary>
ColorAttachment = 0x20
}",CUDAArray3DFlags,0
954,"public enum CUMemHostAllocFlags
{
/// <summary>
/// No flags
/// </summary>
None = 0,
/// <summary>
/// The memory returned by this call will be considered as pinned memory
/// by all CUDA contexts, not just the one that performed the allocation.
/// </summary>
Portable = 1,
/// <summary>
/// Maps the allocation into the CUDA address space. The device pointer
/// to the memory may be obtained by calling <see cref=""DriverAPINativeMethods.MemoryManagement.cuMemHostGetDevicePointer_v2""/>. This feature is available only on
/// GPUs with compute capability greater than or equal to 1.1.
/// </summary>
DeviceMap = 2,
/// <summary>
/// Allocates the memory as write-combined (WC). WC memory
/// can be transferred across the PCI Express bus more quickly on some system configurations, but cannot be read
/// efficiently by most CPUs. WC memory is a good option for buffers that will be written by the CPU and read by
/// the GPU via mapped pinned memory or host->device transfers.<para/>
/// If set, host memory is allocated as write-combined - fast to write,
/// faster to DMA, slow to read except via SSE4 streaming load instruction
/// (MOVNTDQA).
/// </summary>
WriteCombined = 4
}","CUMemHostAllocFlags. All of these flags are orthogonal to one another: a developer may allocate memory that is portable, mapped and/or write-combined with no restrictions.",1
955,"public enum CUCtxFlags
{
/// <summary>
/// The default value if the flags parameter is zero, uses a heuristic based on the
/// number of active CUDA contexts in the process C and the number of logical processors in the system P. If C >
/// P, then CUDA will yield to other OS threads when waiting for the GPU, otherwise CUDA will not yield while
/// waiting for results and actively spin on the processor.
/// </summary>
SchedAuto = 0,
/// <summary>
/// Instruct CUDA to actively spin when waiting for results from the GPU. This can decrease
/// latency when waiting for the GPU, but may lower the performance of CPU threads if they are performing
/// work in parallel with the CUDA thread.
/// </summary>
SchedSpin = 1,
/// <summary>
/// Instruct CUDA to yield its thread when waiting for results from the GPU. This can
/// increase latency when waiting for the GPU, but can increase the performance of CPU threads performing work
/// in parallel with the GPU.
/// </summary>
SchedYield = 2,
/// <summary>
/// Instruct CUDA to block the CPU thread on a synchronization primitive when waiting for the GPU to finish work.
/// </summary>
BlockingSync = 4,
/// <summary>
/// No description found...
/// </summary>
SchedMask = 7,
/// <summary>
/// Instruct CUDA to support mapped pinned allocations. This flag must be set in order to allocate pinned host memory that is accessible to the GPU.
/// </summary>
MapHost = 8,
/// <summary>
/// Instruct CUDA to not reduce local memory after resizing local memory
/// for a kernel. This can prevent thrashing by local memory allocations when launching many kernels with high
/// local memory usage at the cost of potentially increased memory usage.
/// </summary>
LMemResizeToMax = 16,
/// <summary>
/// No description found...
/// </summary>
FlagsMask = 0x1f
}","The two LSBs of the flags parameter can be used to control how the OS thread, which owns the CUDA context at the time of an API call, interacts with the OS scheduler when waiting for results from the GPU.",1
956,"public enum CUMemHostRegisterFlags
{
/// <summary>
/// No flags
/// </summary>
None = 0,
/// <summary>
/// The memory returned by this call will be considered as pinned memory
/// by all CUDA contexts, not just the one that performed the allocation.
/// </summary>
Portable = 1,
/// <summary>
/// Maps the allocation into the CUDA address space. The device pointer
/// to the memory may be obtained by calling <see cref=""DriverAPINativeMethods.MemoryManagement.cuMemHostGetDevicePointer_v2""/>. This feature is available only on
/// GPUs with compute capability greater than or equal to 1.1.
/// </summary>
DeviceMap = 2,
/// <summary>
/// If set, the passed memory pointer is treated as pointing to some
/// memory-mapped I/O space, e.g. belonging to a third-party PCIe device.<para/>
/// On Windows the flag is a no-op.<para/>
/// On Linux that memory is marked as non cache-coherent for the GPU and
/// is expected to be physically contiguous.<para/>
/// On all other platforms, it is not supported and CUDA_ERROR_INVALID_VALUE
/// is returned.<para/>
/// </summary>
IOMemory = 0x04
}",CUMemHostRegisterFlags. All of these flags are orthogonal to one another: a developer may allocate memory that is portable or mapped with no restrictions.,1
957,"public enum CUStreamAddCallbackFlags
{
/// <summary>
/// No flags
/// </summary>
None = 0x0,
///// <summary>
///// The stream callback blocks the stream until it is done executing.
///// </summary>
//Blocking = 0x01,
}",Flag for cuStreamAddCallback(),0
958,"public enum CUEventFlags
{
/// <summary>
/// Default event creation flag.
/// </summary>
Default = 0,
/// <summary>
/// Specifies that event should use blocking synchronization. A CPU thread
/// that uses <see cref=""DriverAPINativeMethods.Events.cuEventSynchronize""/> to wait on an event created with this flag will block until the event has actually
/// been recorded.
/// </summary>
BlockingSync = 1,
/// <summary>
/// Event will not record timing data
/// </summary>
DisableTiming = 2,
/// <summary>
/// Event is suitable for interprocess use. CUEventFlags.DisableTiming must be set
/// </summary>
InterProcess = 4
}",Event creation flags,0
959,"public enum CUstreamWaitValue_flags
{
/// <summary>
/// Wait until (int32_t)(*addr - value) >= 0 (or int64_t for 64 bit values). Note this is a cyclic comparison which ignores wraparound. (Default behavior.) /// </summary>
GEQ = 0x0,
/// <summary>
/// Wait until *addr == value.
/// </summary>
EQ = 0x1,
/// <summary>
/// Wait until (*addr &amp; value) != 0.
/// </summary>
And = 0x2,
/// <summary>
/// Wait until ~(*addr | value) != 0. Support for this operation can be
/// queried with ::cuDeviceGetAttribute() and ::CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR. /// Generally, this requires compute capability 7.0 or greater. /// </summary>
NOr = 0x3,
/// <summary>
/// Follow the wait operation with a flush of outstanding remote writes. This
/// means that, if a remote write operation is guaranteed to have reached the
/// device before the wait can be satisfied, that write is guaranteed to be
/// visible to downstream device work. The device is permitted to reorder
/// remote writes internally. For example, this flag would be required if
/// two remote writes arrive in a defined order, the wait is satisfied by the
/// second write, and downstream work needs to observe the first write.
/// </summary>
Flush = 1 << 30
}",Flags for ::cuStreamWaitValue32,1
960,"public enum CUstreamWriteValue_flags
{
/// <summary>
/// Default behavior
/// </summary>
Default = 0x0,
/// <summary>
/// Permits the write to be reordered with writes which were issued
/// before it, as a performance optimization. Normally, ::cuStreamWriteValue32 will provide a memory fence before the
/// write, which has similar semantics to __threadfence_system() but is scoped to the stream rather than a CUDA thread.
/// </summary>
NoMemoryBarrier = 0x1
}",Flags for ::cuStreamWriteValue32,1
961,"public enum CudaExternalMemory
{
/// <summary>
/// No flags
/// </summary>
Nothing = 0x0,
/// <summary>
/// Indicates that the external memory object is a dedicated resource
/// </summary>
Dedicated = 0x01,
}",Indicates that the external memory object is a dedicated resource,1
962,"public enum CublasStatus
{
/// <summary>
/// /// </summary>
Success = 0,
/// <summary>
/// /// </summary>
NotInitialized = 1,
/// <summary>
/// /// </summary>
AllocFailed = 3,
/// <summary>
/// /// </summary>
InvalidValue = 7,
/// <summary>
/// /// </summary>
ArchMismatch = 8,
/// <summary>
/// /// </summary>
MappingError = 11,
/// <summary>
/// /// </summary>
ExecutionFailed = 13,
/// <summary>
/// /// </summary>
InternalError = 14,
/// <summary>
/// /// </summary>
NotSupported = 15,
/// <summary>
/// /// </summary>
LicenseError = 16
}",CUBLAS status type returns,1
963,"public enum FillMode
{
/// <summary>
/// the lower part of the matrix is filled
/// </summary>
Lower=0,
/// <summary>
/// the upper part of the matrix is filled
/// </summary>
Upper=1
}",The FillMode type indicates which part (lower or upper) of the dense matrix was filled and consequently should be used by the function. Its values correspond to Fortran characters L or l (lower) and U or u (upper) that are often used as parameters to legacy BLAS implementations.,1
964,"public enum DiagType
{
/// <summary>
/// the matrix diagonal has non-unit elements
/// </summary>
NonUnit=0, /// <summary>
/// the matrix diagonal has unit elements
/// </summary>
Unit=1
}",The DiagType type indicates whether the main diagonal of the dense matrix is unity and consequently should not be touched or modified by the function. Its values correspond to Fortran characters N or n (non-unit) and U or u (unit) that are often used as parameters to legacy BLAS implementations.,1
965,"public enum SideMode
{
/// <summary>
/// the matrix is on the left side in the equation
/// </summary>
Left=0, /// <summary>
/// the matrix is on the right side in the equation
/// </summary>
Right=1
}",The SideMode type indicates whether the dense matrix is on the left or right side in the matrix equation solved by a particular function. Its values correspond to Fortran characters L or l (left) and R or r (right) that are often used as parameters to legacy BLAS implementations.,1
966,"public enum Operation
{
/// <summary>
/// the non-transpose operation is selected
/// </summary>
NonTranspose=0, /// <summary>
/// the transpose operation is selected
/// </summary>
Transpose=1, /// <summary>
/// the conjugate transpose operation is selected
/// </summary>
ConjugateTranspose=2
}","The Operation type indicates which operation needs to be performed with the dense matrix. Its values correspond to Fortran characters N or n (non-transpose), T or t (transpose) and C or c (conjugate transpose) that are often used as parameters to legacy BLAS implementations",1
967,"public enum PointerMode
{
/// <summary>
/// the scalars are passed by reference on the host
/// </summary>
Host=0, /// <summary>
/// the scalars are passed by reference on the device
/// </summary>
Device=1
}","The PointerMode type indicates whether the scalar values are passed by reference on the host or device. It is important to point out that if several scalar values are present in the function call, all of them must conform to the same single pointer mode. The pointer mode can be set and retrieved using cublasSetPointerMode() and cublasGetPointerMode() routines, respectively.",1
968,"public enum AtomicsMode
{
/// <summary>
/// the usage of atomics is not allowed
/// </summary>
NotAllowed=0, /// <summary>
/// the usage of atomics is allowed
/// </summary>
Allowed=1
}","The type indicates whether cuBLAS routines which has an alternate implementation using atomics can be used. The atomics mode can be set and queried using and routines, respectively.",1
969,"public enum GemmAlgo
{
/// <summary>
/// </summary>
Default = -1,
/// <summary>
/// </summary>
Algo0 = 0,
/// <summary>
/// </summary>
Algo1 = 1,
/// <summary>
/// </summary>
Algo2 = 2,
/// <summary>
/// </summary>
Algo3 = 3,
/// <summary>
/// </summary>
Algo4 = 4,
/// <summary>
/// </summary>
Algo5 = 5,
/// <summary>
/// </summary>
Algo6 = 6,
/// <summary>
/// </summary>
Algo7 = 7,
/// <summary>
/// </summary>
Algo8 = 8,
/// <summary>
/// </summary>
Algo9 = 9,
/// <summary>
/// </summary>
Algo10 = 10,
/// <summary>
/// </summary>
Algo11 = 11,
/// <summary>
/// </summary>
Algo12 = 12,
/// <summary>
/// </summary>
Algo13 = 13,
/// <summary>
/// </summary>
Algo14 = 14,
/// <summary>
/// </summary>
Algo15 = 15,
/// <summary>
/// </summary>
Algo16 = 16,
/// <summary>
/// </summary>
Algo17 = 17,
/// <summary>
/// sliced 32x32 /// </summary>
Algo18 = 18, /// <summary>
/// sliced 64x32
/// </summary> Algo19 = 19, /// <summary>
/// sliced 128x32
/// </summary> Algo20 = 20, /// <summary>
/// sliced 32x32 -splitK
/// </summary> Algo21 = 21, /// <summary>
/// sliced 64x32 -splitK
/// </summary> Algo22 = 22, /// <summary>
/// sliced 128x32 -splitK /// </summary> Algo23 = 23, // /// <summary>
/// </summary>
DefaultTensorOp = 99,
/// <summary>
/// </summary>
Algo0TensorOp = 100,
/// <summary>
/// </summary>
Algo1TensorOp = 101,
/// <summary>
/// </summary>
Algo2TensorOp = 102,
/// <summary>
/// </summary>
Algo3TensorOp = 103,
/// <summary>
/// </summary>
Algo4TensorOp = 104,
/// <summary>
/// </summary>
Algo5TensorOp = 105,
/// <summary>
/// </summary>
Algo6TensorOp = 106,
/// <summary>
/// </summary>
Algo7TensorOp = 107,
/// <summary>
/// </summary>
Algo8TensorOp = 108,
/// <summary>
/// </summary>
Algo9TensorOp = 109,
/// <summary>
/// </summary>
Algo10TensorOp = 110,
/// <summary>
/// </summary>
Algo11TensorOp = 111,
/// <summary>
/// </summary>
Algo12TensorOp = 112,
/// <summary>
/// </summary>
Algo13TensorOp = 113,
/// <summary>
/// </summary>
Algo14TensorOp = 114,
/// <summary>
/// </summary>
Algo15TensorOp = 115
}",For different GEMM algorithm,1
970,"public enum Math
{
/// <summary>
/// </summary>
DefaultMath = 0,
/// <summary>
/// </summary>
TensorOpMath = 1
}",Enum for default math mode/tensor operation,1
971,"public enum DataType
{
///// <summary>
///// the data type is 32-bit floating-point
///// </summary>
//Float = 0,
///// <summary>
///// the data type is 64-bit floating-point
///// </summary>
//Double = 1,
///// <summary>
///// the data type is 16-bit floating-point
///// </summary>
//Half = 2,
///// <summary>
///// the data type is 8-bit signed integer
///// </summary>
//Int8 = 3
/// <summary>
/// 16 bit real /// </summary>
CUDA_R_16F = 2,
/// <summary>
/// 16 bit complex
/// </summary>
CUDA_C_16F = 6,
/// <summary>
/// 32 bit real
/// </summary>
CUDA_R_32F = 0,
/// <summary>
/// 32 bit complex
/// </summary>
CUDA_C_32F = 4,
/// <summary>
/// 64 bit real
/// </summary>
CUDA_R_64F = 1,
/// <summary>
/// 64 bit complex
/// </summary>
CUDA_C_64F = 5,
/// <summary>
/// 8 bit real as a signed integer /// </summary>
CUDA_R_8I = 3,
/// <summary>
/// 8 bit complex as a pair of signed integers
/// </summary>
CUDA_C_8I = 7,
/// <summary>
/// 8 bit real as a signed integer /// </summary>
CUDA_R_8U = 8,
/// <summary>
/// 8 bit complex as a pair of signed integers
/// </summary>
CUDA_C_8U = 9
}","The cublasDataType_t type is an enumerant to specify the data precision. It is used when the data reference does not carry the type itself (e.g void *). To mimic the typedef in cublas_api.h, we redefine the enum identically to cudaDataType",1
972,"public enum cudnnStatus
{
/// <summary>
/// The operation completed successfully.
/// </summary>
Success = 0,
/// <summary>
/// The cuDNN library was not initialized properly.<para/>
/// This error is usually returned when a call to
/// cudnnCreate() fails or when cudnnCreate()
/// has not been called prior to calling another cuDNN
/// routine. In the former case, it is usually due
/// to an error in the CUDA Runtime API called by
/// cudnnCreate() or by an error in the hardware
/// setup.
/// </summary>
NotInitialized = 1,
/// <summary>
/// Resource allocation failed inside the cuDNN
/// library. This is usually caused by an internal
/// cudaMalloc() failure.<para/>
/// To correct: prior to the function call, deallocate
/// previously allocated memory as much as possible.
/// </summary>
AllocFailed = 2,
/// <summary>
/// An incorrect value or parameter was passed to the
/// function.<para/>
/// To correct: ensure that all the parameters being
/// passed have valid values.
/// </summary>
BadParam = 3,
/// <summary>
/// An internal cuDNN operation failed.
/// </summary>
InternalError = 4,
/// <summary>
/// /// </summary>
InvalidValue = 5,
/// <summary>
/// The function requires a feature absent from
/// the current GPU device. Note that cuDNN only
/// supports devices with compute capabilities greater
/// than or equal to 3.0.<para/>
/// To correct: compile and run the application on a
/// device with appropriate compute capability.
/// </summary>
ArchMismatch = 6,
/// <summary>
/// An access to GPU memory space failed, which is
/// usually caused by a failure to bind a texture.<para/>
/// To correct: prior to the function call, unbind any
/// previously bound textures.<para/>
/// Otherwise, this may indicate an internal error/bug
/// in the library.
/// </summary>
MappingError = 7,
/// <summary>
/// The GPU program failed to execute. This is usually
/// caused by a failure to launch some cuDNN kernel
/// on the GPU, which can occur for multiple reasons.<para/>
/// To correct: check that the hardware, an
/// appropriate version of the driver, and the cuDNN
/// library are correctly installed.<para/>
/// Otherwise, this may indicate a internal error/bug
/// in the library.
/// </summary>
ExecutionFailed = 8,
/// <summary>
/// The functionality requested is not presently supported by cuDNN.
/// </summary>
NotSupported = 9,
/// <summary>
/// The functionality requested requires some license
/// and an error was detected when trying to check
/// the current licensing. This error can happen if
/// the license is not present or is expired or if the
/// environment variable NVIDIA_LICENSE_FILE is not
/// set properly.
/// </summary>
LicenseError = 10,
/// <summary>
/// /// </summary>
RuntimePrerequisiteMissing = 11,
/// <summary>
/// /// </summary>
RuntimInProgress = 12,
/// <summary>
/// /// </summary>
RuntimeFPOverflow = 13
}",CUDNN return codes,1
973,"public enum cudnnDataType
{
/// <summary>
/// The data is 32-bit single-precision floating point (float).
/// </summary>
Float = 0,
/// <summary>
/// The data is 64-bit double-precision floating point (double).
/// </summary>
Double = 1,
/// <summary>
/// The data is 16-bit floating point.
/// </summary>
Half = 2,
/// <summary>
/// The data is 8-bit signed integer.
/// </summary>
Int8 = 3,
/// <summary>
/// The data is 32-bit signed integer.
/// </summary>
Int32 = 4,
/// <summary>
/// The data is 32-bit element composed of 4 8-bit signed integer. This data type
/// is only supported with tensor format CUDNN_TENSOR_NCHW_VECT_C.
/// </summary>
Int8x4 = 5,
/// <summary>
/// The data is 8-bit unsigned integer.
/// </summary>
UInt8 = 6,
/// <summary>
/// The data is 32-bit element composed of 4 8-bit unsigned integer. This data type
/// is only supported with tensor format CUDNN_TENSOR_NCHW_VECT_C.
/// </summary>
UInt8x4 = 7,
}",cudnnDataType is an enumerated type indicating the data type to which a tensor descriptor or filter descriptor refers.,1
974,"public enum cudnnNanPropagation
{
/// <summary>
/// Selects the not propagate NaN option.
/// </summary>
NotPropagateNan = 0,
/// <summary>
/// Selects the propagate NaN option.
/// </summary>
PropagateNan = 1
}",cudnnNanPropagation is an enumerated type for the NanPropagation flag.,1
975,"public enum cudnnTensorFormat
{
/// <summary>
/// This tensor format specifies that the data is laid out in the following order: image, features map,
/// rows, columns. The strides are implicitly defined in such a way that the data are contiguous in
/// memory with no padding between images, feature maps, rows, and columns; the columns are the
/// inner dimension and the images are the outermost dimension.
/// </summary>
NCHW = 0, /* row major (wStride = 1, hStride = w) */
/// <summary>
/// This tensor format specifies that the data is laid out in the following order: image, rows, columns,
/// features maps. The strides are implicitly defined in such a way that the data are contiguous in memory
/// with no padding between images, rows, columns, and features maps; the feature maps are the
/// inner dimension and the images are the outermost dimension.
/// </summary>
NHWC = 1, /* feature maps interleaved ( cStride = 1 )*/
/// <summary>
/// This tensor format specifies that the data is laid out in the following order: batch size, feature
/// maps, rows, columns. However, each element of the tensor is a vector of multiple feature
/// maps. The length of the vector is carried by the data type of the tensor. The strides are
/// implicitly defined in such a way that the data are contiguous in memory with no padding
/// between images, feature maps, rows, and columns; the columns are the inner dimension
/// and the images are the outermost dimension. This format is only supported with tensor data type
/// CUDNN_DATA_INT8x4.
/// </summary>
NCHW_VECT_C = 2 /* each image point is vector of element of C : the length of the vector is carried by the data type*/
}",cudnnTensorFormat is an enumerated type used by cudnnSetTensor4dDescriptor() to create a tensor with a pre-defined layout.,1
976,"public enum cudnnAddMode
{
/// <summary>
/// In this mode, the bias tensor is defined as one
/// image with one feature map. This image will be
/// added to every feature map of every image of the
/// input/output tensor.
/// </summary>
Image = 0, /* add one image to every feature maps of each input */
/// <summary>
/// In this mode, the bias tensor is defined as one
/// image with one feature map. This image will be
/// added to every feature map of every image of the
/// input/output tensor.
/// </summary>
SameHW = 0,
/// <summary>
/// In this mode, the bias tensor is defined as one
/// image with multiple feature maps. This image
/// will be added to every image of the input/output
/// tensor.
/// </summary>
FeatureMap = 1, /* add a set of feature maps to a batch of inputs : tensorBias has n=1 , same nb feature than Src/dest */
/// <summary>
/// In this mode, the bias tensor is defined as one
/// image with multiple feature maps. This image
/// will be added to every image of the input/output
/// tensor.
/// </summary>
SameCHW = 1,
/// <summary>
/// In this mode, the bias tensor is defined as one
/// image with multiple feature maps of dimension
/// 1x1; it can be seen as an vector of feature maps.
/// Each feature map of the bias tensor will be added
/// to the corresponding feature map of all height-bywidth
/// pixels of every image of the input/output
/// tensor.
/// </summary>
SameC = 2, /* add a tensor of size 1,c,1,1 to every corresponding point of n,c,h,w input */
/// <summary>
/// In this mode, the bias tensor has the same
/// dimensions as the input/output tensor. It will be
/// added point-wise to the input/output tensor.
/// </summary>
FullTensor = 3 /* add 2 tensors with same n,c,h,w */
}",cudnnAddMode is an enumerated type used by cudnnAddTensor() to specify how a bias tensor is added to an input/output tensor.,1
977,"public enum cudnnConvolutionMode
{
/// <summary>
/// In this mode, a convolution operation will be done
/// when applying the filter to the images.
/// </summary>
Convolution = 0,
/// <summary>
/// In this mode, a cross-correlation operation will be
/// done when applying the filter to the images.
/// </summary>
CrossCorrelation = 1
}",cudnnConvolutionMode is an enumerated type used by cudnnSetConvolutionDescriptor() to configure a convolution descriptor.,1
978,"public enum cudnnConvolutionFwdPreference
{
/// <summary>
/// In this configuration, the routine cudnnGetConvolutionForwardAlgorithm() is
/// guaranteed to return an algorithm that does not require any extra workspace to be provided by the
/// user.
/// </summary>
NoWorkspace = 0,
/// <summary>
/// In this configuration, the routine cudnnGetConvolutionForwardAlgorithm() will
/// return the fastest algorithm regardless how much workspace is needed to execute it.
/// </summary>
PreferFastest = 1,
/// <summary>
/// In this configuration, the routine cudnnGetConvolutionForwardAlgorithm() will
/// return the fastest algorithm that fits within the memory limit that the user provided.
/// </summary>
SpecifyWorkspaceLimit = 2,
}",cudnnConvolutionFwdPreference is an enumerated type used by cudnnGetConvolutionForwardAlgorithm() to help the choice of the algorithm used for the forward convolution.,1
979,"public enum cudnnConvolutionFwdAlgo
{
/// <summary>
/// This algorithm expresses the convolution as a matrix product without actually explicitly form the
/// matrix that holds the input tensor data.
/// </summary>
ImplicitGEMM = 0,
/// <summary>
/// This algorithm expresses the convolution as a matrix product without actually explicitly form
/// the matrix that holds the input tensor data, but still needs some memory workspace to precompute
/// some indices in order to facilitate the implicit construction of the matrix that holds the input
/// tensor data
/// </summary>
ImplicitPrecompGEMM = 1,
/// <summary>
/// This algorithm expresses the convolution as an explicit matrix product. A significant memory
/// workspace is needed to store the matrix that holds the input tensor data.
/// </summary>
GEMM = 2,
/// <summary>
/// This algorithm expresses the convolution as a direct convolution (e.g without implicitly or
/// explicitly doing a matrix multiplication).
/// </summary>
Direct = 3,
/// <summary>
/// This algorithm uses a Fast-Fourier Transform approach to compute the convolution. A
/// significant memory workspace is needed to store intermediate results.
/// </summary>
FFT = 4,
/// <summary>
/// This algorithm uses a Fast-Fourier Transform approach but splits the inputs into 32x32 tiles. A
/// significant memory workspace is needed to store intermediate results but significantly less than
/// FFT for big size images.
/// </summary>
FFTWithTiling = 5,
/// <summary>
/// This algorithm uses a Winograd Transform approach to compute the convolution. A reasonably /// sized workspace is needed to store intermediate results.
/// </summary>
Winograd = 6
}",cudnnConvolutionFwdAlgo is an enumerated type that exposes the different algorithms available to execute the forward convolution operation.,1
980,"public enum cudnnSoftmaxAlgorithm
{
/// <summary>
/// This implementation applies the straightforward softmax operation.
/// </summary>
Fast = 0, /* straightforward implementation */
/// <summary>
/// This implementation scales each point of the softmax input domain by its maximum value to
/// avoid potential floating point overflows in the softmax evaluation.
/// </summary>
Accurate = 1, /* subtract max from every point to avoid overflow */
/// <summary>
/// This entry performs the Log softmax operation, avoiding overflows by scaling each point in the
/// input domain as in CUDNN_SOFTMAX_ACCURATE
/// </summary>
Log = 2
}",cudnnSoftmaxAlgorithm is used to select an implementation of the softmax function used in cudnnSoftmaxForward() and cudnnSoftmaxBackward().,1
981,"public enum cudnnSoftmaxMode
{
/// <summary>
/// The softmax operation is computed per image (N) across the dimensions C,H,W.
/// </summary>
Instance = 0, /* compute the softmax over all C, H, W for each N */
/// <summary>
/// The softmax operation is computed per spatial location (H,W) per image (N) across the dimension C.
/// </summary>
Channel = 1 /* compute the softmax over all C for each H, W, N */
}",cudnnSoftmaxMode is used to select over which data the cudnnSoftmaxForward() and cudnnSoftmaxBackward() are computing their results.,1
982,"public enum cudnnPoolingMode
{
/// <summary>
/// The maximum value inside the pooling window will be used.
/// </summary>
Max = 0,
/// <summary>
/// The values inside the pooling window will be averaged. The number of padded values will be
/// taken into account when computing the average value.
/// </summary>
AverageCountIncludePadding = 1, // count for average includes padded values
/// <summary>
/// The values inside the pooling window will be averaged. The number of padded values will not
/// be taken into account when computing the average value.
/// </summary>
AverageCountExcludePadding = 2 // count for average does not include padded values
};",cudnnPoolingMode is an enumerated type passed to cudnnSetPoolingDescriptor() to select the pooling method to be used by cudnnPoolingForward() and cudnnPoolingBackward().,1
983,"public enum cudnnActivationMode
{
/// <summary>
/// Selects the sigmoid function.
/// </summary>
Sigmoid = 0,
/// <summary>
/// Selects the rectified linear function.
/// </summary>
Relu = 1,
/// <summary>
/// Selects the hyperbolic tangent function.
/// </summary>
Tanh = 2,
/// <summary>
/// Selects the clipped rectified linear function.
/// </summary>
ClippedRelu = 3,
/// <summary>
/// Selects the exponential linear function
/// </summary>
Elu = 4,
/// <summary>
/// Selects the identity function, intended for bypassing the activation step in cudnnConvolutionBiasActivationForward() (need to use CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_GEMM). Does not work with cudnnActivationForward() or cudnnActivationBackward().
/// </summary>
Identity = 5
}",cudnnActivationMode is an enumerated type used to select the neuron activation function used in cudnnActivationForward() and cudnnActivationBackward().,1
984,"public enum cudnnConvolutionBwdFilterPreference
{
/// <summary>
/// In this configuration, the routine cudnnGetConvolutionBackwardFilterAlgorithm()
/// is guaranteed to return an algorithm that does not require any extra workspace to be provided by the user.
/// </summary>
NoWorkspace = 0,
/// <summary>
/// In this configuration, the routine cudnnGetConvolutionBackwardFilterAlgorithm()
/// will return the fastest algorithm regardless how much workspace is needed to execute it.
/// </summary>
PreferFastest = 1,
/// <summary>
/// In this configuration, the routine cudnnGetConvolutionBackwardFilterAlgorithm()
/// will return the fastest algorithm that fits within the memory limit that the user provided.
/// </summary>
SpecifyWorkspaceLimit = 2
}",cudnnConvolutionBwdFilterPreference is an enumerated type used by cudnnGetConvolutionBackwardFilterAlgorithm() to help the choice of the algorithm used for the backward filter convolution.,1
985,"public enum cudnnConvolutionBwdFilterAlgo
{
/// <summary>
/// This algorithm expresses the convolution as a sum of matrix product without actually explicitly form
/// the matrix that holds the input tensor data. The sum is done using atomic adds operation, thus the
/// results are non-deterministic.
/// </summary>
Algo0 = 0, // non-deterministic
/// <summary>
/// This algorithm expresses the convolution as a matrix product without actually explicitly form
/// the matrix that holds the input tensor data. The results are deterministic.
/// </summary>
Algo1 = 1,
/// <summary>
/// This algorithm uses a Fast-Fourier Transform approach to compute the convolution. A
/// significant memory workspace is needed to store intermediate results. The results are
/// deterministic.
/// </summary>
AlgoFFT = 2,
/// <summary>
/// This algorithm is similar to CUDNN_CONVOLUTION_BWD_FILTER_ALGO_0 but
/// uses some small workspace to precomputes some indices. The results are also non-deterministic.
/// </summary>
Algo3 = 3, // non-deterministic, algo0 with workspace
/// <summary>
/// Not implemented
/// </summary>
AlgoWinograd = 4, // not implemented
/// <summary>
/// This algorithm uses the Winograd Transform
/// approach to compute the convolution. Significant
/// workspace may be needed to store intermediate
/// results. The results are deterministic.
/// </summary>
AlgoWinogradNonFused = 5,
/// <summary>
/// This algorithm uses the Fast-Fourier Transform
/// approach to compute the convolution but splits
/// the input tensor into tiles. Significant workspace
/// may be needed to store intermediate results. The
/// results are deterministic.
/// </summary>
AlgoFFTTiling = 6
}",cudnnConvolutionBwdFilterAlgo is an enumerated type that exposes the different algorithms available to execute the backward filter convolution operation.,1
986,"public enum cudnnConvolutionBwdDataPreference
{
/// <summary>
/// In this configuration, the routine cudnnGetConvolutionBackwardDataAlgorithm()
/// is guaranteed to return an algorithm that does not require any extra workspace to be provided by the
/// user.
/// </summary>
NoWorkspace = 0,
/// <summary>
/// In this configuration, the routine cudnnGetConvolutionBackwardDataAlgorithm()
/// will return the fastest algorithm regardless how much workspace is needed to execute it.
/// </summary>
PreferFastest = 1,
/// <summary>
/// In this configuration, the routine cudnnGetConvolutionBackwardDataAlgorithm()
/// will return the fastest algorithm that fits within the memory limit that the user provided.
/// </summary>
SpecifyWorkspaceLimit = 2
}",cudnnConvolutionBwdDataPreference is an enumerated type used by cudnnGetConvolutionBackwardDataAlgorithm() to help the choice of the algorithm used for the backward data convolution.,1
987,"public enum cudnnConvolutionBwdDataAlgo
{
/// <summary>
/// This algorithm expresses the convolution as a sum of matrix product without actually explicitly form
/// the matrix that holds the input tensor data. The sum is done using atomic adds operation, thus the
/// results are non-deterministic.
/// </summary>
Algo0 = 0, // non-deterministic
/// <summary>
/// This algorithm expresses the convolution as a matrix product without actually explicitly form
/// the matrix that holds the input tensor data. The results are deterministic.
/// </summary>
Algo1 = 1,
/// <summary>
/// This algorithm uses a Fast-Fourier Transform approach to compute the convolution. A
/// significant memory workspace is needed to store intermediate results. The results are
/// deterministic.
/// </summary>
AlgoFFT = 2,
/// <summary>
/// This algorithm uses a Winograd Transform approach to compute the convolution. /// A reasonably sized workspace is needed to store intermediate results. The results are deterministic.
/// </summary>
Winograd = 3
}",cudnnConvolutionBwdDataAlgo is an enumerated type that exposes the different algorithms available to execute the backward data convolution operation.,1
988,"public enum cudnnLRNMode
{
/// <summary>
/// LRN co mputation is performed across tensor's dimension dimA[1].
/// </summary>
CrossChannelDim1 = 0
}",cudnnLRNMode is an enumerated type used to specify the mode of operation in cudnnLRNCrossChannelForward() and cudnnLRNCrossChannelBackward().,1
989,"public enum cudnnDivNormMode
{
/// <summary>
/// The means tensor data pointer is expected to
/// contain means or other kernel convolution values
/// precomputed by the user. The means pointer
/// can also be NULL, in that case it's considered
/// to be filled with zeroes. This is equivalent to
/// spatial LRN. Note that in the backward pass
/// the means are treated as independent inputs
/// and the gradient over means is computed
/// independently. In this mode to yield a net gradient
/// over the entire LCN computational graph the
/// destDiffMeans result should be backpropagated
/// through the user's means layer (which can
/// be impelemented using average pooling) and
/// added to the destDiffData tensor produced by
/// cudnnDivisiveNormalizationBackward.
/// </summary>
PrecomputedMeans = 0
}",cudnnDivNormMode is an enumerated type used to specify the mode of operation in cudnnDivisiveNormalizationForward() and cudnnDivisiveNormalizationBackward().,1
990,"public enum cudnnBatchNormMode
{
/// <summary>
/// Normalization is performed per-activation. This mode is intended to be used after nonconvolutional
/// network layers. In this mode bnBias and bnScale tensor dimensions are 1xCxHxW.
/// </summary>
BatchNormPerActivation = 0,
/// <summary>
/// Normalization is performed over N+spatial dimensions. This mode is intended for use after
/// convolutional layers (where spatial invariance is desired). In this mode bnBias, bnScale tensor
/// dimensions are 1xCx1x1.
/// </summary>
BatchNormSpatial = 1,
/// <summary>
/// bnScale, bnBias tensor dims are 1xCx1x1 (one value per C-dim normalized over Nx1xHxW subtensors). /// May be faster than CUDNN_BATCHNORM_SPATIAL but imposes some limits on the range of values
/// </summary>
BatchNormSpatialPersitent = 2
}","cudnnBatchNormMode is an enumerated type used to specify the mode of operation in cudnnBatchNormalizationForwardInference(), cudnnBatchNormalizationForwardTraining(), cudnnBatchNormalizationBackward() and cudnnDeriveBNTensorDescriptor() routines.",1
991,"public enum cudnnSamplerType
{
/// <summary>
/// Selects the bilinear sampler.
/// </summary>
SamplerBilinear = 0
}",cudnnSamplerType_t is an enumerated type passed to cudnnSetSpatialTransformerNdDescriptor() to select the sampler type to be used by cudnnSpatialTfSamplerForward() and cudnnSpatialTfSamplerBackward().,1
992,"public enum cudnnRNNMode
{
/// <summary>
/// A single-gate recurrent neural network with a ReLU activation function. In the forward pass the output ht for a /// given iteration can be computed from the recurrent input ht-1 and the previous layer input xt given matrices /// W, R and biases bW, bR from the following equation:
/// h_t = ReLU(W_i x_t + R_i h_(t-1) + b_Wi + b_Ri) /// Where ReLU(x) = max(x, 0). /// </summary>
RNNRelu = 0, // Stock RNN with ReLu activation
/// <summary>
/// A single-gate recurrent neural network with a tanh activation function. In the forward pass the output ht /// for a given iteration can be computed from the recurrent input ht-1 and the previous layer input xt given /// matrices W, R and biases bW, bR from the following equation:
/// h_t = tanh(W_i x_t + R_i h_(t-1) + b_Wi + b_Ri) /// Where tanh is the hyperbolic tangent function.
/// </summary>
RNNTanh = 1, // Stock RNN with tanh activation
/// <summary>
/// A four-gate Long Short-Term Memory network with no peephole connections. In the forward pass the output ht /// and cell output c_t for a given iteration can be computed from the recurrent input h_(t-1), the cell input c_(t-1)
/// and the previous layer input x_t given matrices W, R and biases b_W, b_R from the following equations: /// i_t = (W_i x_t + R_i h_(t-1) + b_Wi + b_Ri) /// f_t = (W_f x_t + R_f h_(t-1) + b_Wf + b_Rf) /// o_t = (W_o x_t + R_o h_(t-1) + b_Wo + b_Ro)
/// c_'t = tanh(W_c x_t + R_c h_(t-1) + b_Wc + b_Rc) /// c_t = f_tc_'(t-1) + i_tc_'t /// h_t = o_ttanh(c_t)
/// Where is the sigmoid operator: (x) = 1 / (1 + e^-x), represents a point-wise multiplication /// and tanh is the hyperbolic tangent function. i_t, f_t, o_t, c_'t represent the input, forget, output /// and new gates respectively. /// </summary>
LSTM = 2, // LSTM with no peephole connections
/// <summary>
/// A three-gate network consisting of Gated Recurrent Units. In the forward pass the output ht /// for a given iteration can be computed from the recurrent input ht-1 and the previous layer input /// xt given matrices W, R and biases bW, bR from the following equations:
/// i_t = (W_i x_t + R_i h_(t-1) + b_Wi + b_Ru)
/// r_t = (W_r x_t + R_r h_(t-1) + b_Wr + b_Rr)
/// h_'t = tanh(W_h x_t + r_tR_h h_(t-1) + b_Wh + b_Rh) /// h_t = (1 - i_th_'t) + i_th_(t-1)
/// Where is the sigmoid operator: (x) = 1 / (1 + e^-x), represents a point-wise multiplication /// and tanh is the hyperbolic tangent function. i_t, r_t, h_'t represent the input, reset, new gates respectively.
/// </summary>
GRU = 3 // Using h' = tanh(r * Uh(t-1) + Wx) and h = (1 - z) * h' + z * h(t-1);
}","cudnnRNNMode_t is an enumerated type used to specify the type of network used in the cudnnRNNForwardInference(), cudnnRNNForwardTraining(), cudnnRNNBackwardData() and cudnnRNNBackwardWeights() routines.",1
993,"public enum cudnnDirectionMode
{
/// <summary>
/// The network iterates recurrently from the first input to the last.
/// </summary>
Unidirectional = 0,
/// <summary>
/// Each layer of the the network iterates recurrently from the first input to the last and separately /// from the last input to the first. The outputs of the two are concatenated at each iteration giving /// the output of the layer.
/// </summary>
Bidirectional = 1 // Using output concatination at each step. Do we also want to support output sum?
}","cudnnDirectionMode_t is an enumerated type used to specify the recurrence pattern in the cudnnRNNForwardInference(), cudnnRNNForwardTraining(), cudnnRNNBackwardData() and cudnnRNNBackwardWeights() routines.",1
994,"public enum cudnnRNNInputMode
{
/// <summary>
/// A biased matrix multiplication is performed at the input of the first recurrent layer.
/// </summary>
LinearInput = 0,
/// <summary>
/// No operation is performed at the input of the first recurrent layer. If CUDNN_SKIP_INPUT /// is used the leading dimension of the input tensor must be equal to the hidden state size /// of the network.
/// </summary>
SkipInput = 1
}","cudnnRNNInputMode_t is an enumerated type used to specify the behavior of the first layer in the cudnnRNNForwardInference(), cudnnRNNForwardTraining(), cudnnRNNBackwardData() and cudnnRNNBackwardWeights() routines.",1
995,"public enum cudnnDeterminism
{
/// <summary>
/// Results are not guaranteed to be reproducible
/// </summary>
NonDeterministic = 0,
/// <summary>
/// Results are guaranteed to be reproducible
/// </summary>
Deterministic = 1,
}",cudnnDeterminism_t is an enumerated type used to indicate if the computed results are deterministic(reproducible). See section 2.5 (Reproducibility) for more details on determinism.,1
996,"public enum cudnnReduceTensorOp
{
/// <summary>
/// The operation to be performed is addition
/// </summary>
Add = 0,
/// <summary>
/// The operation to be performed is multiplication
/// </summary>
Mul = 1,
/// <summary>
/// The operation to be performed is a minimum comparison
/// </summary>
Min = 2,
/// <summary>
/// The operation to be performed is a maximum comparison
/// </summary>
Max = 3,
/// <summary>
/// The operation to be performed is a maximum comparison of absolute values
/// </summary>
AMax = 4,
/// <summary>
/// The operation to be performed is averaging
/// </summary>
Avg = 5,
/// <summary>
/// The operation to be performed is addition of absolute values
/// </summary>
Norm1 = 6,
/// <summary>
/// The operation to be performed is a square root of sum of squares
/// </summary>
Norm2 = 7,
/// <summary>
/// /// </summary>
MulNoZeros = 8,
}",cudnnReduceTensorOp is an enumerated type used to indicate the tensor operation to be used by the cudnnReduceTensor() routine.This enumerated type is used as a field for the cudnnReduceTensorDescriptor_t descriptor.,1
997,"public enum cudnnReduceTensorIndices
{
/// <summary>
/// Do not compute indices
/// </summary>
NoIndices = 0,
/// <summary>
/// Compute indices. The resulting indices are relative, and flattened.
/// </summary>
FlattenedIndices = 1,
}",cudnnReduceTensorIndices_t is an enumerated type used to indicate whether indices are to be computed by the cudnnReduceTensor() routine.This enumerated type is used as a field for the cudnnReduceTensorDescriptor_t descriptor.,1
998,"public enum cudnnIndicesType
{
/// <summary>
/// Compute unsigned int indices
/// </summary>
Indices32Bit = 0,
/// <summary>
/// Compute unsigned long long indices
/// </summary>
Indices64Bit = 1,
/// <summary>
/// Compute unsigned short indices
/// </summary>
Indices16Bit = 2,
/// <summary>
/// Compute unsigned char indices
/// </summary>
Indices8Bit = 3,
}",cudnnIndicesType_t is an enumerated type used to indicate the data type for the indices to be computed by the cudnnReduceTensor() routine. This enumerated type is used as a field for the cudnnReduceTensorDescriptor_t descriptor.,1
999,"public enum cudnnRNNAlgo
{
/// <summary>
/// Each RNN layer is executed as a sequence of operations. This
/// algorithm is expected to have robust performance across a wide
/// range of network parameters.
/// </summary>
Standard = 0,
/// <summary>
/// The recurrent parts of the network are executed using a persistent
/// kernel approach. This method is expected to be fast when the first
/// dimension of the input tensor is small (ie. a small minibatch).
/// CUDNN_RNN_ALGO_PERSIST_STATIC is only supported on devices
/// with compute capability >= 6.0.
/// </summary>
PersistStatic = 1,
/// <summary>
/// The recurrent parts of the network are executed using a persistent
/// kernel approach. This method is expected to be fast when the first
/// dimension of the input tensor is small (ie. a small minibatch). When
/// using CUDNN_RNN_ALGO_PERSIST_DYNAMIC persistent kernels are
/// prepared at runtime and are able to optimized using the specific
/// parameters of the network and active GPU.As such, when using
/// CUDNN_RNN_ALGO_PERSIST_DYNAMIC a one-time plan preparation
/// stage must be executed.These plans can then be reused in repeated
/// calls with the same model parameters.<para/>
/// The limits on the maximum number of hidden units
/// supported when using CUDNN_RNN_ALGO_PERSIST_DYNAMIC
/// are significantly higher than the limits when using
/// CUDNN_RNN_ALGO_PERSIST_STATIC, however throughput is likely
/// to significantly reduce when exceeding the maximums supported by
/// CUDNN_RNN_ALGO_PERSIST_STATIC.In this regime this method will
/// still outperform CUDNN_RNN_ALGO_STANDARD for some cases.<para/>
/// CUDNN_RNN_ALGO_PERSIST_DYNAMIC is only supported on devices
/// with compute capability >= 6.0 on Linux machines.
/// </summary>
PersistDynamic = 2,
/// <summary>
/// /// </summary>
Count = 3
}","cudnnRNNAlgo_t is an enumerated type used to specify the algorithm used in the cudnnRNNForwardInference(), cudnnRNNForwardTraining(), cudnnRNNBackwardData() and cudnnRNNBackwardWeights() routines.",1
1000,"public enum cudnnMathType
{
/// <summary>
/// /// </summary>
Default = 0,
/// <summary>
/// /// </summary>
TensorOP = 1
}",CUDNN math type,0
1001,"public enum MessageMask
{
/// <summary>
/// /// </summary>
Error = 1 << (int)cudnnSeverity.Error,
/// <summary>
/// /// </summary>
Warning = 1 << (int)cudnnSeverity.Warning,
/// <summary>
/// /// </summary>
Info = 1 << (int)cudnnSeverity.Info }",Message masks to be used with cudnnSetCallback(),1
1002,"public enum cufftResult
{
/// <summary>
/// Any CUFFT operation is successful.
/// </summary>
Success = 0x0,
/// <summary>
/// CUFFT is passed an invalid plan handle.
/// </summary>
InvalidPlan = 0x1,
/// <summary>
/// CUFFT failed to allocate GPU memory.
/// </summary>
AllocFailed = 0x2,
/// <summary>
/// The user requests an unsupported type.
/// </summary>
InvalidType = 0x3,
/// <summary>
/// The user specifies a bad memory pointer.
/// </summary>
InvalidValue = 0x4,
/// <summary>
/// Used for all internal driver errors.
/// </summary>
InternalError = 0x5,
/// <summary>
/// CUFFT failed to execute an FFT on the GPU.
/// </summary>
ExecFailed = 0x6,
/// <summary>
/// The CUFFT library failed to initialize.
/// </summary>
SetupFailed = 0x7,
/// <summary>
/// The user specifies an unsupported FFT size.
/// </summary>
InvalidSize = 0x8,
/// <summary>
/// Input or output does not satisfy texture alignment requirements.
/// </summary>
UnalignedData = 0x9,
/// <summary>
/// /// </summary>
IncompleteParameterList = 0xA,
/// <summary>
/// Plan creation and execution are on different device
/// </summary>
InvalidDevice = 0xB,
/// <summary>
/// /// </summary>
ParseError = 0xC,
/// <summary>
/// Workspace not initialized
/// </summary>
NoWorkspace = 0xD,
/// <summary>
/// Not implemented
/// </summary>
NotImplemented = 0xE,
/// <summary>
/// License error
/// </summary>
LicenseError = 0xF,
/// <summary>
/// Not supported error
/// </summary>
NotSupported = 0x10
}",CUFFT API function return values,1
1003,"public enum TransformDirection
{
/// <summary>
/// /// </summary>
Forward = -1,
/// <summary>
/// /// </summary>
Inverse = 1
}",CUFFT transform directions,1
1004,"public enum cufftType
{
/// <summary>
/// Real to Complex (interleaved)
/// </summary>
R2C = 0x2a,
/// <summary>
/// Complex (interleaved) to Real
/// </summary>
C2R = 0x2c,
/// <summary>
/// Complex to Complex, interleaved
/// </summary>
C2C = 0x29,
/// <summary>
/// Double to Double-Complex
/// </summary>
D2Z = 0x6a,
/// <summary>
/// Double-Complex to Double
/// </summary>
Z2D = 0x6c,
/// <summary>
/// Double-Complex to Double-Complex
/// </summary>
Z2Z = 0x69
}",CUFFT supports the following transform types,1
1005,"public enum CurandStatus
{
/// <summary>
/// No errors.
/// </summary>
Success = 0,
/// <summary>
/// Header file and linked library version do not match.
/// </summary>
VersionMismatch = 100,
/// <summary>
/// Generator not initialized.
/// </summary>
NotInitialized = 101,
/// <summary>
/// Memory allocation failed.
/// </summary>
AllocationFailed = 102,
/// <summary>
/// Generator is wrong type.
/// </summary>
TypeError = 103,
/// <summary>
/// Argument out of range.
/// </summary>
OutOfRange = 104,
/// <summary>
/// Length requested is not a multple of dimension.
/// </summary>
LengthNotMultiple = 105,
/// <summary>
/// GPU does not have double precision required by MRG32k3a.
/// </summary>
DoublePrecisionRequired = 106,
/// <summary>
/// Kernel launch failure.
/// </summary>
LaunchFailure = 201,
/// <summary>
/// Preexisting failure on library entry.
/// </summary>
PreexistingFailure = 202,
/// <summary>
/// Initialization of CUDA failed.
/// </summary>
InitializationFailed = 203,
/// <summary>
/// Architecture mismatch, GPU does not support requested feature.
/// </summary>
ArchMismatch = 204,
/// <summary>
/// Internal library error.
/// </summary>
InternalError = 999
}",CURAND function call status types,1
1006,"public enum GeneratorType
{
/// <summary>
/// /// </summary>
Test = 0,
/// <summary>
/// Default pseudorandom generator.
/// </summary>
PseudoDefault = 100,
/// <summary>
/// XORWOW pseudorandom generator.
/// </summary>
PseudoXORWOW = 101,
/// <summary>
/// MRG32k3a pseudorandom generator.
/// </summary>
PseudoMRG32K3A = 121,
/// <summary>
/// Mersenne Twister pseudorandom generator.
/// </summary>
PseudoMTGP32 = 141,
/// <summary>
/// Mersenne Twister MT19937 pseudorandom generator.
/// </summary>
PseudoMT19937 = 142,
/// <summary>
/// PseudoPhilox4_32_10 quasirandom generator.
/// </summary>
PseudoPhilox4_32_10 = 161,
/// <summary>
/// Default quasirandom generator.
/// </summary>
QuasiDefault = 200,
/// <summary>
/// Sobol32 quasirandom generator.
/// </summary>
QuasiSobol32 = 201,
/// <summary>
/// Scrambled Sobol32 quasirandom generator.
/// </summary>
QuasiScrambledSobol32 = 202,
/// <summary>
/// Sobol64 quasirandom generator.
/// </summary>
QuasiSobol64 = 203,
/// <summary>
/// Scrambled Sobol64 quasirandom generator.
/// </summary>
QuasiScrambledSobol64 = 204
}",CURAND generator types,1
1007,"public enum Ordering
{
/// <summary>
/// Best ordering for pseudorandom results.
/// </summary>
PseudoBest = 100,
/// <summary>
/// Specific default 4096 thread sequence for pseudorandom results.
/// </summary>
PseudoDefault = 101,
/// <summary>
/// Specific seeding pattern for fast lower quality pseudorandom results.
/// </summary>
PseudoSeeded = 102,
/// <summary>
/// Specific n-dimensional ordering for quasirandom results.
/// </summary>
QuasiDefault = 201
}",CURAND orderings of results in memory,1
1008,"public enum DirectionVectorSet
{
/// <summary>
/// Specific set of 32-bit direction vectors generated from polynomials /// recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions.
/// </summary>
JoeKuo6_32 = 101,
/// <summary>
/// Specific set of 32-bit direction vectors generated from polynomials /// recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions, and scrambled.
/// </summary>
ScrambledJoeKuo6_32 = 102,
/// <summary>
/// Specific set of 64-bit direction vectors generated from polynomials /// recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions.
/// </summary>
JoeKuo6_64 = 103,
/// <summary>
/// Specific set of 64-bit direction vectors generated from polynomials /// recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions, and scrambled.
/// </summary>
ScrambledJoeKuo6_64 = 104
}",CURAND choice of direction vector set,1
1009,"public enum curandMethod
{
/// <summary>
/// choose best depends on args
/// </summary>
ChooseBest = 0, /// <summary></summary>
ITR = 1,
/// <summary></summary>
Knuth = 2,
/// <summary></summary>
HITR = 3,
/// <summary></summary>
M1 = 4,
/// <summary></summary>
M2 = 5,
/// <summary></summary>
BinarySearch = 6,
/// <summary></summary>
DiscreteGauss = 7,
/// <summary></summary>
Rejection = 8,
/// <summary></summary>
DeviceAPI = 9,
/// <summary></summary>
FastRejection = 10,
/// <summary></summary>
Third = 11,
/// <summary></summary>
Definition = 12,
/// <summary></summary>
Poisson = 13,
};",CURAND method,0
1010,"public enum cusolverStatus
{
/// <summary>
/// The operation completed successfully
/// </summary>
Success=0,
/// <summary>
/// The cuSolver library was not initialized. This is usually caused by the
/// lack of a prior call, an error in the CUDA Runtime API called by the
/// cuSolver routine, or an error in the hardware setup.<para/>
/// To correct: call cusolverCreate() prior to the function call; and
/// check that the hardware, an appropriate version of the driver, and the
/// cuSolver library are correctly installed.
/// </summary>
NotInititialized=1,
/// <summary>
/// Resource allocation failed inside the cuSolver library. This is usually
/// caused by a cudaMalloc() failure.<para/>
/// To correct: prior to the function call, deallocate previously allocated
/// memory as much as possible.
/// </summary>
AllocFailed=2,
/// <summary>
/// An unsupported value or parameter was passed to the function (a
/// negative vector size, for example).<para/>
/// To correct: ensure that all the parameters being passed have valid
/// values.
/// </summary>
InvalidValue=3,
/// <summary>
/// The function requires a feature absent from the device architecture;
/// usually caused by the lack of support for atomic operations or double
/// precision.<para/>
/// To correct: compile and run the application on a device with compute
/// capability 2.0 or above.
/// </summary>
ArchMismatch = 4,
/// <summary>
/// /// </summary>
MappingError = 5,
/// <summary>
/// The GPU program failed to execute. This is often caused by a launch
/// failure of the kernel on the GPU, which can be caused by multiple
/// reasons.<para/>
/// To correct: check that the hardware, an appropriate version of the
/// driver, and the cuSolver library are correctly installed.
/// </summary>
ExecutionFailed = 6,
/// <summary>
/// An internal cuSolver operation failed. This error is usually caused by a
/// cudaMemcpyAsync() failure.<para/>
/// To correct: check that the hardware, an appropriate version of the
/// driver, and the cuSolver library are correctly installed. Also, check
/// that the memory passed as a parameter to the routine is not being
/// deallocated prior to the routines completion.
/// </summary>
InternalError = 7,
/// <summary>
/// The matrix type is not supported by this function. This is usually caused
/// by passing an invalid matrix descriptor to the function.<para/>
/// To correct: check that the fields in descrA were set correctly.
/// </summary>
MatrixTypeNotSupported = 8,
/// <summary>
/// /// </summary>
NotSupported = 9,
/// <summary>
/// /// </summary>
ZeroPivot = 10,
/// <summary>
/// /// </summary>
InvalidLicense=11
}",This is a status type returned by the library functions and it can have the following values.,1
1011,"public enum ResetValuesFastMode
{
/// <summary>
/// default
/// </summary>
Off = 0, /// <summary/> On = 1
}",The ResetValuesFastMode is an enum that indicates the mode used for the cusolverRfResetValues() routine. The fast mode requires extra memory and is recommended only if very fast calls to cusolverRfResetValues() are needed.,1
1012,"public enum MatrixFormat
{
/// <summary>
/// default
/// </summary>
Csr = 0, /// <summary/>
Csc = 1
}","The MatrixFormat is an enum that indicates the input/output matrix format assumed by the cusolverRfSetup(), cusolverRfSetupHost(), cusolverRfResetValues(), cusolveRfExtractBundledFactorsHost() and cusolverRfExtractSplitFactorsHost() routines.",1
1013,"public enum UnitDiagonal
{
/// <summary>
/// unit diagonal is stored in lower triangular factor. (default)
/// </summary>
StoredL = 0,
/// <summary>
/// unit diagonal is stored in upper triangular factor.
/// </summary>
StoredU = 1,
/// <summary>
/// unit diagonal is assumed in lower triangular factor.
/// </summary>
AssumedL = 2,
/// <summary>
/// unit diagonal is assumed in upper triangular factor.
/// </summary>
AssumedU = 3
}","The UnitDiagonal is an enum that indicates whether and where the unit diagonal is stored in the input/output triangular factors in the cusolverRfSetup(), cusolverRfSetupHost() and cusolverRfExtractSplitFactorsHost() routines.",1
1014,"public enum Factorization
{
/// <summary>
/// algorithm 0. (default)
/// </summary>
Alg0 = 0,
/// <summary>
/// algorithm 1.
/// </summary>
Alg1 = 1,
/// <summary>
/// algorithm 2. Domino-based scheme.
/// </summary>
Alg2 = 2,
}",The Factorization is an enum that indicates which (internal) algorithm is used for refactorization in the cusolverRfRefactor() routine.,1
1015,"public enum TriangularSolve
{
/// <summary>
/// algorithm 0.
/// </summary>
Alg0 = 0,
/// <summary>
/// algorithm 1. (default)
/// </summary>
Alg1 = 1,
/// <summary>
/// algorithm 2. Domino-based scheme.
/// </summary>
Alg2 = 2,
/// <summary>
/// algorithm 3. Domino-based scheme.
/// </summary>
Alg3 = 3
}",The TriangularSolve is an enum that indicates which (internal) algorithm is used for triangular solve in the cusolverRfSolve() routine.,1
1016,"public enum NumericBoostReport
{
/// <summary>
/// default
/// </summary>
NotUsed = 0, /// <summary/>
Used = 1
}",The cusolverRfNumericBoostReport_t is an enum that indicates whether numeric boosting (of the pivot) was used during the cusolverRfRefactor() and cusolverRfSolve() routines. The numeric boosting is disabled by default.,1
1017,"public enum cusparseStatus
{
/// <summary>
/// The operation completed successfully.
/// </summary>
Success = 0,
/// <summary>
/// ""The CUSPARSE library was not initialized. This is usually caused by the lack of a prior /// cusparseCreate() call, an error in the CUDA Runtime API called by the CUSPARSE routine, or an /// error in the hardware setup. To correct: call cusparseCreate() prior to the function call; and
/// check that the hardware, an appropriate version of the driver, and the CUSPARSE library are /// correctly installed.
/// </summary>
NotInitialized = 1,
/// <summary>
/// ""Resource allocation failed inside the CUSPARSE library. This is usually caused by a /// cudaMalloc() failure. To correct: prior to the function call, deallocate previously allocated
/// memory as much as possible.
/// </summary>
AllocFailed = 2,
/// <summary>
/// ""An unsupported value or parameter was passed to the function (a negative vector size, /// for example). To correct: ensure that all the parameters being passed have valid values.
/// </summary>
InvalidValue = 3,
/// <summary>
/// ""The function requires a feature absent from the device architecture; usually caused by /// the lack of support for atomic operations or double precision. To correct: compile and run the
/// application on a device with appropriate compute capability, which is 1.1 for 32-bit atomic /// operations and 1.3 for double precision.
/// </summary>
ArchMismatch = 4,
/// <summary>
/// ""An access to GPU memory space failed, which is usually caused by a failure to bind a texture. /// To correct: prior to the function call, unbind any previously bound textures.
/// </summary>
MappingError = 5,
/// <summary>
/// ""The GPU program failed to execute. This is often caused by a launch failure of the kernel on /// the GPU, which can be caused by multiple reasons. To correct: check that the hardware, an appropriate
/// version of the driver, and the CUSPARSE library are correctly installed.
/// </summary>
ExecutionFailed = 6,
/// <summary>
/// ""An internal CUSPARSE operation failed. This error is usually caused by a cudaMemcpyAsync() /// failure. To correct: check that the hardware, an appropriate version of the driver, and the CUSPARSE
/// library are correctly installed. Also, check that the memory passed as a parameter to the routine /// is not being deallocated prior to the routines completion.
/// </summary>
InternalError = 7,
/// <summary>
/// ""The matrix type is not supported by this function. This is usually caused by passing an invalid /// matrix descriptor to the function. To correct: check that the fields in cusparseMatDescr_t descrA were /// set correctly.
/// </summary>
MatrixTypeNotSupported = 8,
/// <summary>
///
/// </summary>
ZeroPivot = 9
}",This is a status type returned by the library functions and it can have the following values.,1
1018,"public enum cusparseAction
{
/// <summary>
/// the operation is performed only on indices.
/// </summary>
Symbolic = 0,
/// <summary>
/// the operation is performed on data and indices.
/// </summary>
Numeric = 1
}",This type indicates whether the operation is performed only on indices or on data and indices.,1
1019,"public enum cusparseMatrixType
{
/// <summary>
/// the matrix is general.
/// </summary>
General = 0,
/// <summary>
/// the matrix is symmetric.
/// </summary>
Symmetric = 1,
/// <summary>
/// the matrix is Hermitian.
/// </summary>
Hermitian = 2,
/// <summary>
/// the matrix is triangular.
/// </summary>
Triangular = 3
}","This type indicates the type of matrix stored in sparse storage. Notice that for symmetric, Hermitian and triangular matrices only their lower or upper part is assumed to be stored.",1
1020,"public enum cusparseFillMode
{
/// <summary>
/// the lower triangular part is stored.
/// </summary>
Lower = 0,
/// <summary>
/// the upper triangular part is stored.
/// </summary>
Upper = 1
}",This type indicates if the lower or upper part of a matrix is stored in sparse storage.,1
1021,"public enum cusparseDiagType
{
/// <summary>
/// the matrix diagonal has non-unit elements.
/// </summary>
NonUnit = 0,
/// <summary>
/// the matrix diagonal has unit elements.
/// </summary>
Unit = 1
}","This type indicates if the matrix diagonal entries are unity. The diagonal elements are always assumed to be present, but if CUSPARSE_DIAG_TYPE_UNIT is passed to an API routine, then the routine will assume that all diagonal entries are unity and will not read or modify those entries. Note that in this case the routine assumes the diagonal entries are equal to one, regardless of what those entries are actuall set to in memory.",1
1022,"public enum cusparseIndexBase
{
/// <summary>
/// the base index is zero.
/// </summary>
Zero = 0,
/// <summary>
/// the base index is one.
/// </summary>
One = 1
}",This type indicates if the base of the matrix indices is zero or one.,1
1023,"public enum cusparseOperation
{
/// <summary>
/// the non-transpose operation is selected.
/// </summary>
NonTranspose = 0,
/// <summary>
/// the transpose operation is selected.
/// </summary>
Transpose = 1,
/// <summary>
/// the conjugate transpose operation is selected.
/// </summary>
ConjugateTranspose = 2
}",This type indicates which operations need to be performed with the sparse matrix.,1
1024,"public enum cusparseDirection
{
/// <summary>
/// the matrix should be parsed by rows.
/// </summary>
Row = 0,
/// <summary>
/// the matrix should be parsed by columns.
/// </summary>
Column = 1
}",This type indicates whether the elements of a dense matrix should be parsed by rows or by columns (assuming column-major storage in memory of the dense matrix).,1
1025,"public enum cusparseHybPartition
{
/// <summary>
/// the automatic partitioning is selected (default).
/// </summary>
Auto = 0,
/// <summary>
/// the user specified treshold is used.
/// </summary>
User = 1,
/// <summary>
/// the data is stored in ELL format.
/// </summary>
Max = 2
}","This type indicates how to perform the partitioning of the matrix into regular (ELL) and irregular (COO) parts of the HYB format. The partitioning is performed during the conversion of the matrix from a dense or sparse format into the HYB format and is governed by the following rules. When CUSPARSE_HYB_PARTITION_AUTO is selected, the CUSPARSE library automatically decides how much data to put into the regular and irregular parts of the HYB format. When CUSPARSE_HYB_PARTITION_USER is selected, the width of the regular part of the HYB format should be specified by the caller. When CUSPARSE_HYB_PARTITION_MAX is selected, the width of the regular part of the HYB format equals to the maximum number of non-zero elements per row, in other words, the entire matrix is stored in the regular part of the HYB format. The default is to let the library automatically decide how to split the data.",1
1026,"public enum cusparseSolvePolicy
{
/// <summary>
/// no level information is generated, only reports structural zero.
/// </summary>
NoLevel = 0,
/// <summary>
/// /// </summary>
UseLevel = 1
}","used in csrsv2, csric02, and csrilu02",1
1027,"public enum InterpolationMode
{
/// <summary>
/// Undefined
/// </summary>
Undefined = 0,
/// <summary>
/// Nearest neighbor filtering.
/// </summary>
NearestNeighbor = 1,
/// <summary>
/// Linear interpolation.
/// </summary>
Linear = 2,
/// <summary>
/// Cubic interpolation.
/// </summary>
Cubic = 4,
/// <summary>
/// Super sampling.
/// </summary>
SuperSampling = 8,
/// <summary>
/// Lanczos filtering.
/// </summary>
Lanczos = 16, /// <summary>
/// Generic Lanczos filtering with order 3.
/// </summary>
Lanczos3Advanced = 17,
/// <summary>
/// Smooth edge filtering.
/// </summary>
SmoothEdge = (1 << 31)
}",Filtering methods,1
1028,"public enum MaskSize
{
/// <summary/>
Size_1_X_3,
/// <summary/>
Size_1_X_5,
/// <summary/>
Size_3_X_1 = 100, // leaving space for more 1 X N type enum values /// <summary/>
Size_5_X_1,
/// <summary/>
Size_3_X_3 = 200, // leaving space for more N X 1 type enum values
/// <summary/>
Size_5_X_5,
/// <summary/>
Size_7_X_7 = 400,
/// <summary/>
Size_9_X_9 = 500,
/// <summary/>
Size_11_X_11 = 600,
/// <summary/>
Size_13_X_13 = 700,
/// <summary/>
Size_15_X_15 = 800
}",Fixed filter-kernel sizes.,1
1029,"public enum GpuComputeCapability
{
/// <summary>
/// Indicates that the compute-capability query failed
/// </summary>
UnknownVersion = -1,
/// <summary>
/// Indicates that no CUDA capable device was found on machine
/// </summary>
CudaNotCapable = 0,
/// <summary>
/// Indicates that CUDA 1.0 capable device is default device on machine
/// </summary>
Cuda1_0 = 100,
/// <summary>
/// Indicates that CUDA 1.1 capable device
/// </summary>
Cuda1_1 = 110,
/// <summary>
/// Indicates that CUDA 1.2 capable device
/// </summary>
Cuda1_2 = 120,
/// <summary>
/// Indicates that CUDA 1.3 capable device
/// </summary>
Cuda1_3 = 130,
/// <summary>
/// Indicates that CUDA 2.0 capable device is machine's default device
/// </summary>
Cuda2_0 = 200,
/// <summary>
/// Indicates that CUDA 2.1 capable device is machine's default device
/// </summary>
Cuda2_1 = 210,
/// <summary>
/// Indicates that CUDA 3.0 capable device is machine's default device
/// </summary>
Cuda3_0 = 300,
/// <summary>
/// Indicates that CUDA 3.2 capable device is machine's default device
/// </summary>
Cuda3_2 = 320,
/// <summary>
/// Indicates that CUDA 3.5 capable device is machine's default device
/// </summary>
Cuda3_5 = 350,
/// <summary>
/// Indicates that CUDA 3.7 capable device is machine's default device
/// </summary>
Cuda3_7 = 370,
/// <summary>
/// Indicates that CUDA 5.0 capable device is machine's default device
/// </summary>
Cuda5_0 = 500, /// <summary>
/// Indicates that CUDA 5.2 capable device is machine's default device
/// </summary>
Cuda5_2 = 520,
/// <summary>
/// Indicates that CUDA 5.3 capable device is machine's default device
/// </summary>
Cuda5_3 = 530,
/// <summary>
/// Indicates that CUDA 6.0 capable device is machine's default device
/// </summary>
Cuda6_0 = 600,
/// <summary>
/// Indicates that CUDA 6.1 capable device is machine's default device
/// </summary>
Cuda6_1 = 610,
/// <summary>
/// Indicates that CUDA 6.2 capable device is machine's default device
/// </summary>
Cuda6_2 = 620,
/// <summary>
/// Indicates that CUDA 6.3 capable device is machine's default device
/// </summary>
Cuda6_3 = 630,
/// <summary>
/// Indicates that CUDA 7.0 capable device is machine's default device
/// </summary>
Cuda7_0 = 700,
/// <summary>
/// Indicates that CUDA 7.2 capable device is machine's default device
/// </summary>
Cuda7_2 = 720,
/// <summary>
/// Indicates that CUDA 7.3 capable device is machine's default device
/// </summary>
Cuda7_3 = 730,
/// <summary>
/// Indicates that CUDA 7.5 or better is machine's default device
/// </summary>
Cuda7_5 = 750
}",Gpu Compute Capabilities,1
1030,"public enum NppiAxis
{
/// <summary>
/// /// </summary>
Horizontal,
/// <summary>
/// /// </summary>
Vertical,
/// <summary>
/// /// </summary>
Both
}",Axis,0
1031,"public enum NppCmpOp
{
/// <summary>
/// /// </summary>
Less,
/// <summary>
/// /// </summary>
LessEq,
/// <summary>
/// /// </summary>
Eq,
/// <summary>
/// /// </summary>
GreaterEq,
/// <summary>
/// /// </summary>
Greater
}",Compare Operator,1
1032,"public enum NppRoundMode
{
/// <summary>
/// Round towards zero (truncation).<para/> /// All fractional numbers of the form integer.decimals are truncated to
/// integer.<para/>
/// - roundZero(1.5) = 1<para/>
/// - roundZero(1.9) = 1<para/>
/// - roundZero(-2.5) = -2<para/>
/// </summary>
Zero,
/// <summary>
/// Round towards zero (truncation).<para/> /// All fractional numbers of the form integer.decimals are truncated to
/// integer.<para/>
/// - roundZero(1.5) = 1<para/>
/// - roundZero(1.9) = 1<para/>
/// - roundZero(-2.5) = -2<para/>
/// </summary>
RoundTowardZero,
/// <summary>
/// Round to the nearest even integer.<para/>
/// All fractional numbers are rounded to their nearest integer. The ambiguous
/// cases (i.e. integer.5) are rounded to the closest even integer.<para/>
/// E.g.<para/>
/// - roundNear(0.5) = 0<para/>
/// - roundNear(0.6) = 1<para/>
/// - roundNear(1.5) = 2<para/>
/// - roundNear(-1.5) = -2<para/>
/// </summary>
Near,
/// <summary>
/// Round to the nearest even integer.<para/>
/// All fractional numbers are rounded to their nearest integer. The ambiguous
/// cases (i.e. integer.5) are rounded to the closest even integer.<para/>
/// E.g.<para/>
/// - roundNear(0.5) = 0<para/>
/// - roundNear(0.6) = 1<para/>
/// - roundNear(1.5) = 2<para/>
/// - roundNear(-1.5) = -2<para/>
/// </summary>
RoundNearestTiesToEven = Near,
/// <summary>
/// Round according to financial rule.<para/>
/// All fractional numbers are rounded to their nearest integer. The ambiguous
/// cases (i.e. integer.5) are rounded away from zero.<para/>
/// E.g.<para/>
/// - roundFinancial(0.4) = 0<para/>
/// - roundFinancial(0.5) = 1<para/>
/// - roundFinancial(-1.5) = -2<para/>
/// </summary>
Financial,
/// <summary>
/// Round according to financial rule.<para/>
/// All fractional numbers are rounded to their nearest integer. The ambiguous
/// cases (i.e. integer.5) are rounded away from zero.<para/>
/// E.g.<para/>
/// - roundFinancial(0.4) = 0<para/>
/// - roundFinancial(0.5) = 1<para/>
/// - roundFinancial(-1.5) = -2<para/>
/// </summary>
RoundNearestTiesAwayFromZero = Financial
}",Rounding Modes,1
1033,"public enum NppiBorderType
{
/// <summary/>
Undefined = 0,
/// <summary/>
None = Undefined,
/// <summary/>
Constant = 1,
/// <summary/>
Replicate = 2,
/// <summary/>
Wrap = 3,
/// <summary/>
Mirror = 4
}",BorderType,1
1034,"public enum NppHintAlgorithm
{
/// <summary>
/// /// </summary>
None,
/// <summary>
/// /// </summary>
Fast,
/// <summary>
/// /// </summary>
Accurate
}",HintAlgorithm,1
1035,"public enum NppiAlphaOp
{
/// <summary>
/// /// </summary>
Over,
/// <summary>
/// /// </summary>
In,
/// <summary>
/// /// </summary>
Out,
/// <summary>
/// /// </summary>
Atop,
/// <summary>
/// /// </summary>
XOR,
/// <summary>
/// /// </summary>
Plus,
/// <summary>
/// /// </summary>
OverPremul,
/// <summary>
/// /// </summary>
InPremul,
/// <summary>
/// /// </summary>
OutPremul,
/// <summary>
/// /// </summary>
AtopPremul,
/// <summary>
/// /// </summary>
XORPremul,
/// <summary>
/// /// </summary>
PlusPremul,
/// <summary>
/// /// </summary>
Premul
}",NppiAlphaOp,1
1036,"public enum NppsZCType
{
/// <summary>
/// sign change
/// </summary>
nppZCR,
/// <summary>
/// sign change XOR
/// </summary>
nppZCXor,
/// <summary>
/// sign change count_0
/// </summary>
nppZCC }",NppsZCType,1
1037,"public enum NppiHuffmanTableType
{
/// <summary>
/// DC Table
/// </summary>
nppiDCTable,
/// <summary>
/// AC Table
/// </summary>
nppiACTable,
}",NppiHuffmanTableType,1
1038,"public enum NppiNorm
{
/// <summary>
/// maximum
/// </summary>
nppiNormInf = 0,
/// <summary>
/// sum
/// </summary>
nppiNormL1 = 1,
/// <summary>
/// square root of sum of squares
/// </summary>
nppiNormL2 = 2
}",NppiNorm,1
1039,"public enum NppiBayerGridPosition
{
/// <summary/>
BGGR = 0,
/// <summary/> RGGB = 1,
/// <summary/>
GBRG = 2,
/// <summary/>
GRBG = 3
}",Bayer Grid Position Registration.,1
1040,"public enum ComplexChannel
{
/// <summary>
/// Real part of the complex number
/// </summary>
Real = 0,
/// <summary>
/// Imaginary part of the complex number
/// </summary>
Imag = 1
}",Channel indicator for complex numbers,1
1041,"public enum NppiJpegDecodeJobKind
{
/// <summary>
/// Decode whole scan using a single job
/// </summary>
NPPI_JPEG_DECODE_SIMPLE,
/// <summary>
/// Preprocessing scan on GPU
/// </summary>
NPPI_JPEG_DECODE_PRE,
/// <summary>
/// Part of decoding run on CPU
/// </summary>
NPPI_JPEG_DECODE_CPU,
/// <summary>
/// Part of decoding run on GPU
/// </summary>
NPPI_JPEG_DECODE_GPU,
/// <summary>
/// Zeroing memory before decoding
/// </summary>
NPPI_JPEG_DECODE_MEMZERO,
/// <summary>
/// Change memory representation of DCT coefficients to final
/// </summary>
NPPI_JPEG_DECODE_FINALIZE
}","Type of job to execute. Usually you will need just SIMPLE for each scan, one MEMZERO at the beginning and FINALIZE at the end. See the example in nppiJpegDecodeJob SIMPLE can be split into multiple jobs: PRE, CPU & GPU. Please note that if you don't use SIMPLE, you man need to add some memcopies and synchronizes as described in nppiJpegDecodeJob.",1
1042,"public enum nvgraphStatus
{
Success = 0,
NotInitialized = 1,
AllocFailed = 2,
InvalidValue = 3,
ArchMismatch = 4,
MappingError = 5,
ExecutionFailed = 6,
InternalError = 7,
TypeNotSupported = 8,
NotConverged = 9
}",nvGRAPH status type returns,1
1043,"public enum nvgraphSemiring
{
PlusTimesSR = 0,
MinPlusSR = 1,
MaxMinSR = 2,
OrAndSR = 3,
}",Semi-ring types,0
1044,"public enum nvmlNvLinkUtilizationCountUnits
{
/// <summary>
/// count by cycles
/// </summary>
Cycles = 0, /// <summary>
/// count by packets
/// </summary>
Packets = 1,
/// <summary>
/// count by bytes
/// </summary>
Bytes = 2, }",enum to represent the NvLink utilization counter packet units,1
1045,"public enum nvmlNvLinkUtilizationCountPktTypes
{
/// <summary>
/// no operation packets
/// </summary>
PktFilterNop = 0x1, /// <summary>
/// read packets
/// </summary>
PktFilterRead = 0x2, /// <summary>
/// write packets
/// </summary>
PktFilterWrite = 0x4, /// <summary>
/// reduction atomic requests
/// </summary>
PktFilterRAtom = 0x8, /// <summary>
/// non-reduction atomic requests
/// </summary>
PktFilterNRAtom = 0x10, /// <summary>
/// flush requests
/// </summary>
PktFilterFlush = 0x20, /// <summary>
/// responses with data
/// </summary>
PktFilterRespData = 0x40, /// <summary>
/// responses without data
/// </summary>
PktFilterRespNoData = 0x80, /// <summary>
/// all packets
/// </summary>
PktFilterAll= 0xFF }","enum to represent the NvLink utilization counter packet types to count ** this is ONLY applicable with the units as packets or bytes ** all packet filter descriptions are target GPU centric ** these can be ""OR'd"" together",1
1046,"public enum nvmlNvLinkCapability
{
/// <summary>
/// P2P over NVLink is supported
/// </summary>
P2PSupported = 0, /// <summary>
/// Access to system memory is supported
/// </summary>
SysMemAccess = 1, /// <summary>
/// P2P atomics are supported
/// </summary>
P2PAtomics = 2, /// <summary>
/// System memory atomics are supported
/// </summary>
SysMemAtomics = 3, /// <summary>
/// SLI is supported over this link
/// </summary>
SLIBridge = 4, /// <summary>
/// Link is supported on this device
/// </summary>
Valid = 5, }",enum to represent NvLink queryable capabilities,1
1047,"public enum nvmlNvLinkErrorCounter
{
/// <summary>
/// Data link transmit replay error counter
/// </summary>
DLReplay = 0, /// <summary>
/// Data link transmit recovery error counter
/// </summary>
DLRecovery = 1, /// <summary>
/// Data link receive flow control digit CRC error counter
/// </summary>
DL_CRC_FLIT = 2, /// <summary>
/// Data link receive data CRC error counter
/// </summary>
DL_CRC_Data = 3, }",enum to represent NvLink queryable error counters,1
1048,"public enum nvmlGpuTopologyLevel
{
/// <summary>
/// e.g. Tesla K80
/// </summary>
Internal = 0, /// <summary>
/// all devices that only need traverse a single PCIe switch
/// </summary>
Single = 10, /// <summary>
/// all devices that need not traverse a host bridge
/// </summary>
Multiple = 20, /// <summary>
/// all devices that are connected to the same host bridge
/// </summary>
Hostbridge = 30, /// <summary>
/// all devices that are connected to the same CPU but possibly multiple host bridges
/// </summary>
CPU = 40, /// <summary>
/// all devices in the system
/// </summary>
System = 50, }",Represents level relationships within a system between two GPUs The enums are spaced to allow for future relationships,1
1049,"public enum nvmlSamplingType
{
/// <summary>
/// To represent total power drawn by GPU
/// </summary>
NVMLOTAL_POWER_SAMPLES = 0,
/// <summary>
/// To represent percent of time during which one or more kernels was executing on the GPU
/// </summary>
NVML_GPU_UTILIZATION_SAMPLES = 1,
/// <summary>
/// To represent percent of time during which global (device) memory was being read or written
/// </summary>
NVML_MEMORY_UTILIZATION_SAMPLES = 2,
/// <summary>
/// To represent percent of time during which NVENC remains busy
/// </summary>
NVML_ENC_UTILIZATION_SAMPLES = 3,
/// <summary>
/// To represent percent of time during which NVDEC remains busy /// </summary>
NVML_DEC_UTILIZATION_SAMPLES = 4,
/// <summary>
/// To represent processor clock samples
/// </summary> NVML_PROCESSOR_CLK_SAMPLES = 5,
/// <summary>
/// To represent memory clock samples
/// </summary>
NVML_MEMORY_CLK_SAMPLES = 6 }",Represents Type of Sampling Event,1
1050,"public enum nvmlPcieUtilCounter
{
/// <summary>
/// 1KB granularity
/// </summary>
TXBytes = 0,
/// <summary>
/// 1KB granularity
/// </summary>
RXBytes = 1
}",Represents the queryable PCIe utilization counters,1
1051,"public enum nvmlEnableState {
/// <summary>
/// Feature disabled /// </summary>
Disabled = 0, /// <summary>
/// Feature enabled
/// </summary>
Enabled = 1 }",Generic enable/disable enum.,0
1052,"public enum nvmlBrandType
{
Unknown = 0, Quadro = 1,
Tesla = 2,
Nvs = 3,
Grid = 4,
GeForce = 5
}",The Brand of the GPU,0
1053,"public enum nvmlTemperatureThresholds
{
/// <summary>
/// Temperature at which the GPU will shut down for HW protection
/// </summary>
Shutdown = 0,
/// <summary>
/// Temperature at which the GPU will begin slowdown
/// </summary>
Slowdown = 1
}",Temperature thresholds.,0
1054,"public enum nvmlTemperatureSensors {
/// <summary>
/// Temperature sensor for the GPU die
/// </summary>
Gpu = 0
}",Temperature sensors.,0
1055,"public enum nvmlComputeMode {
/// <summary>
/// Default compute mode -- multiple contexts per device
/// </summary>
Default = 0,
/// <summary>
/// Support Removed
/// </summary>
ExclusiveThread = 1,
/// <summary>
/// Compute-prohibited mode -- no contexts per device
/// </summary>
Prohibited = 2,
/// <summary>
/// Compute-exclusive-process mode -- only one context per device, usable from multiple threads at a time
/// </summary>
ExclusiveProcess = 3,
}","Compute mode. NVML_COMPUTEMODE_EXCLUSIVE_PROCESS was added in CUDA 4.0. Earlier CUDA versions supported a single exclusive mode, which is equivalent to NVML_COMPUTEMODE_EXCLUSIVE_THREAD in CUDA 4.0 and beyond.",0
1056,"public enum nvmlMemoryErrorType
{
/// <summary>
/// A memory error that was corrected<para/>
/// For ECC errors, these are single bit errors<para/>
/// For Texture memory, these are errors fixed by resend
/// </summary>
Corrected = 0,
/// <summary>
/// A memory error that was not corrected<para/>
/// For ECC errors, these are double bit errors<para/>
/// For Texture memory, these are errors where the resend fails
/// </summary>
Uncorrected = 1
}",Memory error types,0
1057,"public enum nvmlEccCounterType {
/// <summary>
/// Volatile counts are reset each time the driver loads.
/// </summary>
VolatileECC = 0, /// <summary>
/// Aggregate counts persist across reboots (i.e. for the lifetime of the device)
/// </summary>
AggregateECC = 1, }",ECC counter types.,0
1058,"public enum nvmlClockType {
/// <summary>
/// Graphics clock domain /// </summary>
Graphics = 0,
/// <summary>
/// SM clock domain
/// </summary>
SM = 1, /// <summary>
/// Memory clock domain
/// </summary>
Mem = 2,
/// <summary>
/// Video encoder/decoder clock domain
/// </summary>
Video = 3
}",Clock types. All speeds are in Mhz.,0
1059,"public enum nvmlClockId
{
/// <summary>
/// Current actual clock value
/// </summary>
Current = 0, /// <summary>
/// Target application clock
/// </summary>
AppClockTarget = 1, /// <summary>
/// Default application clock target
/// </summary>
ClockDefault = 2, /// <summary>
/// OEM-defined maximum clock rate
/// </summary>
CustomerBoostMax = 3, }",Clock Ids. These are used in combination with nvmlClockType to specify a single clock value.,1
1060,"public enum nvmlDriverModel {
/// <summary>
/// WDDM driver model -- GPU treated as a display device
/// </summary>
WDDM = 0, /// <summary>
/// WDM (TCC) model (recommended) -- GPU treated as a generic device
/// </summary>
WDM = 1
}",Driver models. Windows only.,0
1061,"public enum nvmlPstates {
/// <summary>
/// Performance state 0 -- Maximum Performance
/// </summary>
PState_0 = 0, /// <summary>
/// Performance state 1 /// </summary>
PState_1 = 1, /// <summary>
/// Performance state 2
/// </summary>
PState_2 = 2, /// <summary>
/// Performance state 3
/// </summary>
PState_3 = 3, /// <summary>
/// Performance state 4
/// </summary>
PState_4 = 4, /// <summary>
/// Performance state 5
/// </summary>
PState_5 = 5, /// <summary>
/// Performance state 6
/// </summary>
PState_6 = 6, /// <summary>
/// Performance state 7
/// </summary>
PState_7 = 7, /// <summary>
/// Performance state 8
/// </summary>
PState_8 = 8, /// <summary>
/// Performance state 9
/// </summary>
PState_9 = 9, /// <summary>
/// Performance state 10
/// </summary>
PState_10 = 10,
/// <summary>
/// Performance state 11
/// </summary>
PState_11 = 11,
/// <summary>
/// Performance state 12
/// </summary>
PState_12 = 12,
/// <summary>
/// Performance state 13
/// </summary>
PState_13 = 13,
/// <summary>
/// Performance state 14
/// </summary>
PState_14 = 14,
/// <summary>
/// Performance state 15 -- Minimum Performance /// </summary>
PState_15 = 15,
/// <summary>
/// Unknown performance state
/// </summary>
PState_UNKNOWN = 32 }",Allowed PStates.,0
1062,"public enum nvmlGpuOperationMode
{
/// <summary>
/// Everything is enabled and running at full speed
/// </summary>
AllOn = 0,
/// <summary>
/// Designed for running only compute tasks. Graphics operations are not allowed
/// </summary>
Compute = 1, /// <summary>
/// Designed for running graphics applications that don't require high bandwidth double precision
/// </summary>
LowDP = 2 }",GPU Operation Mode GOM allows to reduce power usage and optimize GPU throughput by disabling GPU features. Each GOM is designed to meet specific user needs.,1
1063,"public enum nvmlInforomObject {
/// <summary>
/// An object defined by OEM
/// </summary>
OEM = 0, /// <summary>
/// The ECC object determining the level of ECC support
/// </summary>
ECC = 1,
/// <summary>
/// The power management object
/// </summary>
Power = 2
}",Available infoROM objects.,0
1064,"public enum nvmlReturn {
/// <summary>
/// The operation was successful
/// </summary>
Success = 0, /// <summary>
/// NVML was not first initialized with nvmlInit()
/// </summary>
Uninitialized = 1, /// <summary>
/// A supplied argument is invalid
/// </summary>
InvalidArgument = 2, /// <summary>
/// The requested operation is not available on target device
/// </summary>
NotSupported = 3, /// <summary>
/// The current user does not have permission for operation
/// </summary>
NoPermission = 4, /// <summary>
/// Deprecated: Multiple initializations are now allowed through ref counting
/// </summary>
[Obsolete(""Deprecated: Multiple initializations are now allowed through ref counting"")]
AlreadyInitialized = 5,
/// <summary>
/// A query to find an object was unsuccessful
/// </summary>
NotFound = 6, /// <summary>
/// An input argument is not large enough
/// </summary>
InsufficientSize = 7, /// <summary>
/// A device's external power cables are not properly attached
/// </summary>
InsufficientPower = 8, /// <summary>
/// NVIDIA driver is not loaded
/// </summary>
DriverNotLoaded = 9, /// <summary>
/// User provided timeout passed
/// </summary>
TimeOut = 10, /// <summary>
/// NVIDIA Kernel detected an interrupt issue with a GPU
/// </summary>
IRQIssue = 11, /// <summary>
/// NVML Shared Library couldn't be found or loaded
/// </summary>
LibraryNotFound = 12, /// <summary>
/// Local version of NVML doesn't implement this function
/// </summary>
FunctionNotFound = 13,
/// <summary>
/// infoROM is corrupted
/// </summary>
CorruptedInfoROM = 14, /// <summary>
/// The GPU has fallen off the bus or has otherwise become inaccessible
/// </summary>
GPUIsLost = 15, /// <summary>
/// The GPU requires a reset before it can be used again
/// </summary>
ResetRequired = 16, /// <summary>
/// The GPU control device has been blocked by the operating system/cgroups
/// </summary>
OperatingSystem = 17, /// <summary>
/// RM detects a driver/library version mismatch
/// </summary>
LibRMVersionMismatch = 18, /// <summary>
/// An operation cannot be performed because the GPU is currently in use
/// </summary>
InUse = 19, /// <summary>
/// An internal driver error occurred
/// </summary>
Unknown = 999 }",Return values for NVML API calls.,0
1065,"public enum nvmlMemoryLocation
{
/// <summary>
/// GPU L1 Cache
/// </summary>
L1Cache = 0, /// <summary>
/// GPU L2 Cache
/// </summary>
L2Cache = 1, /// <summary>
/// GPU Device Memory
/// </summary>
DeviceMemory = 2, /// <summary>
/// GPU Register File
/// </summary>
RegisterFile = 3, /// <summary>
/// GPU Texture Memory
/// </summary>
TextureMemory = 4,
/// <summary>
/// Shared memory
/// </summary>
TextureSHM = 5
}",Memory locations,0
1066,"public enum nvmlPageRetirementCause
{
/// <summary>
/// Page was retired due to multiple single bit ECC error
/// </summary>
MultipleSingleBitECCErrors = 0,
/// <summary>
/// Page was retired due to double bit ECC error
/// </summary>
DoubleBitECCError = 1
}",Causes for page retirement,0
1067,"public enum nvmlRestrictedAPI
{
/// <summary>
/// APIs that change application clocks, see nvmlDeviceSetApplicationsClocks and see nvmlDeviceResetApplicationsClocks
/// </summary>
ApplicationClocks = 0, /// <summary>
/// APIs that enable/disable auto boosted clocks see nvmlDeviceSetAutoBoostedClocksEnabled
/// </summary>
AutoBoostedClocks = 1
}",API types that allow changes to default permission restrictions,0
1068,"public enum nvmlFanState {
/// <summary>
/// Fan is working properly
/// </summary>
Normal = 0, /// <summary>
/// Fan has failed /// </summary>
Failed = 1
}",Fan state enum.,0
1069,"public enum nvmlLedColor {
/// <summary>
/// GREEN, indicates good health
/// </summary>
Green = 0, /// <summary>
/// AMBER, indicates problem
/// </summary>
Amber = 1
}",Led color enum.,0
1070,"public enum nvmlEventType : long
{
/// <summary>
/// Event about single bit ECC errors
/// </summary>
SingleBitEccError = 0x0000000000000001L,
/// <summary>
/// Event about double bit ECC errors
/// </summary>
DoubleBitEccError = 0x0000000000000002L,
/// <summary>
/// Event about PState changes
/// </summary>
PState = 0x0000000000000004L,
/// <summary>
/// Event that Xid critical error occurred
/// </summary>
XidCriticalError = 0x0000000000000008L,
/// <summary>
/// Event about clock changes
/// </summary>
Clock = 0x0000000000000010L,
/// <summary>
/// Mask with no events
/// </summary>
None = 0x0000000000000000L,
/// <summary>
/// Mask of all events
/// </summary>
All = (None | SingleBitEccError | DoubleBitEccError | PState | Clock | XidCriticalError)
}",Event Types which user can be notified about. Types can be combined with bitwise or operator '|' when passed to nvmlDeviceRegisterEvents,1
1071,"public enum nvmlClocksThrottleReason : ulong
{
/// <summary>
/// Nothing is running on the GPU and the clocks are dropping to Idle state
/// </summary>
GpuIdle = 0x0000000000000001L,
/// <summary>
/// GPU clocks are limited by current setting of applications clocks
/// </summary>
ApplicationsClocksSetting = 0x0000000000000002L,
/// <summary>
/// SW Power Scaling algorithm is reducing the clocks below requested clocks /// </summary>
SwPowerCap = 0x0000000000000004L,
/// <summary>
/// HW Slowdown (reducing the core clocks by a factor of 2 or more) is engaged<para/>
/// This is an indicator of:<para/>
/// - temperature being too high<para/>
/// - External Power Brake Assertion is triggered (e.g. by the system power supply)<para/>
/// - Power draw is too high and Fast Trigger protection is reducing the clocks<para/>
/// - May be also reported during PState or clock change<para/>
/// - This behavior may be removed in a later release.<para/>
/// </summary>
HwSlowdown = 0x0000000000000008L,
/// <summary>
/// Sync Boost. /// This GPU has been added to a Sync boost group with nvidia-smi or DCGM in
/// order to maximize performance per watt. All GPUs in the sync boost group
/// will boost to the minimum possible clocks across the entire group. Look at
/// the throttle reasons for other GPUs in the system to see why those GPUs are
/// holding this one at lower clocks.
/// </summary>
SyncBoost = 0x0000000000000010L,
/// <summary>
/// Some other unspecified factor is reducing the clocks
/// </summary>
Unknown = 0x8000000000000000L,
/// <summary>
/// Bit mask representing no clocks throttling. Clocks are as high as possible.
/// </summary>
None = 0x0000000000000000L,
/// <summary>
/// Bit mask representing all supported clocks throttling reasons. New reasons might be added to this list in the future
/// </summary>
All = (None | GpuIdle | ApplicationsClocksSetting | SwPowerCap | HwSlowdown | SyncBoost | Unknown) }",nvmlClocksThrottleReasons,0
1072,"public enum nvrtcResult
{
/// <summary/>
Success = 0,
/// <summary/>
ErrorOutOfMemory = 1,
/// <summary/>
ErrorProgramCreationFailure = 2,
/// <summary/>
ErrorInvalidInput = 3,
/// <summary/>
ErrorInvalidProgram = 4,
/// <summary/>
ErrorInvalidOption = 5,
/// <summary/>
ErrorCompilation = 6,
/// <summary/>
ErrorBuiltinOperationFailure = 7,
/// <summary/>
NoNameExpressionsAfterCompilation = 8,
/// <summary/>
NoLoweredNamesBeforeCompilation = 9,
/// <summary/>
ExpressionNotValid = 10,
/// <summary/>
InternalError = 11
}",CUDA Online Compiler API call result code.,0
1073,"public enum State
{
/// <summary>
/// Read header represenation state.
/// </summary>
READ_HEADER_REPRESENTATION,
/// <summary>
/// Read max dynamic table size state.
/// </summary>
READ_MAX_DYNAMIC_TABLE_SIZE,
/// <summary>
/// Read indexed header state.
/// </summary>
READ_INDEXED_HEADER,
/// <summary>
/// Read indexed header name state.
/// </summary>
READ_INDEXED_HEADER_NAME,
/// <summary>
/// Read literal header name length prefix state.
/// </summary>
READ_LITERAL_HEADER_NAME_LENGTH_PREFIX,
/// <summary>
/// Read literal header name length state.
/// </summary>
READ_LITERAL_HEADER_NAME_LENGTH,
/// <summary>
/// Read literal header name state.
/// </summary>
READ_LITERAL_HEADER_NAME,
/// <summary>
/// Skip literal header name state.
/// </summary>
SKIP_LITERAL_HEADER_NAME,
/// <summary>
/// Read literal header value length prefix state.
/// </summary>
READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX,
/// <summary>
/// Read literal header value length state.
/// </summary>
READ_LITERAL_HEADER_VALUE_LENGTH,
/// <summary>
/// Read literal header value state.
/// </summary>
READ_LITERAL_HEADER_VALUE,
/// <summary>
/// Skip literal header value state.
/// </summary>
SKIP_LITERAL_HEADER_VALUE
}",The State enum.,1
1074,"public int Length()
{
var length = 0;
if (this.head < this.tail) {
length = this.headerFields.Length - this.tail + this.head;
} else {
length = this.head - this.tail;
}
return length;
}",Return the number of header fields in the dynamic table.,1
1075,"public HeaderField Remove()
{
var removed = this.headerFields[this.tail];
if (removed == null) {
return null;
}
this.size -= removed.Size;
this.headerFields[this.tail++] = null;
if (this.tail == this.headerFields.Length) {
this.tail = 0;
}
return removed;
}",Remove and return the oldest header field from the dynamic table.,1
1076,"public void Clear()
{
while(this.tail != this.head) {
this.headerFields[this.tail++] = null;
if (this.tail == this.headerFields.Length) {
this.tail = 0;
}
}
this.head = 0;
this.tail = 0;
this.size = 0;
}",Remove all entries from the dynamic table.,1
1077,"public int Length()
{
return this.size == 0 ? 0 : this.head.After.Index - this.head.Before.Index + 1;
}",Return the number of header fields in the dynamic table. Exposed for testing.,1
1078,"private HeaderField Remove()
{
if (this.size == 0) {
return null;
}
var eldest = this.head.After;
var h = eldest.Hash;
var i = Encoder.Index(h);
var prev = this.headerFields[i];
var e = prev;
while(e != null) {
var next = e.Next;
if (e == eldest) {
if (prev == eldest) {
this.headerFields[i] = next;
} else {
prev.Next = next;
}
eldest.Remove();
this.size -= eldest.Size;
return eldest;
}
prev = e;
e = next;
}
return null;
}",Remove and return the oldest header field from the dynamic table.,1
1079,"private void Clear()
{
for(var i = 0; i < this.headerFields.Length; i++) {
this.headerFields[i] = null;
}
this.head.Before = this.head.After = this.head;
this.size = 0;
}",Remove all entries from the dynamic table.,1
1080,"public void Remove()
{
this.before.after = this.after;
this.after.before = this.before;
}",Removes this entry from the linked list.,1
1081,"public static sbyte[] DecodeHex(char[] data)
{
var len = data.Length;
if ((len & 0x01) != 0) {
throw new IOException(""Odd number of characters."");
}
var output = new sbyte[len >> 1];
// two characters form the hex value.
for(int i = 0, j = 0; j < len; i++) {
var f = Hex.ToDigit(data[j], j) << 4;
j++;
f = f | Hex.ToDigit(data[j], j);
j++;
output[i] = (sbyte)(f & 0xFF);
}
return output;
}","Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The returned array will be half the length of the passed array, as it takes two characters to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.",1
1082,"public static char[] EncodeHex(byte[] data, bool toLowerCase)
{
return Hex.EncodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);
}","Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order. The returned array will be double the length of the passed array, as it takes two characters to represent any given byte.",1
1083,"public static String EncodeHexString(byte[] data)
{
return new String(Hex.EncodeHex(data));
}","Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned String will be double the length of the passed array, as it takes two characters to represent any given byte.",1
1084,"protected static char[] EncodeHex(byte[] data, char[] toDigits)
{
var l = data.Length;
var output = new char[l << 1];
// two characters form the hex value.
for(int i = 0, j = 0; i < l; i++) {
output[j++] = toDigits[(0xF0 & data[i]) >> 4];
output[j++] = toDigits[0x0F & data[i]];
}
return output;
}","Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order. The returned array will be double the length of the passed array, as it takes two characters to represent any given byte.",1
1085,"protected static int ToDigit(char ch, int index)
{
var digit = Convert.ToInt32(ch) - 48;
if (digit >= 17 && digit <= 22) {
digit -= 7;
}
if (digit >= 49 && digit <= 54) {
digit -= 39;
}
if (digit < 0 || digit > 15) {
throw new IOException(""Illegal hexadecimal character "" + ch + "" at index "" + index + ""; digit: "" + digit);
}
return digit;
}",Converts a hexadecimal character to an integer.,1
1086,"private void InitializeComponent()
{
this.components = new System.ComponentModel.Container();
this.BackPanel = new System.Windows.Forms.Panel();
this.Turn = new System.Windows.Forms.Label();
this.RemoveButton = new System.Windows.Forms.Button();
this.AddButton = new System.Windows.Forms.Button();
this.CurrentWord = new System.Windows.Forms.Label();
this.Words = new System.Windows.Forms.RichTextBox();
this.TimeProgress = new System.Windows.Forms.ProgressBar();
this.b14 = new System.Windows.Forms.Button();
this.b13 = new System.Windows.Forms.Button();
this.b12 = new System.Windows.Forms.Button();
this.b11 = new System.Windows.Forms.Button();
this.b10 = new System.Windows.Forms.Button();
this.b9 = new System.Windows.Forms.Button();
this.b8 = new System.Windows.Forms.Button();
this.b7 = new System.Windows.Forms.Button();
this.b6 = new System.Windows.Forms.Button();
this.b5 = new System.Windows.Forms.Button();
this.b4 = new System.Windows.Forms.Button();
this.b3 = new System.Windows.Forms.Button();
this.b2 = new System.Windows.Forms.Button();
this.b1 = new System.Windows.Forms.Button();
this.StartButton = new System.Windows.Forms.Button();
this.MyTimer = new System.Windows.Forms.Timer(this.components);
this.OpponentTimer = new System.Windows.Forms.Timer(this.components);
this.TimerSecond = new System.Windows.Forms.Timer(this.components);
this.BackPanel.SuspendLayout();
this.SuspendLayout();
// // BackPanel
// this.BackPanel.BackColor = System.Drawing.SystemColors.ControlDark;
this.BackPanel.Controls.Add(this.Turn);
this.BackPanel.Controls.Add(this.RemoveButton);
this.BackPanel.Controls.Add(this.AddButton);
this.BackPanel.Controls.Add(this.CurrentWord);
this.BackPanel.Controls.Add(this.Words);
this.BackPanel.Controls.Add(this.TimeProgress);
this.BackPanel.Controls.Add(this.b14);
this.BackPanel.Controls.Add(this.b13);
this.BackPanel.Controls.Add(this.b12);
this.BackPanel.Controls.Add(this.b11);
this.BackPanel.Controls.Add(this.b10);
this.BackPanel.Controls.Add(this.b9);
this.BackPanel.Controls.Add(this.b8);
this.BackPanel.Controls.Add(this.b7);
this.BackPanel.Controls.Add(this.b6);
this.BackPanel.Controls.Add(this.b5);
this.BackPanel.Controls.Add(this.b4);
this.BackPanel.Controls.Add(this.b3);
this.BackPanel.Controls.Add(this.b2);
this.BackPanel.Controls.Add(this.b1);
this.BackPanel.Location = new System.Drawing.Point(12, 12);
this.BackPanel.Name = ""BackPanel"";
this.BackPanel.Size = new System.Drawing.Size(409, 258);
this.BackPanel.TabIndex = 0;
// // Turn
// this.Turn.AutoSize = true;
this.Turn.Font = new System.Drawing.Font(""Arial Narrow"", 14.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
this.Turn.ForeColor = System.Drawing.Color.Red;
this.Turn.Location = new System.Drawing.Point(243, 206);
this.Turn.Name = ""Turn"";
this.Turn.Size = new System.Drawing.Size(132, 23);
this.Turn.TabIndex = 20;
this.Turn.Text = "" !"";
// // RemoveButton
// this.RemoveButton.Location = new System.Drawing.Point(323, 34);
this.RemoveButton.Name = ""RemoveButton"";
this.RemoveButton.Size = new System.Drawing.Size(23, 23);
this.RemoveButton.TabIndex = 19;
this.RemoveButton.Text = ""-"";
this.RemoveButton.UseVisualStyleBackColor = true;
this.RemoveButton.Click += new System.EventHandler(this.RemoveButton_Click);
this.RemoveButton.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.RemoveButton_KeyPress);
// // AddButton
// this.AddButton.Location = new System.Drawing.Point(352, 34);
this.AddButton.Name = ""AddButton"";
this.AddButton.Size = new System.Drawing.Size(52, 23);
this.AddButton.TabIndex = 18;
this.AddButton.Text = ""+"";
this.AddButton.UseVisualStyleBackColor = true;
this.AddButton.Click += new System.EventHandler(this.AddButton_Click);
this.AddButton.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.AddButton_KeyPress);
// // CurrentWord
// this.CurrentWord.AutoSize = true;
this.CurrentWord.Font = new System.Drawing.Font(""Microsoft Sans Serif"", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(204)));
this.CurrentWord.Location = new System.Drawing.Point(212, 37);
this.CurrentWord.Name = ""CurrentWord"";
this.CurrentWord.Size = new System.Drawing.Size(0, 15);
this.CurrentWord.TabIndex = 17;
// // Words
// this.Words.BorderStyle = System.Windows.Forms.BorderStyle.None;
this.Words.Location = new System.Drawing.Point(4, 34);
this.Words.Name = ""Words"";
this.Words.ReadOnly = true;
this.Words.ScrollBars = System.Windows.Forms.RichTextBoxScrollBars.Vertical;
this.Words.Size = new System.Drawing.Size(197, 221);
this.Words.TabIndex = 15;
this.Words.Text = """";
this.Words.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.Words_KeyPress);
// // TimeProgress
// this.TimeProgress.Location = new System.Drawing.Point(207, 232);
this.TimeProgress.Name = ""TimeProgress"";
this.TimeProgress.Size = new System.Drawing.Size(197, 23);
this.TimeProgress.Style = System.Windows.Forms.ProgressBarStyle.Continuous;
this.TimeProgress.TabIndex = 14;
// // b14
// this.b14.Location = new System.Drawing.Point(381, 4);
this.b14.Name = ""b14"";
this.b14.Size = new System.Drawing.Size(23, 23);
this.b14.TabIndex = 13;
this.b14.UseVisualStyleBackColor = true;
this.b14.Click += new System.EventHandler(this.b14_Click);
this.b14.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b14_KeyPress);
// // b13
// this.b13.Location = new System.Drawing.Point(352, 4);
this.b13.Name = ""b13"";
this.b13.Size = new System.Drawing.Size(23, 23);
this.b13.TabIndex = 12;
this.b13.UseVisualStyleBackColor = true;
this.b13.Click += new System.EventHandler(this.b13_Click);
this.b13.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b13_KeyPress);
// // b12
// this.b12.Location = new System.Drawing.Point(323, 4);
this.b12.Name = ""b12"";
this.b12.Size = new System.Drawing.Size(23, 23);
this.b12.TabIndex = 11;
this.b12.UseVisualStyleBackColor = true;
this.b12.Click += new System.EventHandler(this.b12_Click);
this.b12.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b12_KeyPress);
// // b11
// this.b11.Location = new System.Drawing.Point(294, 4);
this.b11.Name = ""b11"";
this.b11.Size = new System.Drawing.Size(23, 23);
this.b11.TabIndex = 10;
this.b11.UseVisualStyleBackColor = true;
this.b11.Click += new System.EventHandler(this.b11_Click);
this.b11.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b11_KeyPress);
// // b10
// this.b10.Location = new System.Drawing.Point(265, 4);
this.b10.Name = ""b10"";
this.b10.Size = new System.Drawing.Size(23, 23);
this.b10.TabIndex = 9;
this.b10.UseVisualStyleBackColor = true;
this.b10.Click += new System.EventHandler(this.b10_Click);
this.b10.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b10_KeyPress);
// // b9
// this.b9.Location = new System.Drawing.Point(236, 4);
this.b9.Name = ""b9"";
this.b9.Size = new System.Drawing.Size(23, 23);
this.b9.TabIndex = 8;
this.b9.UseVisualStyleBackColor = true;
this.b9.Click += new System.EventHandler(this.b9_Click);
this.b9.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b9_KeyPress);
// // b8
// this.b8.Location = new System.Drawing.Point(207, 4);
this.b8.Name = ""b8"";
this.b8.Size = new System.Drawing.Size(23, 23);
this.b8.TabIndex = 7;
this.b8.UseVisualStyleBackColor = true;
this.b8.Click += new System.EventHandler(this.b8_Click);
this.b8.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b8_KeyPress);
// // b7
// this.b7.Location = new System.Drawing.Point(178, 4);
this.b7.Name = ""b7"";
this.b7.Size = new System.Drawing.Size(23, 23);
this.b7.TabIndex = 6;
this.b7.UseVisualStyleBackColor = true;
this.b7.Click += new System.EventHandler(this.b7_Click);
this.b7.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b7_KeyPress);
// // b6
// this.b6.Location = new System.Drawing.Point(149, 4);
this.b6.Name = ""b6"";
this.b6.Size = new System.Drawing.Size(23, 23);
this.b6.TabIndex = 5;
this.b6.UseVisualStyleBackColor = true;
this.b6.Click += new System.EventHandler(this.b6_Click);
this.b6.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b6_KeyPress);
// // b5
// this.b5.Location = new System.Drawing.Point(120, 4);
this.b5.Name = ""b5"";
this.b5.Size = new System.Drawing.Size(23, 23);
this.b5.TabIndex = 4;
this.b5.UseVisualStyleBackColor = true;
this.b5.Click += new System.EventHandler(this.b5_Click);
this.b5.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b5_KeyPress);
// // b4
// this.b4.Location = new System.Drawing.Point(91, 4);
this.b4.Name = ""b4"";
this.b4.Size = new System.Drawing.Size(23, 23);
this.b4.TabIndex = 3;
this.b4.UseVisualStyleBackColor = true;
this.b4.Click += new System.EventHandler(this.b4_Click);
this.b4.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b4_KeyPress);
// // b3
// this.b3.Location = new System.Drawing.Point(62, 4);
this.b3.Name = ""b3"";
this.b3.Size = new System.Drawing.Size(23, 23);
this.b3.TabIndex = 2;
this.b3.UseVisualStyleBackColor = true;
this.b3.Click += new System.EventHandler(this.b3_Click);
this.b3.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b3_KeyPress);
// // b2
// this.b2.Location = new System.Drawing.Point(33, 4);
this.b2.Name = ""b2"";
this.b2.Size = new System.Drawing.Size(23, 23);
this.b2.TabIndex = 1;
this.b2.UseVisualStyleBackColor = true;
this.b2.Click += new System.EventHandler(this.b2_Click);
this.b2.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b2_KeyPress);
// // b1
// this.b1.Location = new System.Drawing.Point(4, 4);
this.b1.Name = ""b1"";
this.b1.Size = new System.Drawing.Size(23, 23);
this.b1.TabIndex = 0;
this.b1.UseVisualStyleBackColor = true;
this.b1.Click += new System.EventHandler(this.b1_Click);
this.b1.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.b1_KeyPress);
// // StartButton
// this.StartButton.Location = new System.Drawing.Point(12, 276);
this.StartButton.Name = ""StartButton"";
this.StartButton.Size = new System.Drawing.Size(75, 23);
this.StartButton.TabIndex = 1;
this.StartButton.Text = """";
this.StartButton.UseVisualStyleBackColor = true;
this.StartButton.Click += new System.EventHandler(this.StartButton_Click);
this.StartButton.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.StartButton_KeyPress);
// // MyTimer
// this.MyTimer.Tick += new System.EventHandler(this.MyTimer_Tick);
// // OpponentTimer
// this.OpponentTimer.Tick += new System.EventHandler(this.OpponentTimer_Tick);
// // TimerSecond
// this.TimerSecond.Interval = 1000;
this.TimerSecond.Tick += new System.EventHandler(this.TimerSecond_Tick);
// // Client
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.BackColor = System.Drawing.SystemColors.ControlDarkDark;
this.ClientSize = new System.Drawing.Size(434, 305);
this.Controls.Add(this.StartButton);
this.Controls.Add(this.BackPanel);
this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
this.MaximizeBox = false;
this.MinimizeBox = false;
this.Name = ""Client"";
this.ShowIcon = false;
this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
this.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.Client_KeyPress);
this.BackPanel.ResumeLayout(false);
this.BackPanel.PerformLayout();
this.ResumeLayout(false);
}",- .,1
1087,"public App()
{
this.InitializeComponent();
this.Suspending += OnSuspending;
this.NavigationStructure = new NavigationStructure();
}","Initializes the singleton application object. This is the first line of authored code executed, and as such is the logical equivalent of main() or WinMain().",1
1088,"public static readonly DependencyProperty PageTitleVisibilityProperty = DependencyProperty.Register(""PageTitleVisibility"", typeof(Visibility), typeof(ContentFrame), new PropertyMetadata(Visibility.Visible));",Identifies the PageTitleVisibility property.,1
1089,"public static DependencyProperty FrameProperty = DependencyProperty.Register(""Frame"", typeof(Frame), typeof(FrameCommands), new PropertyMetadata(null, OnFrameChanged));",Identifies the Frame dependency property.,1
1090,"public interface IApplicationViewEventSink
{
/// <summary>
/// Occurs when the window is removed from the list of recently used apps, or if the user executes a close gesture on it.
/// </summary>
/// <param name=""sender""></param>
/// <param name=""args""></param>
void OnConsolidated(ApplicationView sender, ApplicationViewConsolidatedEventArgs args);
/// <summary>
/// This event is raised when the value of VisibleBounds changes, typically as a result of the status bar, app bar, or other chrome being shown or hidden.
/// </summary>
/// <param name=""sender""></param>
/// <param name=""args""></param>
void OnVisibleBoundsChanged(ApplicationView sender, object args);
}",The ApplicationView event sink.,1
1091,"public interface IFrameNavigationEventSink
{
/// <summary>
/// Occurs when the content that is being navigated to has been found and is available from the Content property, although it may not have completed loading.
/// </summary>
/// <param name=""sender""></param>
/// <param name=""e""></param>
void OnNavigated(object sender, NavigationEventArgs e);
/// <summary>
/// Occurs when a new navigation is requested.
/// </summary>
/// <param name=""sender""></param>
/// <param name=""e""></param>
void OnNavigating(object sender, NavigatingCancelEventArgs e);
/// <summary>
/// Occurs when an error is raised while navigating to the requested content.
/// </summary>
/// <param name=""sender""></param>
/// <param name=""e""></param>
void OnNavigationFailed(object sender, NavigationFailedEventArgs e);
/// <summary>
/// Occurs when a new navigation is requested while a current navigation is in progress.
/// </summary>
/// <param name=""sender""></param>
/// <param name=""e""></param>
void OnNavigationStopped(object sender, NavigationEventArgs e);
}",The Frame event sink for tracking navigation events.,1
1092,"public interface IHierarchyService<T>
{
/// <summary>
/// Retrieves the children of specified object.
/// </summary>
/// <param name=""o""></param>
/// <returns></returns>
IEnumerable<T> GetChildren(T o);
/// <summary>
/// Retrieves the parent of specified object.
/// </summary>
/// <param name=""o""></param>
/// <returns></returns>
T GetParent(T o);
}",Defines a uniform contract for hierarchical data structures.,1
1093,"public interface IWindowEventSink
{
/// <summary>
/// Occurs when the window has successfully been activated.
/// </summary>
/// <param name=""sender""></param>
/// <param name=""e""></param>
void OnActivated(object sender, WindowActivatedEventArgs e);
/// <summary>
/// Occurs when the window has closed.
/// </summary>
/// <param name=""sender""></param>
/// <param name=""e""></param>
void OnClosed(object sender, CoreWindowEventArgs e);
/// <summary>
/// Occurs when the app window has first rendered or has changed its rendering size.
/// </summary>
/// <param name=""sender""></param>
/// <param name=""e""></param>
void OnSizeChanged(object sender, WindowSizeChangedEventArgs e);
/// <summary>
/// Occurs when the value of the Visible property changes.
/// </summary>
/// <param name=""sender""></param>
/// <param name=""e""></param>
void OnVisibilityChanged(object sender, VisibilityChangedEventArgs e);
}",The Window event sink.,0
1094,"void IFrameworkView.Run()
{
this.window.Activate();
this.window.Dispatcher.ProcessEvents(CoreProcessEventsOption.ProcessUntilQuit);
}",Starts the app view.,0
1095,"void IFrameworkView.Uninitialize()
{
this.window = null;
this.view = null;
}",Uninitializes the app view.,0
1096,"public static readonly DependencyProperty NavigationListViewStyleProperty = DependencyProperty.Register(""NavigationListViewStyle"", typeof(Style), typeof(MasterNavigationPage), null);",Identifies the NavigationListViewStyle dependency property.,1
1097,"public Navigation()
{
InitializeComponent();
}",Initializes a new instance of the Navigation class.,1
1098,"protected override void ClearItems()
{
var items = this.Items.ToArray();
base.ClearItems();
// clear parent from items
foreach (var item in items) {
item.Parent = null;
}
}",Removes all items from the collection.,1
1099,"public static readonly DependencyProperty NavigationItemProperty = DependencyProperty.Register(""NavigationItem"", typeof(NavigationItem), typeof(NavigationPage), new PropertyMetadata(null, OnNavigationItemChanged));",Identifies the NavigationItem dependency property.,1
1100,"public static readonly DependencyProperty RootItemProperty = DependencyProperty.Register(""RootItem"", typeof(NavigationItem), typeof(NavigationPage), null);",Identifies the RootItem dependency property.,1
1101,"public static readonly DependencyProperty SelectedItemProperty = DependencyProperty.Register(""SelectedItem"", typeof(NavigationItem), typeof(NavigationPage), new PropertyMetadata(null, OnSelectedItemChanged));",Identifies the SelectedItem dependency property.,1
1102,"public static readonly DependencyProperty WindowStateProperty = DependencyProperty.Register(""WindowState"", typeof(string), typeof(NavigationPage), new PropertyMetadata(null, OnWindowStateChanged));",Identifies the WindowState dependency property.,1
1103,"public static readonly DependencyProperty IconProperty = DependencyProperty.Register(""Icon"", typeof(string), typeof(PageHeader), null);",Identifies the Icon dependency property.,1
1104,"public static readonly DependencyProperty IconButtonStyleProperty = DependencyProperty.Register(""IconButtonStyle"", typeof(Style), typeof(PageHeader), null);",Identifies the IconButtonStyle dependency property.,1
1105,"public static readonly DependencyProperty IconCommandProperty = DependencyProperty.Register(""IconCommand"", typeof(ICommand), typeof(PageHeader), null);",Identifies the IconCommand dependency property.,1
1106,"public static readonly DependencyProperty IsSearchBoxVisibleProperty = DependencyProperty.Register(""IsSearchBoxVisible"", typeof(bool), typeof(PageHeader), new PropertyMetadata(false));",Identifies the IsSearchBoxVisible dependency property.,1
1107,"public static readonly DependencyProperty SearchTermProperty = DependencyProperty.Register(""SearchTerm"", typeof(string), typeof(PageHeader), null);",Identifies the SearchTerm dependency property.,1
1108,"public static readonly DependencyProperty TitleProperty = DependencyProperty.Register(""Title"", typeof(string), typeof(PageHeader), null);",Identifies the Title dependency property.,1
1109,"public Action<WeakEventHandler<TEventTarget, TEventTypedSource, TEventSource, TEventArgs>, TEventTypedSource> Detach { get; set; }",The method for detaching the event handler.,1
1110,internal static System.Drawing.Bitmap explosion {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1111,internal static System.Drawing.Bitmap kaboom {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1112,internal static System.Drawing.Bitmap lawn {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1113,internal static System.Drawing.Bitmap redAnt {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1114,internal static System.Drawing.Bitmap redMissile {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1115,internal static System.Drawing.Bitmap redMissile2 {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1116,internal static System.Drawing.Bitmap rock {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1117,internal static System.Drawing.Bitmap wood {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1118,internal static System.Drawing.Bitmap yellowAnt {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1119,internal static System.Drawing.Bitmap yellowMissile {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1120,public static string DefaultArenaConfigurationName {,Looks up a localized string similar to /ArenaConfiguration.xml.,0
1121,public static string InfoUrlSuffix {,Looks up a localized string similar to info.,0
1122,public static string PerformNextMoveUrlSuffix {,Looks up a localized string similar to PerformNextMove.,0
1123,public static System.Drawing.Bitmap blast_example {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1124,public static System.Drawing.Bitmap board_explained {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1125,public static System.Drawing.Bitmap bomb {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1126,public static System.Drawing.Bitmap bomb_expl_mid_hor {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1127,public static System.Drawing.Bitmap bomb_expl_mid_vert {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1128,public static System.Drawing.Bitmap fortifiedTile {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1129,public static System.Drawing.Bitmap fortifiedTileBlast {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1130,public static System.Drawing.Bitmap grass {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1131,public static System.Drawing.Bitmap hello_wars_example {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1132,public static System.Drawing.Bitmap indestructibleTile {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1133,public static System.Drawing.Bitmap missile {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1134,public static System.Drawing.Bitmap regularTile {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1135,public static System.Drawing.Bitmap tank_blaster_chained_explosion {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1136,public static System.Drawing.Bitmap tank1 {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1137,public static System.Drawing.Bitmap tank2 {,Looks up a localized resource of type System.Drawing.Bitmap.,0
1138,"private void Filter()
{
if (_currentSession == null)
return;
_currentSession.SelectedCompletionSet.SelectBestMatch();
_currentSession.SelectedCompletionSet.Recalculate();
}",Narrow down the list of options as the user types input,1
1139,"bool Cancel()
{
if (_currentSession == null)
return false;
_currentSession.Dismiss();
return true;
}","Cancel the auto-complete session, and leave the text unmodified",1
1140,"bool Complete(bool force)
{
if (_currentSession == null)
return false;
if (!_currentSession.SelectedCompletionSet.SelectionStatus.IsSelected && !force)
{
_currentSession.Dismiss();
return false;
}
else
{
_currentSession.Commit();
return true;
}
}",Auto-complete text using the specified token,1
1141,"bool StartSession()
{
if (_currentSession != null)
return false;
SnapshotPoint caret = TextView.Caret.Position.BufferPosition;
ITextSnapshot snapshot = caret.Snapshot;
if (!_emojiLocationHandler.CanHazEmoji(new SnapshotSpan(caret - 1, caret)))
return false;
if (!Broker.IsCompletionActive(TextView))
{
_currentSession = Broker.CreateCompletionSession(TextView, snapshot.CreateTrackingPoint(caret, PointTrackingMode.Positive), true);
}
else
{
_currentSession = Broker.GetSessions(TextView)[0];
}
_currentSession.Dismissed += (sender, args) => _currentSession = null;
if (!_currentSession.IsStarted)
_currentSession.Start();
return true;
}",Display list of potential tokens,1
1142,"protected void InvalidateSpans(IList<SnapshotSpan> spans)
{
lock (invalidatedSpans)
{
bool wasEmpty = invalidatedSpans.Count == 0;
invalidatedSpans.AddRange(spans);
if (wasEmpty && this.invalidatedSpans.Count > 0)
view.VisualElement.Dispatcher.BeginInvoke(new Action(AsyncUpdate));
}
}",Causes intra-text adornments to be updated asynchronously.,1
1143,"protected void RaiseTagsChanged(SnapshotSpan span)
{
var handler = TagsChanged;
if (handler != null)
handler(this, new SnapshotSpanEventArgs(span));
}",Causes intra-text adornments to be updated synchronously.,1
1144,"static bool IsNumeric(object value)
{
if (value is sbyte) return true;
if (value is byte) return true;
if (value is short) return true;
if (value is ushort) return true;
if (value is int) return true;
if (value is uint) return true;
if (value is long) return true;
if (value is ulong) return true;
if (value is float) return true;
if (value is double) return true;
if (value is decimal) return true;
return false;
}","Determines if a given object is numeric in any way (can be integer, double, null, etc).",1
1145,"public AccessTokenModel() {
this.Id = Guid.NewGuid();
this.LastTouched = DateTime.Now;
this.ExpiredWindowSeconds = 172800;
}","Initializes the basics, like a new guid.",1
1146,"public AccountModel()
: base() {
this.Username = String.Empty;
this.PasswordHash = String.Empty;
this.PreferredLanguageCode = String.Empty;
this.Players = new List<AccountPlayerModel>();
this.AccessTokens = new ConcurrentDictionary<Guid, AccessTokenModel>();
}",Initializes the account with default values.,1
1147,"public AccountPlayerModel() {
this.ProtocolType = CommonProtocolType.None;
this.Uid = String.Empty;
}",Initializes the account player with default values.,1
1148,"public AsynchronousCommandStateModel() : base() {
this.PendingCommandsQueue = new ConcurrentQueue<AsynchronousCommandModel>();
this.ExecutedCommandsPool = new ConcurrentDictionary<Guid, AsynchronousCommandModel>();
this.TaskQueueWaitCancellationTokenSource = new CancellationTokenSource();
this.TaskQueueWait = new AutoResetEvent(false);
}",Initalizes with the default values.,1
1149,"protected AsynchronousCoreController() : base() {
this.AsyncStateModel = new AsynchronousCommandStateModel();
}",Initializes the controller with the default values,1
1150,"public virtual void ExecuteQueuedCommands() {
while (this.AsyncStateModel.TaskQueueWaitCancellationTokenSource.IsCancellationRequested == false) {
// Wait until we are poked that something has been added to the queue.
this.AsyncStateModel.TaskQueueWait.WaitOne();
// Dequeue and process a new command.
AsynchronousCommandModel asynchronousCommand = null;
if (this.AsyncStateModel.PendingCommandsQueue.TryDequeue(out asynchronousCommand) == true) {
// Add it so we can look for a reference when it comes back.
this.AsyncStateModel.ExecutedCommandsPool.TryAdd(asynchronousCommand.Command.CommandGuid, asynchronousCommand);
Task.Factory.StartNew(() => {
if (asynchronousCommand.IsTunneling == true) {
base.Tunnel(asynchronousCommand.Command);
}
else {
base.Bubble(asynchronousCommand.Command);
}
});
}
}
// Cleanup
this.AsyncStateModel.TaskQueueWaitCancellationTokenSource.Dispose();
this.AsyncStateModel.TaskQueueWait.Dispose();
this.AsyncStateModel.ExecutedCommandsPool.Clear();
this.AsyncStateModel = null;
}",Long running loop to process commands when signaled that a new command(s) has been added to the queue.,1
1151,"public override void Dispose() {
base.Dispose();
// This should end the pendingcommandpool -> commandexecutedpool thread
this.AsyncStateModel.TaskQueueWaitCancellationTokenSource.Cancel();
this.AsyncStateModel.TaskQueueWait.Set();
}",Allows for an optional child implementation.,1
1152,"public void Build() {
foreach (var availablePackage in this.Source) {
PackageWrapperModel packageWrapper = this.Cache.FirstOrDefault(pack => pack.Id == availablePackage.Id);
if (packageWrapper == null) {
this.Cache.Add(new PackageWrapperModel() {
State = PackageState.NotInstalled,
Available = PackageFactory.CreatePackageModelFromNugetPackage(availablePackage)
});
}
else {
// Note that we preserve the state in its current form because we don't know here if an update is available.
packageWrapper.State = availablePackage.Version.CompareTo(new SemanticVersion(packageWrapper.Installed.Version)) > 0 ? PackageState.UpdateAvailable : PackageState.Installed;
packageWrapper.Available = PackageFactory.CreatePackageModelFromNugetPackage(availablePackage);
}
}
}","Build the cache within the repository, appending known information to the repository packages.",1
1153,"public BanModel() : base() {
this.Scope.Content = new List<String>();
this.Scope.Players = new List<PlayerModel>();
this.Scope.Times = new List<TimeSubsetModel>();
}",Initializes the underlying networkmodel with the required collections.,1
1154,"public Battlefield3Game() : base() {
this.ServerInfoParameters = new List<string>() {
""ServerName"",
""PlayerCount"",
""MaxPlayerCount"",
""GameMode"",
""Map"",
""CurrentRound"",
""TotalRounds"",
""TeamScores"",
""ConnectionState"",
""Ranked"",
""PunkBuster"",
""Passworded"",
""ServerUpTime"",
""RoundTime""
};
this.PacketDispatcher.Append(new Dictionary<IPacketDispatch, Action<IPacketWrapper, IPacketWrapper>>() {
{
new PacketDispatch() {
Name = ""player.ping"", Origin = PacketOrigin.Client
},
new Action<IPacketWrapper, IPacketWrapper>(this.PlayerPingResponseDispatchHandler)
}
});
}",Game constructor to initalize the server info and any other dispatch methods,1
1155,"protected override void AuxiliarySynchronize() {
base.AuxiliarySynchronize();
foreach (var player in this.State.Players) {
this.SendPlayerPingPacket(player.Value.Name);
}
}",Override and provide support for battlefield 3 to fetch each players ping,1
1156,"protected void PlayerPingResponseDispatchHandler(IPacketWrapper request, IPacketWrapper response) {
if (request.Packet.Words.Count >= 2 && response != null && response.Packet.Words.Count >= 2) {
PlayerModel player = this.State.Players.Select(p => p.Value).FirstOrDefault(p => p.Name == request.Packet.Words[1]);
uint ping = 0;
if (player != null && uint.TryParse(response.Packet.Words[1], out ping) == true) {
// Sometimes the protocol sends through the max value of uint. We ignore everything above 1000.
player.Ping = ping > 1000 ? 0 : ping;
}
}
}","We don't update the state to avoid spamming the sandbox with 64 simple ping requests, instead we allow the player list to pass through these changes when it updates.",1
1157,"protected void SendPlayerPingPacket(String playerName) {
this.Send(this.CreatePacket(""player.ping {0}"", playerName));
}",Builds and sends the player ping packet,1
1158,"public Battlefield4Game() : base() {
this.ServerInfoParameters = new List<string>() {
""ServerName"",
""PlayerCount"",
""MaxPlayerCount"",
""GameMode"",
""Map"",
""CurrentRound"",
""TotalRounds"",
""TeamScores"",
""ConnectionState"",
""Ranked"",
""PunkBuster"",
""Passworded"",
""ServerUpTime"",
""RoundTime""
};
this.PacketDispatcher.Append(new Dictionary<IPacketDispatch, Action<IPacketWrapper, IPacketWrapper>>() {
{
new PacketDispatch() {
Name = ""server.onLevelLoaded"",
Origin = PacketOrigin.Server
},
new Action<IPacketWrapper, IPacketWrapper>(this.ServerOnLevelLoadedDispatchHandler)
}
});
}",Game constructor to initalize the server info and any other dispatch methods,1
1159,"public CertificateController() {
this.Shared = new SharedReferences();
}",Initializes the certificate with the default values.,1
1160,"public override ICoreController Execute() {
this.Load();
return base.Execute();
}",Executes the controller.,1
1161,public String Password {,The password for the certificate,0
1162,public bool Exists {,Check if the certificate exists or not.,0
1163,"public CertificateModel() {
this.RandomizePassword();
this.Watch();
}",Sets up the directory watch to look for changes in the certificates folder,1
1164,"public void RandomizePassword() {
const string characters = ""abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNOPQRSTUVWXYZ0123456789"";
String password = """";
SecureRandom random = new SecureRandom(new CryptoApiRandomGenerator());
while (password.Length < 15) {
password += characters[random.Next(characters.Length)];
}
this.Password = password;
}",Randomizes the password set in this certificate.,1
1165,"public void Generate() {
RsaKeyPairGenerator rsaKeyPairGenerator = new RsaKeyPairGenerator();
rsaKeyPairGenerator.Init(new KeyGenerationParameters(new SecureRandom(new CryptoApiRandomGenerator()), 2048));
AsymmetricCipherKeyPair asymmetricCipherKeyPair = rsaKeyPairGenerator.GenerateKeyPair();
X509Name certificateName = new X509Name(""CN="" + Environment.MachineName);
BigInteger serialNumber = BigInteger.ProbablePrime(120, new SecureRandom());
X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();
certificateGenerator.SetSerialNumber(serialNumber);
certificateGenerator.SetSubjectDN(certificateName);
certificateGenerator.SetIssuerDN(certificateName);
certificateGenerator.SetNotAfter(DateTime.Now.AddYears(1));
certificateGenerator.SetNotBefore(DateTime.Now.Subtract(new TimeSpan(7, 0, 0, 0)));
certificateGenerator.SetSignatureAlgorithm(""Sha1WithRSA"");
certificateGenerator.SetPublicKey(asymmetricCipherKeyPair.Public);
certificateGenerator.AddExtension(
X509Extensions.AuthorityKeyIdentifier.Id,
false,
new AuthorityKeyIdentifier(
SubjectPublicKeyInfoFactory.CreateSubjectPublicKeyInfo(asymmetricCipherKeyPair.Public),
new GeneralNames(new GeneralName(certificateName)),
serialNumber
)
);
certificateGenerator.AddExtension(
X509Extensions.ExtendedKeyUsage.Id,
false,
new ExtendedKeyUsage(KeyPurposeID.IdKPServerAuth)
);
X509CertificateEntry certificateEntry = new X509CertificateEntry(certificateGenerator.Generate(asymmetricCipherKeyPair.Private));
Pkcs12Store store = new Pkcs12Store();
store.SetCertificateEntry(certificateName.ToString(), certificateEntry);
store.SetKeyEntry(certificateName.ToString(), new AsymmetricKeyEntry(asymmetricCipherKeyPair.Private), new[] {
certificateEntry
});
// Save to the file system
using (var filestream = new FileStream(Defines.CertificatesDirectoryCommandServerPfx.FullName, FileMode.Create, FileAccess.ReadWrite)) {
store.Save(filestream, this.Password.ToCharArray(), new SecureRandom());
}
}",Generates and saves a new certificate to the default CommandServer plx path,1
1166,"public virtual void Poke() {
bool downstreamDead = this.LastPacketReceived == null || this.LastPacketReceived.Packet.Stamp < DateTime.Now.AddMinutes(-5);
bool upstreamDead = this.LastPacketSent == null || this.LastPacketSent.Packet.Stamp < DateTime.Now.AddMinutes(-5);
if (downstreamDead && upstreamDead) {
this.Shutdown();
}
}",This method is a final check to make sure communications are proceeding in both directions in the last five minutes. If nothing has been sent and received in the last five minutes then the connection is assumed dead and a shutdown is initiated.,1
1167,"public ClientEventArgs() {
this.Stamp = DateTime.Now;
this.Then = new ClientEventData();
this.Now = new ClientEventData();
}",Initializes the event with the default values.,1
1168,"public void TestAcquireSequenceNumber() {
MockTcpClient client = new MockTcpClient();
Assert.AreEqual(1, client.AcquireSequenceNumber);
}",Tests that 0 + 1 = 1. Really.,1
1169,"public void TestPokeNulledValues() {
MockTcpListener listener = new MockTcpListener() {
Port = 36000
};
listener.BeginListener();
MockTcpClient client = new MockTcpClient() {
ConnectionState = ConnectionState.ConnectionLoggedIn
};
client.Setup(new ClientSetup() {
Hostname = ""localhost"",
Port = 36000
});
AutoResetEvent connectionWait = new AutoResetEvent(false);
client.ConnectionStateChanged += (sender, state) => {
if (state == ConnectionState.ConnectionReady) {
connectionWait.Set();
}
};
client.Connect();
Assert.IsTrue(connectionWait.WaitOne(1000));
client.ConnectionState = ConnectionState.ConnectionLoggedIn;
client.Poke();
Assert.AreEqual(ConnectionState.ConnectionDisconnected, client.ConnectionState);
}",Tests that poking a new client that has not sent or recieved any packets is marked failed.,1
1170,"public void TestPokeNewValues() {
MockTcpListener listener = new MockTcpListener() {
Port = 36001
};
listener.BeginListener();
MockTcpClient client = new MockTcpClient() {
LastPacketReceived = new MockPacket() {
Packet = {
Stamp = DateTime.Now
}
},
LastPacketSent = new MockPacket() {
Packet = {
Stamp = DateTime.Now
}
}
};
client.Setup(new ClientSetup() {
Hostname = ""localhost"",
Port = 36001
});
AutoResetEvent connectionWait = new AutoResetEvent(false);
client.ConnectionStateChanged += (sender, state) => {
if (state == ConnectionState.ConnectionReady) {
connectionWait.Set();
}
};
client.Connect();
Assert.IsTrue(connectionWait.WaitOne(1000));
client.ConnectionState = ConnectionState.ConnectionLoggedIn;
client.Poke();
Assert.AreEqual(ConnectionState.ConnectionLoggedIn, client.ConnectionState);
}",Tests that fresh values in both sent/receieved still won't mark the client as failed.,1
1171,"public void TestPokeOldValues() {
MockTcpListener listener = new MockTcpListener() {
Port = 36002
};
listener.BeginListener();
MockTcpClient client = new MockTcpClient() {
LastPacketReceived = new MockPacket() {
Packet = {
Stamp = DateTime.Now.AddHours(-1)
}
},
LastPacketSent = new MockPacket() {
Packet = {
Stamp = DateTime.Now.AddHours(-1)
}
}
};
client.Setup(new ClientSetup() {
Hostname = ""localhost"",
Port = 36002
});
AutoResetEvent connectionWait = new AutoResetEvent(false);
client.ConnectionStateChanged += (sender, state) => {
if (state == ConnectionState.ConnectionReady) {
connectionWait.Set();
}
};
client.Connect();
Assert.IsTrue(connectionWait.WaitOne(1000));
client.ConnectionState = ConnectionState.ConnectionLoggedIn;
client.Poke();
Assert.AreEqual(ConnectionState.ConnectionDisconnected, client.ConnectionState);
}",Tests that old values will cause a client to shutdown when poked.,1
1172,"public static float Mean<T>(this ICollection<T> items, Func<T, float> value) {
return items.Select(value).DefaultIfEmpty().Average(r => r);
}",Finds the mean value given a function defining the value from an object to use.,1
1173,"public static float Mean<T>(this ICollection<T> items, Func<T, int> value) {
return items.Select(value).DefaultIfEmpty().Average(r => (float)r);
}",Finds the mean value given a function defining the value from an object to use.,1
1174,"public static float StdDev<T>(this ICollection<T> items, Func<T, float> value, float mean) {
float standardDeviation = 0;
float count = items.Count();
if (count > 1) {
float sum = items.Select(value).Sum(s => (s - mean) * (s - mean));
standardDeviation = (float)Math.Sqrt(sum / count);
}
return standardDeviation;
}",Fetches the standard deviation of a set given a function defining the value from an object to use.,1
1175,"public static float StdDev<T>(this ICollection<T> items, Func<T, int> value, float mean) {
return StdDev(items, t => (float) value(t), mean);
}",Fetches the standard deviation of a set given a function defining the value from an object to use.,1
1176,"public Command() {
this.CommandGuid = Guid.NewGuid();
this.Authentication = new CommandAuthenticationModel();
this.Scope = new CommandScopeModel();
}",Initializes a new command with the default values.,1
1177,"public CommandAuthenticationModel() {
this.Username = null;
this.GameType = CommonProtocolType.None;
this.Uid = null;
this.PasswordPlainText = null;
}",Initializes the authentication model with the default values.,1
1178,"public void Dispose() {
if (this.Content != null) this.Content.Clear();
this.Content = null;
if (this.ProtocolTypes != null) this.ProtocolTypes.Clear();
this.ProtocolTypes = null;
if (this.ProtocolAssemblyMetadatas != null) this.ProtocolAssemblyMetadatas.Clear();
this.ProtocolAssemblyMetadatas = null;
if (this.Connections != null) this.Connections.Clear();
this.Connections = null;
if (this.Groups != null) this.Groups.Clear();
this.Groups = null;
if (this.Accounts != null) this.Accounts.Clear();
this.Accounts = null;
if (this.AccessTokens != null) this.AccessTokens.Clear();
this.AccessTokens = null;
if (this.Permissions != null) this.Permissions.Clear();
this.Permissions = null;
if (this.AccountPlayers != null) this.AccountPlayers.Clear();
this.AccountPlayers = null;
if (this.Variables != null) this.Variables.Clear();
this.Variables = null;
if (this.Languages != null) this.Languages.Clear();
this.Languages = null;
if (this.TextCommands != null) this.TextCommands.Clear();
this.TextCommands = null;
if (this.TextCommandMatches != null) this.TextCommandMatches.Clear();
this.TextCommandMatches = null;
if (this.Plugins != null) this.Plugins.Clear();
this.Plugins = null;
if (this.Chats != null) this.Chats.Clear();
this.Chats = null;
if (this.Players != null) this.Players.Clear();
this.Players = null;
if (this.Kills != null) this.Kills.Clear();
this.Kills = null;
if (this.Moves != null) this.Moves.Clear();
this.Moves = null;
if (this.Spawns != null) this.Spawns.Clear();
this.Spawns = null;
if (this.Kicks != null) this.Kicks.Clear();
this.Kicks = null;
if (this.Bans != null) this.Bans.Clear();
this.Bans = null;
if (this.Settings != null) this.Settings.Clear();
this.Settings = null;
if (this.Maps != null) this.Maps.Clear();
this.Maps = null;
if (this.CommandResults != null) this.CommandResults.Clear();
this.CommandResults = null;
if (this.Packets != null) this.Packets.Clear();
this.Packets = null;
if (this.Queries != null) this.Queries.Clear();
this.Queries = null;
}","Empties and clears the list, but does not remove the actual elements as they may reference data that still exists.",1
1179,"public CommandDispatch() {
this.CommandAttributeType = CommandAttributeType.Handler;
}",Initializes the dispatch with default values.,1
1180,"public Dictionary<String, ICommandParameter> BuildParameterDictionary(IList<ICommandParameter> parameters) {
Dictionary<String, ICommandParameter> parameterDictionary = new Dictionary<String, ICommandParameter>();
// If we're not expecting any parameters
if (this.ParameterTypes != null) {
if (parameters != null && this.ParameterTypes.Count == parameters.Count) {
for (int offset = 0; offset < this.ParameterTypes.Count && parameterDictionary != null; offset++) {
if (this.ParameterTypes[offset].IsList == true) {
if (parameters[offset].HasMany(this.ParameterTypes[offset].Type, this.ParameterTypes[offset].IsConvertable) == true) {
parameterDictionary.Add(this.ParameterTypes[offset].Name, parameters[offset]);
}
else {
// Parameter type mismatch. Return null.
parameterDictionary = null;
}
}
else {
if (parameters[offset].HasOne(this.ParameterTypes[offset].Type, this.ParameterTypes[offset].IsConvertable) == true) {
parameterDictionary.Add(this.ParameterTypes[offset].Name, parameters[offset]);
}
else {
// Parameter type mismatch. Return null.
parameterDictionary = null;
}
}
}
}
else {
// Parameter count mismatch. Return null.
parameterDictionary = null;
}
}
return parameterDictionary;
}","Compares an expected parameter list against the parameters supplied. If the types match (or can be converted) then a dictionary of parameter names to the parameters supplied is returned, otherwise null is returned implying and error was encountered or a type wasn't found.",1
1181,"public CommandParameterType() {
this.IsConvertable = true;
this.IsList = false;
}",Initializes the parameter type with default values.,1
1182,public event EventHandler Disposed;,Called when the object is being disposed.,1
1183,"public CommandResult() {
this.Name = String.Empty;
this.Stamp = DateTime.Now;
this.Message = String.Empty;
this.Scope = new CommandData();
this.Then = new CommandData();
this.Now = new CommandData();
}",Initializes the command result with the default values.,1
1184,"public void Dispose() {
this.Name = null;
this.Message = null;
this.Scope.Dispose();
this.Scope = null;
this.Then.Dispose();
this.Then = null;
this.Now.Dispose();
this.Now = null;
this.OnDisposed();
}",Note this only releases the items (ignoring the fact the GC will do this anyway) but does not dispose the items it holds.,1
1185,"public CommandScopeModel() {
this.ConnectionGuid = Guid.Empty;
this.PluginGuid = Guid.Empty;
}",Initializes the model with the default values.,1
1186,"public CommandServerController() : base() {
this.Shared = new SharedReferences();
this.Certificate = new CertificateController();
}",Initalizes the command server controller with default values,1
1187,"public override void Dispose() {
base.Dispose();
this.Shared.Variables.Variable(CommonVariableNames.CommandServerEnabled).PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(OnPropertyChanged);
this.Shared.Variables.Variable(CommonVariableNames.CommandServerPort).PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(OnPropertyChanged);
this.Shared.Variables.Variable(CommonVariableNames.CommandServerCertificatePath).PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(OnPropertyChanged);
if (this.CommandServerListener != null) this.CommandServerListener.Dispose();
this.CommandServerListener = null;
}",Allows for an optional child implementation.,1
1188,"public override void Poke() {
// Method implemented here instead of calling the public method so we can do
// additional work during a Poke in the future.
if (this.CommandServerListener != null) {
this.CommandServerListener.Poke();
}
}","Pokes the underlying listener, ensuring that all clients held in memory are still active and not disconnected.",1
1189,"public void Configure() {
if (this.Shared.Variables.Get<bool>(CommonVariableNames.CommandServerEnabled) == true) {
if (this.Certificate.Certificate != null) {
this.CommandServerListener = new CommandServerListener {
Certificate = this.Certificate.Certificate,
Port = this.Shared.Variables.Get<int>(CommonVariableNames.CommandServerPort),
PacketReceived = OnPacketReceived,
BeginException = OnBeginException,
ListenerException = OnListenerException
};
// Start accepting connections.
if (this.CommandServerListener.BeginListener() == true) {
this.Shared.Events.Log(new GenericEvent() {
GenericEventType = GenericEventType.CommandServerStarted,
Success = true,
CommandResultType = CommandResultType.Success
});
}
else {
this.Shared.Events.Log(new GenericEvent() {
GenericEventType = GenericEventType.CommandServerStarted,
Success = false,
CommandResultType = CommandResultType.Failed
});
}
}
}
else if (this.CommandServerListener != null) {
this.CommandServerListener.Dispose();
this.CommandServerListener = null;
this.Shared.Events.Log(new GenericEvent() {
GenericEventType = GenericEventType.CommandServerStopped,
Success = true,
CommandResultType = CommandResultType.Success
});
}
}",We should fetch and listen for changes to the CommandServer* variables,1
1190,"protected ICommandResult Authenticate(CommandServerPacket request, ICommand command) {
ICommandResult result = null;
if (String.IsNullOrEmpty(command.Authentication.Username) == false && String.IsNullOrEmpty(command.Authentication.PasswordPlainText) == false) {
result = this.Shared.Security.Tunnel(CommandBuilder.SecurityAccountAuthenticate(command.Authentication.Username, command.Authentication.PasswordPlainText, this.ExtractIdentifer(request)).SetOrigin(CommandOrigin.Remote));
}
else if (command.Authentication.TokenId != Guid.Empty && String.IsNullOrEmpty(command.Authentication.Token) == false) {
result = this.Shared.Security.Tunnel(CommandBuilder.SecurityAccountAuthenticateToken(command.Authentication.TokenId, command.Authentication.Token, this.ExtractIdentifer(request)).SetOrigin(CommandOrigin.Remote));
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.Failed,
Message = ""Invalid username or password""
};
}
return result;
}","This command only checks if the user is authenticated with our system, not if they can execute the command. This is accomplished while executing the command.",1
1191,"public CommandServerListener() {
this.Clients = new ConcurrentDictionary<String, CommandServerClient>();
}",Initializes the command server with the default values,1
1192,"public bool BeginListener() {
bool started = false;
try {
if (this.Clients == null) {
this.Clients = new ConcurrentDictionary<String, CommandServerClient>();
}
this.Listener = new TcpListener(IPAddress.Any, this.Port);
this.Listener.Start();
// Accept the connection.
this.Listener.BeginAcceptTcpClient(new AsyncCallback(CommandServerListener.AcceptTcpClientCallback), this);
started = true;
}
catch (Exception e) {
this.Shutdown();
this.OnBeginException(e);
}
return started;
}",Creates and starts listening for tcp clients on the specified port.,1
1193,"public void Poke() {
if (this.Clients != null) {
List<CommandServerClient> poked = new List<CommandServerClient>(this.Clients.Values);
poked.ForEach(client => client.Poke());
}
}","Copy the list of clients, then run through poking them to ensure they are still alive.",1
1194,"public void Shutdown() {
lock (this.ShutdownLock) {
// Stop listening or new connections
if (this.Listener != null) {
this.Listener.Stop();
this.Listener = null;
}
// Disconnect all existing connections
if (this.Clients != null) {
foreach (var client in this.Clients) {
client.Value.Shutdown();
client.Value.PacketReceived -= this.client_PacketReceived;
client.Value.ConnectionStateChanged -= this.client_ConnectionStateChanged;
}
this.Clients.Clear();
this.Clients = null;
}
}
}",Shuts down the current instance,1
1195,"public CommandServerPacket() {
this.Headers = new WebHeaderCollection();
this.Query = new NameValueCollection();
this.Content = String.Empty;
this.Packet = new Packet();
}",Initializes default values.,1
1196,"public CommandServerPacketSerializer() : base() {
this.PacketHeaderSize = 14;
}",Initializes the packet header size requirment for this packet type,1
1197,"public CompiledQuery() : base() {
this.Children = new List<ICompiledQuery>();
this.Compiled = new List<String>();
}",Initializes all defaults,1
1198,public String Text {,"The basic text of the text command, what was supplied to build the compilation.",0
1199,"public Config() {
this.Document = new JObject();
}",Initializes the serializer,1
1200,"public ConnectionController() : base() {
this.Shared = new SharedReferences();
this.ConnectionModel = new ConnectionModel();
this.ProtocolState = new ProtocolState();
this.CommandDispatchers.AddRange(new List<ICommandDispatch>() {
new CommandDispatch() {
CommandType = CommandType.ConnectionQuery,
Handler = this.ConnectionQuery
},
new CommandDispatch() {
CommandType = CommandType.NetworkProtocolQueryPlayers,
Handler = this.NetworkProtocolQueryPlayers
},
new CommandDispatch() {
CommandType = CommandType.NetworkProtocolQuerySettings,
Handler = this.NetworkProtocolQuerySettings
},
new CommandDispatch() {
CommandType = CommandType.NetworkProtocolQueryBans,
Handler = this.NetworkProtocolQueryBans
},
new CommandDispatch() {
CommandType = CommandType.NetworkProtocolQueryMaps,
Handler = this.NetworkProtocolQueryMaps
},
new CommandDispatch() {
CommandType = CommandType.NetworkProtocolQueryMapPool,
Handler = this.NetworkProtocolQueryMapPool
}
});
// Add all network actions, dispatching them to NetworkProtocolAction
this.CommandDispatchers.AddRange(Enum.GetValues(typeof(NetworkActionType)).Cast<NetworkActionType>().Select(actionType => new CommandDispatch() {
Name = actionType.ToString(),
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""action"",
Type = typeof(INetworkAction)
}
},
Handler = this.NetworkProtocolAction
}));
this.CommandDispatchers.AddRange(Enum.GetValues(typeof(NetworkActionType)).Cast<NetworkActionType>().Select(actionType => new CommandDispatch() {
Name = actionType.ToString(),
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""action"",
Type = typeof(INetworkAction),
IsList = true
}
},
Handler = this.NetworkProtocolActions
}));
}","Initializes the connection controller with default values, setting up command dispatches",1
1201,"public void SetupProtocolFactory(IProtocolAssemblyMetadata meta) {
AppDomainSetup setup = this.CreateAppDomainSetup();
PermissionSet permissions = this.CreatePermissionSet(meta);
// Create the app domain and the plugin factory in the new domain.
this.AppDomainSandbox = AppDomain.CreateDomain(String.Format(""Potato.Protocols.{0}"", this.ConnectionModel != null ? this.ConnectionModel.ConnectionGuid.ToString() : String.Empty), null, setup, permissions);
this.ProtocolFactory = (ISandboxProtocolController)this.AppDomainSandbox.CreateInstanceAndUnwrap(typeof(ISandboxProtocolController).Assembly.FullName, typeof(SandboxProtocolController).FullName);
this.AssignProtocolEvents();
}","Sets everything up to load the plugins, creating the seperate appdomin and permission requirements",1
1202,"public bool SetupProtocol(IProtocolAssemblyMetadata meta, IProtocolType type, ProtocolSetup setup) {
if (this.ProtocolFactory == null) {
this.SetupProtocolFactory(meta);
}
if (this.ProtocolFactory.Create(meta.Assembly.FullName, type) == true) {
this.Protocol = this.ProtocolFactory;
this.Protocol.Setup(setup);
}
return this.Protocol != null;
}","Sets up the factory, then attempts to load a specific type into the protocol appdomain.",1
1203,"public override void Poke() {
base.Poke();
if (this.Protocol != null) {
if (this.ProtocolState != null && this.ProtocolState.Settings.Current.ConnectionState == ConnectionState.ConnectionDisconnected) {
this.AttemptConnection();
}
else {
this.Protocol.Synchronize();
}
}
if (this.Plugins != null) {
this.Plugins.Poke();
}
// Update the lease on the protocol AppDomain
if (this.ProtocolFactory != null) {
ILease lease = ((MarshalByRefObject)this.ProtocolFactory).GetLifetimeService() as ILease;
if (lease != null) {
lease.Renew(lease.InitialLeaseTime);
}
}
}",A set interval Poke,1
1204,"public void AttemptConnection() {
if (this.Protocol != null) {
this.Protocol.AttemptConnection();
}
}",Attempts communication with the game server.,1
1205,"public ICommandResult ConnectionQuery(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
ICommandResult players = this.Tunnel(new Command(command) {
CommandType = CommandType.NetworkProtocolQueryPlayers
});
ICommandResult settings = this.Tunnel(new Command(command) {
CommandType = CommandType.NetworkProtocolQuerySettings
});
ICommandResult maps = this.Tunnel(new Command(command) {
CommandType = CommandType.NetworkProtocolQueryMaps
});
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Scope = new CommandData() {
Connections = new List<ConnectionModel>() {
this.ConnectionModel
}
},
Now = new CommandData() {
// I didn't want plugins to be able to hide themselves.
Plugins = new List<PluginModel>(this.Plugins.LoadedPlugins),
Players = players.Now.Players,
Settings = settings.Now.Settings,
Maps = maps.Now.Maps
}
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Queries for information about the current connection,1
1206,"public ICommandResult NetworkProtocolQueryPlayers(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Scope = new CommandData() {
Connections = new List<ConnectionModel>() {
this.ConnectionModel
}
},
Now = new CommandData() {
Players = new List<PlayerModel>(this.ProtocolState.Players.Values)
}
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Queries this connection for an up to date list of players,1
1207,"public ICommandResult NetworkProtocolQuerySettings(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Scope = new CommandData() {
Connections = new List<ConnectionModel>() {
this.ConnectionModel
}
},
Now = new CommandData() {
Settings = new List<Settings>() {
this.ProtocolState.Settings
}
}
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Queries this connection for the current protocol settings,1
1208,"public ICommandResult NetworkProtocolQueryBans(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Scope = new CommandData() {
Connections = new List<ConnectionModel>() {
this.ConnectionModel
}
},
Now = new CommandData() {
Bans = new List<BanModel>(this.ProtocolState.Bans.Values)
}
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Queries this connection for a complete list of active bans,1
1209,"public ICommandResult NetworkProtocolQueryMaps(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Scope = new CommandData() {
Connections = new List<ConnectionModel>() {
this.ConnectionModel
}
},
Now = new CommandData() {
Maps = new List<MapModel>(this.ProtocolState.Maps.Values)
}
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Queries this connection for a list of maps currently running,1
1210,"public ICommandResult NetworkProtocolQueryMapPool(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Scope = new CommandData() {
Connections = new List<ConnectionModel>() {
this.ConnectionModel
}
},
Now = new CommandData() {
Maps = new List<MapModel>(this.ProtocolState.MapPool.Values)
}
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Queries this connection for a list of maps available,1
1211,"public ICommandResult NetworkProtocolAction(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
INetworkAction action = parameters[""action""].First<INetworkAction>();
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
action.Name = command.Name;
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Now = new CommandData() {
Packets = this.Protocol.Action(action)
}
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Executes a single action on the protocol,1
1212,"public override void Dispose() {
this.ConnectionModel.ProtocolType = null;
this.ConnectionModel.Hostname = null;
this.ConnectionModel.Port = 0;
// Now shutdown and null out the game. Note that we want to capture and report
// events during the shutdown, but then we want to unassign events to the game
// object before we null it out. We only null it so we dont suppress errors.
if (this.Protocol != null) {
this.Protocol.Shutdown();
}
if (this.AppDomainSandbox != null) {
AppDomain.Unload(this.AppDomainSandbox);
this.AppDomainSandbox = null;
}
this.ProtocolFactory = null;
this.UnassignProtocolEvents();
// this.Game.Dispose();
this.Protocol = null;
if (this.TextCommands != null) {
this.TextCommands.Dispose();
}
if (this.Plugins != null) {
this.Plugins.Dispose();
}
base.Dispose();
}",Allows for an optional child implementation.,1
1213,"protected void AssignProtocolEvents() {
this.UnassignProtocolEvents();
if (this.ProtocolFactory != null) {
this.ProtocolFactory.Bubble = new SandboxProtocolCallbackProxy() {
ProtocolEvent = Protocol_ProtocolEvent,
ClientEvent = Protocol_ClientEvent
};
}
}",Assign all current event handlers.,1
1214,"protected void UnassignProtocolEvents() {
if (this.ProtocolFactory != null) {
this.ProtocolFactory.Bubble = null;
}
}",Removes all current event handlers.,1
1215,"public virtual void Dispose() {
this.OnDisposed();
if (this.BubbleObjects != null) this.BubbleObjects.Clear();
this.BubbleObjects = null;
if (this.TunnelObjects != null) this.TunnelObjects.Clear();
this.TunnelObjects = null;
this.Disposed = null;
}",Allows for an optional child implementation.,1
1216,"public virtual void Poke() {
}",A set interval Poke,1
1217,"public CorePluginController() : base() {
this.Shared = new SharedReferences();
this.LoadedPlugins = new List<PluginModel>();
this.CorePluginControllerCallbackProxy = new CorePluginControllerCallbackProxy() {
BubbleObjects = {
this
}
};
this.CommandDispatchers.AddRange(new List<ICommandDispatch>() {
new CommandDispatch() {
CommandType = CommandType.PluginsEnable,
Handler = this.EnablePlugin
},
new CommandDispatch() {
CommandType = CommandType.PluginsDisable,
Handler = this.DisablePlugin
}
});
}",Default Initialization,0
1218,"public override ICoreController Execute() {
this.SetupPluginFactory();
this.TunnelObjects.Add(this.PluginFactory);
this.BubbleObjects.Add(this.Connection);
// Load all the plugins.
this.LoadPlugins();
if (this.Connection != null) {
this.Connection.ClientEvent += Connection_ClientEvent;
this.Connection.ProtocolEvent += Connection_GameEvent;
}
// Return the base execution.
return base.Execute();
}",Executes the commands specified in the config file and returns a reference itself.,1
1219,"public override void Poke() {
ILease lease = ((MarshalByRefObject)this.PluginFactory).GetLifetimeService() as ILease;
if (lease != null) {
lease.Renew(lease.InitialLeaseTime);
}
}",Renews the lease on the plugin factory as well as each loaded plugin proxy,1
1220,"public override void Dispose() {
this.ClientEventStream.Stop();
this.ProtocolEventStream.Stop();
this.PluginFactory.Shutdown();
this.LoadedPlugins.Clear();
this.LoadedPlugins = null;
AppDomain.Unload(this.AppDomainSandbox);
this.AppDomainSandbox = null;
this.PluginFactory = null;
base.Dispose();
}",Disposes of all the plugins before calling the base dispose.,1
1221,"protected void CreateDirectories() {
Directory.CreateDirectory(Path.Combine(Defines.ConfigsDirectory.FullName, this.Connection != null ? this.Connection.ConnectionModel.ConnectionGuid.ToString() : Guid.Empty.ToString()));
}",Creates all of the directories required by plugins,1
1222,"protected void SetupPluginFactory() {
AppDomainSetup setup = this.CreateAppDomainSetup();
PermissionSet permissions = this.CreatePermissionSet();
this.CreateDirectories();
// Create the app domain and the plugin factory in the new domain.
this.AppDomainSandbox = AppDomain.CreateDomain(String.Format(""Potato.Plugins.{0}"", this.Connection != null ? this.Connection.ConnectionModel.ConnectionGuid.ToString() : String.Empty), null, setup, permissions);
this.PluginFactory = (ISandboxPluginController)this.AppDomainSandbox.CreateInstanceAndUnwrap(typeof(SandboxPluginController).Assembly.FullName, typeof(SandboxPluginController).FullName);
this.PluginFactory.BubbleObjects = new List<ICoreController>() {
this.CorePluginControllerCallbackProxy
};
this.ClientEventStream = new ThrottledStream<IClientEventArgs>() {
FlushTo = this.PluginFactory.ClientEvent
}.Start();
this.ProtocolEventStream = new ThrottledStream<IProtocolEventArgs>() {
FlushTo = this.PluginFactory.ProtocolEvent
}.Start();
}","Sets everything up to load the plugins, creating the seperate appdomin and permission requirements",1
1223,"protected void LoadPlugins() {
// If there are dll files in this directory, setup the plugins.
foreach (String path in this.GetPluginAssemblies().Select(file => file.FullName)) {
PluginModel plugin = new PluginModel() {
Name = new FileInfo(path).Name.Replace("".dll"", """")
};
IPluginController proxy = this.PluginFactory.Create(path, plugin.Name + "".Program"");
if (proxy != null) {
plugin.PluginGuid = proxy.PluginGuid;
Guid connectionGuid = this.Connection != null ? this.Connection.ConnectionModel.ConnectionGuid : Guid.Empty;
IPluginSetupResult result = proxy.Setup(new PluginSetup() {
ConnectionGuid = connectionGuid.ToString(),
ConfigDirectoryPath = Path.Combine(Defines.ConfigsDirectory.FullName, connectionGuid.ToString(), plugin.PluginGuid.ToString()),
LogDirectoryPath = Path.Combine(Defines.LogsDirectory.FullName, connectionGuid.ToString(), plugin.PluginGuid.ToString())
});
plugin.Commands = result.Commands;
plugin.Title = result.Title;
// Tell the plugin it's ready to begin, everything is setup and ready // for it to start loading its config.
proxy.GenericEvent(new GenericEvent() {
GenericEventType = GenericEventType.PluginsLoaded
});
}
this.LoadedPlugins.Add(plugin);
}
}",Setup the plugins located in or in sub-folders of this directory.,1
1224,"public DatabaseController() : base() {
this.Shared = new SharedReferences();
this.OpenDrivers = new Dictionary<String, IDriver>();
this.GroupedVariableListener = new GroupedVariableListener() {
Variables = this.Shared.Variables,
GroupsVariableName = CommonVariableNames.DatabaseConfigGroups.ToString(),
ListeningVariablesNames = new List<String>() {
CommonVariableNames.DatabaseDriverName.ToString(),
CommonVariableNames.DatabaseHostname.ToString(),
CommonVariableNames.DatabasePort.ToString(),
CommonVariableNames.DatabaseUid.ToString(),
CommonVariableNames.DatabasePassword.ToString(),
CommonVariableNames.DatabaseMemory.ToString()
}
};
this.CommandDispatchers.AddRange(new List<ICommandDispatch>() {
new CommandDispatch() {
CommandType = CommandType.DatabaseQuery,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""query"",
Type = typeof(IDatabaseObject)
}
},
Handler = this.Query
},
new CommandDispatch() {
CommandType = CommandType.DatabaseQuery,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""query"",
Type = typeof(IDatabaseObject),
IsList = true
}
},
Handler = this.Query
},
new CommandDispatch() {
CommandType = CommandType.DatabaseQuery,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""driver"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""query"",
Type = typeof(IDatabaseObject)
}
},
Handler = this.QueryDriver
},
new CommandDispatch() {
CommandType = CommandType.DatabaseQuery,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""driver"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""query"",
Type = typeof(IDatabaseObject),
IsList = true
}
},
Handler = this.QueryDriver
}
});
}",Initializes default attributes,0
1225,"public override void Dispose() {
this.UnassignEvents();
this.GroupedVariableListener = null;
foreach (var driver in this.OpenDrivers) {
driver.Value.Close();
}
this.OpenDrivers.Clear();
this.OpenDrivers = null;
foreach (IDriver driver in this.AvailableDrivers) {
driver.Close();
}
this.AvailableDrivers.Clear();
this.AvailableDrivers = null;
base.Dispose();
}",Allows for an optional child implementation.,1
1226,"protected void AssignEvents() {
// Remove all current handlers, also clears the list in this.ListeningVariables
this.UnassignEvents();
this.GroupedVariableListener.AssignEvents();
this.GroupedVariableListener.VariablesModified += GroupedVariableListenerOnVariablesModified;
}",This will also setup the empty namespace group.,1
1227,"protected void UnassignEvents() {
this.GroupedVariableListener.VariablesModified -= GroupedVariableListenerOnVariablesModified;
this.GroupedVariableListener.UnassignEvents();
}",Removes all current event handlers.,1
1228,"public IDatabaseObject Index(String collection, String name, ISortByModifier sortByModifier) {
Field field = this.BuildField(name);
return this.Raw(
new Index() {
Name = String.Format(""{0}_INDEX"", field.Name)
}
.Sort(
new Sort() {
Name = field.Name
}
.Modifier(sortByModifier)
.Implicit()
)
.Raw(
new Collection() {
Name = collection
}.Implicit()
)
.Implicit()
);
}",Passing Ascending through is as good as using Index(name),1
1229,"public DeathsPropertyReference() {
this.ThingReference = new PlayerThingReference();
}",Initializes with the default player thing reference,1
1230,"public void Release() {
this.Sent = null;
this.Each = null;
this.Done = null;
this.Expired = null;
this.Always = null;
}",Releases all handles on callbacks,1
1231,"public void TestDeferredActionGetAction() {
INetworkAction chat = new NetworkAction() {
ActionType = NetworkActionType.NetworkTextSay
};
DeferredAction<INetworkAction> deferredAction = new DeferredAction<INetworkAction>() {
Action = chat
};
Assert.AreEqual(chat.Uid, deferredAction.GetAction().Uid);
}",Fetches the current action attached to the deferred action. Coverage. Just coverage.,1
1232,"public void TestDeferredActionEach() {
bool eachFlag = false;
INetworkAction chat = new NetworkAction();
DeferredAction<INetworkAction> deferredAction = new DeferredAction<INetworkAction>() {
Action = chat,
Each = (action, request, response) => {
eachFlag = true;
}
};
Assert.IsTrue(deferredAction.TryInsertDone(chat, new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
}, new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 1
}
}));
Assert.IsTrue(eachFlag);
}",Tests an action's each callback will be called.,1
1233,"public void TestDeferredActionDone() {
bool doneFlag = false;
INetworkAction chat = new NetworkAction();
DeferredAction<INetworkAction> deferredAction = new DeferredAction<INetworkAction>() {
Action = chat,
Done = (action, requests, responses) => {
doneFlag = true;
}
};
Assert.IsTrue(deferredAction.TryInsertDone(chat, new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
}, new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 1
}
}));
Assert.IsTrue(doneFlag);
}",Tests an action's done callback will be called.,1
1234,"public void TestDeferredActionSent() {
bool sentFlag = false;
INetworkAction chat = new NetworkAction();
DeferredAction<INetworkAction> deferredAction = new DeferredAction<INetworkAction>() {
Action = chat,
Sent = (action, requests) => {
sentFlag = true;
}
};
Assert.IsTrue(deferredAction.TryInsertSent(chat, new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
}));
Assert.IsTrue(sentFlag);
}",Tests an action's sent callback will be called.,1
1235,"public void TestDeferredActionExpired() {
bool expiredFlag = false;
INetworkAction chat = new NetworkAction();
DeferredAction<INetworkAction> deferredAction = new DeferredAction<INetworkAction>() {
Action = chat,
Expired = (action, requests, responses) => {
expiredFlag = true;
}
};
Assert.IsTrue(deferredAction.TryInsertExpired(chat, new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
}, new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 1
}
}));
Assert.IsTrue(expiredFlag);
}",Tests an action's expired callback will be called.,1
1236,"public void TestDeferredActionAlways() {
bool alwaysFlag = false;
INetworkAction chat = new NetworkAction();
DeferredAction<INetworkAction> deferredAction = new DeferredAction<INetworkAction>() {
Action = chat,
Always = action => {
alwaysFlag = true;
}
};
Assert.IsTrue(deferredAction.TryInsertAlways(chat));
Assert.IsTrue(alwaysFlag);
}",Tests an action's always callback will be called.,1
1237,"public void TestDeferredActionRelease() {
INetworkAction chat = new NetworkAction();
DeferredAction<INetworkAction> deferredAction = new DeferredAction<INetworkAction>() {
Action = chat,
Sent = (action, requests) => {
},
Each = (action, request, response) => {
},
Done = (action, requests, responses) => {
},
Expired = (action, requests, responses) => {
},
Always = action => {
}
};
deferredAction.Release();
Assert.IsNull(deferredAction.Sent);
Assert.IsNull(deferredAction.Each);
Assert.IsNull(deferredAction.Done);
Assert.IsNull(deferredAction.Expired);
Assert.IsNull(deferredAction.Always);
}",Tests callbacks will be nulled out on release.,1
1238,public static readonly DirectoryInfo BaseDirectory = new DirectoryInfo(AppDomain.CurrentDomain.BaseDirectory);,"The base directory, given from the current AppDomain.",1
1239,"public static readonly DirectoryInfo LogsDirectory = new DirectoryInfo(Path.Combine(Defines.BaseDirectory.FullName, ""Logs""));",The full path to the logs directory,1
1240,"public static readonly DirectoryInfo ErrorsLogsDirectory = new DirectoryInfo(Path.Combine(LogsDirectory.FullName, ""Errors""));",The full path to the errors log directory,1
1241,"public static readonly DirectoryInfo ConfigsDirectory = new DirectoryInfo(Path.Combine(Defines.BaseDirectory.FullName, ""Configs""));",The full path to the configs directory,1
1242,"public static readonly DirectoryInfo LocalizationDirectory = new DirectoryInfo(Path.Combine(Defines.BaseDirectory.FullName, Defines.LocalizationDirectoryName));",The full path to the base localization folder (an custom localization files),1
1243,"public static readonly DirectoryInfo CertificatesDirectory = new DirectoryInfo(Path.Combine(Defines.BaseDirectory.FullName, ""Certificates""));",The full path to known/trusted/used certificates.,1
1244,"public static readonly DirectoryInfo PackagesDirectory = new DirectoryInfo(Path.Combine(Defines.BaseDirectory.FullName, ""Packages""));",The full path to download/install packages to. The local package repository.,1
1245,"static Defines() {
Defines.CertificatesDirectory.Create();
Defines.ConfigsDirectory.Create();
Defines.PackagesDirectory.Create();
Defines.LogsDirectory.Create();
Defines.ErrorsLogsDirectory.Create();
Defines.LocalizationDirectory.Create();
}",Ensure the entire directory structure has been created.,1
1246,"public EventsConsoleController() : base() {
this.Shared = new SharedReferences();
}",Initializes events console with default values.,1
1247,"public override void Dispose() {
this.Shared.Events.EventLogged -= new Core.Events.EventsController.EventLoggedHandler(Events_EventLogged);
base.Dispose();
}",Allows for an optional child implementation.,1
1248,"public EventsController() : base() {
this.Shared = new SharedReferences();
this.LoggedEvents = new List<IGenericEvent>();
this.CommandDispatchers.AddRange(new List<ICommandDispatch>() {
new CommandDispatch() {
CommandType = CommandType.EventsFetchAfterEventId,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""eventId"",
Type = typeof(ulong)
}
},
Handler = this.EventsFetchAfterEventId
},
new CommandDispatch() {
CommandType = CommandType.EventsLog,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""event"",
Type = typeof(IGenericEvent)
}
},
Handler = this.EventsLog
}
});
}",Initializes default attributes and sets up command dispatching,1
1249,"public override void Dispose() {
this.WriteEventsList(this.LoggedEvents);
this.LoggedEvents.Clear();
this.LoggedEvents = null;
this.EventLogged = null;
base.Dispose();
}",Allows for an optional child implementation.,1
1250,"public ICommandResult EventsFetchAfterEventId(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
ulong eventId = parameters[""eventId""].First<ulong>();
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
List<IGenericEvent> events = null;
lock (this.LoggedEvents) {
events = this.LoggedEvents.Where(e => e.Stamp > DateTime.Now - TimeSpan.FromSeconds(this.Shared.Variables.Get(CommonVariableNames.MaximumEventsTimeSeconds, 300)))
.Where(e => e.Id > eventId)
.OrderBy(e => e.Id)
.ToList();
}
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = String.Format(@""Fetched {0} event(s)"", events.Count),
Now = {
Events = events
}
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}","Fetches all events after a passed id, as well as after a certain date.",1
1251,"public ICommandResult EventsLog(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
IGenericEvent @event = parameters[""event""].First<IGenericEvent>();
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
this.Log(@event);
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Now = {
Events = new List<IGenericEvent>() {
@event
}
}
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Logs a new event,1
1252,"public ICommandResult SetTestFlag(ICommand command, Dictionary<String, ICommandParameter> parameters) {
int value = parameters[""value""].First<int>();
TestNumber = value;
return new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = ""Set Number"",
Now = new CommandData() {
Variables = new List<VariableModel>() {
new VariableModel() {
Name = ""TestNumber"",
Value = TestNumber
}
}
}
};
}",Sets the value of the test flag.,1
1253,"public ICommandResult GetTestFlag(ICommand command, Dictionary<String, ICommandParameter> parameters) {
return new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = ""Get Number"",
Now = new CommandData() {
Variables = new List<VariableModel>() {
new VariableModel() {
Name = ""TestNumber"",
Value = TestNumber
}
}
}
};
}",Gets the value as an integer for the single test flag.,1
1254,"public ICommandResult CustomSetTestFlag(ICommand command, Dictionary<String, ICommandParameter> parameters) {
return SetTestFlag(command, parameters);
}","Sets the value of the test flag, but with a custom name.",1
1255,"public ICommandResult SetTestFlagsEnum(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ExecutableFlagsEnum value = parameters[""value""].First<ExecutableFlagsEnum>();
ICommandResult result = command.Result;
TestExecutableFlagsEnum = value;
return result;
}",Tests that a flags enumerator will be passed through,1
1256,"public ICommandResult SetTestEnum(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ExecutableEnum value = parameters[""value""].First<ExecutableEnum>();
ICommandResult result = command.Result;
TestExecutableEnum = value;
return result;
}",Tests that a enumerator will be passed through,1
1257,"public ICommandResult SetTestFlagPreview(ICommand command, Dictionary<String, ICommandParameter> parameters) {
int value = parameters[""value""].First<int>();
ICommandResult result = command.Result;
ExecutedTestValue = TestNumber * 2;
return result;
}",Sets the value of the test flag.,1
1258,"public ICommandResult SetTestFlagInteger(ICommand command, Dictionary<String, ICommandParameter> parameters) {
int value = parameters[""value""].First<int>();
TestNumber = value;
return new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = ""Set Number"",
Now = new CommandData() {
Variables = new List<VariableModel>() {
new VariableModel() {
Name = ""TestNumber"",
Value = TestNumber
}
}
}
};
}",Sets the value of the test flag.,1
1259,"public ICommandResult SetTestFlagFloat(ICommand command, Dictionary<String, ICommandParameter> parameters) {
float value = parameters[""value""].First<float>();
TestNumber = (int) value;
return new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = ""Set Number"",
Now = new CommandData() {
Variables = new List<VariableModel>() {
new VariableModel() {
Name = ""TestNumber"",
Value = TestNumber
}
}
}
};
}",Sets the value of the test flag.,1
1260,"public ICommandResult SetTestFlagPreview(ICommand command, Dictionary<String, ICommandParameter> parameters) {
int value = parameters[""value""].First<int>();
ICommandResult result = command.Result;
if (value == 10) {
result.CommandResultType = CommandResultType.None;
}
return result;
}",Sets the value of the test flag.,1
1261,"public override void PlayerOnKillDispatchHandler(IPacketWrapper request, IPacketWrapper response) {
if (request.Packet.Words.Count >= 5) {
bool headshot = false;
if (bool.TryParse(request.Packet.Words[4], out headshot) == true) {
ItemModel item = this.State.Items.Select(i => i.Value).FirstOrDefault(i => i.Name == Regex.Replace(request.Packet.Words[3], @""[^\w\/_-]+"", """")) ?? new ItemModel() { Name = request.Packet.Words[3] };
var killer = this.State.Players.Select(p => p.Value).FirstOrDefault(p => p.Name == request.Packet.Words[1]);
var victim = this.State.Players.Select(p => p.Value).FirstOrDefault(p => p.Name == request.Packet.Words[2]);
if (killer != null && victim != null) {
// Assign the item to the player, overwriting everything else attached to this killer.
killer.Inventory.Now.Items.Clear();
killer.Inventory.Now.Items.Add(item);
victim.Deaths++;
// If this wasn't an inside job.
if (killer.Uid != victim.Uid) {
killer.Kills++;
}
var difference = new ProtocolStateDifference() {
Modified = {
Players = new ConcurrentDictionary<String, PlayerModel>()
}
};
difference.Modified.Players.AddOrUpdate(killer.Uid, id => killer, (id, model) => killer);
difference.Modified.Players.AddOrUpdate(victim.Uid, id => victim, (id, model) => victim);
this.ApplyProtocolStateDifference(difference);
// We've updated the state, now fetch the players from the state with all of the statistics information attached.
PlayerModel stateKiller = null;
PlayerModel stateVictim = null;
this.State.Players.TryGetValue(killer.Uid, out stateKiller);
this.State.Players.TryGetValue(victim.Uid, out stateVictim);
this.OnProtocolEvent(
ProtocolEventType.ProtocolPlayerKill,
difference,
new ProtocolEventData() {
Kills = new List<KillModel>() {
new KillModel() {
Scope = {
Players = new List<PlayerModel>() {
stateVictim
},
Items = new List<ItemModel>() {
item
},
HumanHitLocations = new List<HumanHitLocation>() {
headshot == true ? FrostbiteGame.Headshot : FrostbiteGame.Bodyshot
}
},
Now = {
Players = new List<PlayerModel>() {
stateKiller
}
}
}
}
}
);
}
}
}
}","Handles the player.onKill event sent from the server. This method holds for Battlefield 3/4, but may need an override in bfbc2.",1
1262,"protected override void ShutdownConnection() {
base.ShutdownConnection();
this.PacketQueue.Clear();
}","Shuts down the connection, closing the Client.",1
1263,"public override void Synchronize() {
base.Synchronize();
if (this.Client.ConnectionState == ConnectionState.ConnectionLoggedIn) {
this.Send(this.CreatePacket(""admin.listPlayers all""));
this.Send(this.CreatePacket(""serverInfo""));
if (DateTime.Now >= this.NextAuxiliarySynchronization) {
this.AuxiliarySynchronize();
this.NextAuxiliarySynchronization = DateTime.Now.AddSeconds(120);
}
}
}",General timed event to synch everything on the server with what is known locally.,1
1264,"protected Dictionary<String, PropertyInfo> PropertyInfoCache = new Dictionary<string, PropertyInfo>();",Dictionary of cached property info fetches. Minor optimization.,1
1265,"public GameModeModel() {
this.Name = String.Empty;
this.FriendlyName = String.Empty;
this.TeamCount = 0;
}",Initializes the game mode with the default values.,1
1266,"public void TestGameTypeAttributeConversion() {
MockGame game = new MockGame();
Assert.AreEqual(""MOCK_3"", game.ProtocolType.Type);
Assert.AreEqual(""MockGame 3"", game.ProtocolType.Name);
Assert.AreEqual(""Myrcon"", game.ProtocolType.Provider);
Assert.IsInstanceOf<ProtocolType>(game.ProtocolType);
}",Tests the attribute will be fetched and converted to a GameType object.,1
1267,"public void TestGameActionDispatch() {
List<IPacket> packets = new List<IPacket>();
MockActionDispatchGame game = new MockActionDispatchGame();
packets.AddRange(game.Action(new NetworkAction() { ActionType = NetworkActionType.NetworkTextSay }));
packets.AddRange(game.Action(new NetworkAction() { ActionType = NetworkActionType.NetworkPlayerKick }));
packets.AddRange(game.Action(new NetworkAction() { ActionType = NetworkActionType.NetworkPlayerBan }));
packets.AddRange(game.Action(new NetworkAction() { ActionType = NetworkActionType.NetworkMapAppend }));
packets.AddRange(game.Action(new NetworkAction() { ActionType = NetworkActionType.NetworkPlayerKill }));
packets.AddRange(game.Action(new NetworkAction() { ActionType = NetworkActionType.NetworkPlayerMove }));
packets.AddRange(game.Action(new NetworkAction() { ActionType = NetworkActionType.NetworkPacketSend }));
Assert.IsTrue(packets.Any(packet => packet.Text == ""Chat""));
Assert.IsTrue(packets.Any(packet => packet.Text == ""Kick""));
Assert.IsTrue(packets.Any(packet => packet.Text == ""Ban""));
Assert.IsTrue(packets.Any(packet => packet.Text == ""Map""));
Assert.IsTrue(packets.Any(packet => packet.Text == ""Kill""));
Assert.IsTrue(packets.Any(packet => packet.Text == ""Move""));
Assert.IsTrue(packets.Any(packet => packet.Text == ""Chat""));
}",Simply tests that actions are dispatched correctly. Coverage.,1
1268,"public void TestGameActionDispatchNullsRemoved() {
MockActionChatNullResultGame game = new MockActionChatNullResultGame();
List<IPacket> packets = game.Action(new NetworkAction() {
ActionType = NetworkActionType.NetworkTextSay
});
Assert.AreEqual(0, packets.Count);
}",Tests that null values are removed during a dispatch.,1
1269,protected List<VariableModel> ListeningVariables { get; set; },"List of variables we have assigned event handlers to. Allows us to cleanup properly during a dispose. We also do it this way because a group may be removed, in which case we won't know what variable to dereference.",1
1270,"public GroupedVariableListener() : base() {
this.ListeningVariables = new List<VariableModel>();
}",Initializes with default attributes,1
1271,"public void AssignEvents() {
// Remove all current handlers, also clears the list in this.ListeningVariables
this.UnassignEvents();
// Populate the list of variables we're listening to events on.
this.ListeningVariables.Add(this.Variables.Variable(this.GroupsVariableName));
foreach (String groupName in this.GetGroupedNames()) {
foreach (String listeningVariable in this.ListeningVariablesNames) {
this.ListeningVariables.Add(this.Variables.Variable(VariableModel.NamespaceVariableName(groupName, listeningVariable)));
}
}
// Now assign all of the event handlers.
foreach (VariableModel variable in this.ListeningVariables) {
variable.PropertyChanged += new PropertyChangedEventHandler(EventsPushConfigGroups_PropertyChanged);
}
}",This will also setup the empty namespace group.,1
1272,"public void UnassignEvents() {
foreach (VariableModel variable in this.ListeningVariables) {
variable.PropertyChanged -= new PropertyChangedEventHandler(EventsPushConfigGroups_PropertyChanged);
}
this.ListeningVariables.Clear();
}",Removes all current event handlers.,1
1273,"public void Execute() {
this.OnOpenGroupedControllerList(this.GetGroupedNames());
}","Fires off a change immediately, so any existing grouped variables are included in an event to set themselves up.",1
1274,"public GroupModel() : base() {
this.Name = String.Empty;
this.Accounts = new List<AccountModel>();
this.Permissions = new List<PermissionModel>();
// Setup the default permissions.
foreach (CommandType name in Enum.GetValues(typeof(CommandType)).Cast<CommandType>().Where(name => name != CommandType.None)) {
var permission = new PermissionModel() {
CommandType = name,
// All of the CommandType are boolean.
Traits = {
PermissionTraitsType.Boolean
}
};
var attributes = typeof(CommandType).GetMember(name.ToString()).First().GetCustomAttributes(typeof(DescriptionAttribute), false);
if (attributes.Length > 0) {
permission.Description = attributes.Cast<DescriptionAttribute>().First().Description;
}
this.Permissions.Add(permission);
}
// List of permissions that are not simple boolean (they take into account the level of Authority)
var authorityConstrainedActions = new List<String>() {
""NetworkPlayerMove"",
""NetworkPlayerMoveForce"",
""NetworkPlayerMoveRotate"",
""NetworkPlayerMoveRotateForce"",
""NetworkPlayerBan"",
""NetworkPlayerUnban"",
""NetworkPlayerKick"",
""NetworkPlayerKill""
};
foreach (NetworkActionType name in Enum.GetValues(typeof(NetworkActionType)).Cast<NetworkActionType>().Where(name => name != NetworkActionType.None)) {
var permission = new PermissionModel() {
Name = name.ToString()
};
if (authorityConstrainedActions.Contains(name.ToString()) == false) {
permission.Traits.Add(PermissionTraitsType.Boolean);
}
var attributes = typeof(NetworkActionType).GetMember(name.ToString()).First().GetCustomAttributes(typeof(DescriptionAttribute), false);
if (attributes.Length > 0) {
permission.Description = attributes.Cast<DescriptionAttribute>().First().Description;
}
this.Permissions.Add(permission);
}
List<String> booleanTraits = new List<String>() { PermissionTraitsType.Boolean };
// Set default boolean traits for default permissions
Dictionary<String, List<String>> defaultTraits = new Dictionary<String, List<String>>() {
{ CommandType.SecurityGroupAddAccount.ToString(), booleanTraits },
{ CommandType.SecurityRemoveAccount.ToString(), booleanTraits },
{ CommandType.SecurityAccountAuthenticate.ToString(), booleanTraits },
{ CommandType.SecurityAccountSetPassword.ToString(), booleanTraits },
{ CommandType.SecurityAccountSetPasswordHash.ToString(), booleanTraits },
{ CommandType.SecurityAccountSetPreferredLanguageCode.ToString(), booleanTraits }
// @todo more
};
foreach (var trait in defaultTraits) {
this.Permissions.First(permission => permission.Name == trait.Key).Traits.AddRange(trait.Value);
}
}",Initializes the group with default values.,1
1275,"public GroupModel() {
this.Type = String.Empty;
this.Uid = null;
this.FriendlyName = String.Empty;
}",Initializes default values.,0
1276,"public HttpCommandRequest() {
this.Tags = new Dictionary<String, String>();
this.Content = new List<String>();
this.Packets = new List<IPacket>();
}",Initalizes the request with default values.,1
1277,"public interface ICacheBuilder {
/// <summary>
/// The repository to build the cache on.
/// </summary>
IList<PackageWrapperModel> Cache { get; set; }
/// <summary>
/// The repository to use as a reference.
/// </summary>
IList<IPackage> Source { get; set; }
/// <summary>
/// Build the cache within the repository, appending known information to the repository packages.
/// </summary>
void Build();
}",Interface for building various information about the repository from a source.,1
1278,"public interface ICertificateController : ISharedReferenceAccess {
/// <summary>
/// The loaded X509Certificate object
/// </summary>
X509Certificate2 Certificate { get; }
/// <summary>
/// Executes the controller.
/// </summary>
ICoreController Execute();
}",Manages loading and holding the X509Certificate object,1
1279,"public interface IClientEventArgs {
/// <summary>
/// Stores the type of event (ConnectionStateChanged, PacketSent etc)
/// </summary>
ClientEventType EventType { get; set; }
/// <summary>
/// The state of the connection (Connected/Disconnected/LoggedIn)
/// </summary>
ConnectionState ConnectionState { get; set; }
/// <summary>
/// When the event occured. Defaults to the current date/time.
/// </summary>
DateTime Stamp { get; set; }
/// <summary>
/// Data describing the effected data before the event occured.
/// </summary>
IClientEventData Then { get; set; }
/// <summary>
/// Data describing how the data looked after the event.
/// </summary>
IClientEventData Now { get; set; }
}",An event originating from the networking side of the protocol implementation.,1
1280,"public interface IClientEventData {
/// <summary>
/// List of exceptions attached to this event, if any.
/// </summary>
List<String> Exceptions { get; set; }
/// <summary>
/// List of packets attached to this event, if any.
/// </summary>
List<IPacket> Packets { get; set; }
/// <summary>
/// List of actions attached to this event, if any.
/// </summary>
List<INetworkAction> Actions { get; set; } }",Data attached to a client event,1
1281,"public interface IClientSetup {
/// <summary>
/// The hostname to connect to.
/// </summary>
String Hostname { get; }
/// <summary>
/// The port to connect on.
/// </summary>
ushort Port { get; }
}",Setup variables used when creating a new client,1
1282,"public interface ICommand {
/// <summary>
/// The command being executed. This is the only value used to match up a command.
/// </summary>
String Name { get; set; }
/// <summary>
/// The command to be executed, will be converted to a string in Name
/// </summary>
CommandType CommandType { get; set; }
/// <summary>
/// The commands unique identifier, created when the command object is created.
/// </summary>
Guid CommandGuid { get; set; }
/// <summary>
/// The scope that this commands execution should be limited to.
/// </summary>
CommandScopeModel Scope { get; set; }
/// <summary>
/// Where the command came from
/// </summary>
CommandOrigin Origin { get; set; }
/// <summary>
/// The final result of this command.
/// </summary>
ICommandResult Result { get; set; }
/// <summary>
/// The original request from a remote source.
/// </summary>
ICommandRequest Request { get; set; }
/// <summary>
/// The raw parameters to be passed into the executable command.
/// </summary>
List<ICommandParameter> Parameters { get; set; }
/// <summary>
/// Holds the authentication information required to execute the command.
/// </summary>
CommandAuthenticationModel Authentication { get; set; }
/// <summary>
/// Sets the origin of the command, then returns the command. Allows for method chaining
/// </summary>
/// <param name=""origin"">The origin to set this command</param>
/// <returns>this</returns>
ICommand SetOrigin(CommandOrigin origin);
/// <summary>
/// Sets the authentication of the command, then returns the command. Allows for method chaining.
/// </summary>
/// <param name=""authentication"">The authentication model to set</param>
/// <returns>this</returns>
ICommand SetAuthentication(CommandAuthenticationModel authentication);
/// <summary>
/// Sets the scope of the command, then returns the command. Allows for method chaining
/// </summary>
/// <param name=""scope"">The scope to set this command</param>
/// <returns>this</returns>
ICommand SetScope(CommandScopeModel scope);
/// <summary>
/// The config only requires the name and parameters, everything else is ignored. We could just
/// return the results of ToXElement() but we neaten it up a little bit just so the config
/// isn't bloated with useless information.
/// </summary>
/// <returns></returns>
IConfigCommand ToConfigCommand();
/// <summary>
/// Parses a command type from an enum if it is valid.
/// </summary>
/// <param name=""commandName""></param>
ICommand ParseCommandType(String commandName);
}","A simple command to be passed between executable objects, allowing for commands to originate for various sources but allow for security, serialization and general neatness.",1
1283,"public interface ICommandData : IDisposable {
/// <summary>
/// List of strings to use as general content (localization(s), html etc.)
/// </summary>
List<String> Content { get; set; }
/// <summary>
/// Connections effected by this event.
/// </summary>
List<ConnectionModel> Connections { get; set; }
/// <summary>
/// Game types attached to this event.
/// </summary>
List<ProtocolType> ProtocolTypes { get; set; }
/// <summary>
/// Meta data for a protocol type
/// </summary>
List<IProtocolAssemblyMetadata> ProtocolAssemblyMetadatas { get; set; }
/// <summary>
/// Groups effected by this event.
/// </summary>
List<Core.Shared.Models.GroupModel> Groups { get; set; }
/// <summary>
/// Accounts effected by this event.
/// </summary>
List<AccountModel> Accounts { get; set; }
/// <summary>
/// Access tokens used or generated by this event.
/// </summary>
List<AccessTokenTransportModel> AccessTokens { get; set; }
/// <summary>
/// Permissions effected by this event.
/// </summary>
List<PermissionModel> Permissions { get; set; }
/// <summary>
/// Account players effected by this event.
/// </summary>
List<AccountPlayerModel> AccountPlayers { get; set; }
/// <summary>
/// Variables effected by this event.
/// </summary>
List<VariableModel> Variables { get; set; }
/// <summary>
/// Languages effected by this event.
/// </summary>
List<LanguageModel> Languages { get; set; }
/// <summary>
/// Text commands effected by this event.
/// </summary>
List<TextCommandModel> TextCommands { get; set; }
/// <summary>
/// The results of any text commands matches
/// </summary>
List<TextCommandMatchModel> TextCommandMatches { get; set; }
/// <summary>
/// Variables effected by this event.
/// </summary>
List<IGenericEvent> Events { get; set; }
/// <summary>
/// Repositories effected by this event.
/// </summary>
List<RepositoryModel> Repositories { get; set; }
/// <summary>
/// Packages effected by this event.
/// </summary>
List<PackageWrapperModel> Packages { get; set; }
/// <summary>
/// The plugins attached to this event
/// </summary>
List<PluginModel> Plugins { get; set; }
/// <summary>
/// The network actions attached to this event, if any.
/// </summary>
List<INetworkAction> NetworkActions { get; set; }
/// <summary>
/// The chats attached to this event, if any.
/// </summary>
List<ChatModel> Chats { get; set; }
/// <summary>
/// The players attached to this event, if any.
/// </summary>
List<PlayerModel> Players { get; set; }
/// <summary>
/// The kills attached to this event, if any.
/// </summary>
List<KillModel> Kills { get; set; }
/// <summary>
/// The moves attached to this event, if any.
/// </summary>
List<MoveModel> Moves { get; set; }
/// <summary>
/// The spawns attached to this event, if any.
/// </summary>
List<SpawnModel> Spawns { get; set; }
/// <summary>
/// The kicks attached to this event, if any.
/// </summary>
List<KickModel> Kicks { get; set; }
/// <summary>
/// The bans attached to this event, if any.
/// </summary>
List<BanModel> Bans { get; set; }
/// <summary>
/// The settings attached to this event, if any. If any, if any. If any. Hai Ike.
/// </summary>
List<Settings> Settings { get; set; }
/// <summary>
/// The maps attached to this event, if any.
/// </summary>
List<MapModel> Maps { get; set; }
/// <summary>
/// The command results attached to this event, if any.
/// </summary>
List<ICommandResult> CommandResults { get; set; }
/// <summary>
/// The raw packets attached to this command or event, if any.
/// </summary>
List<IPacket> Packets { get; set; }
/// <summary>
/// A query or query result.
/// </summary>
List<IDatabaseObject> Queries { get; set; }
}","All data types, as lists, that can be attached to a command.",1
1284,"Func<ICommand, Dictionary<String, ICommandParameter>, ICommandResult> Handler { get; set; }",The handler to dispatch the command to,1
1285,"public interface ICommandDispatch {
/// <summary>
/// The command being executed. This is the only value used to match up a command.
/// </summary>
String Name { get; set; }
/// <summary>
/// The command to be executed, will be converted to a string in Name
/// </summary>
CommandType CommandType { get; set; }
/// <summary>
/// When in the execution we want to capture the command (before, as the handler or after)
/// </summary>
CommandAttributeType CommandAttributeType { get; set; }
/// <summary>
/// A list of parameter names with the type of parameter expected.
/// </summary>
List<CommandParameterType> ParameterTypes { get; set; }
/// <summary>
/// The handler to dispatch the command to
/// </summary>
Func<ICommand, Dictionary<String, ICommandParameter>, ICommandResult> Handler { get; set; }
/// <summary>
/// Checks if this dspatcher can handle the command
/// </summary>
/// <returns></returns>
bool CanDispatch(CommandAttributeType attributeType, ICommand command);
/// <summary>
/// Compares an expected parameter list against the parameters supplied. If the types match (or can be converted) then
/// a dictionary of parameter names to the parameters supplied is returned, otherwise null is returned implying
/// and error was encountered or a type wasn't found.
/// </summary>
Dictionary<String, ICommandParameter> BuildParameterDictionary(IList<ICommandParameter> parameters);
}",Description of how to dispatch a command where to dispatch it to,1
1286,"public interface ICommandRequest {
/// <summary>
/// Dictionary of base string variables attached to the request.
/// </summary>
Dictionary<String, String> Tags { get; set; }
/// <summary>
/// The full content of the original request
/// </summary>
List<String> Content { get; set; }
/// <summary>
/// Any packets attached to this request
/// </summary>
List<IPacket> Packets { get; set; }
}",Holds all information about a proxied request (via the command server),1
1287,event EventHandler Disposed;,Called when the object is being disposed.,1
1288,"public interface ICommandResult {
/// <summary>
/// Text based version of CommandResultType, but allows for custom result types from
/// custom commands within plugins.
/// </summary>
String Name { get; set; }
/// <summary>
/// A general text message used to describe the event in more detail, if required.
/// </summary>
String Message { get; set; }
/// <summary>
/// When the event occured. Defaults to the current date/time.
/// </summary>
DateTime Stamp { get; set; }
/// <summary>
/// The limiting scope of the event (the connection, player etc. that this event is limited to)
/// </summary>
ICommandData Scope { get; set; }
/// <summary>
/// Data that this used to be, like an account being moved from one group to another
/// this would be the original group.
/// </summary>
ICommandData Then { get; set; }
/// <summary>
/// Data as it is seen ""now""
/// </summary>
ICommandData Now { get; set; }
/// <summary>
/// Simple flag determining the success of the command being executed.
/// </summary>
Boolean Success { get; set; }
/// <summary>
/// A more detailed status describing the command execution.
/// </summary>
CommandResultType CommandResultType { get; set; }
/// <summary>
/// How the output of the command should be handled if it is a remote request.
/// Defaults to application/xml where the entire result is output
/// </summary>
String ContentType { get; set; }
/// <summary>
/// Called when the object is being disposed.
/// </summary>
event EventHandler Disposed;
}",I'd be tempted to refactor GenericEventArgs so I can seal this class. It's used as a backbone for xml serialization so any inherited classes could cause the xml serializer to encounter a type it didn't expect.,1
1289,"public interface ICompiledQuery : IQueryData {
/// <summary>
/// List of compiled child queries.
/// </summary>
List<ICompiledQuery> Children { get; set; }
/// <summary>
/// The combined and compield version of the query
/// </summary>
List<string> Compiled { get; set; }
}",A compiled version of the query with as basic information as we can boil the complex query down to,1
1290,"public interface IConfig {
/// <summary>
/// The data loaded or saved for this config
/// </summary>
JObject Document { get; set; }
/// <summary>
/// The working root for a config of this type.
/// </summary>
JArray Root { get; set; }
/// <summary>
/// Converts data into a JObject and appends it to the root
/// </summary>
/// <returns>this</returns>
IConfig Append<T>(T data);
/// <summary>
/// Finds the root of a specific type.
/// </summary>
/// <returns>this</returns>
JArray RootOf<T>();
/// <summary>
/// Finds the root of a specific type.
/// </summary>
/// <returns>this</returns>
JArray RootOf(Type type);
/// <summary>
/// Finds the root of a specific type.
/// </summary>
/// <returns>this</returns>
JArray RootOf(String @namespace);
/// <summary>
/// Combines this configuration file with another configuration file.
/// Returns a reference back to this config.
/// </summary>
/// <returns>this</returns>
IConfig Union(IConfig config);
/// <summary>
/// Loads all the files in the specified directory into this configuration file.
/// Returns a reference back to this config.
/// </summary>
/// <returns>this</returns>
IConfig Load(DirectoryInfo directory);
/// <summary>
/// Loads the specified file into this configuration file using the file's contents.
/// Returns a reference back to this config.
/// </summary>
/// <returns>this</returns>
IConfig Load(FileInfo file);
/// <summary>
/// Initializes this configuration file for the specified object type.
/// Returns a reference back to this config.
/// </summary>
/// <returns>this</returns>
IConfig Create<T>();
/// <summary>
/// Initializes this configuration file for the specified object type.
/// Returns a reference back to this config.
/// </summary>
/// <returns>this</returns>
IConfig Create(Type type);
/// <summary>
/// Write this configuration file out to disk using the specified path and name.
/// Returns a reference back to this config.
/// </summary>
/// <returns>this</returns>
IConfig Save(FileInfo file);
}",A namespace json config for saving serialized commands,1
1291,"public interface IConfigCommand {
/// <summary>
/// Salt used to derive a key from a password
/// </summary>
String Salt { get; set; }
/// <summary>
/// A vector used for decrypting the data into a command.
/// </summary>
String Vector { get; set; }
/// <summary>
/// The encrypted data to be decrypted and deserialized into a command.
/// </summary>
String Data { get; set; }
/// <summary>
/// The plain command object, or the decrypted and deserialized command.
/// </summary>
ICommand Command { get; set; }
/// <summary>
/// Encrypts the command to the data
/// </summary>
/// <returns></returns>
IConfigCommand Encrypt(String password);
/// <summary>
/// Decrypted the config command, if it's currently encrypted.
/// </summary>
/// <returns></returns>
IConfigCommand Decrypt(String password);
}",A wrapper for a command being saved to a config,1
1292,"public interface IConnectionController : ICoreController {
/// <summary>
/// Data about the protocol connection
/// </summary>
ConnectionModel ConnectionModel { get; set; }
/// <summary>
/// Fired when a protocol event is recieved from the protocol appdomain.
/// </summary>
event Action<IProtocolEventArgs> ProtocolEvent;
/// <summary>
/// Fired when a client event is recieved from the protocol appdomain.
/// </summary>
event Action<IClientEventArgs> ClientEvent;
/// <summary>
/// Proxy to the active protocol state
/// </summary>
IProtocolState ProtocolState { get; }
}","Handles connections, plugins and text commands for a single game server.",1
1293,"public interface ICoreController : IDisposable {
/// <summary>
/// List of commands this controller will handle/dispatch.
/// </summary>
List<ICommandDispatch> CommandDispatchers { get; set; } /// <summary>
/// All objects to tunnel downwards during execution
/// </summary>
List<ICoreController> TunnelObjects { get; set; }
/// <summary>
/// All objects to bubble upwards during execution
/// </summary>
List<ICoreController> BubbleObjects { get; set; }
/// <summary>
/// Run a preview of a command on the current object, then tunnel or bubble the command.
/// </summary>
/// <param name=""command""></param>
/// <param name=""direction"">If the command should then be tunneled or bubbled</param>
/// <returns>The result of the preview. A handler may have canceled the command.</returns>
ICommandResult PropogatePreview(ICommand command, CommandDirection direction);
/// <summary>
/// Run a command on the current object, then tunnel or bubble the command.
/// </summary>
/// <param name=""command""></param>
/// <param name=""direction"">If the command should then be tunneled or bubbled</param>
/// <returns>The result of the execution.</returns>
ICommandResult PropogateHandler(ICommand command, CommandDirection direction);
/// <summary>
/// Alert the object that a command has been executed with the following results
/// </summary>
/// <param name=""command""></param>
/// <param name=""direction"">If the command should then be tunneled or bubbled</param>
/// <returns>The result of the executed.</returns>
ICommandResult PropogateExecuted(ICommand command, CommandDirection direction);
/// <summary>
/// Execute a command, then tunnel it if the dispatch fails or remains as continuing
/// </summary>
/// <param name=""command""></param>
/// <returns></returns>
ICommandResult Tunnel(ICommand command);
/// <summary>
/// Execute a command, then bubble it if the dispatch fails or remains as continuing
/// </summary>
/// <param name=""command""></param>
/// <returns></returns>
ICommandResult Bubble(ICommand command);
/// <summary>
/// Call after the constructor is called to setup events with any assigned properties
/// </summary>
ICoreController Execute();
/// <summary>
/// Appends config items
/// </summary>
void WriteConfig(IConfig config, String password = null);
/// <summary>
/// A set interval Poke
/// </summary>
void Poke();
}",The implementing object accepts command execution,1
1294,"public interface IDatabaseObject : ICollection<IDatabaseObject> {
/// <summary>
/// Append a Method type to the list of objects on this
/// </summary>
/// <param name=""data"">A method object</param>
/// <returns>this</returns>
IDatabaseObject Method(IDatabaseObject data);
/// <summary>
/// Appends a Database object to the list of objects on this
/// </summary>
/// <param name=""data"">A database object</param>
/// <returns>this</returns>
IDatabaseObject Database(IDatabaseObject data);
/// <summary>
/// Creates a new Database object with a specified name, then
/// appends the object ot the list of objects on this
/// </summary>
/// <param name=""name"">The name of the database</param>
/// <returns>this</returns>
IDatabaseObject Database(String name);
/// <summary>
/// Append a Index type to the list of objects on this
/// </summary>
/// <param name=""data"">The index to append</param>
/// <returns>this</returns>
IDatabaseObject Index(IDatabaseObject data);
/// <summary>
/// Creates a new ascending index on a field with name
/// </summary>
/// <param name=""collection"">The name of the collectionthe field with name exists in</param>
/// <param name=""name"">The name of the field to index on</param>
/// <returns>this</returns>
IDatabaseObject Index(String collection, String name);
/// <summary>
/// Creates a new ascending or descending index on a field with name
/// </summary>
/// <param name=""collection"">The name of the collectionthe field with name exists in</param>
/// <param name=""name"">The name of the field to index on</param>
/// <param name=""sortByModifier"">The direction to sort by</param>
/// <returns>this</returns>
/// <remarks>Passing Ascending through is as good as using Index(name)</remarks>
IDatabaseObject Index(String collection, String name, ISortByModifier sortByModifier);
/// <summary>
/// Creates a new ascending index on a field with name, potentially a unique or primary key
/// </summary>
/// <param name=""collection"">The name of the collectionthe field with name exists in</param>
/// <param name=""name"">The name of the field to index on</param>
/// <param name=""indexModifier"">The type of index (primary, unique etc.)</param>
/// <returns>this</returns>
IDatabaseObject Index(String collection, String name, IIndexModifier indexModifier);
/// <summary>
/// Creates a new ascending or descenting index on a field with name, potentially a unique or primary key
/// </summary>
/// <param name=""collection"">The name of the collectionthe field with name exists in</param>
/// <param name=""name"">The name of the field to index on</param>
/// <param name=""indexModifier"">The type of index (primary, unique etc.)</param>
/// <param name=""sortByModifier"">The direction to sort by</param>
/// <returns>this</returns>
IDatabaseObject Index(String collection, String name, IIndexModifier indexModifier, ISortByModifier sortByModifier);
/// <summary>
/// Appends a modifier
/// </summary>
/// <param name=""data"">The modifier to append</param>
/// <returns>this</returns>
IDatabaseObject Modifier(IDatabaseObject data);
/// <summary>
/// Appends a field type
/// </summary>
/// <param name=""data"">The field type to append</param>
/// <returns>this</returns>
IDatabaseObject FieldType(IDatabaseObject data);
/// <summary>
/// Appends a field object to the chain
/// </summary>
/// <param name=""data"">The field objec to append</param>
/// <returns>this</returns>
IDatabaseObject Field(IDatabaseObject data);
/// <summary>
/// Creates and appends new field object with a field name of `name`
/// </summary>
/// <param name=""name"">The name of the field</param>
/// <returns>this</returns>
IDatabaseObject Field(String name);
/// <summary>
/// Creates and appends a new field object with name of `name`, a specified type and if the field is nullable or not
/// </summary>
/// <param name=""name"">The name of the field</param>
/// <param name=""type"">The type of field to use</param>
/// <param name=""nullable"">true if the field allows null</param>
/// <returns>this</returns>
IDatabaseObject Field(String name, IFieldType type, bool nullable = true);
/// <summary>
/// Creates and appends a new field object with name of `name`, a string type with a specified length and if the field is nullable or not
/// </summary>
/// <param name=""name"">The name of the field</param>
/// <param name=""length"">The maximum length of the field data</param>
/// <param name=""nullable"">true if the field allows null</param>
/// <returns>this</returns>
IDatabaseObject Field(String name, int length, bool nullable = true);
/// <summary>
/// Appends an equality object
/// </summary>
/// <param name=""data"">The equality object to append</param>
/// <returns>this</returns>
IDatabaseObject Condition(IDatabaseObject data);
/// <summary>
/// Creates a new condition object, a field with name equaling data
/// </summary>
/// <param name=""name"">The name of the field to compare against</param>
/// <param name=""data"">The data to compare against</param>
/// <returns>this</returns>
IDatabaseObject Condition(String name, Object data);
/// <summary>
/// Create a new condition object, field with name, a comparison of equality
/// against data
/// </summary>
/// <param name=""name"">The name of the field to compare against</param>
/// <param name=""equality"">The equality to compare the field against the data</param>
/// <param name=""data"">The data to compare against</param>
/// <returns>this</returns>
IDatabaseObject Condition(String name, IEquality equality, Object data);
/// <summary>
/// Creates a new condition object, a field with name equaling data
/// </summary>
/// <param name=""collection"">The specific collection to prefix the field with e.g ""Player.Name""</param>
/// <param name=""name"">The name of the field to compare against</param>
/// <param name=""data"">The data to compare against</param>
/// <returns>this</returns>
IDatabaseObject Condition(String collection, String name, Object data);
/// <summary>
/// Create a new condition object, field with name, a comparison of equality
/// against data
/// </summary>
/// <param name=""collection"">The specific collection to prefix the field with e.g ""Player.Name""</param>
/// <param name=""name"">The name of the field to compare against</param>
/// <param name=""equality"">The equality to compare the field against the data</param>
/// <param name=""data"">The data to compare against</param>
/// <returns>this</returns>
IDatabaseObject Condition(String collection, String name, IEquality equality, Object data);
/// <summary>
/// Appends an assignment object to the chain
/// </summary>
/// <param name=""data"">The assignment object</param>
/// <returns>this</returns>
IDatabaseObject Set(IDatabaseObject data);
/// <summary>
/// Creates a new assignment object to set a field with `name` to `data`
/// </summary>
/// <param name=""name"">The field to set</param>
/// <param name=""data"">The data to set the field as</param>
/// <returns>this</returns>
IDatabaseObject Set(String name, Object data);
/// <summary>
/// Appends a collection object to the chain
/// </summary>
/// <param name=""data"">The collection object</param>
/// <returns>this</returns>
IDatabaseObject Collection(IDatabaseObject data);
/// <summary>
/// Creates a new collection object, then appends to the list
/// </summary>
/// <param name=""name"">The name of the table or collection</param>
/// <returns>this</returns>
IDatabaseObject Collection(String name);
/// <summary>
/// Appends a sort object to the chain
/// </summary>
/// <param name=""data"">The sort object</param>
/// <returns>this</returns>
IDatabaseObject Sort(IDatabaseObject data);
/// <summary>
/// Creates a new sort object, then appends to the list
/// </summary>
/// <param name=""name"">The name of the field to sort</param>
/// <param name=""modifier"">Ascending or descending, which appends a Ascending order modifier if null (default) </param>
/// <returns>this</returns>
IDatabaseObject Sort(String name, ISortByModifier modifier = null);
/// <summary>
/// Creates a new sort object, then appends to the list
/// </summary>
/// <param name=""collection"">The collection the field exists in to sort</param>
/// <param name=""name"">The name of the field to sort</param>
/// <param name=""modifier"">Ascending or descending, which appends a Ascending order modifier if null (default) </param>
/// <returns>this</returns>
IDatabaseObject Sort(String collection, String name, ISortByModifier modifier = null);
/// <summary>
/// Appends a limit modifer to the chain
/// </summary>
/// <param name=""data"">The limit object</param>
/// <returns>this</returns>
IDatabaseObject Limit(IDatabaseObject data);
/// <summary>
/// Creates a new limit modifier and appends it to the chain
/// </summary>
/// <param name=""limit"">The value to place inside the limit</param>
/// <returns>this</returns>
IDatabaseObject Limit(int limit);
/// <summary>
/// Appends a skip modifer to the chain
/// </summary>
/// <param name=""data"">The skip object</param>
/// <returns>this</returns>
IDatabaseObject Skip(IDatabaseObject data);
/// <summary>
/// Creates a new skip modifier and appends it to the chain
/// </summary>
/// <param name=""skip"">The value to place inside the skip object</param>
/// <returns>this</returns>
IDatabaseObject Skip(int skip);
/// <summary>
/// Tags this object with a implicit modifier, letting the serializer know that it has been automatically generated
/// while using shorthand methods.
/// </summary>
/// <returns>this</returns>
IDatabaseObject Implicit();
/// <summary>
/// Tags the object with an explicit modifier, letting the serializer know it has been explicitly appended
/// to the query chain and not generated bybuilder code.
/// </summary>
/// <returns>this</returns>
IDatabaseObject Explicit();
/// <summary>
/// Appends a database object without any modifications, returns the current object.
/// </summary>
/// <param name=""item"">The item to append to the chain</param>
/// <returns>this</returns>
IDatabaseObject Raw(IDatabaseObject item);
}",The base object with a bunch of helper methods to make building a query relatively,1
1295,"public interface IDeferredAction {
/// <summary>
/// Fetches the action attached to this object, without concern to the exact type.
/// </summary>
/// <returns>The action attached to this object</returns>
INetworkAction GetAction();
/// <summary>
/// Insert data for a sent action
/// </summary>
/// <param name=""action"">The action that has completed</param>
/// <param name=""requests"">The packets that were sent to complete this action</param>
/// <returns>True if data was successfully inserted, false otherwise.</returns>
bool TryInsertSent(INetworkAction action, List<IPacket> requests);
/// <summary>
/// Insert data for a completed action to be propogated through the callbacks for this action.
/// </summary>
/// <param name=""action"">The action that has completed</param>
/// <param name=""requests"">The packets that were sent to complete this action</param>
/// <param name=""responses"">The response packets received for each packet sent</param>
/// <returns>True if data was successfully inserted, false otherwise.</returns>
bool TryInsertDone(INetworkAction action, List<IPacket> requests, List<IPacket> responses);
/// <summary>
/// Insert data for an expired action
/// </summary>
/// <param name=""action"">The action that has expired</param>
/// <param name=""requests"">The packets that were sent to complete this action</param>
/// <param name=""responses"">Any of the responses that were received before expiring</param>
/// <returns>True if data was successfully inserted, false otherwise.</returns>
bool TryInsertExpired(INetworkAction action, List<IPacket> requests, List<IPacket> responses);
/// <summary>
/// Insert any data required to call always on this deferred action.
/// </summary>
/// <param name=""action"">The action that has expired</param>
/// <returns>True if data was successfully inserted, false otherwise.</returns>
bool TryInsertAlways(INetworkAction action);
/// <summary>
/// Releases all handles on callbacks
/// </summary>
void Release();
}",A deferred action that will dispatch on the network layer and later call the associated delegate,1
1296,"public interface IDriver : ICloneable {
/// <summary>
/// The name of this driver.
/// </summary>
String Name { get; }
/// <summary>
/// The settings used to connect & authenticate with the database
/// </summary>
IDriverSettings Settings { get; set; }
/// <summary>
/// Opens the connection to the database.
/// </summary>
bool Connect();
/// <summary>
/// Query the open driver
/// </summary>
/// <param name=""query""></param>
List<IDatabaseObject> Query(IDatabaseObject query);
/// <summary>
/// Closes the open connection the database.
/// </summary>
void Close();
}",Base driver for a database connection,1
1297,"public interface IDriverSettings {
/// <summary>
/// The hostname to connect to.
/// </summary>
String Hostname { get; set; }
/// <summary>
/// The port to connect over.
/// </summary>
uint? Port { get; set; }
/// <summary>
/// The username for authentication.
/// </summary>
String Username { get; set; }
/// <summary>
/// The password for authentication.
/// </summary>
String Password { get; set; }
/// <summary>
/// The name of the database to select.
/// </summary>
String Database { get; set; }
/// <summary>
/// If the database should exists in memory only, not on a file system.
/// </summary>
bool Memory { get; set; }
}",The connection details for a driver to use when connecting/authenticating,1
1298,"public interface IFuzzyState {
/// <summary>
/// Language file, used to lookup values to attach to each object. The xml should be structured like
/// the namespace of the object.
/// </summary>
JObject Document { get; set; }
/// <summary>
/// Converts a phrase into a token if the token matches an object
/// </summary>
/// <param name=""state""></param>
/// <param name=""phrase""></param>
/// <returns></returns>
Phrase ParseThing(IFuzzyState state, Phrase phrase);
/// <summary>
/// Parses the text for any commands it can use.
/// </summary>
/// <param name=""state""></param>
/// <param name=""phrase""></param>
/// <returns></returns>
Phrase ParseMethod(IFuzzyState state, Phrase phrase);
/// <summary>
/// Parse a property, building the property reference.
/// </summary>
/// <param name=""state""></param>
/// <param name=""phrase""></param>
/// <returns></returns>
Phrase ParseProperty(IFuzzyState state, Phrase phrase);
/// <summary>
/// Parses a self reflection token to define who ""me"" is.
/// </summary>
/// <param name=""state""></param>
/// <param name=""selfThing""></param>
/// <returns></returns>
SelfReflectionThingObjectToken ParseSelfReflectionThing(IFuzzyState state, SelfReflectionThingObjectToken selfThing);
}",A state passed through to all combination and parse methods,1
1299,"public interface IMigration {
/// <summary>
/// A handler to execute when migrating upwards.
/// </summary>
/// <returns>True if the migration was successful, false if an error occured</returns>
Func<bool> Up { get; set; }
/// <summary>
/// A handler to execute when migrating downwards.
/// </summary>
/// <returns>True if the migration was successful, false if an error occured</returns>
Func<bool> Down { get; set; }
}",What actions should be taken in a migration up/down stream.,1
1300,"public interface IMigrationSettings {
/// <summary>
/// The name of the stream to focus on.
/// </summary>
MigrationOrigin Origin { get; set; }
/// <summary>
/// The name of the stream to focus on.
/// </summary>
String Name { get; set; }
/// <summary>
/// The current version of the migration for the specified name.
/// </summary>
int CurrentVersion { get; set; }
}",Holds settings to describe how migrations should be handled and what stream to look into.,1
1301,"public void Write(string textToAppend)
{
if (string.IsNullOrEmpty(textToAppend))
{
return;
}
// If we're starting off, or if the previous text ended with a newline,
// we have to append the current indent first.
if (((this.GenerationEnvironment.Length == 0) || this.endsWithNewline))
{
this.GenerationEnvironment.Append(this.currentIndentField);
this.endsWithNewline = false;
}
// Check if the current text ends with a newline
if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
{
this.endsWithNewline = true;
}
// This is an optimization. If the current indent is """", then we don't have to do any
// of the more complex stuff further down.
if ((this.currentIndentField.Length == 0))
{
this.GenerationEnvironment.Append(textToAppend);
return;
}
// Everywhere there is a newline in the text, add an indent after it
textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
// If the text ends with a newline, then we should strip off the indent added at the very end
// because the appropriate indent will be added when the next time Write() is called
if (this.endsWithNewline)
{
this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
}
else
{
this.GenerationEnvironment.Append(textToAppend);
}
}",Write text directly into the generated output,1
1302,"public void WriteLine(string textToAppend)
{
this.Write(textToAppend);
this.GenerationEnvironment.AppendLine();
this.endsWithNewline = true;
}",Write text directly into the generated output,1
1303,"public void Write(string format, params object[] args)
{
this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
}",Write formatted text directly into the generated output,1
1304,"public void WriteLine(string format, params object[] args)
{
this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
}",Write formatted text directly into the generated output,1
1305,"public void Error(string message)
{
System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
error.ErrorText = message;
this.Errors.Add(error);
}",Raise an error,1
1306,"public void Warning(string message)
{
System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
error.ErrorText = message;
error.IsWarning = true;
this.Errors.Add(error);
}",Raise a warning,1
1307,"public void PushIndent(string indent)
{
if ((indent == null))
{
throw new global::System.ArgumentNullException(""indent"");
}
this.currentIndentField = (this.currentIndentField + indent);
this.indentLengths.Add(indent.Length);
}",Increase the indent,1
1308,"public string PopIndent()
{
string returnValue = """";
if ((this.indentLengths.Count > 0))
{
int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
if ((indentLength > 0))
{
returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
}
}
return returnValue;
}",Remove the last indent that was added with PushIndent,1
1309,"public void ClearIndent()
{
this.indentLengths.Clear();
this.currentIndentField = """";
}",Remove any indentation,1
1310,"public interface INetworkAction : INetworkModel {
/// <summary>
/// The name of the action to take.
/// </summary>
String Name { get; set; }
/// <summary>
/// The specific type of action taken with this object.
/// </summary>
NetworkActionType ActionType { get; set; }
/// <summary>
/// A unique id generated for this particular action
/// </summary>
Guid Uid { get; set; }
}",An action for the network layer to execute,1
1311,"public void Build() {
foreach (var installedPackage in this.Source) {
PackageWrapperModel packageWrapper = this.Cache.FirstOrDefault(pack => pack.Id == installedPackage.Id);
if (packageWrapper != null) {
packageWrapper.Installed = PackageFactory.CreatePackageModelFromNugetPackage(installedPackage);
packageWrapper.State = installedPackage.Version.CompareTo(new SemanticVersion(packageWrapper.Available.Version)) < 0 ? PackageState.UpdateAvailable : PackageState.Installed;
}
// else we don't actually know if the package belongs to us or not, so we can't add it.
}
}","Build the cache within the repository, appending known information to the repository packages.",1
1312,"public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) {
var value = new C();
serializer.Populate(JObject.Load(reader).CreateReader(), value);
return value;
}",Converts type I to type C,1
1313,"public interface INumericPropertyReference {
/// <summary>
/// What thing this property can relate to
/// </summary>
IThingReference ThingReference { get; set; }
/// <summary>
/// Remove all references that do not match the comparator
/// </summary>
/// <param name=""thing""></param>
/// <param name=""comparator""></param>
/// <param name=""value""></param>
/// <returns></returns>
bool RemoveAll(IThingReference thing, EqualityLogicalOperatorToken comparator, FloatNumericPrimitiveToken value);
}",How to interact with a numeric property on a given thing,1
1314,"public interface IPackageManagerDispatch {
/// <summary>
/// Dispatches an install request on a package manager to install the passed in package
/// </summary>
/// <param name=""manager"">The build package manager with the source/local queried, checked and completed</param>
/// <param name=""package"">The package to install</param>
void InstallPackage(IPackageManager manager, IPackage package);
/// <summary>
/// Dispatches an update request on a package manager to install the passed in package
/// </summary>
/// <param name=""manager"">The build package manager with the source/local queried, checked and completed</param>
/// <param name=""package"">The package to install</param>
void UpdatePackage(IPackageManager manager, IPackage package);
/// <summary>
/// Dispatches an uninstall request on a package manager to install the passed in package
/// </summary>
/// <param name=""manager"">The build package manager with the source/local queried, checked and completed</param>
/// <param name=""package"">The package to install</param>
void UninstallPackage(IPackageManager manager, IPackage package);
}",Dispatches requests on a package manager,1
1315,"public interface IPacket {
/// <summary>
/// When this packet was created
/// </summary>
DateTime Stamp { get; set; }
/// <summary>
/// The origin of the packet. This is useful when the server sends back responses to packets, we
/// can say the packet originiated from the client and this is the response.
/// </summary>
PacketOrigin Origin { get; set; }
/// <summary>
/// If this is a response or not to a previous packet.
/// </summary>
PacketType Type { get; set; }
/// <summary>
/// The sequence id for this command/event
/// </summary>
int? RequestId { get; set; }
/// <summary>
/// The raw bytes used to deserialize this packet.
/// </summary>
byte[] Data { get; set; }
/// <summary>
/// Textual representation of this packet
/// </summary>
String Text { get; set; }
/// <summary>
/// Textual representation of the packet
/// </summary>
String DebugText { get; set; }
/// <summary>
/// The wordified version of the text string version of the packet.
/// </summary>
List<String> Words { get; set; }
/// <summary>
/// The remote end point for the packet.
/// </summary>
IPEndPoint RemoteEndPoint { get; set; }
}",Basic information sent/recv from the connected client.,0
1316,"public interface IPacketDispatch {
/// <summary>
/// The name of the packet we should check against
/// </summary>
String Name { get; set; }
/// <summary>
/// Where the packet originated from (initiated from client, recieved response or initiated by server, expecting response)
/// </summary>
PacketOrigin Origin { get; set; }
}",A simple predicate to determine if the packet matches criteria to dispatch,1
1317,"public interface IPacketDispatcher {
/// <summary>
/// Appends a dispatch handler, first checking if an existing dispatch exists for this exact
/// packet. If it exists then it will be overridden.
/// </summary>
/// <param name=""handlers"">A dictionary of handlers to append to the dispatch handlers.</param>
void Append(Dictionary<IPacketDispatch, Action<IPacketWrapper, IPacketWrapper>> handlers);
/// <summary>
/// Dispatches a recieved packet. Each game implementation needs to supply its own dispatch
/// method as the protocol may be very different and have additional requirements beyond a /// simple text match.
/// </summary>
/// <param name=""packet"">The packet recieved from the game server.</param>
void Dispatch(IPacketWrapper packet);
}","A dispatcher of packets, will inspect data within a packet and if it matches will call the respective handler.",1
1318,"public interface IPacketQueue {
/// <summary>
/// Clears the current queue
/// </summary>
void Clear();
/// <summary>
/// Validates that packets are not 'lost' after being sent. If this is the case then the connection is shutdown
/// to then be rebooted at a later time.
/// /// If a packet exists in our outgoing ""SentPackets""
/// </summary>
bool RestartConnectionOnQueueFailure();
/// <summary>
/// Fetches the packet that initiated the request.
/// </summary>
/// <param name=""recievedPacket"">The response packet</param>
/// <returns>The request packet</returns>
IPacketWrapper GetRequestPacket(IPacketWrapper recievedPacket);
/// <summary>
/// Dequeues the current packet. If a packet is returned then it should be sent
/// </summary>
/// <param name=""packet""></param>
/// <returns></returns>
IPacketWrapper PacketReceived(IPacketWrapper packet);
/// <summary>
/// Enqueues a packet, also pops a packet for sending if a packet is waiting.
/// </summary>
/// <param name=""packet""></param>
/// <returns></returns>
IPacketWrapper PacketSend(IPacketWrapper packet);
}","Handles queing of packets, sending packets in a sequential order.",1
1319,"public interface IPacketSerializer {
/// <summary>
/// The minimum packet size requires to be passed into the packet serializer. Anything smaller
/// and it the full header of a packet wouldn't be available, therefore we wouldn't know
/// how many bytes the full packet is.
/// </summary>
uint PacketHeaderSize { get; set; }
/// <summary>
/// Deserializes an array of bytes into a Packet of type P
/// </summary>
/// <param name=""packetData"">The array to deserialize to a packet. Must be exact length of bytes.</param>
/// <returns>A new packet with data extracted from packetDate</returns>
IPacketWrapper Deserialize(byte[] packetData);
/// <summary>
/// Serializes a packet into an array of bytes to send to the server.
/// </summary>
/// <param name=""packet"">The packe to serialize</param>
/// <returns>An array of bytes to send to the server.</returns>
byte[] Serialize(IPacketWrapper packet);
/// <summary>
/// Fetches the full packet size by reading the header of a packet.
/// </summary>
/// <param name=""packetData"">The possibly incomplete packet data, or as much data as we have recieved from the server.</param>
/// <returns>The total size, in bytes, that is requires for the header + data to be deserialized.</returns>
long ReadPacketSize(byte[] packetData);
}",Handles serialization of packets to/from a byte stream,1
1320,"public interface IPacketStream {
/// <summary>
/// Returns the size of the stored Data.
/// </summary>
/// <returns>The length of the data array</returns>
int Size();
/// <summary>
/// Appends data onto the end of the stream
/// </summary>
/// <param name=""data"">The byte array to append to the stream</param>
/// <param name=""length"">The number of bytes to read off the data to append to the stream</param>
void Push(byte[] data, int length);
/// <summary>
/// Removes a specified number of bytes from the stream, returning them in a new byte array.
/// </summary>
/// <param name=""length"">The length of bytes to pull from the start of the stream</param>
/// <returns>The shifted bytes of length, if available. Null if nothing can be shifted.</returns>
byte[] Shift(uint length);
/// <summary>
/// Peeks at the start of the stream, but does not remove the data.
/// </summary>
/// <param name=""length"">The number of bytes to peek at</param>
/// <returns>The peeked data of length, or null if no data exists</returns>
byte[] PeekShift(uint length);
}",A packet stream to pull completed packets from,1
1321,"public interface IParsedQuery : IQueryData {
/// <summary>
/// List of parsed child queries.
/// </summary>
List<IParsedQuery> Children { get; set; }
}",The initial parse to collection peices of information but remain in a hierarchy,1
1322,"public interface IProcess {
/// <summary>
/// Kill the current process.
/// </summary>
void Kill();
}",Handles functionality affecting the running process.,1
1323,"public interface IProtocolAssemblyMetadata {
/// <summary>
/// The name of the file/directory without extension
/// </summary>
String Name { get; set; }
/// <summary>
/// The reference to the dll file
/// </summary>
FileInfo Assembly { get; set; }
/// <summary>
/// The reference to the meta file
/// </summary>
FileInfo Meta { get; set; }
/// <summary>
/// The directory holding the assembly and config information
/// </summary>
DirectoryInfo Directory { get; set; }
/// <summary>
/// The supported protocol types provided by the assembly
/// </summary>
List<IProtocolType> ProtocolTypes { get; set; } }",Wraps an assembly reference and supported protocol types.,1
1324,"public interface IProtocolEventArgs {
/// <summary>
/// Stores the type of event (PlayerJoin, PlayerLeave etc)
/// </summary>
ProtocolEventType ProtocolEventType { get; set; }
/// <summary>
/// The game type itself (BlackOps, BFBC2)
/// </summary>
IProtocolType ProtocolType { get; set; }
/// <summary>
/// Data describing the effected data before the event occured.
/// </summary>
IProtocolEventData Then { get; set; }
/// <summary>
/// Data describing how the data looked after the event.
/// </summary>
IProtocolEventData Now { get; set; }
/// <summary>
/// Any modifications or deletions that need to occur on the current state
/// to be synchronized.
/// </summary>
IProtocolStateDifference StateDifference { get; set; }
/// <summary>
/// When this event occured.
/// </summary>
DateTime Stamp { get; set; }
}","Even though a majority of the data inherits from ProtocolObject, we still have these as seperate fields for serialization.",1
1325,"public interface IProtocolEventData {
/// <summary>
/// The chats attached to this event, if any.
/// </summary>
List<ChatModel> Chats { get; set; }
/// <summary>
/// The players attached to this event, if any.
/// </summary>
List<PlayerModel> Players { get; set; }
/// <summary>
/// The kills attached to this event, if any.
/// </summary>
List<KillModel> Kills { get; set; }
/// <summary>
/// The moves attached to this event, if any.
/// </summary>
List<MoveModel> Moves { get; set; }
/// <summary>
/// The spawns attached to this event, if any.
/// </summary>
List<SpawnModel> Spawns { get; set; }
/// <summary>
/// The kicks attached to this event, if any.
/// </summary>
List<KickModel> Kicks { get; set; }
/// <summary>
/// The bans attached to this event, if any.
/// </summary>
List<BanModel> Bans { get; set; }
/// <summary>
/// The maps attached to this event, if any.
/// </summary>
List<MapModel> Maps { get; set; }
/// <summary>
/// The settings attached to this event, if any.
/// </summary>
List<Settings> Settings { get; set; }
/// <summary>
/// The list of points (3d) attached to this event, if any.
/// </summary>
List<Point3DModel> Points { get; set; }
/// <summary>
/// List of items attached to this event, if any.
/// </summary>
List<ItemModel> Items { get; set; }
}",Holds data attached to a protocol event,1
1326,"public interface IProtocolSetup {
/// <summary>
/// The hostname to connect to.
/// </summary>
String Hostname { get; }
/// <summary>
/// The port to connect on.
/// </summary>
ushort Port { get; }
/// <summary>
/// The password used to authenticate with the server.
/// </summary>
String Password { get; }
/// <summary>
/// A list of generic variables to us /// </summary>
IDictionary<String, String> Arguments { get; }
/// <summary>
/// Convert the variables dictionary to a simple string
/// </summary>
String ArgumentsString();
/// <summary>
/// The path for the protocol to look for configs at
/// </summary>
String ConfigDirectory { get; set; }
}",Setup variables used when creating a new protocol,1
1327,"public interface IProtocolShared {
/// <summary>
/// The client to handle all communications with the game server
/// </summary>
IClient Client { get; }
/// <summary>
/// Everything the connection currently knows about the game. This is updated
/// with all of the information we receive from the server.
/// </summary>
IProtocolState State { get; }
/// <summary>
/// All of the credentials and connection details required to connect the protocol
/// </summary>
IProtocolSetup Options { get; }
/// <summary>
/// Describing attribute of this game.
/// </summary>
IProtocolType ProtocolType { get; }
/// <summary>
/// Sets up the protocol, initializing the client
/// </summary>
IProtocolSetupResult Setup(IProtocolSetup setup);
/// <summary>
/// Process a generic network action. All packets generated and sent to the server should be returned here.
/// </summary>
/// <param name=""action"">The action to take, which will be conerted to packets to send to the game server</param>
/// <returns>A list of packets generated</returns>
List<IPacket> Action(INetworkAction action);
/// <summary>
/// Sends a packet to the server, provided a client exists and the connection is open and ready or logged in.
/// This allows for the login command to be sent to a ready connection, otherwise no login packets could be sent.
/// </summary>
/// <param name=""packet""></param>
IPacket Send(IPacketWrapper packet);
/// <summary>
/// Attempts a connection to the server.
/// </summary>
void AttemptConnection();
/// <summary>
/// Shutsdown this connection
/// </summary>
void Shutdown();
/// <summary>
/// General timed event to synch everything on the server with what is known locally.
/// </summary>
void Synchronize();
}",The base methods and attributes of protocol. Essentially anything that a third party should be able to see from the protocol implementation.,1
1328,"public interface IProtocolStateDifference {
/// <summary>
/// Override all modifications. Will *set* the list, not update it.
/// </summary>
bool Override { get; set; }
/// <summary>
/// Any data that exists in the current state but has been modified. If the data
/// is not found then it will be inserted.
/// </summary>
IProtocolStateData Modified { get; set; }
/// <summary>
/// Any data that exists in the current state, but should be removed.
/// </summary>
IProtocolStateData Removed { get; set; }
}",Stores a single update between the current state and a new state.,1
1329,"public interface IProtocolType {
/// <summary>
/// The name of the author or organization that provides this protocol implementation
/// </summary>
String Provider { get; }
/// <summary>
/// The short key for this game type.
/// </summary>
String Type { get; }
/// <summary>
/// The friendly name of the game.
/// </summary>
String Name { get; }
}","The type of packet, originally sent or recieved.",1
1330,"public interface IPushEventsEndPoint : IDisposable {
/// <summary>
/// The identifier of this stream
/// </summary>
String Id { get; set; }
/// <summary>
/// The stream key (temporary password) specified by the stream end point when setting up.
/// </summary>
String StreamKey { get; set; }
/// <summary>
/// Simple flag to determine if a push is in progress.
/// </summary>
bool Pushing { get; set; }
/// <summary>
/// The url to push data to.
/// </summary>
Uri Uri { get; set; }
/// <summary>
/// The interval in seconds to push events
/// </summary>
int Interval { get; set; }
/// <summary>
/// The content type of the data to be pushed. This determines how the events list should be
/// serialized for this end point. The default is xml serialization.
/// </summary>
String ContentType { get; set; }
/// <summary>
/// A list of names the event must match to be appended to this stream. Anything not in this list
/// won't be pushed to the end point.
/// </summary>
List<String> InclusiveNames { get; set; }
/// <summary>
/// List of objects to serialize to xml passing through as content as POST.
/// </summary>
List<IGenericEvent> EventsStream { get; set; }
/// <summary>
/// Event fired whenever a push has completed successfully or with an error.
/// </summary>
event Action<IPushEventsEndPoint> PushCompleted;
/// <summary>
/// Appends an event onto the end of the objects to stream next sync
/// </summary>
/// <param name=""item"">The event to append</param>
void Append(IGenericEvent item);
/// <summary>
/// Pushes the current data to the Uri.
/// </summary>
void Push();
}",An end point to push grouped events to via http/https,1
1331,"public interface IQueryData {
/// <summary>
/// The number of documents to read or edit before ignoring.
/// </summary>
long? Limit { get; set; }
/// <summary>
/// The number of documents to ignore before reading or editing.
/// </summary>
long? Skip { get; set; }
/// <summary>
/// The method used in the SQL (SELECT, INSERT, UPDATE, DELETE)
/// </summary>
List<string> Methods { get; set; }
/// <summary>
/// The databases to query against
/// </summary>
List<string> Databases { get; set; }
/// <summary>
/// The fields to select from the collections
/// </summary>
List<string> Fields { get; set; }
/// <summary>
/// The values to assign to fields
/// </summary>
List<string> Values { get; set; }
/// <summary>
/// The fields used to when assigning a value to a field (update, insert)
/// </summary>
List<string> Assignments { get; set; }
/// <summary>
/// The indices to apply when the alter/create
/// </summary>
List<string> Indices { get; set; }
/// <summary>
/// The conditions placed on a select, update or delete method
/// </summary>
List<string> Conditions { get; set; }
/// <summary>
/// The collections placed on a select, update, delete or insert method
/// </summary>
List<string> Collections { get; set; }
/// <summary>
/// What fields and direction to sort by.
/// </summary>
List<string> Sortings { get; set; }
/// <summary>
/// The base element in the query being serialized.
/// </summary>
IDatabaseObject Root { get; set; }
}",The base shared data between Compiled and Parsed data.,1
1332,"public interface IRepositoryCache {
/// <summary>
/// A list of repositories
/// </summary>
ConcurrentBag<RepositoryModel> Repositories { get; }
/// <summary>
/// When the cache was last rebuilt.
/// </summary>
DateTime? RebuiltTime { get; }
/// <summary>
/// Add a new repository, provided we don't already know about it.
/// </summary>
/// <param name=""uri"">The uri of the repository</param>
void Add(String uri);
/// <summary>
/// Builds/Rebuilds the entire cache.
/// </summary>
/// <param name=""localRepository"">The nuget local repository to check for installed packages</param>
void Build(IPackageRepository localRepository);
/// <summary>
/// Empty the cache of repositories
/// </summary>
void Clear();
}",Manages storage and caching of multiple repository sources.,1
1333,"public interface ISandboxProtocolCallbackProxy {
/// <summary>
/// Fires a protocol event back across the appdomain
/// </summary>
void FireProtocolEvent(IProtocolEventArgs args);
/// <summary>
/// Fires a client event back across the appdomain
/// </summary>
void FireClientEvent(IClientEventArgs args);
}","Callback for to be initialized in the host domain, set and passed into the sandboxed domain allowing for events to be pushed through.",1
1334,"public interface ISerializer {
/// <summary>
/// Compile a query, creating a new compiled object and assigning all reduced data
/// from the serializer to the compiled query.
/// </summary>
/// <returns></returns>
ICompiledQuery Compile();
/// <summary>
/// Converts a query into the required query (String by default), however
/// the object may also be populated with additional requirements /// </summary>
/// <param name=""method"">The method object</param>
/// <returns></returns>
ISerializer Parse(IMethod method);
/// <summary>
/// Alias for Parse(Method method) without requirement of caller to convert type.
/// </summary>
/// <param name=""query""></param>
/// <returns></returns>
ISerializer Parse(IDatabaseObject query);
}",Base class for serializing a collection of database objects to a usable compiled query,1
1335,"public interface IServiceLoaderProxy : IService {
/// <summary>
/// Creates the Potato instance in the Potato instance appdomain
/// </summary>
void Create();
}",The proxy to be loaded in the service appdomain,1
1336,"public interface IServiceObserver {
/// <summary>
/// Delegate called when the status is modified
/// </summary>
Action<IServiceObserver, ServiceStatusType> StatusChange { get; set; }
/// <summary>
/// The current status of the service.
/// </summary>
ServiceStatusType Status { get; set; }
/// <summary>
/// When the service was started
/// </summary>
DateTime? StartTime { get; }
/// <summary>
/// When the service was stopped
/// </summary>
DateTime? StopTime { get; }
/// <summary>
/// Fetch the current uptime of the service
/// </summary>
/// <returns>How long the service has been started</returns>
TimeSpan? Uptime();
/// <summary>
/// Fetch the current downtime of the service
/// </summary>
/// <returns>How long the service has been stopped</returns>
TimeSpan? Downtime();
}",Used to track the state of the service,1
1337,"public interface IServiceSettings {
/// <summary>
/// If the service should check & update the core of Potato before it starts
/// </summary>
bool ServiceUpdateCore { get; set; }
/// <summary>
/// How long the service should wait for a message from the instance before restarting
/// </summary>
int ServicePollingTimeout { get; set; }
/// <summary>
/// The maximum time to wait when saving the config for Potato.
/// </summary>
int WriteServiceConfigTimeout { get; set; }
/// <summary>
/// The maximum time to wait when disposing objects before collapsing the AppDomain.
/// </summary>
int DisposeServiceTimeout { get; set; }
/// <summary>
/// The main source repository uri to download core updates from.
/// </summary>
String PackagesDefaultSourceRepositoryUri { get; set; }
/// <summary>
/// Processes the command line arguments
/// </summary>
/// <param name=""arguments"">The arguments from the command line ""-key value""</param>
void ParseArguments(IDictionary<String, String> arguments);
}",Settings interface for controlling the service.,1
1338,"public interface ISharedReferenceAccess {
/// <summary>
/// A reference to the shared reference of static variables.
/// </summary>
SharedReferences Shared { get; }
}",Enforces variable to access static references of common controllers.,1
1339,"public ItemModel() {
this.Name = String.Empty;
this.FriendlyName = String.Empty;
this.Tags = new List<String>();
}",Initializes default values.,1
1340,"public interface ITextCommandParser {
/// <summary>
/// Parses text and a prefix, creating a command result with the containing matches
/// </summary>
/// <param name=""prefix"">The text prefix that was used at the start of the text (!, @, #) ""!hello world"" -> ""!""</param>
/// <param name=""text"">The rest of the text ""!hello world"" -> ""hello world""</param>
/// <returns></returns>
ICommandResult Parse(string prefix, string text);
}",A parser for text commands,1
1341,"public interface IThingReference {
/// <summary>
/// Tests compatability with another thing reference, making sure both
/// are the same type or can be used together.
/// </summary>
/// <param name=""other""></param>
/// <returns></returns>
bool CompatibleWith(IThingReference other);
/// <summary>
/// Combines two thing references, used so keeping track of the references can be merged
/// </summary>
/// <param name=""other""></param>
/// <returns></returns>
IThingReference Union(IThingReference other);
/// <summary>
/// Returns only references in this object and not in the other reference
/// </summary>
/// <param name=""other""></param>
/// <returns></returns>
IThingReference Complement(IThingReference other);
}",A reference to an object and how to interact with it.,1
1342,"public interface ITruth : ICollection<ITruth> {
/// <summary>
/// Checks if a given branch is within the tree
/// </summary>
/// <param name=""branches"">The branches to check against the tree</param>
/// <returns>True if the entire branch exists in our tree</returns>
bool BuildAndTest(params ITruth[] branches);
/// <summary>
/// Checks if a given branch is within the tree
/// </summary>
/// <param name=""branches"">The branches to check against the tree</param>
/// <returns>True if the entire branch exists in our tree</returns>
bool Test(List<ITruth> branches);
}",A truthy object that can be polled to determine if its children has a specific branch.,1
1343,"public interface IWaitingAction {
/// <summary>
/// When we should stop waiting for actions and accept the action has timed out.
/// </summary>
DateTime Expiration { get; set; }
/// <summary>
/// The action taken to generate the requests
/// </summary>
INetworkAction Action { get; set; }
/// <summary>
/// List of packets waiting for responses
/// </summary>
List<IPacket> Requests { get; set; }
/// <summary>
/// List of responses to requests we have sent. When Responses.Count == Requests.Count, we have a completed action.
/// </summary>
List<IPacket> Responses { get; set; } }",An action currently pending completion,1
1344,"public interface IWaitingActions {
/// <summary>
/// Called once all of the packets sent have had packets marked against them.
/// </summary>
Action<INetworkAction, List<IPacket>, List<IPacket>> Done { get; set; }
/// <summary>
/// Called when an action has expired.
/// </summary>
Action<INetworkAction, List<IPacket>, List<IPacket>> Expired { get; set; }
/// <summary>
/// Register a new action to await for responses.
/// </summary>
/// <param name=""action"">The action being taken</param>
/// <param name=""requests"">A list of packets sent to the game server to complete this action</param>
/// <param name=""expiration"">An optional datetime when this action should expire</param>
void Wait(INetworkAction action, List<IPacket> requests, DateTime? expiration = null);
/// <summary>
/// Register a response to check against actions being taken
/// </summary>
/// <param name=""response"">A single response to check against pending actions</param>
void Mark(IPacket response);
/// <summary>
/// Find and removes all expired actions.
/// </summary>
void Flush();
}",A controller for waiting actions,1
1345,"public static String Serialize(this JsonSerializer serializer, Object value) {
String data = """";
using (var writer = new StringWriter()) {
serializer.Serialize(writer, value);
data = writer.ToString();
}
return data;
}",Serializes and returns a string from a JsonSerializer class,1
1346,"public static T Deserialize<T>(this JsonSerializer serializer, String data) {
T value = default(T);
using (var text = new StringReader(data)) {
using (var reader = new JsonTextReader(text)) {
value = serializer.Deserialize<T>(reader);
}
}
return value;
}",Deserializes from a string on a JsonSerializer class and returns the new object.,1
1347,"public KdrPropertyReference() {
this.ThingReference = new PlayerThingReference();
}",Initializes with the default player thing reference,1
1348,"public KickModel() : base() {
this.Scope.Content = new List<String>();
this.Scope.Players = new List<PlayerModel>();
}",Initializes the underlying networkmodel with the required collections.,1
1349,"public KillModel() : base() {
// Target
this.Scope.Content = new List<String>();
this.Scope.Players = new List<PlayerModel>();
this.Scope.Items = new List<ItemModel>();
this.Scope.HumanHitLocations = new List<HumanHitLocation>();
// Killer
this.Now.Players = new List<PlayerModel>();
this.Now.Items = new List<ItemModel>();
}",Initializes the underlying networkmodel with the required collections.,1
1350,"public KillsPropertyReference() {
this.ThingReference = new PlayerThingReference();
}",Initializes with the default player thing reference,1
1351,"public LanguageConfig() {
this.LanguageModel = new LanguageModel();
this.Config = new Config();
this.Cached = new Dictionary<String, List<LanguageEntryModel>>();
}",Initializes default values for the language config,1
1352,"public void Load(FileInfo file) {
this.Config.Load(file);
if (this.Config.RootOf<LanguageConfig>().First != null) {
this.LanguageModel = this.Config.RootOf<LanguageConfig>().First.ToObject<LanguageModel>();
}
}",Loads the specified file into this language file using the file's contents. Returns a reference back to this config.,1
1353,"public override ICoreController Execute() {
var languageDirectories = new DirectoryInfo(Defines.PackagesDirectory.FullName)
.GetDirectories(Defines.LocalizationDirectoryName, SearchOption.AllDirectories)
.Union(new [] {
new DirectoryInfo(Defines.LocalizationDirectory.FullName)
})
.SelectMany(localizationDirectory => localizationDirectory.GetDirectories());
// Loop over each grouped language
foreach (var groupedLanguageDirectories in languageDirectories.GroupBy(directory => directory.Name)) {
// Loop over each directory for this language, appending to the build language file.
LanguageConfig language = null;
foreach (var languageDirectory in groupedLanguageDirectories) {
if (language == null) {
language = new LanguageConfig();
language.Load(languageDirectory);
}
else {
language.Config.Union(new Config().Load(languageDirectory));
}
}
if (language != null && language.LanguageModel.LanguageCode != null) {
this.LoadedLanguageFiles.Add(language);
}
}
this.AssignEvents();
this.Shared.Variables.Variable(CommonVariableNames.LocalizationDefaultLanguageCode).Value = ""en-GB"";
this.LoadDefaultLanguage();
return base.Execute();
}",Loads the languages found in the languages directory. Sets the default language to english before looking at config file. Executes the commands specified in the configuration file. Returns a reference back to this object.,1
1354,"public override void Dispose() {
this.UnassignEvents();
this.LoadedLanguageFiles.Clear();
this.LoadedLanguageFiles = null;
base.Dispose();
}",Allows for an optional child implementation.,1
1355,"protected void AssignEvents() {
this.UnassignEvents();
this.Shared.Variables.Variable(CommonVariableNames.LocalizationDefaultLanguageCode).PropertyChanged += new System.ComponentModel.PropertyChangedEventHandler(LanguageController_PropertyChanged);
}",Assign all current event handlers for all grouped options.,1
1356,"protected void UnassignEvents() {
this.Shared.Variables.Variable(CommonVariableNames.LocalizationDefaultLanguageCode).PropertyChanged -= new System.ComponentModel.PropertyChangedEventHandler(LanguageController_PropertyChanged);
}",Removes all current event handlers.,1
1357,"public Location() {
this.CountryName = String.Empty;
this.CountryCode = String.Empty;
}",Initializes with the default values,1
1358,"private void InitializeComponent() {
this.components = new System.ComponentModel.Container();
System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainWindow));
this.lblVersion = new System.Windows.Forms.Label();
this.pnlConnection = new System.Windows.Forms.Panel();
this.txtAdditional = new System.Windows.Forms.TextBox();
this.label1 = new System.Windows.Forms.Label();
this.cboGames = new System.Windows.Forms.ComboBox();
this.lblGameType = new System.Windows.Forms.Label();
this.lblPassword = new System.Windows.Forms.Label();
this.txtPassword = new System.Windows.Forms.TextBox();
this.lblHostname = new System.Windows.Forms.Label();
this.txtHostname = new System.Windows.Forms.TextBox();
this.txtPort = new System.Windows.Forms.TextBox();
this.lblPort = new System.Windows.Forms.Label();
this.btnConnect = new System.Windows.Forms.Button();
this.tbcPanels = new System.Windows.Forms.TabControl();
this.tabConsole = new System.Windows.Forms.TabPage();
this.chkVerboseLogging = new System.Windows.Forms.CheckBox();
this.chkAnchorScrollbar = new System.Windows.Forms.CheckBox();
this.rtbConsole = new Potato.Tools.NetworkConsole.Controls.CodRichTextBox();
this.btnSend = new System.Windows.Forms.Button();
this.txtConsoleText = new System.Windows.Forms.TextBox();
this.tabProtocolTest = new System.Windows.Forms.TabPage();
this.protocolTestControl1 = new Potato.Tools.NetworkConsole.Controls.ProtocolTestControl();
this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
this.pnlConnection.SuspendLayout();
this.tbcPanels.SuspendLayout();
this.tabConsole.SuspendLayout();
this.tabProtocolTest.SuspendLayout();
this.SuspendLayout();
// // lblVersion
// this.lblVersion.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.lblVersion.Font = new System.Drawing.Font(""Microsoft Sans Serif"", 6F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
this.lblVersion.Location = new System.Drawing.Point(627, 698);
this.lblVersion.Name = ""lblVersion"";
this.lblVersion.Size = new System.Drawing.Size(213, 9);
this.lblVersion.TabIndex = 13;
this.lblVersion.Text = ""version"";
this.lblVersion.TextAlign = System.Drawing.ContentAlignment.TopRight;
// // pnlConnection
// this.pnlConnection.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.pnlConnection.Controls.Add(this.txtAdditional);
this.pnlConnection.Controls.Add(this.label1);
this.pnlConnection.Controls.Add(this.cboGames);
this.pnlConnection.Controls.Add(this.lblGameType);
this.pnlConnection.Controls.Add(this.lblPassword);
this.pnlConnection.Controls.Add(this.txtPassword);
this.pnlConnection.Controls.Add(this.lblHostname);
this.pnlConnection.Controls.Add(this.txtHostname);
this.pnlConnection.Controls.Add(this.txtPort);
this.pnlConnection.Controls.Add(this.lblPort);
this.pnlConnection.Location = new System.Drawing.Point(3, 12);
this.pnlConnection.Name = ""pnlConnection"";
this.pnlConnection.Size = new System.Drawing.Size(827, 50);
this.pnlConnection.TabIndex = 12;
// // txtAdditional
// this.txtAdditional.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.txtAdditional.Location = new System.Drawing.Point(626, 20);
this.txtAdditional.Name = ""txtAdditional"";
this.txtAdditional.Size = new System.Drawing.Size(198, 20);
this.txtAdditional.TabIndex = 14;
// // label1
// this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.label1.AutoSize = true;
this.label1.Location = new System.Drawing.Point(623, 4);
this.label1.Name = ""label1"";
this.label1.Size = new System.Drawing.Size(129, 13);
this.label1.TabIndex = 13;
this.label1.Text = ""Additional (e.g LogUrl=...):"";
// // cboGames
// this.cboGames.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.cboGames.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this.cboGames.FormattingEnabled = true;
this.cboGames.Location = new System.Drawing.Point(10, 20);
this.cboGames.Name = ""cboGames"";
this.cboGames.Size = new System.Drawing.Size(300, 21);
this.cboGames.TabIndex = 12;
// // lblGameType
// this.lblGameType.AutoSize = true;
this.lblGameType.Location = new System.Drawing.Point(7, 4);
this.lblGameType.Name = ""lblGameType"";
this.lblGameType.Size = new System.Drawing.Size(38, 13);
this.lblGameType.TabIndex = 11;
this.lblGameType.Text = ""Game:"";
// // lblPassword
// this.lblPassword.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.lblPassword.AutoSize = true;
this.lblPassword.Location = new System.Drawing.Point(517, 4);
this.lblPassword.Name = ""lblPassword"";
this.lblPassword.Size = new System.Drawing.Size(56, 13);
this.lblPassword.TabIndex = 10;
this.lblPassword.Text = ""Password:"";
// // txtPassword
// this.txtPassword.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.txtPassword.Location = new System.Drawing.Point(520, 20);
this.txtPassword.Name = ""txtPassword"";
this.txtPassword.Size = new System.Drawing.Size(100, 20);
this.txtPassword.TabIndex = 9;
// // lblHostname
// this.lblHostname.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.lblHostname.AutoSize = true;
this.lblHostname.Location = new System.Drawing.Point(316, 4);
this.lblHostname.Name = ""lblHostname"";
this.lblHostname.Size = new System.Drawing.Size(58, 13);
this.lblHostname.TabIndex = 5;
this.lblHostname.Text = ""Hostname:"";
// // txtHostname
// this.txtHostname.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.txtHostname.Location = new System.Drawing.Point(316, 20);
this.txtHostname.Name = ""txtHostname"";
this.txtHostname.Size = new System.Drawing.Size(145, 20);
this.txtHostname.TabIndex = 4;
this.txtHostname.TextChanged += new System.EventHandler(this.txtHostname_TextChanged);
// // txtPort
// this.txtPort.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.txtPort.Location = new System.Drawing.Point(467, 20);
this.txtPort.Name = ""txtPort"";
this.txtPort.Size = new System.Drawing.Size(47, 20);
this.txtPort.TabIndex = 7;
// // lblPort
// this.lblPort.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.lblPort.AutoSize = true;
this.lblPort.Location = new System.Drawing.Point(464, 4);
this.lblPort.Name = ""lblPort"";
this.lblPort.Size = new System.Drawing.Size(29, 13);
this.lblPort.TabIndex = 6;
this.lblPort.Text = ""Port:"";
// // btnConnect
// this.btnConnect.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.btnConnect.Location = new System.Drawing.Point(745, 58);
this.btnConnect.Name = ""btnConnect"";
this.btnConnect.Size = new System.Drawing.Size(85, 23);
this.btnConnect.TabIndex = 8;
this.btnConnect.Text = ""Connect"";
this.btnConnect.UseVisualStyleBackColor = true;
this.btnConnect.Click += new System.EventHandler(this.btnConnect_Click);
// // tbcPanels
// this.tbcPanels.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.tbcPanels.Controls.Add(this.tabConsole);
this.tbcPanels.Controls.Add(this.tabProtocolTest);
this.tbcPanels.Location = new System.Drawing.Point(12, 68);
this.tbcPanels.Name = ""tbcPanels"";
this.tbcPanels.SelectedIndex = 0;
this.tbcPanels.Size = new System.Drawing.Size(828, 627);
this.tbcPanels.TabIndex = 11;
// // tabConsole
// this.tabConsole.Controls.Add(this.chkVerboseLogging);
this.tabConsole.Controls.Add(this.chkAnchorScrollbar);
this.tabConsole.Controls.Add(this.rtbConsole);
this.tabConsole.Controls.Add(this.btnSend);
this.tabConsole.Controls.Add(this.txtConsoleText);
this.tabConsole.Location = new System.Drawing.Point(4, 22);
this.tabConsole.Name = ""tabConsole"";
this.tabConsole.Padding = new System.Windows.Forms.Padding(3);
this.tabConsole.Size = new System.Drawing.Size(820, 601);
this.tabConsole.TabIndex = 1;
this.tabConsole.Text = ""Console"";
this.tabConsole.UseVisualStyleBackColor = true;
// // chkVerboseLogging
// this.chkVerboseLogging.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.chkVerboseLogging.AutoSize = true;
this.chkVerboseLogging.Location = new System.Drawing.Point(598, 549);
this.chkVerboseLogging.Name = ""chkVerboseLogging"";
this.chkVerboseLogging.Size = new System.Drawing.Size(106, 17);
this.chkVerboseLogging.TabIndex = 5;
this.chkVerboseLogging.Text = ""Verbose Logging"";
this.toolTip1.SetToolTip(this.chkVerboseLogging, ""Enables logging in the console while viewing another tab page"");
this.chkVerboseLogging.UseVisualStyleBackColor = true;
// // chkAnchorScrollbar
// this.chkAnchorScrollbar.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.chkAnchorScrollbar.AutoSize = true;
this.chkAnchorScrollbar.Location = new System.Drawing.Point(710, 549);
this.chkAnchorScrollbar.Name = ""chkAnchorScrollbar"";
this.chkAnchorScrollbar.Size = new System.Drawing.Size(104, 17);
this.chkAnchorScrollbar.TabIndex = 4;
this.chkAnchorScrollbar.Text = ""Anchor Scrollbar"";
this.chkAnchorScrollbar.UseVisualStyleBackColor = true;
// // rtbConsole
// this.rtbConsole.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.rtbConsole.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
this.rtbConsole.Font = new System.Drawing.Font(""Segoe UI"", 9F, System.Drawing.FontStyle.Bold);
this.rtbConsole.Location = new System.Drawing.Point(6, 6);
this.rtbConsole.Name = ""rtbConsole"";
this.rtbConsole.ReadOnly = true;
this.rtbConsole.Size = new System.Drawing.Size(808, 538);
this.rtbConsole.TabIndex = 3;
this.rtbConsole.Text = """";
this.rtbConsole.WordWrap = false;
// // btnSend
// this.btnSend.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.btnSend.Location = new System.Drawing.Point(739, 572);
this.btnSend.Name = ""btnSend"";
this.btnSend.Size = new System.Drawing.Size(75, 23);
this.btnSend.TabIndex = 2;
this.btnSend.Text = ""Send"";
this.btnSend.UseVisualStyleBackColor = true;
this.btnSend.Click += new System.EventHandler(this.btnSend_Click);
// // txtConsoleText
// this.txtConsoleText.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.txtConsoleText.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Append;
this.txtConsoleText.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.CustomSource;
this.txtConsoleText.Location = new System.Drawing.Point(6, 572);
this.txtConsoleText.Name = ""txtConsoleText"";
this.txtConsoleText.Size = new System.Drawing.Size(727, 20);
this.txtConsoleText.TabIndex = 1;
this.txtConsoleText.KeyDown += new System.Windows.Forms.KeyEventHandler(this.txtConsoleText_KeyDown);
// // tabProtocolTest
// this.tabProtocolTest.Controls.Add(this.protocolTestControl1);
this.tabProtocolTest.Location = new System.Drawing.Point(4, 22);
this.tabProtocolTest.Name = ""tabProtocolTest"";
this.tabProtocolTest.Size = new System.Drawing.Size(820, 601);
this.tabProtocolTest.TabIndex = 8;
this.tabProtocolTest.Text = ""Protocol Test"";
this.tabProtocolTest.UseVisualStyleBackColor = true;
// // protocolTestControl1
// this.protocolTestControl1.Dock = System.Windows.Forms.DockStyle.Fill;
this.protocolTestControl1.IsTestRunning = false;
this.protocolTestControl1.Location = new System.Drawing.Point(0, 0);
this.protocolTestControl1.Name = ""protocolTestControl1"";
this.protocolTestControl1.Size = new System.Drawing.Size(820, 601);
this.protocolTestControl1.TabIndex = 0;
// // MainWindow
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(852, 716);
this.Controls.Add(this.btnConnect);
this.Controls.Add(this.lblVersion);
this.Controls.Add(this.pnlConnection);
this.Controls.Add(this.tbcPanels);
this.Icon = ((System.Drawing.Icon)(resources.GetObject(""$this.Icon"")));
this.Name = ""MainWindow"";
this.Text = ""Potato - Protocol Test Console"";
this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.Form1_FormClosing);
this.Load += new System.EventHandler(this.Form1_Load);
this.pnlConnection.ResumeLayout(false);
this.pnlConnection.PerformLayout();
this.tbcPanels.ResumeLayout(false);
this.tabConsole.ResumeLayout(false);
this.tabConsole.PerformLayout();
this.tabProtocolTest.ResumeLayout(false);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
1359,"public virtual MarkManager Mark(DateTime? time = null) {
time = time ?? DateTime.Now;
lock (this.MarkListLock) {
this.Marks.Add(time.Value);
}
return this;
}",Marks the current connection attempt.,1
1360,"public virtual MarkManager RemoveExpiredMarks() {
lock (this.MarkListLock) {
this.Marks.RemoveAll(time => time < DateTime.Now.AddSeconds(this.MaximumMarkAge * -1));
}
return this;
}",Removes all connection attempts that have expired.,1
1361,"public void TestEmptyMarkListOpenWindow() {
MarkManager marks = new MarkManager();
Assert.IsTrue(marks.IsValidMarkWindow());
}",Tests the window is open if the mark list is empty.,1
1362,"public void TestTwentyMarkListClosedWindow() {
MarkManager marks = new MarkManager();
for (var count = 0; count < 20; count++) {
marks.Mark();
}
Assert.IsFalse(marks.IsValidMarkWindow());
}",Tests throwing a simple 20 marks in quick succession will close the window.,1
1363,"public void TestEmptyMarkListRemoveExpiredNoChange() {
MarkManager marks = new MarkManager();
marks.RemoveExpiredMarks();
Assert.AreEqual(0, marks.Marks.Count);
}",Tests removing expires marks on an empty list results in no change.,1
1364,"public void TestTwoMarkListRemoveExpiredOneOld() {
MarkManager marks = new MarkManager();
marks.Mark();
marks.Mark(DateTime.Now.AddHours(-1));
marks.RemoveExpiredMarks();
Assert.AreEqual(1, marks.Marks.Count);
}",Tests that removing expired marks will remove a mark one hour old.,1
1365,"public static String File(String path) {
return System.IO.File.Exists(path) ? Data(System.IO.File.ReadAllBytes(path)) : string.Empty;
}",Generates the md5 hash of a file,0
1366,"public static String Data(byte[] data) {
return MD5.Hasher.ComputeHash(data).Select(x => x.ToString(""x2"")).Aggregate((a, b) => a + b);
}",Generates the md5 hash of a byte array,0
1367,"public static String String(String data) {
return MD5.Data(Encoding.ASCII.GetBytes(data));
}",Generates the md5 hash of a string,0
1368,"public static Guid Guid(String data) {
return new Guid(Hasher.ComputeHash(Encoding.ASCII.GetBytes(data)));
}",Generates a GUID based on the md5 data of a string,1
1369,"public MigrationController() {
this.Settings = new MigrationSettings();
this.Migrations = new List<IMigration>();
}",Sets up a migration controller and initializes the default values.,1
1370,"public static Dictionary<String, List<String>> Types = Mime.Extensions.GroupBy(type => type.Value).Select(groupedTypes => new {","The inverse of the extensions dictionary, but indexed by the mime type with a list of file extensions associated with it.",1
1371,"public override void ExecuteQueuedCommands() {
base.ExecuteQueuedCommands();
if (ExecuteQueuedCommandsFinished != null) {
this.ExecuteQueuedCommandsFinished();
}
}",Long running loop to process commands when signaled that a new command(s) has been added to the queue.,1
1372,"public void Poke() {
}",This method is a final check to make sure communications are proceeding in both directions in the last five minutes. If nothing has been sent and received in the last five minutes then the connection is assumed dead and a shutdown is initiated.,0
1373,"public void Connect() {
}",Attempts a connection to the server using the specified host name and port.,0
1374,"public void Shutdown() {
}","Shuts down the connection, closing streams etc.",0
1375,"public override void Connect() {
throw new NotImplementedException();
}",Attempts a connection to the server using the specified host name and port.,1
1376,"public override void Shutdown() {
throw new NotImplementedException();
}","Shuts down the connection, closing streams etc.",1
1377,"protected override void ShutdownConnection() {
throw new NotImplementedException();
}","Shuts down the connection, closing the Client.",1
1378,"public void Poke() {
if (this.PokeCallback != null) this.PokeCallback();
}",This method is a final check to make sure communications are proceeding in both directions in the last five minutes. If nothing has been sent and received in the last five minutes then the connection is assumed dead and a shutdown is initiated.,1
1379,"public void Connect() {
if (this.ConnectCallback != null) this.ConnectCallback();
}",Attempts a connection to the server using the specified host name and port.,1
1380,"public void Shutdown() {
if (this.ShutdownCallback != null) this.ShutdownCallback();
}","Shuts down the connection, closing streams etc.",1
1381,"public IProtocolSetupResult Setup(IProtocolSetup setup) {
return this.OnSetupHandler != null ? this.OnSetupHandler(setup) : null;
}","Sets up the protocol, initializing the client",1
1382,"public void AttemptConnection() {
if (this.OnAttemptConnectionHandler != null) {
this.OnAttemptConnectionHandler();
}
}",Attempts a connection to the server.,1
1383,"public void Shutdown() {
if (this.OnShutdownHandler != null) {
this.OnShutdownHandler();
}
}",Shutsdown this connection,1
1384,"public void Synchronize() {
if (this.OnSynchronizeHandler != null) {
this.OnSynchronizeHandler();
}
}",General timed event to synch everything on the server with what is known locally.,1
1385,"public void MockProtocolEvent(IProtocolEventArgs args) {
if (this.ProtocolEvent != null) {
this.ProtocolEvent(this, args);
}
}",Mocks a call to the protocol event,1
1386,"public void MockClientEvent(IClientEventArgs args) {
if (this.ClientEvent != null) {
this.ClientEvent(this, args);
}
}",Mocks a call to the client event,1
1387,"public void MockResponses() {
this.Waiting.Mark(new Packet() {
RequestId = 100,
Words = new List<string>() {
""OK""
},
DebugText = ""[0-OK]"",
Origin = PacketOrigin.Client,
Type = PacketType.Response
});
this.Waiting.Mark(new Packet() {
RequestId = 101,
Words = new List<string>() {
""OK""
},
DebugText = ""[0-OK]"",
Origin = PacketOrigin.Client,
Type = PacketType.Response
});
}",Fake receiving packets from the server.,1
1388,"public void Start() {
throw new NotImplementedException();
}","A method to signify the instance should begin, loading it's configs and setting up connections & what not.",0
1389,"public void WriteConfig() {
throw new NotImplementedException();
}",Tells the instance the configs should now be written.,0
1390,"public void Dispose() {
throw new NotImplementedException();
}",Dispose of this instance. The AppDomain will be clonsed shortly afterwards.,1
1391,"public void Dispose() {
throw new NotImplementedException();
}",Dispose of this instance. The AppDomain will be clonsed shortly afterwards.,1
1392,"public ServiceMessage PollService() {
throw new NotImplementedException();
}",Polls the service for a running status or other message.,1
1393,"public ServiceMessage ExecuteMessage(ServiceMessage message) {
throw new NotImplementedException();
}",This will only ever handle very simple requests that require strings/integers for arguments,1
1394,public String Text {,Basic text to pass bac kand forth,0
1395,"public void Kill() {
this.OnKill = true;
}",Kill the current process.,0
1396,"public IProtocolSetupResult Setup(IProtocolSetup setup) {
this.Options = setup;
this.Client.Setup(ClientSetup.FromProtocolSetup(setup));
return new ProtocolSetupResult();
}","Sets up the protocol, initializing the client",1
1397,"public void AttemptConnection() {
}",Attempts a connection to the server.,0
1398,"public void Shutdown() {
}",Shutsdown this connection,0
1399,"public void Synchronize() {
}",General timed event to synch everything on the server with what is known locally.,0
1400,"public void Start() {
this.OnStart = true;
}","A method to signify the instance should begin, loading it's configs and setting up connections & what not.",0
1401,"public void Dispose() {
this.OnDispose = true;
if (this.OnDisposeHandler != null) this.OnDisposeHandler();
}",Dispose of this instance. The AppDomain will be clonsed shortly afterwards.,1
1402,"public ServiceMessage PollService() {
this.OnPollService = true;
return this.WaitingMessage;
}",Polls the service for a running status or other message.,1
1403,"public ServiceMessage ExecuteMessage(ServiceMessage message) {
this.OnExecuteMessage = true;
return this.ExecuteResultMessage;
}",This will only ever handle very simple requests that require strings/integers for arguments,1
1404,"public void Start() {
if (this.StartSleep > 0) {
Thread.Sleep(StartSleep);
}
}","A method to signify the instance should begin, loading it's configs and setting up connections & what not.",1
1405,"public void WriteConfig() {
if (this.WriteConfigSleep > 0) {
Thread.Sleep(WriteConfigSleep);
}
}",Tells the instance the configs should now be written.,1
1406,"public void Dispose() {
if (this.DisposeSleep > 0) {
Thread.Sleep(DisposeSleep);
}
}",Dispose of this instance. The AppDomain will be clonsed shortly afterwards.,1
1407,"public ServiceMessage PollService() {
if (this.PollServiceSleep > 0) {
Thread.Sleep(PollServiceSleep);
}
return new ServiceMessage();
}",Polls the service for a running status or other message.,1
1408,"public ServiceMessage ExecuteMessage(ServiceMessage message) {
if (this.PollServiceSleep > 0) {
Thread.Sleep(ExecuteMessageSleep);
}
return new ServiceMessage();
}",This will only ever handle very simple requests that require strings/integers for arguments,1
1409,"public ICommandResult AppendMessage(ICommand command, Dictionary<String, ICommandParameter> parameters) {
String value = parameters[""value""].First<String>();
return new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = ""SetMessage: "" + value
};
}",Sets the value of the test flag.,0
1410,"public void BeginListener() {
try {
this.Listener = new TcpListener(IPAddress.Any, this.Port);
this.Listener.Start();
// Accept the connection.
this.Listener.BeginAcceptTcpClient(new AsyncCallback(MockTcpListener.AcceptTcpClientCallback), this);
}
catch (Exception e) {
this.OnException(e);
}
}",Creates and starts listening for tcp clients on the specified port.,1
1411,"public void BeginListener() {
try {
this.Listener = new MockUdpClient() {
RemoteIpEndPoint = new IPEndPoint(IPAddress.Loopback, this.Port),
Client = new System.Net.Sockets.UdpClient {
Client = {
DontFragment = true
},
ExclusiveAddressUse = false
}
};
this.Listener.Setup(new ClientSetup() {
Hostname = ""localhost"",
Port = this.Port
});
this.Listener.Client.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
this.Listener.Client.Client.Bind(this.Listener.RemoteIpEndPoint);
this.Listener.Client.Client.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastTimeToLive, true);
this.Listener.PacketReceived += Listener_PacketReceived;
this.Listener.ConnectionStateChanged += Listener_ConnectionStateChanged;
// Accept the connection.
this.Listener.BeginRead();
}
catch (Exception e) {
this.OnException(e);
}
}",Creates and starts listening for tcp clients on the specified port.,1
1412,"public override bool Connect() {
bool opened = true;
if (this.Client == null) {
try {
MongoClientSettings settings = new MongoClientSettings();
if (this.Settings.Hostname != null && this.Settings.Port.HasValue == true) {
settings.Server = new MongoServerAddress(this.Settings.Hostname, (int)this.Settings.Port.Value);
}
else if (this.Settings.Hostname != null) {
settings.Server = new MongoServerAddress(this.Settings.Hostname);
}
if (this.Database != null && this.Settings.Username != null && this.Settings.Password != null) {
settings.Credentials = new List<MongoCredential>() {
MongoCredential.CreateMongoCRCredential(this.Settings.Database, this.Settings.Username, this.Settings.Password)
};
}
this.Client = new MongoClient(settings);
this.Database = this.Client.GetServer().GetDatabase(this.Settings.Database);
}
catch {
opened = false;
}
}
return opened;
}",Opens the connection to the database.,1
1413,"public override void Close() {
if (this.Client != null) {
this.Client.GetServer().Disconnect();
this.Client = null;
}
}",Closes the open connection the database.,1
1414,"public MoveModel() {
this.Scope.Players = new List<PlayerModel>();
this.Then.Groups = new List<GroupModel>();
this.Now.Groups = new List<GroupModel>();
}",Initializes the underlying networkmodel with the required collections.,1
1415,"public override bool Connect() {
bool opened = true;
if (this.Connection == null || this.Connection.State == ConnectionState.Closed) {
if (this.Connection != null) {
this.Connection.Close();
this.Connection = null;
}
MySqlConnectionStringBuilder connectionBuilder = new MySqlConnectionStringBuilder {
Server = this.Settings.Hostname,
Port = this.Settings.Port != null ? this.Settings.Port.Value : 0,
Database = this.Settings.Database,
UserID = this.Settings.Username,
Password = this.Settings.Password,
UseCompression = true
};
try {
this.Connection = new MySqlConnection(connectionBuilder.ToString());
this.Connection.Open();
if (this.Connection.State != ConnectionState.Open) {
this.Connection.Close();
this.Connection = null;
}
}
catch {
opened = false;
}
}
return opened;
}",Opens the connection to the database.,1
1416,"public override void Close() {
if (this.Connection != null) {
this.Connection.Close();
// Is this already disposed when closed?
this.Connection.Dispose();
this.Connection = null;
}
}",Closes the open connection the database.,1
1417,"public NetworkModel() {
this.Created = DateTime.Now;
this.Scope = new NetworkModelData();
this.Then = new NetworkModelData();
this.Now = new NetworkModelData();
}",Initializes the model with the default values.,1
1418,"public void Build() {
foreach (var orphanedPackage in this.Source) {
PackageWrapperModel packageWrapper = this.Cache.FirstOrDefault(pack => pack.Id == orphanedPackage.Id);
if (packageWrapper == null) {
this.Cache.Add(new PackageWrapperModel() {
State = PackageState.Installed,
Installed = PackageFactory.CreatePackageModelFromNugetPackage(orphanedPackage)
});
}
else {
packageWrapper.Installed = PackageFactory.CreatePackageModelFromNugetPackage(orphanedPackage);
packageWrapper.State = PackageState.Installed;
}
}
}","Build the cache within the repository, appending known information to the repository packages.",1
1419,"public void TestResultInsufficientPermissions() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that attempting the command without any users in the security controller will result in insufficient permissions,1
1420,"public void TestResultSuccess() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests adding a uri will setup the repository to have packages fetched.,1
1421,"public void TestResultSuccessEventListed() {
var wait = new AutoResetEvent(false);
PackagesController packages = (PackagesController)new PackagesController().Execute();
packages.Shared.Events.EventLogged += (sender, @event) => {
if (@event.GenericEventType == GenericEventType.PackagesRepositoryAppended && @event.Now.Repositories.First().Uri == ""https://teamcity.myrcon.com/nuget"") {
wait.Set();
}
};
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(wait.WaitOne(5000));
}",Tests adding a uri will fire a repository added event,1
1422,"public void TestSingleRepositorySetup() {
PackagesController packages = (PackagesController)new PackagesController().Execute();
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
Assert.AreEqual(2, packages.Cache.Repositories.Count);
Assert.AreEqual(""https://teamcity.myrcon.com/nuget"", packages.Cache.Repositories.First().Uri);
}",Tests adding a uri will setup the repository to have packages fetched.,1
1423,"public void TestDoubleRepositorySetup() {
PackagesController packages = (PackagesController)new PackagesController().Execute();
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
Assert.AreEqual(2, packages.Cache.Repositories.Count);
}",Tests adding the same uri twice will still result in only a single uri being added.,1
1424,"public void TestSuccessTwoUniqueRepositoriesAdded() {
PackagesController packages = (PackagesController)new PackagesController().Execute();
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget1"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget2"").SetOrigin(CommandOrigin.Local));
Assert.AreEqual(3, packages.Cache.Repositories.Count);
}",Tests that two repository unique url's will both be setup for their packages to be fetched.,1
1425,"public void TestSuccessTwoRepositoriesSaved() {
PackagesController packages = (PackagesController)new PackagesController().Execute();
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget1"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget2"").SetOrigin(CommandOrigin.Local));
Assert.AreEqual(3, packages.Cache.Repositories.Count);
Assert.AreEqual(2, packages.Shared.Variables.ArchiveVariables.First(archive => archive.Key.ToLower() == CommonVariableNames.PackagesConfigGroups.ToString().ToLower()).Value.ToList<String>().Count);
}",Tests that two end points are saved to the config,1
1426,"public PackagesController() {
this.Shared = new SharedReferences();
this.Cache = new RepositoryCache();
this.LocalRepository = PackageRepositoryFactory.Default.CreateRepository(Defines.PackagesDirectory.FullName);
this.GroupedVariableListener = new GroupedVariableListener() {
Variables = this.Shared.Variables,
GroupsVariableName = CommonVariableNames.PackagesConfigGroups.ToString(),
ListeningVariablesNames = new List<String>() {
CommonVariableNames.PackagesRepositoryUri.ToString()
}
};
this.CommandDispatchers.AddRange(new List<ICommandDispatch>() {
new CommandDispatch() {
CommandType = CommandType.PackagesMergePackage,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""packageId"",
Type = typeof(String)
}
},
Handler = this.PackagesMergePackage
},
new CommandDispatch() {
CommandType = CommandType.PackagesUninstallPackage,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""packageId"",
Type = typeof(String)
}
},
Handler = this.PackagesUninstallPackage
},
new CommandDispatch() {
CommandType = CommandType.PackagesFetchPackages,
Handler = this.PackagesFetchPackages
},
new CommandDispatch() {
CommandType = CommandType.PackagesAppendRepository,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""uri"",
Type = typeof(String)
}
},
Handler = this.PackagesAppendRepository
},
new CommandDispatch() {
CommandType = CommandType.PackagesRemoveRepository,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""uri"",
Type = typeof(String)
}
},
Handler = this.PackagesRemoveRepository
}
});
}",Initiates the package controller with the default values.,1
1427,"public override void Poke() {
if (this.Cache != null) {
lock (this.Cache) {
this.Cache.Build(this.LocalRepository);
this.Shared.Events.Log(new GenericEvent() {
GenericEventType = GenericEventType.PackagesCacheRebuilt,
Now = {
Repositories = new List<RepositoryModel>(this.Cache.Repositories)
}
});
}
}
}",This method can potentially be time consuming and should be run in a new thread.,1
1428,"public override void Dispose() {
this.UnassignEvents();
this.GroupedVariableListener = null;
lock (this.Cache) {
this.Cache.Clear();
this.Cache = null;
}
this.LocalRepository = null;
base.Dispose();
}",Allows for an optional child implementation.,1
1429,"protected void AssignEvents() {
// Remove all current handlers, also clears the list in this.ListeningVariables
this.UnassignEvents();
this.GroupedVariableListener.AssignEvents();
this.GroupedVariableListener.VariablesModified += GroupedVariableListenerOnVariablesModified;
}",Assign all current event handlers for all grouped options.,1
1430,"public void TestResultInsufficientPermissions() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesRemoveRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that attempting the command without any users in the security controller will result in insufficient permissions,1
1431,"public void TestResultSuccess() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesRemoveRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests removing a non-existant uri will still result in a success,1
1432,"public void TestResultSuccessEventListed() {
var wait = new AutoResetEvent(false);
PackagesController packages = (PackagesController)new PackagesController().Execute();
packages.Shared.Events.EventLogged += (sender, @event) => {
if (@event.GenericEventType == GenericEventType.PackagesRepositoryRemoved && @event.Then.Repositories.First().Uri == ""https://teamcity.myrcon.com/nuget"") {
wait.Set();
}
};
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesRemoveRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(wait.WaitOne(5000));
}",Tests removing a uri will fire a repository removed event,1
1433,"public void TestSingleRepositoryAddedThenRemoved() {
PackagesController packages = (PackagesController)new PackagesController().Execute();
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesRemoveRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
Assert.AreEqual(1, packages.Cache.Repositories.Count);
Assert.IsTrue(packages.Cache.Repositories.First().IsOrphanage);
}",Tests adding a uri then removing it will result in only the orphanage remaining,1
1434,"public void TestDoubleRepositorySetup() {
PackagesController packages = (PackagesController)new PackagesController().Execute();
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesRemoveRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesRemoveRepository(""https://teamcity.myrcon.com/nuget"").SetOrigin(CommandOrigin.Local));
Assert.AreEqual(1, packages.Cache.Repositories.Count);
Assert.IsTrue(packages.Cache.Repositories.First().IsOrphanage);
}",Tests removing the same uri twice still results in a success,1
1435,"public void TestSuccessTwoUniqueRepositoriesAdded() {
PackagesController packages = (PackagesController)new PackagesController().Execute();
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget1"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget2"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesRemoveRepository(""https://teamcity.myrcon.com/nuget1"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesRemoveRepository(""https://teamcity.myrcon.com/nuget2"").SetOrigin(CommandOrigin.Local));
Assert.AreEqual(1, packages.Cache.Repositories.Count);
}",Tests two unique repositories added and removed will result in only the orphanage,1
1436,"public void TestSuccessOneRepositorySaved() {
PackagesController packages = (PackagesController)new PackagesController().Execute();
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget1"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesAppendRepository(""https://teamcity.myrcon.com/nuget2"").SetOrigin(CommandOrigin.Local));
packages.Tunnel(CommandBuilder.PackagesRemoveRepository(""https://teamcity.myrcon.com/nuget1"").SetOrigin(CommandOrigin.Local));
Assert.AreEqual(2, packages.Cache.Repositories.Count);
Assert.AreEqual(1, packages.Shared.Variables.ArchiveVariables.First(archive => archive.Key.ToLower() == CommonVariableNames.PackagesConfigGroups.ToString().ToLower()).Value.ToList<String>().Count);
}",Tests that two repositories added but only one removed will result in only one repository being saved,1
1437,public String Id {,The id found in this models Installed or Available properties.,0
1438,"public PackageWrapperModel() {
this.Installed = new PackageModel();
this.Available = new PackageModel();
}",Initializes the wrapper with the default values.,1
1439,"public Packet() {
this.RequestId = null;
this.Stamp = DateTime.Now;
this.Words = new List<String>();
}",Initializes the packet with the default values.,1
1440,"public Action<IPacketDispatch, IPacketWrapper, IPacketWrapper> MissingDispatchHandler { get; set; }",Handler to dispatch to if a request fails.,1
1441,"public void TestMockPacketDispatcherSuccess() {
bool dispatched = false;
MockPacketDispatcher dispatcher = new MockPacketDispatcher();
dispatcher.Append(new Dictionary<IPacketDispatch, Action<IPacketWrapper, IPacketWrapper>>() {
{ new PacketDispatch() {
Name = ""TestMockPacketDispatcherSuccess"", Origin = PacketOrigin.Client
}, (request, response) => {
dispatched = true;
} }
});
dispatcher.Dispatch(new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
RequestId = 2,
Type = PacketType.Request,
},
Text = ""TestMockPacketDispatcherSuccess"",
});
Assert.IsTrue(dispatched);
}",Tests that a packet will be successfully dispatched.,1
1442,"public void TestMockPacketDispatcherDifferentOriginFailed() {
bool dispatched = false;
bool failed = false;
MockPacketDispatcher dispatcher = new MockPacketDispatcher() {
MissingDispatchHandler = (identifer, request, response) => { failed = true; }
};
dispatcher.Append(new Dictionary<IPacketDispatch, Action<IPacketWrapper, IPacketWrapper>>() {
{ new PacketDispatch() {
Name = ""TestMockPacketDispatcherDifferentOriginFailed"", Origin = PacketOrigin.Client
}, (request, response) => {
dispatched = true;
} }
});
dispatcher.Dispatch(new MockPacket() {
Packet = {
Origin = PacketOrigin.Server,
RequestId = 2,
Type = PacketType.Request,
},
Text = ""TestMockPacketDispatcherDifferentOriginFailed"",
});
Assert.IsFalse(dispatched);
Assert.IsTrue(failed);
}",Tests that a dispatch will fail when the origin is different.,1
1443,"public void TestMockPacketDispatcherMissingDispatchNameFailed() {
bool dispatched = false;
bool failed = false;
MockPacketDispatcher dispatcher = new MockPacketDispatcher() {
MissingDispatchHandler = (identifer, request, response) => { failed = true; }
};
dispatcher.Append(new Dictionary<IPacketDispatch, Action<IPacketWrapper, IPacketWrapper>>() {
{ new PacketDispatch() {
Name = ""TestMockPacketDispatcherMissingDispatchNameFailed"", Origin = PacketOrigin.Client
}, (request, response) => {
dispatched = true;
} }
});
dispatcher.Dispatch(new MockPacket() {
Packet = {
Origin = PacketOrigin.Server,
RequestId = 2,
Type = PacketType.Request,
},
Text = ""ThisDoesNotExist"",
});
Assert.IsFalse(dispatched);
Assert.IsTrue(failed);
}","Tests that if origin matches, but a method name is not found the dispatch will fail.",1
1444,"public void TestMockPacketDispatcherReplacedDispatcherSuccess() {
int handler = 0;
MockPacketDispatcher dispatcher = new MockPacketDispatcher();
dispatcher.Append(new Dictionary<IPacketDispatch, Action<IPacketWrapper, IPacketWrapper>>() {
{ new PacketDispatch() {
Name = ""TestMockPacketDispatcherReplacedDispatcherSuccess"", Origin = PacketOrigin.Client
}, (request, response) => {
handler = 1;
} }
});
dispatcher.Append(new Dictionary<IPacketDispatch, Action<IPacketWrapper, IPacketWrapper>>() {
{ new PacketDispatch() {
Name = ""TestMockPacketDispatcherReplacedDispatcherSuccess"", Origin = PacketOrigin.Client
}, (request, response) => {
handler = 2;
} }
});
dispatcher.Dispatch(new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
RequestId = 2,
Type = PacketType.Request,
},
Text = ""TestMockPacketDispatcherReplacedDispatcherSuccess""
});
Assert.AreEqual(2, handler);
}",Tests that appending two methods with identical dispatchers will replace the previous handler. Useful when overwriting functionality in a subclass of a game.,1
1445,"public void TestPacketDispatchEquality() {
PacketDispatch dispatchA = new PacketDispatch() {
Name = ""equal""
};
PacketDispatch dispatchB = new PacketDispatch() {
Name = ""equal""
};
Assert.IsTrue(dispatchA.Equals(dispatchB));
}",Tests equality with another object with the same value.,1
1446,"public void TestPacketDispatchEqualityAgainstNull() {
PacketDispatch dispatch = new PacketDispatch() {
Name = ""equal""
};
Assert.IsFalse(dispatch.Equals(null));
}",Tests a comparison with null will not be true.,1
1447,"public void TestPacketDispatchEqualityCastToObjectAgainstNull() {
Object dispatch = new PacketDispatch() {
Name = ""equal""
};
Assert.IsFalse(dispatch.Equals(null));
}",Tests a comparison with null will not be true.,1
1448,"public void TestPacketDispatchEqualityAgainstReferenceToSameObject() {
PacketDispatch dispatchA = new PacketDispatch() {
Name = ""equal""
};
PacketDispatch dispatchB = dispatchA;
Assert.IsTrue(dispatchA.Equals(dispatchB));
}",Tests that a dispatch will be equal against a reference to itself.,1
1449,"public void TestPacketDispatchEqualityAgainstReferenceToSameObjectCastToObject() {
PacketDispatch dispatchA = new PacketDispatch() {
Name = ""equal""
};
Object dispatchB = dispatchA;
Assert.IsTrue(dispatchA.Equals(dispatchB));
}",Tests that a dispatch will be equal against a reference to itself.,1
1450,"public void TestPacketDispatchEqualityAgainstDifferenceType() {
PacketDispatch dispatchA = new PacketDispatch() {
Name = ""equal""
};
String dispatchB = ""equal"";
Assert.IsFalse(dispatchA.Equals(dispatchB));
}",Tests that a comparison with a different type will come back as false.,1
1451,"public void TestPacketDispatchEqualityHashCode() {
PacketDispatch dispatchA = new PacketDispatch() {
Name = ""equal""
};
PacketDispatch dispatchB = new PacketDispatch() {
Name = ""equal""
};
Assert.AreEqual(dispatchA.GetHashCode(), dispatchB.GetHashCode());
}",Tests the same value in two different objects with have the same hash codes.,1
1452,"public void TestPacketDispatchNotEqualHashCode() {
PacketDispatch dispatchA = new PacketDispatch() {
Name = ""equalA""
};
PacketDispatch dispatchB = new PacketDispatch() {
Name = ""equalB""
};
Assert.AreNotEqual(dispatchA.GetHashCode(), dispatchB.GetHashCode());
}",Tests that different values will yield a different hash code.,1
1453,"public void Clear() {
this.OutgoingPackets = new ConcurrentDictionary<int?, IPacketWrapper>();
this.QueuedPackets = new ConcurrentQueue<IPacketWrapper>();
}",Clears the current queue,1
1454,"public bool RestartConnectionOnQueueFailure() {
bool failed = false;
if (this.OutgoingPackets.Any(outgoingPacket => outgoingPacket.Value.Packet.Stamp < DateTime.Now.AddMinutes(-2)) == true) {
this.Clear();
failed = true;
}
return failed;
}","If a packet exists in our outgoing ""SentPackets""",1
1455,"public void TestPacketSendImmediate() {
PacketQueue queue = new PacketQueue();
IPacketWrapper packet = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
};
IPacketWrapper poppedPacket = queue.PacketSend(packet);
// Client would send to the server.
Assert.AreEqual(packet, poppedPacket);
Assert.AreEqual(1, queue.OutgoingPackets.Count);
Assert.AreEqual(0, queue.QueuedPackets.Count);
}","Tests that a packet is returned immediately from telling the queue it has been sent, inferring the packet is not queued and should be sent immediately.",1
1456,"public void TestPacketSendQueued() {
PacketQueue queue = new PacketQueue();
IPacketWrapper firstPacket = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
};
IPacketWrapper poppedPacket = queue.PacketSend(firstPacket);
// Client would send to the server.
Assert.AreEqual(firstPacket, poppedPacket);
Assert.AreEqual(1, queue.OutgoingPackets.Count);
IPacketWrapper secondPacket = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
};
poppedPacket = queue.PacketSend(secondPacket);
// Popped packet is null, client would essentially ignore it until later.
Assert.IsNull(poppedPacket);
Assert.AreEqual(1, queue.OutgoingPackets.Count);
Assert.AreEqual(1, queue.QueuedPackets.Count);
}",Tests that a packet will not be sent to the server if another packet is currently sent to the server and awaiting a response.,1
1457,"public void TestPacketReceivedRemoveFromOutgoing() {
PacketQueue queue = new PacketQueue();
IPacketWrapper sentPacket = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
};
IPacketWrapper recievedPacket = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 1
}
};
IPacketWrapper poppedPacket = queue.PacketSend(sentPacket);
// Client would send to the server.
Assert.AreEqual(sentPacket, poppedPacket);
Assert.AreEqual(1, queue.OutgoingPackets.Count);
Assert.AreEqual(0, queue.QueuedPackets.Count);
poppedPacket = queue.PacketReceived(recievedPacket);
Assert.IsNull(poppedPacket);
Assert.AreEqual(0, queue.OutgoingPackets.Count);
Assert.AreEqual(0, queue.QueuedPackets.Count);
}",Tests that response to a request will remove from the outgoing list of packets.,1
1458,"public void TestPacketReceivedRemovedAndPopped() {
PacketQueue queue = new PacketQueue();
IPacketWrapper firstPacketRequest = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
};
IPacketWrapper secondPacketRequest = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 2
}
};
IPacketWrapper firstPacketResponse = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 1
}
};
queue.PacketSend(firstPacketRequest);
queue.PacketSend(secondPacketRequest);
Assert.AreEqual(1, queue.OutgoingPackets.Count);
Assert.AreEqual(1, queue.QueuedPackets.Count);
IPacketWrapper poppedPacket = queue.PacketReceived(firstPacketResponse);
Assert.AreEqual(secondPacketRequest, poppedPacket);
queue.PacketSend(poppedPacket);
Assert.AreEqual(1, queue.OutgoingPackets.Count);
Assert.AreEqual(0, queue.QueuedPackets.Count);
}",Tests that a packet will be removed from the outgoing packets and a new packet is dequeued.,1
1459,"public void TestRestartConnectionOnQueueFailureTruey() {
PacketQueue queue = new PacketQueue();
IPacketWrapper packet = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1,
Stamp = DateTime.Now.AddMinutes(-5)
}
};
IPacketWrapper poppedPacket = queue.PacketSend(packet);
Assert.AreEqual(packet, poppedPacket);
Assert.AreEqual(1, queue.OutgoingPackets.Count);
Assert.IsTrue(queue.RestartConnectionOnQueueFailure());
}",Tests that a connection restart will be required if a packet has expired (2 minutes),1
1460,"public void TestRestartConnectionOnQueueFailureFalsey() {
PacketQueue queue = new PacketQueue();
IPacketWrapper packet = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
};
IPacketWrapper poppedPacket = queue.PacketSend(packet);
Assert.AreEqual(packet, poppedPacket);
Assert.AreEqual(1, queue.OutgoingPackets.Count);
Assert.IsFalse(queue.RestartConnectionOnQueueFailure());
}",Tests that no restart of a connection will be required if the queue contains no old packets.,1
1461,"public void TestGetRequestPacketExists() {
PacketQueue queue = new PacketQueue();
IPacketWrapper packetRequest = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
};
IPacketWrapper packetResponse = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 1
}
};
queue.PacketSend(packetRequest);
Assert.AreEqual(1, queue.OutgoingPackets.Count);
IPacketWrapper fetchedRequestPacket = queue.GetRequestPacket(packetResponse);
Assert.AreEqual(packetRequest, fetchedRequestPacket);
}",Tests that we can get the original request packet given a response packet tht exists,1
1462,"public void TestGetRequestPacketDoesNotExists() {
PacketQueue queue = new PacketQueue();
IPacketWrapper packetRequest = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
};
IPacketWrapper packetResponse = new MockPacket() {
Packet = {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 2
}
};
queue.PacketSend(packetRequest);
Assert.AreEqual(1, queue.OutgoingPackets.Count);
IPacketWrapper fetchedRequestPacket = queue.GetRequestPacket(packetResponse);
Assert.IsNull(fetchedRequestPacket);
}",Tests that we get a null value back when no request has been requested from a response.,1
1463,"public void TestEmptyPacketStreamPush() {
PacketStream stream = new PacketStream();
stream.Push(new byte[] { 0x01 }, 1);
Assert.AreEqual(1, stream.Data.Length);
Assert.AreEqual(0x01, stream.Data[0]);
}","Tests that data can be pushed onto the end of the packet stream, if the packet stream is uninitialized.",1
1464,"public void TestEmptyPacketStreamSizeZero() {
PacketStream stream = new PacketStream();
Assert.AreEqual(0, stream.Size());
}","Tests that a size is returned of 0, even on an uninitialized stream.",1
1465,"public void TestEmptyPacketStreamSizeOne() {
PacketStream stream = new PacketStream();
stream.Push(new byte[] { 0x01 }, 1);
Assert.AreEqual(1, stream.Size());
}",Tests that a size can be obtained from an initialized stream.,1
1466,"public void TestEmptyPacketStreamPushNullData() {
PacketStream stream = new PacketStream();
stream.Push(null, 0);
Assert.AreEqual(0, stream.Data.Length);
}",Tests that pushing a null data array onto the packet stream results in no changes and no exceptions.,1
1467,"public void TestSingleAppendPacketStreamPush() {
PacketStream stream = new PacketStream() {
Data = new byte[] {0x01}
};
stream.Push(new byte[] { 0x02 }, 1);
Assert.AreEqual(2, stream.Data.Length);
Assert.AreEqual(0x01, stream.Data[0]);
Assert.AreEqual(0x02, stream.Data[1]);
}",Tests that single data can be appended to the end of an existing stream.,1
1468,"public void TestSingleAppendPacketStreamPushEmptyData() {
PacketStream stream = new PacketStream() {
Data = new byte[] { 0x01 }
};
stream.Push(new byte[0], 0);
Assert.AreEqual(1, stream.Data.Length);
Assert.AreEqual(0x01, stream.Data[0]);
}","Tests that an empty data array can be appended to the end of an existing stream, resulting in no change to the stream with no exceptions posted.",1
1469,"public void TestSingleAppendPacketStreamPushNullData() {
PacketStream stream = new PacketStream() {
Data = new byte[] { 0x01 }
};
stream.Push(null, 0);
Assert.AreEqual(1, stream.Data.Length);
Assert.AreEqual(0x01, stream.Data[0]);
}",Tests that pushing a null data array onto an established stream results in no changes and no exceptions.,1
1470,"public void TestMultipleAppendPacketStreamPush() {
PacketStream stream = new PacketStream() {
Data = new byte[] { 0x01 }
};
stream.Push(new byte[] { 0x02 }, 1);
stream.Push(new byte[] { 0x03, 0x04 }, 2);
Assert.AreEqual(4, stream.Data.Length);
Assert.AreEqual(0x01, stream.Data[0]);
Assert.AreEqual(0x02, stream.Data[1]);
Assert.AreEqual(0x03, stream.Data[2]);
Assert.AreEqual(0x04, stream.Data[3]);
}","Tests that multiple pushes can be done in a row, with multiple bytes.",1
1471,"public void TestSinglePacketStreamPeekShift() {
PacketStream stream = new PacketStream() {
Data = new byte[] {0x01, 0x02, 0x03, 0x04}
};
Assert.AreEqual(0x01, stream.PeekShift(1).First());
Assert.AreEqual(4, stream.Data.Length);
Assert.AreEqual(0x01, stream.Data[0]);
Assert.AreEqual(0x02, stream.Data[1]);
Assert.AreEqual(0x03, stream.Data[2]);
Assert.AreEqual(0x04, stream.Data[3]);
}","Tests a single byte can be pulled from the packet stream, without altering the stream.",1
1472,"public void TestMultiplePacketStreamPeekShift() {
PacketStream stream = new PacketStream() {
Data = new byte[] {0x01, 0x02, 0x03, 0x04}
};
Assert.AreEqual(0x01, stream.PeekShift(2).First());
Assert.AreEqual(0x02, stream.PeekShift(2).Last());
Assert.AreEqual(4, stream.Data.Length);
Assert.AreEqual(0x01, stream.Data[0]);
Assert.AreEqual(0x02, stream.Data[1]);
Assert.AreEqual(0x03, stream.Data[2]);
Assert.AreEqual(0x04, stream.Data[3]);
}",Tests pulling multiple bytes off the stream for a peek will not alter the stream.,1
1473,"public void TestMultiplePacketStreamPeekShiftZeroBytes() {
PacketStream stream = new PacketStream() {
Data = new byte[] { 0x01, 0x02, 0x03, 0x04 }
};
Assert.AreEqual(0, stream.PeekShift(0).Length);
Assert.AreEqual(4, stream.Data.Length);
Assert.AreEqual(0x01, stream.Data[0]);
Assert.AreEqual(0x02, stream.Data[1]);
Assert.AreEqual(0x03, stream.Data[2]);
Assert.AreEqual(0x04, stream.Data[3]);
}",Tests that peeking at no bytes returns an empty array with no changes to the packet stream.,1
1474,"public void TestUninitializedPacketStreamPeekShift() {
PacketStream stream = new PacketStream();
Assert.IsNull(stream.PeekShift(1));
}",Tests that a new packet stream with no data initialized will return null when asked for any data.,1
1475,"public void TestIndexBoundsPacketStreamPeekShift() {
PacketStream stream = new PacketStream() {
Data = new byte[] { 0x01, 0x02, 0x03, 0x04 }
};
Assert.IsNull(stream.PeekShift(5));
}",Tests that requesting a peek at more data than is available will return null,1
1476,"public void TestSinglePacketStreamShift() {
PacketStream stream = new PacketStream() {
Data = new byte[] { 0x01, 0x02, 0x03, 0x04 }
};
byte[] data = stream.Shift(1);
Assert.AreEqual(0x01, data.First());
Assert.AreEqual(3, stream.Data.Length);
Assert.AreEqual(0x02, stream.Data[0]);
Assert.AreEqual(0x03, stream.Data[1]);
Assert.AreEqual(0x04, stream.Data[2]);
}","Tests a single byte can be pulled from the packet stream, removing it from the start of the stream",1
1477,"public void TestMultiplePacketStreamShift() {
PacketStream stream = new PacketStream() {
Data = new byte[] { 0x01, 0x02, 0x03, 0x04 }
};
byte[] data = stream.Shift(2);
Assert.AreEqual(0x01, data.First());
Assert.AreEqual(0x02, data.Last());
Assert.AreEqual(2, stream.Data.Length);
Assert.AreEqual(0x03, stream.Data[0]);
Assert.AreEqual(0x04, stream.Data[1]);
}",Tests pulling multiple bytes off the stream will remove them from the stream,1
1478,"public void TestAllDataPacketStreamShift() {
PacketStream stream = new PacketStream() {
Data = new byte[] { 0x01, 0x02, 0x03, 0x04 }
};
byte[] data = stream.Shift(4);
Assert.AreEqual(0x01, data[0]);
Assert.AreEqual(0x02, data[1]);
Assert.AreEqual(0x03, data[2]);
Assert.AreEqual(0x04, data[3]);
Assert.AreEqual(0, stream.Data.Length);
}","Tests that all data can be moved off the start of the array, resulting in an empty Data array.",1
1479,"public void TestUninitializedPacketStreamShift() {
PacketStream stream = new PacketStream();
Assert.IsNull(stream.Shift(1));
}",Tests that a new packet stream with no data initialized will return null when asked for any data.,1
1480,"public void TestMultiplePacketStreamShiftZeroBytes() {
PacketStream stream = new PacketStream() {
Data = new byte[] { 0x01, 0x02, 0x03, 0x04 }
};
Assert.AreEqual(0, stream.Shift(0).Length);
Assert.AreEqual(4, stream.Data.Length);
Assert.AreEqual(0x01, stream.Data[0]);
Assert.AreEqual(0x02, stream.Data[1]);
Assert.AreEqual(0x03, stream.Data[2]);
Assert.AreEqual(0x04, stream.Data[3]);
}",Tests that shifting no bytes returns an empty array with no changes to the packet stream.,1
1481,"public void TestIndexBoundsPacketStreamShift() {
PacketStream stream = new PacketStream() {
Data = new byte[] { 0x01, 0x02, 0x03, 0x04 }
};
Assert.IsNull(stream.Shift(5));
}",Tests that requesting a peek at more data than is available will return null,1
1482,"public ParsedQuery() : base() {
this.Children = new List<IParsedQuery>();
}",Initializes all defaults,1
1483,"public PermissionModel() {
this.Authority = null;
this.Traits = new List<String>();
}",Initializes the permission with default values.,1
1484,"public Phrase() {
}",Empty constructor,0
1485,"public PingPropertyReference() {
this.ThingReference = new PlayerThingReference();
}",Initializes with the default player thing reference,1
1486,public String Name {,This player's Name.,0
1487,public float Kdr {,This is wrong if the player has no deaths as it should be in infinite k/d r.,0
1488,public String Ip {,This player's IP Address.,0
1489,"public PlayerModel() {
this.Uid = String.Empty;
this.ClanTag = String.Empty;
this.Name = String.Empty;
this.Groups = new List<GroupModel>();
this.Location = new Location();
this.Inventory = new InventoryModel();
this.Outliers = new List<OutlierModel>();
}",Initializes all defaults values for the player,1
1490,"public void TestNameStripped() {
PlayerModel player = new PlayerModel {
Name = ""P]-[0gu3 Brsel""
};
Assert.AreEqual(""P]-[0gu3 Brsel"", player.Name);
Assert.AreEqual(""PHOguE Brosel"", player.NameStripped);
}",Tests a name will be stripped,1
1491,"public void TestKdr() {
PlayerModel player = new PlayerModel() {
Kills = 10,
Deaths = 5
};
Assert.AreEqual(2, player.Kdr);
}",Tests the kdr will be calculated successfully if deaths > 0,1
1492,"public void TestKdrNoDeaths() {
PlayerModel player = new PlayerModel() {
Kills = 10,
Deaths = 0
};
Assert.AreEqual(10, player.Kdr);
}",Tests the number of kills is returned if no kills have been recorded.,1
1493,"public void TestIp() {
PlayerModel player = new PlayerModel() {
Ip = ""1.1.1.1""
};
Assert.AreEqual(""1.1.1.1"", player.Ip);
}",Tests the ip is set when no port is suffixed,1
1494,"public void TestIpPort() {
PlayerModel player = new PlayerModel() {
Ip = ""1.1.1.1:9000""
};
Assert.AreEqual(""1.1.1.1"", player.Ip);
Assert.AreEqual(""9000"", player.Port);
}","Tests the ip:port will be split, with the port field populated.",1
1495,"public void TestModifyGroupDoesNotExist() {
PlayerModel player = new PlayerModel();
player.ModifyGroup(
new GroupModel() {
Type = GroupModel.Team,
Uid = ""1""
}
);
Assert.AreEqual(""1"", player.Groups.First(group => group.Type == GroupModel.Team).Uid);
Assert.AreEqual(1, player.Groups.Count);
}",Tests that a group will be added if it does not exist,1
1496,"public void TestModifyGroupExists() {
PlayerModel player = new PlayerModel() {
Groups = {
new GroupModel() {
Type = GroupModel.Team,
Uid = ""1""
}
}
};
player.ModifyGroup(
new GroupModel() {
Type = GroupModel.Team,
Uid = ""2""
}
);
Assert.AreEqual(""2"", player.Groups.First(group => group.Type == GroupModel.Team).Uid);
Assert.AreEqual(1, player.Groups.Count);
}",Tests that a group will be modified if the group already exists,1
1497,"protected virtual void GenericEventTypeTextCommandExecuted(GenericEvent e) {
this.Tunnel(new Command() {
Origin = CommandOrigin.Local,
Name = e.Now.TextCommands.First().PluginCommand,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Events = new List<IGenericEvent>() {
e
}
}
}
}
});
}","We convert to a new command and push it through to this plugin, which just cleans up the plugin implementation a little bit but converting a plugin executed command to a local command. Snazzified.",1
1498,"public virtual ICommandResult Action(INetworkAction action) {
return this.Bubble(new Command() {
Name = action.ActionType.ToString(),
Scope = new CommandScopeModel() {
ConnectionGuid = this.ConnectionGuid
},
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
NetworkActions = new List<INetworkAction>() {
action
}
}
}
}
});
}","The action will be executed with no user specified, so it should always be successful, at least from a permissions point of view.",1
1499,"public virtual void WriteConfig() {
if (this.ConfigDirectoryInfo != null) {
Config config = new Config();
config.Create(this.GetType());
this.WriteConfig(config);
config.Save(new FileInfo(Path.Combine(this.ConfigDirectoryInfo.FullName, this.GetType().Namespace + "".json"")));
}
}","You can see a similar implementation of this in Instance, which is treated as the base class (therefore it's not passing a config to a child class) but instead needs to make the initial config object before writing to it.",1
1500,"public override void WriteConfig(IConfig config, String password = null) {
// Overwrite this method to write out your config
}",Appends config items,1
1501,"public virtual void LoadConfig() {
this.GenericEvent(new GenericEvent() {
GenericEventType = GenericEventType.ConfigLoading
});
this.Execute(new Config().Load(ConfigDirectoryInfo));
this.GenericEvent(new GenericEvent() {
GenericEventType = GenericEventType.ConfigLoaded
});
}",Configs are simply saved commands,1
1502,"public virtual List<String> HandledCommandNames() {
var items = new List<ICoreController>() { this };
var tunneled = items.SelectMany(item => item.TunnelObjects).ToList();
while (tunneled.Count > 0) {
items.AddRange(tunneled);
tunneled = tunneled.SelectMany(item => item.TunnelObjects).ToList();
}
return items.SelectMany(item => item.CommandDispatchers).Select(item => item.Name).Distinct().OrderBy(item => item).ToList();
}",Fetches a list of available commands handled by this controller and any controllers found in TunnelObjects.,1
1503,"public Point3DModel(String x, String y, String z) : base() {
float iX = 0, iY = 0, iZ = 0;
float.TryParse(x, out iX);
float.TryParse(y, out iY);
float.TryParse(z, out iZ);
this.X = iX;
this.Y = iY;
this.Z = iZ;
}",Initializes a point from three strings,1
1504,"public void TestPointZeroed() {
Point3DModel point = new Point3DModel();
Assert.AreEqual(0, point.X);
Assert.AreEqual(0, point.Y);
Assert.AreEqual(0, point.Z);
}",Tests the point is zeroed when using the empty constructor,1
1505,"public void TestPointParsed() {
Point3DModel point = new Point3DModel(""1"", ""2"", ""3"");
Assert.AreEqual(1, point.X);
Assert.AreEqual(2, point.Y);
Assert.AreEqual(3, point.Z);
}",Tests the point is parsed successfully when strings are passed into the constructor,1
1506,"public ServiceMessage PollService() {
ServiceMessage message = null;
if (this.ServiceMessage != null) {
message = this.ServiceMessage;
// clear it for the next poll.
this.ServiceMessage = null;
}
else {
message = new ServiceMessage() {
Name = ""nop""
};
}
return message;
}","If the main thread is tied up then ""nop"" won't be sent back and the service will be shut down. We may expand on this in the future to check extra threads, polling all the plugin appdomains and such.",1
1507,"public ServiceMessage ExecuteMessage(ServiceMessage message) {
// A request from the service controller to run a command locally.
ICommandResult result = this.Tunnel(new Command() {
Name = message.Name,
Origin = CommandOrigin.Local,
// This is possible because of the SortedDictionary used in Potato.Service.Shared.ArgumentsHelper
// This method will always assume that Arguments.Values will result in the order of execution. Parameters = message.Arguments.Values.Select(value => new CommandParameter() {
Data = {
Content = new List<String>() {
value
}
}
}).Cast<ICommandParameter>().ToList()
});
// Format and return the service message.
return new ServiceMessage() {
Name = ""result"",
Arguments = new Dictionary<string, string>() {
{ ""Command"", message.Name },
{ ""Success"", result.Success.ToString() },
{ ""Status"", result.CommandResultType.ToString() },
{ ""Message"", result.Message }
}
};
}",Executes very simple commands originating from the service controller from a local origin.,1
1508,"public void Start() {
this.Execute();
}",IService implementation to call the execute method and ignore the return type.,0
1509,"public void WriteConfig() {
IConfig config = new Config();
config.Create<PotatoController>();
this.WriteConfig(config, this.Shared.Variables.Get<String>(CommonVariableNames.PotatoConfigPassword));
config.Save(new FileInfo(Path.Combine(Defines.ConfigsDirectory.FullName, this.GetType().Namespace + "".json"")));
}",Writes the current object out to a file.,1
1510,"public override void Dispose() {
// 1. Stop all tasks from ticking, removing concurrent executions with this object.
this.Tasks.ForEach(task => task.Dispose());
this.Tasks.Clear();
this.Tasks = null;
// 2. Events contains varies references to other data through out Potato. This // data should be written out first, writing out the full events data then // moving on to disposing the actual data.
this.Shared.Events.Dispose();
this.Shared.Events = null;
// 3. Stop/disconnect all game server connections, unload any plugins etc.
lock (this.Connections) {
foreach (ConnectionController connection in this.Connections) {
connection.Dispose();
}
}
this.Connections.Clear();
this.Connections = null;
// @todo Does the order matter here? If so, document why.
this.Shared.Security.Dispose();
this.Shared.Security = null;
this.Shared.Languages.Dispose();
this.Shared.Languages = null;
this.Packages.Dispose();
this.Packages = null;
this.Database.Dispose();
this.Database = null;
this.CommandServer.Dispose();
this.CommandServer = null;
this.PushEvents.Dispose();
this.PushEvents = null;
this.Protocols.Dispose();
this.Protocols = null;
this.Shared.Variables.Dispose();
this.Shared.Variables = null;
this.EventsConsole.Dispose();
this.EventsConsole = null;
base.Dispose();
}","Shuts down the layer. Disposes of this object's security, packages, and variables. Calls the base dispose.",1
1511,"public PotatoService() {
InitializeComponent();
}",Initializes the base service,0
1512,"private void InitializeComponent() {
components = new System.ComponentModel.Container();
this.ServiceName = ""Potato Daemon"";
this.CanShutdown = true;
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
1513,"public void Kill() {
System.Diagnostics.Process.GetCurrentProcess().Kill();
}",Kill the current process.,1
1514,"static void Main(string[] args) {
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new MainWindow(args));
}",The main entry point for the application.,1
1515,"protected ICommandResult SingleParameterCommand(ICommand command, Dictionary<String, ICommandParameter> parameters) {
String text = parameters[""text""].First<String>();
command.Result.Message = text;
return command.Result;
}",You'll have to name the parameter and specify the type of object you are expecting when appending your dispatch handler.,1
1516,"public virtual IProtocolSetupResult Setup(IProtocolSetup setup) {
this.Options = setup;
this.Client.Setup(ClientSetup.FromProtocolSetup(setup));
// Handle client events, most of which are proxies to events we fire.
this.Client.PacketReceived += (sender, wrapper) => {
this.PacketDispatcher.Dispatch(wrapper);
// Alert the deferrer that we have a new packet that's been dispatched
this.WaitingActions.Mark(wrapper.Packet);
this.OnClientEvent(ClientEventType.ClientPacketReceived, new ClientEventData() {
Packets = new List<IPacket>() {
wrapper.Packet
}
});
};
this.Client.ConnectionStateChanged += (sender, state) => {
this.OnClientEvent(ClientEventType.ClientConnectionStateChange);
this.State.Settings.Current.ConnectionState = state;
IProtocolStateDifference difference = new ProtocolStateDifference() {
Modified = {
Settings = this.State.Settings
}
};
this.ApplyProtocolStateDifference(difference);
this.OnProtocolEvent(ProtocolEventType.ProtocolSettingsUpdated, difference);
if (state == ConnectionState.ConnectionReady) {
this.Login(this.Options.Password);
}
};
this.Client.PacketSent += (sender, wrapper) => this.OnClientEvent(ClientEventType.ClientPacketSent, new ClientEventData() {
Packets = new List<IPacket>() {
wrapper.Packet
}
});
this.Client.SocketException += (sender, se) => this.OnClientEvent(ClientEventType.ClientSocketException, new ClientEventData() {
Exceptions = new List<String>() {
se.ToString()
}
});
this.Client.ConnectionFailure += (sender, exception) => this.OnClientEvent(ClientEventType.ClientConnectionFailure, new ClientEventData() {
Exceptions = new List<String>() {
exception.ToString()
}
});
return new ProtocolSetupResult();
}","Sets up the protocol, initializing the client",1
1517,"public void AttemptConnection() {
if (this.Client != null && this.Client.ConnectionState == ConnectionState.ConnectionDisconnected) {
this.Client.Connect();
}
}",Attempts a connection to the server.,1
1518,"public virtual void Shutdown() {
if (this.Client != null) {
this.Client.Shutdown();
}
}",Shutsdown this connection,1
1519,"public virtual void Synchronize() {
if (this.Client != null && this.Client.ConnectionState != ConnectionState.ConnectionLoggedIn) {
this.Client.Poke();
}
}",General timed event to synch everything on the server with what is known locally.,1
1520,"public ProtocolAssemblyMetadata() {
this.ProtocolTypes = new List<IProtocolType>();
}",Initalizes meta data with default values.,1
1521,"public ProtocolController() : base() {
this.Shared = new SharedReferences();
this.Protocols = new List<IProtocolAssemblyMetadata>();
this.PackagesDirectory = Defines.PackagesDirectory;
this.CommandDispatchers.AddRange(new List<ICommandDispatch>() {
new CommandDispatch() {
CommandType = CommandType.ProtocolsFetchSupportedProtocols,
Handler = this.ProtocolsFetchSupportedProtocols
},
new CommandDispatch() {
CommandType = CommandType.ProtocolsCheckSupportedProtocol,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""provider"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""type"",
Type = typeof(String)
}
},
Handler = this.ProtocolsCheckSupportedProtocol
}
});
}",Initializes the protocol controller with default values.,1
1522,"public void LoadProtocolsMetadata() {
this.Protocols.Clear();
// List of all matching file assemblies
List<FileInfo> assemblies = this.GetProtocolAssemblies();
// List of the latest packages containing protocols
List<DirectoryInfo> packages = this.GetProtocolPackages(assemblies);
// We have all the possible names of assemblies, we have the list of latest packages
// so now we get a list of distinct names and find packages containing both (Name + "".json"" and Name + "".dll"") files.
List<String> names = assemblies.Select(assembly => assembly.Name.Replace(assembly.Extension, String.Empty)).Distinct().ToList();
// Search for both files within a single package.
foreach (DirectoryInfo package in packages) {
foreach (String name in names) {
var json = Directory.GetFiles(this.PackagesDirectory.FullName, name + "".json"", SearchOption.AllDirectories);
var dll = Directory.GetFiles(this.PackagesDirectory.FullName, name + "".dll"", SearchOption.AllDirectories);
if (json.Length > 0 && dll.Length > 0) {
var meta = new ProtocolAssemblyMetadata() {
Name = name,
Assembly = new FileInfo(dll.First()),
Meta = new FileInfo(json.First()),
Directory = package
};
if (meta.Load() == true) {
this.Protocols.Add(meta);
}
}
}
}
}",Loads all of the protocols meta data,1
1523,"public ICommandResult ProtocolsFetchSupportedProtocols(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
// Give a representation of what we know right now
result = new CommandResult() {
CommandResultType = CommandResultType.Success,
Success = true,
Now = {
ProtocolTypes = this.Protocols.SelectMany(meta => meta.ProtocolTypes).Cast<ProtocolType>().ToList()
}
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Fetches all of the protocols from the cache,1
1524,"public ICommandResult ProtocolsCheckSupportedProtocol(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
String provider = parameters[""provider""].First<String>();
String type = parameters[""type""].First<String>();
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
var meta = this.Protocols.FirstOrDefault(metadata => metadata.ProtocolTypes.Any(protocolType => String.Compare(protocolType.Provider, provider, StringComparison.OrdinalIgnoreCase) == 0 && String.Compare(protocolType.Type, type, StringComparison.OrdinalIgnoreCase) == 0));
if (meta != null) {
var protocol = meta.ProtocolTypes.FirstOrDefault(protocolType => String.Compare(protocolType.Provider, provider, StringComparison.OrdinalIgnoreCase) == 0 && String.Compare(protocolType.Type, type, StringComparison.OrdinalIgnoreCase) == 0);
result = new CommandResult() {
CommandResultType = CommandResultType.Success,
Success = true,
Now = {
ProtocolTypes = new List<ProtocolType>() {
protocol as ProtocolType
},
ProtocolAssemblyMetadatas = new List<IProtocolAssemblyMetadata>() {
meta
}
}
};
}
else {
result = new CommandResult() {
CommandResultType = CommandResultType.DoesNotExists,
Success = false
};
}
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Checks if a given protocol is supported by the instance,1
1525,"public override void Dispose() {
this.Protocols.Clear();
this.Protocols = null;
base.Dispose();
}",Disposes all protocol information,1
1526,"public ProtocolEventArgs() {
this.Stamp = DateTime.Now;
this.ProtocolType = new ProtocolType();
this.Then = new ProtocolEventData();
this.Now = new ProtocolEventData();
this.StateDifference = new ProtocolStateDifference();
}",Initializes the protocol event with the default values.,1
1527,"public ProtocolSetup() {
this.Arguments = new Dictionary<String, String>();
}",Initializes the setup with default values.,1
1528,"public String ArgumentsString() {
var list = new List<String>();
foreach (var variable in this.Arguments) {
list.Add(String.Format(""--{0}"", variable.Key));
list.Add(String.Format(@""""""{0}"""""", variable.Value));
}
return String.Join("" "", list);
}",Convert the variables dictionary to a simple string,1
1529,"public ProtocolState() {
this.Players = new ConcurrentDictionary<String, PlayerModel>();
this.Maps = new ConcurrentDictionary<String, MapModel>();
this.Bans = new ConcurrentDictionary<String, BanModel>();
this.MapPool = new ConcurrentDictionary<String, MapModel>();
this.GameModePool = new ConcurrentDictionary<String, GameModeModel>();
this.Groups = new ConcurrentDictionary<String, GroupModel>();
this.Items = new ConcurrentDictionary<String, ItemModel>();
this.Settings = new Settings();
this.Support = new Tree();
}",Initializes the gamestate with the default values.,1
1530,"public IProtocolState Apply(IProtocolStateDifference difference) {
if (difference.Modified != null) {
if (difference.Override == true) {
this.Set(difference.Modified);
}
else {
this.Modified(difference.Modified);
}
}
if (difference.Removed != null) {
this.Removed(difference.Removed);
}
this.Redefine();
return this;
}",Apply differences from a state object onto the this state.,1
1531,"public static void ModifiedDictionary<T>(ConcurrentDictionary<String, T> existing, ConcurrentDictionary<String, T> modified) {
if (modified != null) {
foreach (var item in modified) {
var closuredItem = item;
existing.AddOrUpdate(item.Key, id => closuredItem.Value, (id, model) => closuredItem.Value);
}
}
}",Synchronizes a modified list with a comparator method,1
1532,"public static void RemoveDictionary<T>(ConcurrentDictionary<String, T> existing, ConcurrentDictionary<String, T> removed) {
if (removed != null) {
foreach (var item in removed) {
T removedItem = default(T);
existing.TryRemove(item.Key, out removedItem);
}
}
}",Synchronizes a modified list with a comparator method,1
1533,"public ProtocolStateDifference() {
this.Modified = new ProtocolStateSegment();
this.Removed = new ProtocolStateSegment();
}",Initializes the difference with the default values.,1
1534,"private void InitializeComponent() {
this.label1 = new System.Windows.Forms.Label();
this.txtProtocolTestFile = new System.Windows.Forms.TextBox();
this.btnBrowse = new System.Windows.Forms.Button();
this.btnRun = new System.Windows.Forms.Button();
this.cboTests = new System.Windows.Forms.ComboBox();
this.btnReload = new System.Windows.Forms.Button();
this.chkConnectionIsolation = new System.Windows.Forms.CheckBox();
this.rtbProtocolTestOutput = new Potato.Tools.NetworkConsole.Controls.CodRichTextBox();
this.SuspendLayout();
// // label1
// this.label1.AutoSize = true;
this.label1.Location = new System.Drawing.Point(0, 4);
this.label1.Name = ""label1"";
this.label1.Size = new System.Drawing.Size(89, 13);
this.label1.TabIndex = 0;
this.label1.Text = ""Protocol Test File"";
// // txtProtocolTestFile
// this.txtProtocolTestFile.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.txtProtocolTestFile.Location = new System.Drawing.Point(3, 20);
this.txtProtocolTestFile.Name = ""txtProtocolTestFile"";
this.txtProtocolTestFile.ReadOnly = true;
this.txtProtocolTestFile.Size = new System.Drawing.Size(457, 20);
this.txtProtocolTestFile.TabIndex = 1;
// // btnBrowse
// this.btnBrowse.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.btnBrowse.Location = new System.Drawing.Point(466, 18);
this.btnBrowse.Name = ""btnBrowse"";
this.btnBrowse.Size = new System.Drawing.Size(75, 23);
this.btnBrowse.TabIndex = 2;
this.btnBrowse.Text = ""Browse"";
this.btnBrowse.UseVisualStyleBackColor = true;
this.btnBrowse.Click += new System.EventHandler(this.btnBrowse_Click);
// // btnRun
// this.btnRun.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.btnRun.Enabled = false;
this.btnRun.Location = new System.Drawing.Point(550, 440);
this.btnRun.Name = ""btnRun"";
this.btnRun.Size = new System.Drawing.Size(75, 23);
this.btnRun.TabIndex = 4;
this.btnRun.Text = ""Run"";
this.btnRun.UseVisualStyleBackColor = true;
this.btnRun.Click += new System.EventHandler(this.btnRun_Click);
// // cboTests
// this.cboTests.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.cboTests.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this.cboTests.FormattingEnabled = true;
this.cboTests.Location = new System.Drawing.Point(3, 442);
this.cboTests.Name = ""cboTests"";
this.cboTests.Size = new System.Drawing.Size(413, 21);
this.cboTests.TabIndex = 5;
// // btnReload
// this.btnReload.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.btnReload.Enabled = false;
this.btnReload.Location = new System.Drawing.Point(547, 18);
this.btnReload.Name = ""btnReload"";
this.btnReload.Size = new System.Drawing.Size(75, 23);
this.btnReload.TabIndex = 6;
this.btnReload.Text = ""Reload"";
this.btnReload.UseVisualStyleBackColor = true;
this.btnReload.Click += new System.EventHandler(this.btnReload_Click);
// // chkConnectionIsolation
// this.chkConnectionIsolation.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.chkConnectionIsolation.AutoSize = true;
this.chkConnectionIsolation.Enabled = false;
this.chkConnectionIsolation.Location = new System.Drawing.Point(422, 444);
this.chkConnectionIsolation.Name = ""chkConnectionIsolation"";
this.chkConnectionIsolation.Size = new System.Drawing.Size(122, 17);
this.chkConnectionIsolation.TabIndex = 7;
this.chkConnectionIsolation.Text = ""Connection Isolation"";
this.chkConnectionIsolation.UseVisualStyleBackColor = true;
this.chkConnectionIsolation.CheckedChanged += new System.EventHandler(this.chkConnectionIsolation_CheckedChanged);
// // rtbProtocolTestOutput
// this.rtbProtocolTestOutput.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.rtbProtocolTestOutput.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
this.rtbProtocolTestOutput.Font = new System.Drawing.Font(""Segoe UI"", 9F, System.Drawing.FontStyle.Bold);
this.rtbProtocolTestOutput.Location = new System.Drawing.Point(3, 46);
this.rtbProtocolTestOutput.Name = ""rtbProtocolTestOutput"";
this.rtbProtocolTestOutput.ReadOnly = true;
this.rtbProtocolTestOutput.Size = new System.Drawing.Size(622, 388);
this.rtbProtocolTestOutput.TabIndex = 3;
this.rtbProtocolTestOutput.Text = """";
// // ProtocolTestControl
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.Controls.Add(this.chkConnectionIsolation);
this.Controls.Add(this.btnReload);
this.Controls.Add(this.cboTests);
this.Controls.Add(this.btnRun);
this.Controls.Add(this.rtbProtocolTestOutput);
this.Controls.Add(this.btnBrowse);
this.Controls.Add(this.txtProtocolTestFile);
this.Controls.Add(this.label1);
this.Name = ""ProtocolTestControl"";
this.Size = new System.Drawing.Size(630, 472);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
1535,"protected void FalseAllFoundFlags() {
List<ProtocolUnitTestCommand> commands = this.Tests.SelectMany(test => test.TestCommands).ToList();
List<ProtocolUnitTestPacket> packets = new List<ProtocolUnitTestPacket>();
packets.AddRange(commands.SelectMany(command => command.Requests).ToList());
packets.AddRange(commands.SelectMany(command => command.Responses).ToList());
packets.AddRange(commands.Select(command => command.Send).ToList());
packets.ForEach(packet => packet.Found = false);
}","Kind of late to the game, decided to change how the UI allows for tests to be re-run and such.",0
1536,"public ProtocolType() {
this.Provider = String.Empty;
this.Type = String.Empty;
this.Name = String.Empty;
}",Initalizes the protocol type with empty values.,0
1537,"public ProtocolType(IProtocolType from) {
this.Provider = from.Provider;
this.Type = from.Type;
this.Name = from.Name;
}",Initializes the protocol type from another type,1
1538,"public void TestPunkBusterSerializerPlayer() {
IPunkBuster punkBuster = PunkBusterSerializer.Deserialize(""PunkBuster Server: 1 b88b60a36365592b1ae94fa04c5763ed(-) 111.222.0.1:3659 OK 1 3.0 0 (V) \""PhogueZero\"""");
Assert.IsInstanceOf<PunkBusterPlayer>(punkBuster);
PunkBusterPlayer player = punkBuster as PunkBusterPlayer;
Assert.AreEqual(1, player.SlotId);
Assert.AreEqual(""b88b60a36365592b1ae94fa04c5763ed"", player.Guid);
Assert.AreEqual(""111.222.0.1:3659"", player.Ip);
Assert.AreEqual(""PhogueZero"", player.Name);
}",Tests a punkbuster player from a player list will match,1
1539,"public void TestPunkBusterSerializerBeginPlayerList() {
IPunkBuster punkBuster = PunkBusterSerializer.Deserialize(""PunkBuster Server: Player List: [Slot #] [GUID] [Address] [Status] [Power] [Auth Rate] [Recent SS] [O/S] [Name]"");
Assert.IsInstanceOf<PunkBusterBeginPlayerList>(punkBuster);
}",Tests a punkbuster player list begin will match,1
1540,"public void TestPunkBusterSerializerEndPlayerList() {
IPunkBuster punkBuster = PunkBusterSerializer.Deserialize(""PunkBuster Server: End of Player List (1 Players)"");
Assert.IsInstanceOf<PunkBusterEndPlayerList>(punkBuster);
PunkBusterEndPlayerList endPlayerList = punkBuster as PunkBusterEndPlayerList;
Assert.AreEqual(1, endPlayerList.PlayerCount);
}",Tests a punkbuster player list end will match,1
1541,"public PushEventsController() : base() {
this.Shared = new SharedReferences();
this.EndPoints = new Dictionary<String, IPushEventsEndPoint>();
this.Tasks = new List<Timer>();
this.CommandDispatchers.AddRange(new List<ICommandDispatch>() {
new CommandDispatch() {
CommandType = CommandType.EventsEstablishJsonStream,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""name"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""uri"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""key"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""interval"",
Type = typeof(int)
},
new CommandParameterType() {
IsList = true,
Name = ""inclusive"",
Type = typeof(String)
}
},
Handler = this.EventsEstablishJsonStream
},
new CommandDispatch() {
CommandType = CommandType.EventsEstablishJsonStream,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""name"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""uri"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""key"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""interval"",
Type = typeof(int)
},
new CommandParameterType() {
Name = ""inclusive"",
Type = typeof(String)
}
},
Handler = this.EventsEstablishJsonStream
}
});
this.GroupedVariableListener = new GroupedVariableListener() {
GroupsVariableName = CommonVariableNames.EventsPushConfigGroups.ToString(),
ListeningVariablesNames = new List<String>() {
CommonVariableNames.EventsPushUri.ToString(),
CommonVariableNames.EventPushIntervalSeconds.ToString(),
CommonVariableNames.EventPushContentType.ToString(),
CommonVariableNames.EventPushStreamKey.ToString(),
CommonVariableNames.EventPushInclusiveNames.ToString()
}
};
}",Initializes with default attributes,1
1542,"public void AssignEvents() {
// Remove all current handlers, also clears the list in this.ListeningVariables
this.UnassignEvents();
this.GroupedVariableListener.AssignEvents();
this.GroupedVariableListener.VariablesModified += GroupedVariableListenerOnVariablesModified;
this.Shared.Events.EventLogged += new EventsController.EventLoggedHandler(MasterEvents_EventLogged);
}",This will also setup the empty namespace group.,1
1543,"public void UnassignEvents() {
this.GroupedVariableListener.VariablesModified -= GroupedVariableListenerOnVariablesModified;
this.GroupedVariableListener.UnassignEvents();
this.Shared.Events.EventLogged -= new EventsController.EventLoggedHandler(MasterEvents_EventLogged);
}",Removes all current event handlers.,1
1544,"public ICommandResult EventsEstablishJsonStream(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
String name = parameters[""name""].First<String>();
String uri = parameters[""uri""].First<String>();
String key = parameters[""key""].First<String>();
int interval = parameters[""interval""].First<int>();
List<String> inclusive = parameters[""inclusive""].All<String>();
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
this.Shared.Variables.Tunnel(CommandBuilder.VariablesSetF(VariableModel.NamespaceVariableName(name, CommonVariableNames.EventPushContentType), Mime.ApplicationJson).SetOrigin(CommandOrigin.Local));
this.Shared.Variables.Tunnel(CommandBuilder.VariablesSetF(VariableModel.NamespaceVariableName(name, CommonVariableNames.EventsPushUri), uri).SetOrigin(CommandOrigin.Local));
this.Shared.Variables.Tunnel(CommandBuilder.VariablesSetF(VariableModel.NamespaceVariableName(name, CommonVariableNames.EventPushIntervalSeconds), interval.ToString(CultureInfo.InvariantCulture)).SetOrigin(CommandOrigin.Local));
this.Shared.Variables.Tunnel(CommandBuilder.VariablesSetF(VariableModel.NamespaceVariableName(name, CommonVariableNames.EventPushStreamKey), key).SetOrigin(CommandOrigin.Local));
this.Shared.Variables.Tunnel(CommandBuilder.VariablesSetF(VariableModel.NamespaceVariableName(name, CommonVariableNames.EventPushInclusiveNames), inclusive).SetOrigin(CommandOrigin.Local));
ICommandResult uris = this.Shared.Variables.Tunnel(CommandBuilder.VariablesGet(CommonVariableNames.EventsPushConfigGroups).SetOrigin(CommandOrigin.Local));
var content = uris.Now.Variables != null ? uris.Now.Variables.SelectMany(variable => variable.ToList<String>()).ToList() : new List<String>();
// If the name has not been registered already..
// We always need to set the flash variable. We may have loaded
// from a flash variable, which is why we know of the host already.
if (uris.Success == true) {
this.Shared.Variables.Tunnel(CommandBuilder.VariablesSetF(CommonVariableNames.EventsPushConfigGroups, content.Union(new List<String>() {
name
}).ToList()).SetOrigin(CommandOrigin.Local));
}
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success
};
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Establishes a json stream to an endpoint,1
1545,"public override void Dispose() {
this.UnassignEvents();
foreach (var endPoint in this.EndPoints) {
endPoint.Value.Dispose();
}
this.EndPoints.Clear();
this.EndPoints = null;
this.Tasks.ForEach(task => task.Dispose());
this.Tasks.Clear();
this.Tasks = null;
base.Dispose();
}",Allows for an optional child implementation.,1
1546,"protected void MasterEvents_EventLogged(object sender, IGenericEvent e) {
foreach (var endPoint in this.EndPoints) {
endPoint.Value.Append(e);
}
}",Called whenever an event is logged.,1
1547,"public PushEventsEndPoint() {
this.Id = String.Empty;
this.StreamKey = String.Empty;
this.EventsStream = new List<IGenericEvent>();
this.Pushing = false;
this.Interval = 1;
this.ContentType = Mime.ApplicationJson;
this.Uri = new Uri(""http://localhost/"");
this.InclusiveNames = new List<String>();
}",Initializes the end point with the default values.,1
1548,"public void Push() {
// Don't block, we'll pick it up next round.
if (this.EventsStream != null && this.Pushing == false) {
this.Pushing = true;
List<IGenericEvent> data;
// Clone the list of events we're pushing out.
lock (this.EventsStream) {
data = new List<IGenericEvent>(this.EventsStream);
}
// Only transfer if we have something new to report.
if (data.Count > 0) {
WebRequest request = WebRequest.Create(this.Uri.ToString());
request.Method = WebRequestMethods.Http.Post;
request.ContentType = this.ContentType;
request.Proxy = null;
request.BeginGetRequestStream(streamAsyncResult => {
try {
using (TextWriter writer = new StreamWriter(request.EndGetRequestStream(streamAsyncResult))) {
PushEventsEndPoint.WriteSerializedEventsRequest(writer, this.ContentType, new PushEventsRequest() {
Id = this.Id,
StreamKey = this.StreamKey,
Events = data
});
}
request.BeginGetResponse(responseAsyncResult => {
try {
WebResponse response = request.EndGetResponse(responseAsyncResult);
this.RequestCompleted(data);
response.Close();
}
catch {
// General error, remove our sent data dropping the events. Couldn't communicate with end point.
this.RequestCompleted(data);
}
}, null);
}
catch {
// General error, remove our sent data dropping the events. Couldn't communicate with end point.
this.RequestCompleted(data);
}
}, null);
}
else {
this.Pushing = false;
}
}
}",Pushes the current data to the Uri.,1
1549,"private void RequestCompleted(IEnumerable<IGenericEvent> pushedDataList) {
if (this.EventsStream != null && pushedDataList != null) {
lock (this.EventsStream) {
foreach (GenericEvent pushedData in pushedDataList) {
pushedData.Disposed -= new EventHandler(GenericEventArgs_Disposed);
this.EventsStream.Remove(pushedData);
}
}
}
this.OnPushCompleted();
this.Pushing = false;
}","Fired once the command has completed or errored. We always remove the stream regardless of it being an error, treating it like a udp stream. The server gets the data or it gets left behind. We're just pushing updated data.",1
1550,"public RepositoryCache() {
this.PackageOrphanage = new RepositoryModel() {
IsOrphanage = true
};
this.Repositories = new ConcurrentBag<RepositoryModel>() {
this.PackageOrphanage
};
this.SourceRepositories = new ConcurrentDictionary<String, IPackageRepository>();
}",Initializes the repository cache with the default values.,1
1551,"public void Clear() {
while (this.Repositories.IsEmpty == false) {
RepositoryModel result;
this.Repositories.TryTake(out result);
}
this.Repositories.Add(this.PackageOrphanage);
}",Empty the cache of repositories,1
1552,"public RepositoryModel() : base() {
this.Packages = new List<PackageWrapperModel>();
}",Initializes a repository model with the default values.,1
1553,internal static string Style {,Looks up a localized string similar to .my-style { text-align: center; }.,0
1554,internal static string ConsoleHeader {,"Looks up a localized string similar to .............. .. .......,,,,,,,,,....... .. ... ......,,,,,,,,,,,,,,,,,,,,..... ... .........,,,,,,,,,,,,,,,,,,,,,,,,,,......... .......,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,........ .......,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....... .......,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....... .......,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,........ ........,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,........ .....,,..,,,,,,,,,,,,,,,,,,,,, [rest of string was truncated]"";.",0
1555,"public RouteParser() {
this.CompiledTextCommands = new List<CompiledTextCommand>();
}",Initializes route parser with default values.,1
1556,"protected IEnumerable<CompiledTextCommand> CompileTextCommands() {
return this.TextCommands.SelectMany(textCommand => textCommand.Commands.Select(text => new CompiledTextCommand() {
Text = text,
TextCommand = textCommand
}));
}",Builds a list of compiled text commands,1
1557,"public void Shutdown() {
foreach (var plugin in this.LoadedPlugins) {
plugin.Value.GenericEvent(new GenericEvent() {
GenericEventType = GenericEventType.PluginsUnloading
});
plugin.Value.Dispose();
}
}","Shutdown all of the plugins, firing a",0
1558,"public void FireProtocolEvent(IProtocolEventArgs args) {
if (this.ProtocolEvent != null) {
this.ProtocolEvent(args);
}
}",Fires a protocol event back across the appdomain,1
1559,"public void FireClientEvent(IClientEventArgs args) {
if (this.ClientEvent != null) {
this.ClientEvent(args);
}
}",Fires a client event back across the appdomain,1
1560,"public void AssignEvents() {
if (this.SandboxedProtocol != null) {
this.SandboxedProtocol.ProtocolEvent += (protocol, args) => {
if (this.Bubble != null) {
this.Bubble.FireProtocolEvent(args);
}
};
this.SandboxedProtocol.ClientEvent += (protocol, args) => {
if (this.Bubble != null) {
this.Bubble.FireClientEvent(args);
}
};
}
}","Assigns events from the sandboxed protocol to bubble into the bubble object, provided an object has beeen set and a delegate added to the bubble object.",1
1561,"public IProtocolSetupResult Setup(IProtocolSetup setup) {
return this.SandboxedProtocol != null ? this.SandboxedProtocol.Setup(setup) : null;
}","Sets up the protocol, initializing the client",1
1562,"public void AttemptConnection() {
if (this.SandboxedProtocol != null) {
this.SandboxedProtocol.AttemptConnection();
}
}",Attempts a connection to the server.,1
1563,"public void Shutdown() {
if (this.SandboxedProtocol != null) {
this.SandboxedProtocol.Shutdown();
this.SandboxedProtocol = null;
}
}",Shutsdown this connection,1
1564,"public void Synchronize() {
if (this.SandboxedProtocol != null) {
this.SandboxedProtocol.Synchronize();
}
}",General timed event to synch everything on the server with what is known locally.,1
1565,"public ScorePropertyReference() {
this.ThingReference = new PlayerThingReference();
}",Initializes with the default player thing reference,1
1566,"public SecurityController() : base() {
this.Shared = new SharedReferences();
this.Groups = new List<GroupModel>() {
new GroupModel() {
Name = ""Guest"",
IsGuest = true
}
};
this.CommandDispatchers.AddRange(new List<ICommandDispatch>() {
new CommandDispatch() {
CommandType = CommandType.SecurityAddGroup,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""groupName"",
Type = typeof(String)
}
},
Handler = this.SecurityAddGroup
},
new CommandDispatch() {
CommandType = CommandType.SecurityRemoveGroup,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""groupName"",
Type = typeof(String)
}
},
Handler = this.SecurityRemoveGroup
},
new CommandDispatch() {
CommandType = CommandType.SecurityRemoveAccount,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""username"",
Type = typeof(String)
}
},
Handler = this.SecurityRemoveAccount
},
new CommandDispatch() {
CommandType = CommandType.SecurityRemovePlayer,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""gameType"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""uid"",
Type = typeof(String)
}
},
Handler = this.SecurityRemovePlayer
},
new CommandDispatch() {
CommandType = CommandType.SecurityQueryPermission,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""commandName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""targetGameType"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""targetUid"",
Type = typeof(String)
}
},
Handler = this.DispatchPermissionsCheckByAccountPlayerDetails
},
new CommandDispatch() {
CommandType = CommandType.SecurityQueryPermission,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""commandName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""targetAccountName"",
Type = typeof(String)
}
},
Handler = this.DispatchPermissionsCheckByAccountDetails
},
new CommandDispatch() {
CommandType = CommandType.SecurityQueryPermission,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""commandName"",
Type = typeof(String)
}
},
Handler = this.DispatchPermissionsCheckByCommand
},
new CommandDispatch() {
CommandType = CommandType.SecurityGroupSetPermission,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""groupName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""permissionName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""authority"",
Type = typeof(int)
}
},
Handler = this.SecurityGroupSetPermission
},
new CommandDispatch() {
CommandType = CommandType.SecurityGroupAppendPermissionTrait,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""groupName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""permissionName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""trait"",
Type = typeof(String)
}
},
Handler = this.SecurityGroupAppendPermissionTrait
},
new CommandDispatch() {
CommandType = CommandType.SecurityGroupRemovePermissionTrait,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""groupName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""permissionName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""trait"",
Type = typeof(String)
}
},
Handler = this.SecurityGroupRemovePermissionTrait
},
new CommandDispatch() {
CommandType = CommandType.SecurityGroupSetPermissionDescription,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""groupName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""permissionName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""description"",
Type = typeof(String)
}
},
Handler = this.SecurityGroupSetPermissionDescription
},
new CommandDispatch() {
CommandType = CommandType.SecurityGroupCopyPermissions,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""sourceGroupName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""destinationGroupName"",
Type = typeof(String)
}
},
Handler = this.SecurityGroupCopyPermissions
},
new CommandDispatch() {
CommandType = CommandType.SecurityGroupAddAccount,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""groupName"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""username"",
Type = typeof(String)
}
},
Handler = this.SecurityGroupAddAccount
},
new CommandDispatch() {
CommandType = CommandType.SecurityAccountAddPlayer,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""username"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""gameType"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""uid"",
Type = typeof(String)
}
},
Handler = this.SecurityAccountAddPlayer
},
new CommandDispatch() {
CommandType = CommandType.SecurityAccountSetPassword,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""username"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""password"",
Type = typeof(String)
}
},
Handler = this.SecurityAccountSetPassword
},
new CommandDispatch() {
CommandType = CommandType.SecurityAccountSetPasswordHash,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""username"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""passwordHash"",
Type = typeof(String)
}
},
Handler = this.SecurityAccountSetPasswordHash
},
new CommandDispatch() {
CommandType = CommandType.SecurityAccountAppendAccessToken,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""username"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""id"",
Type = typeof(Guid)
},
new CommandParameterType() {
Name = ""tokenHash"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""lastTouched"",
Type = typeof(DateTime)
}
},
Handler = this.SecurityAccountAppendAccessToken
},
new CommandDispatch() {
CommandType = CommandType.SecurityAccountAuthenticate,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""username"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""passwordPlainText"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""identifier"",
Type = typeof(String)
}
},
Handler = this.SecurityAccountAuthenticate
},
new CommandDispatch() {
CommandType = CommandType.SecurityAccountAuthenticateToken,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""id"",
Type = typeof(Guid)
},
new CommandParameterType() {
Name = ""token"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""identifier"",
Type = typeof(String)
}
},
Handler = this.SecurityAccountAuthenticateToken
},
new CommandDispatch() {
CommandType = CommandType.SecurityAccountSetPreferredLanguageCode,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""username"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""languageCode"",
Type = typeof(String)
}
},
Handler = this.SecurityAccountSetPreferredLanguageCode
},
new CommandDispatch() {
CommandType = CommandType.SecuritySetPredefinedStreamPermissions,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""groupName"",
Type = typeof(String)
}
},
Handler = this.SecuritySetPredefinedStreamPermissions
},
new CommandDispatch() {
CommandType = CommandType.SecuritySetPredefinedAdministratorsPermissions,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""groupName"",
Type = typeof(String)
}
},
Handler = this.SecuritySetPredefinedAdministratorsPermissions
}
});
}",Initializes a security controller with the default values and dispatch.,1
1567,"public override void Dispose() {
foreach (GroupModel group in this.Groups) {
group.Dispose();
}
this.Groups.Clear();
this.Groups = null;
}",Relies on children classes to implement this.,1
1568,"public override void Poke() {
base.Poke();
// When we should remove expired tokens
var expiredThreshold = DateTime.Now.AddSeconds(-1 * Math.Abs(this.Shared.Variables.Get(CommonVariableNames.SecurityMaximumAccessTokenLastTouchedLengthSeconds, 172800)));
foreach (AccountModel account in this.Groups.SelectMany(group => group.Accounts)) {
// Remove all tokens that were last touched beyond the threshold
foreach (var tokenId in account.AccessTokens.Where(token => token.Value.LastTouched < expiredThreshold).Select(token => token.Key)) {
AccessTokenModel removed;
account.AccessTokens.TryRemove(tokenId, out removed);
}
}
}",Remove any expired access tokens,1
1569,"public override void WriteConfig(IConfig config, String password = null) {
base.WriteConfig(config, password);
foreach (GroupModel group in this.Groups) {
config.Append(CommandBuilder.SecurityAddGroup(group.Name).ToConfigCommand());
foreach (PermissionModel permission in group.Permissions) {
if (permission.Authority.HasValue == true) {
config.Append(CommandBuilder.SecurityGroupSetPermission(group.Name, permission.Name, permission.Authority.Value).ToConfigCommand());
}
}
foreach (AccountModel account in group.Accounts) {
config.Append(CommandBuilder.SecurityGroupAddAccount(group.Name, account.Username).ToConfigCommand());
config.Append(CommandBuilder.SecurityAccountSetPasswordHash(account.Username, account.PasswordHash).ToConfigCommand());
config.Append(CommandBuilder.SecurityAccountSetPreferredLanguageCode(account.Username, account.PreferredLanguageCode).ToConfigCommand());
foreach (AccountPlayerModel assignment in account.Players) {
config.Append(CommandBuilder.SecurityAccountAddPlayer(account.Username, assignment.ProtocolType, assignment.Uid).ToConfigCommand());
}
foreach (var token in account.AccessTokens.Select(token => token.Value)) {
config.Append(CommandBuilder.SecurityAccountAppendAccessToken(account.Username, token.Id, token.TokenHash, token.LastTouched).ToConfigCommand());
}
}
}
}",Relies on children classes to implement this.,1
1570,"public ICommandResult SecurityAddGroup(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
String groupName = parameters[""groupName""].First<String>();
if (this.DispatchPermissionsCheck(command, command.Name).Success == true) {
if (groupName.Length > 0) {
if (this.Groups.FirstOrDefault(group => @group.Name == groupName) == null) {
GroupModel group = new GroupModel() {
Name = groupName
};
this.Groups.Add(group);
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = String.Format(@""Group """"{0}"""" created."", groupName),
Now = new CommandData() {
Groups = new List<GroupModel>() {
group
}
}
};
if (this.Shared.Events != null) {
this.Shared.Events.Log(GenericEvent.ConvertToGenericEvent(result, GenericEventType.SecurityGroupAdded));
}
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.AlreadyExists,
Message = String.Format(@""Group """"{0}"""" already exists."", groupName)
};
}
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.InvalidParameter,
Message = ""A group name must not be zero length""
};
}
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Creates a new group if the specified name is unique.,1
1571,"public ICommandResult SecurityRemoveAccount(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
String username = parameters[""username""].First<String>();
if (this.DispatchPermissionsCheck(command, command.Name).Success == true) {
if (username.Length > 0) {
if (this.DispatchIdentityCheck(command, username).Success == false) {
// Fetch the account, whatever group it is added to.
AccountModel account = this.Groups.SelectMany(group => @group.Accounts).FirstOrDefault(a => String.Compare(a.Username, username, StringComparison.OrdinalIgnoreCase) == 0);
if (account != null) {
account.Group.Accounts.Remove(account);
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = String.Format(@""Account """"{0}"""" removed."", account.Username),
Then = new CommandData() {
Accounts = new List<AccountModel>() {
account.Clone() as AccountModel
},
Groups = new List<GroupModel>() {
account.Group
}
}
};
if (this.Shared.Events != null) {
this.Shared.Events.Log(GenericEvent.ConvertToGenericEvent(result, GenericEventType.SecurityAccountRemoved));
}
// Now cleanup our stored account
account.Dispose();
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.DoesNotExists,
Message = String.Format(@""Account """"{0}"""" does not exist."", username)
};
}
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.InvalidParameter,
Message = ""Cannot remove your own account""
};
}
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.InvalidParameter,
Message = ""An account name must not be zero length""
};
}
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}","Removes an account, whatever group it is assigned to.",1
1572,"public AccountModel GetAccount(String gameType, String uid) {
return this.Groups.SelectMany(group => group.Accounts)
.SelectMany(account => account.Players)
.Where(player => player.ProtocolType == gameType)
.Where(player => player.Uid == uid)
.Select(player => player.Account)
.FirstOrDefault();
}",Retrieves an account that contains a specified uid.,1
1573,"public AccountModel GetAccount(String username) {
return this.Groups.SelectMany(group => group.Accounts)
.FirstOrDefault(account => String.Compare(account.Username, username, StringComparison.OrdinalIgnoreCase) == 0);
}",Retrieves an account whose username matches the username specified.,1
1574,"public AccountModel GetAccount(Guid tokenId) {
return this.Groups.SelectMany(group => group.Accounts)
.FirstOrDefault(account => account.AccessTokens.ContainsKey(tokenId));
}",Retrieves an account who has an access token matching the guid specified.,1
1575,"public ICommandResult SecurityGroupAddAccount(ICommand command, Dictionary<String, ICommandParameter> parameters) { // , String groupName, String username) {
ICommandResult result = null;
String groupName = parameters[""groupName""].First<String>();
String username = parameters[""username""].First<String>();
if (this.DispatchPermissionsCheck(command, command.Name).Success == true) {
GroupModel group = this.Groups.FirstOrDefault(g => g.Name == groupName);
if (group != null) {
if (group.IsGuest == false) {
if (username.Length > 0) {
AccountModel account = this.Groups.SelectMany(g => g.Accounts).FirstOrDefault(a => String.Compare(a.Username, username, StringComparison.OrdinalIgnoreCase) == 0);
// If the account does not exist in any other group yet..
if (account == null) {
account = new AccountModel() {
Username = username,
Group = group,
};
group.Accounts.Add(account);
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = String.Format(@""Account """"{0}"""" added to group """"{1}""""."", account.Username, group.Name),
Scope = new CommandData() {
Groups = new List<GroupModel>() {
group
}
},
Now = new CommandData() {
Accounts = new List<AccountModel>() {
account
}
}
};
if (this.Shared.Events != null) {
this.Shared.Events.Log(GenericEvent.ConvertToGenericEvent(result, GenericEventType.SecurityAccountAdded));
}
}
// Else the account exists already, relocate it.
else {
GroupModel existingGroup = account.Group;
// Remove it from the other group
account.Group.Accounts.Remove(account);
// Add the account to this group.
account.Group = group;
group.Accounts.Add(account);
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = String.Format(@""Account """"{0}"""" added to group """"{1}""""."", account.Username, group.Name),
Scope = new CommandData() {
Accounts = new List<AccountModel>() {
account
}
},
Then = new CommandData() {
Groups = new List<GroupModel>() {
existingGroup
}
},
Now = new CommandData() {
Groups = new List<GroupModel>() {
group
}
}
};
if (this.Shared.Events != null) {
this.Shared.Events.Log(GenericEvent.ConvertToGenericEvent(result, GenericEventType.SecurityAccountAdded));
}
}
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.InvalidParameter,
Message = ""An account username must not be zero length""
};
}
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.InvalidParameter,
Message = ""Cannot add an account to a guest group""
};
}
}
else {
result = new CommandResult() {
Message = String.Format(@""Group with name """"{0}"""" does not exists."", groupName),
Success = false,
CommandResultType = CommandResultType.DoesNotExists
};
}
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Creates a new account if the specified name is unique.,1
1576,"public ICommandResult SecurityAccountAppendAccessToken(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
String username = parameters[""username""].First<String>();
Guid id = parameters[""id""].First<Guid>();
String tokenHash = parameters[""tokenHash""].First<String>();
DateTime lastTouched = parameters[""lastTouched""].First<DateTime>();
if (this.DispatchPermissionsCheck(command, command.Name).Success == true) {
AccountModel account = this.Groups.SelectMany(g => g.Accounts).FirstOrDefault(a => String.Compare(a.Username, username, StringComparison.OrdinalIgnoreCase) == 0);
if (account != null) {
if (id != Guid.Empty && tokenHash.Length > 0 && lastTouched > DateTime.Now.AddSeconds(-1 * Math.Abs(this.Shared.Variables.Get(CommonVariableNames.SecurityMaximumAccessTokenLastTouchedLengthSeconds, 172800)))) {
// Upsert the token hash
account.AccessTokens.AddOrUpdate(id, guid => new AccessTokenModel() {
Id = id,
Account = account,
TokenHash = tokenHash,
LastTouched = lastTouched,
ExpiredWindowSeconds = this.Shared.Variables.Get(CommonVariableNames.SecurityMaximumAccessTokenLastTouchedLengthSeconds, 172800)
}, (guid, model) => {
model.TokenHash = tokenHash;
model.LastTouched = lastTouched;
return model;
});
// Keep removing token hashes if we've added too many
while (account.AccessTokens.Count > 0 && account.AccessTokens.Count > this.Shared.Variables.Get(CommonVariableNames.SecurityMaximumAccessTokensPerAccount, 5)) {
var oldestId = account.AccessTokens.OrderBy(accessToken => accessToken.Value.LastTouched).First();
// Remove the token that was touched the longest ago.
AccessTokenModel removed;
account.AccessTokens.TryRemove(oldestId.Key, out removed);
}
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = String.Format(@""Successfully added token hash to account """"{0}""""."", account.Username)
};
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.InvalidParameter,
Message = ""An id or tokenHash must not be empty and a lastTouched not expired""
};
}
}
else {
result = new CommandResult() {
Message = String.Format(@""Account with username """"{0}"""" does not exists."", username),
Success = false,
CommandResultType = CommandResultType.DoesNotExists
};
}
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Appends an access token onto an accounts acceptable token list.,1
1577,"public ICommandResult SecurityAccountAuthenticateToken(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
Guid id = parameters[""id""].First<Guid>();
String token = parameters[""token""].First<String>();
String identifier = parameters[""identifier""].First<String>();
if (this.DispatchPermissionsCheck(command, command.Name).Success == true) {
AccessTokenModel accountAccessToken = this.Groups.SelectMany(group => group.Accounts).Where(account => account.AccessTokens.ContainsKey(id)).SelectMany(account => account.AccessTokens).Where(accessToken => accessToken.Key == id).Select(accessToken => accessToken.Value).FirstOrDefault();
if (accountAccessToken != null) {
if (accountAccessToken.Authenticate(id, token, identifier)) {
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = String.Format(@""Successfully authenticated against account with username """"{0}""""."", accountAccessToken.Account.Username),
Scope = {
Accounts = new List<AccountModel>() {
accountAccessToken.Account
},
Groups = new List<GroupModel>() {
accountAccessToken.Account.Group
}
}
};
if (this.Shared.Events != null) {
this.Shared.Events.Log(GenericEvent.ConvertToGenericEvent(result, GenericEventType.SecurityAccountTokenAuthenticated));
}
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.Failed,
Message = ""Invalid id or token.""
};
}
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.Failed,
Message = ""Invalid id or token.""
};
}
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Authenticates an account against a access token,1
1578,"public ICommandResult SecuritySetPredefinedStreamPermissions(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
String groupName = parameters[""groupName""].First<String>();
if (this.DispatchPermissionsCheck(command, command.Name).Success == true) {
GroupModel group = this.Groups.FirstOrDefault(g => g.Name == groupName);
if (group != null) {
if (group.IsGuest == false) {
// A list of permissions to keep as ""1"", all others will be nulled out.
List<CommandType> permissions = new List<CommandType>() {
CommandType.PotatoPing,
CommandType.SecurityAccountAuthenticate,
CommandType.EventsEstablishJsonStream,
CommandType.PotatoQuery,
CommandType.ProtocolsFetchSupportedProtocols,
CommandType.PackagesFetchPackages,
CommandType.ConnectionQuery,
CommandType.NetworkProtocolQueryBans,
CommandType.NetworkProtocolQueryMapPool,
CommandType.NetworkProtocolQueryMaps,
CommandType.NetworkProtocolQueryPlayers,
CommandType.NetworkProtocolQuerySettings
};
foreach (var permission in group.Permissions) {
permission.Authority = permissions.Contains(permission.CommandType) ? 1 : (int?)null;
}
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = String.Format(@""Group with name """"{0}"""" set permissions to predefined stream setup."", group.Name)
};
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.InvalidParameter,
Message = ""Cannot add an account to a guest group""
};
}
}
else {
result = new CommandResult() {
Message = String.Format(@""Group with name """"{0}"""" does not exists."", groupName),
Success = false,
CommandResultType = CommandResultType.DoesNotExists
};
}
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Sets a group's permissions to a predefined list of permissions required for a simple streaming account.,1
1579,"public ICommandResult SecuritySetPredefinedAdministratorsPermissions(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
String groupName = parameters[""groupName""].First<String>();
if (this.DispatchPermissionsCheck(command, command.Name).Success == true) {
GroupModel group = this.Groups.FirstOrDefault(g => g.Name == groupName);
if (group != null) {
if (group.IsGuest == false) {
foreach (var permission in group.Permissions) {
permission.Authority = 2;
}
result = new CommandResult() {
Success = true,
CommandResultType = CommandResultType.Success,
Message = String.Format(@""Group with name """"{0}"""" set permissions to predefined administrator setup."", group.Name)
};
}
else {
result = new CommandResult() {
Success = false,
CommandResultType = CommandResultType.InvalidParameter,
Message = ""Cannot add an account to a guest group""
};
}
}
else {
result = new CommandResult() {
Message = String.Format(@""Group with name """"{0}"""" does not exists."", groupName),
Success = false,
CommandResultType = CommandResultType.DoesNotExists
};
}
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}",Sets a group's permissions to maximo for the true Administrator experience.,1
1580,public Action<ServiceController> DisposeServiceBegin { get; set; },Called before requesting the service domain dispose/shutdown.,1
1581,public Action<ServiceController> DisposeServiceEnd { get; set; },Called when the service domain has successfully been disposed/shutdown.,1
1582,"public ServiceController() {
AppDomain.MonitoringIsEnabled = true;
this.Observer = new ServiceObserver() {
Panic = this.Panic
};
this.Polling = new Timer(Polling_Tick, this, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
this.WriteConfig = new Timer(WriteConfig_Tick, this, TimeSpan.FromMinutes(10), TimeSpan.FromMinutes(10));
this.ServiceLoaderProxyType = typeof(ServiceLoaderProxy);
this.Process = new Process();
this.Arguments = new List<String>();
this.Settings = new ServiceSettings();
this.Packages = new ServicePackageManager() {
LocalRepository = PackageRepositoryFactory.Default.CreateRepository(Defines.PackagesDirectory.FullName)
};
}",Initiates the service controller with the default values,1
1583,"public void Polling_Tick(object state) {
if (this.Observer.Status == ServiceStatusType.Started && this.ServiceLoaderProxy != null) {
AutoResetEvent pollingTimeoutEvent = new AutoResetEvent(false);
ServiceMessage message = null;
Task.Factory.StartNew(() => {
try {
message = this.ServiceLoaderProxy.PollService();
}
catch (Exception e) {
ServiceControllerHelpers.LogUnhandledException(""ServiceController.Polling_Tick"", e);
message = null;
}
finally {
pollingTimeoutEvent.Set();
}
});
// If we don't get a response or the response wasn't processed properly.
if (pollingTimeoutEvent.WaitOne(this.Settings.ServicePollingTimeout) == false || this.SignalMessage(message) == false) {
this.Restart();
}
}
}",Fired every ten seconds to ensure the appdomain is still responding and does not have any additional messages for us to process.,1
1584,"public void WriteConfig_Tick(object state) {
if (this.Observer.Status == ServiceStatusType.Started && this.ServiceLoaderProxy != null) {
this.SignalMessage(new ServiceMessage() {
Name = ""write""
});
}
}",Fired every 10 minutes to write the current config to disk.,1
1585,"public void Restart() {
this.Stop();
this.Start();
}","Stops the service, updates it then starts it again.",1
1586,"public void WriteServiceConfig() {
if (this.ServiceLoaderProxy != null) {
AutoResetEvent writeServiceConfigWait = new AutoResetEvent(false);
this.OnWriteServiceConfigBegin();
Task.Factory.StartNew(() => {
try {
this.ServiceLoaderProxy.WriteConfig();
this.OnWriteServiceConfigEnd();
}
catch (Exception e) {
ServiceControllerHelpers.LogUnhandledException(""ServiceController.WriteServiceConfig"", e);
}
finally {
writeServiceConfigWait.Set();
}
});
if (writeServiceConfigWait.WaitOne(this.Settings.WriteServiceConfigTimeout) == false) {
ServiceControllerHelpers.LogUnhandledException(""ServiceController.WriteServiceConfig"", new Exception(""Timeout waiting for service to write config.""));
}
}
}",Writes the service config,1
1587,"public void DisposeService() {
if (this.ServiceLoaderProxy != null) {
AutoResetEvent disposeServerWait = new AutoResetEvent(false);
this.OnDisposeServiceBegin();
Task.Factory.StartNew(() => {
try {
this.ServiceLoaderProxy.Dispose();
this.OnDisposeServiceEnd();
}
catch (Exception e) {
ServiceControllerHelpers.LogUnhandledException(""ServiceController.DisposeService"", e);
}
finally {
disposeServerWait.Set();
}
});
if (disposeServerWait.WaitOne(this.Settings.DisposeServiceTimeout) == false) {
ServiceControllerHelpers.LogUnhandledException(""ServiceController.DisposeService"", new Exception(""Timeout waiting for service to dispose.""));
}
this.ServiceLoaderProxy = null;
}
}",Disposes the service,1
1588,"public void UnloadService() {
if (this.ServiceDomain != null) {
try {
this.OnUnloadServiceBegin();
AppDomain.Unload(this.ServiceDomain);
this.OnUnloadServiceEnd();
}
catch (Exception e) {
ServiceControllerHelpers.LogUnhandledException(""ServiceController.UnloadService.General"", e);
// The AppDomain is still running, though it may be in serious trouble or an unknown state.
// We terminate the current process instead of continuing, having reached a critical state.
this.Process.Kill();
}
finally {
this.ServiceDomain = null;
}
}
}","We have no time out for this process. If this fails then when we start it will behave strangely anyway. We'll be binding to identical ports, unable to perform updates etc. If unloading the domain fails then the process will be terminated.",1
1589,"public void Stop() {
if (this.ServiceLoaderProxy != null || this.ServiceDomain != null) {
this.Observer.Status = ServiceStatusType.Stopping;
this.WriteServiceConfig();
this.DisposeService();
this.UnloadService();
}
// After running through the above, provided both are set to null then shutting down was successful.
if (this.ServiceLoaderProxy == null && this.ServiceDomain == null) {
this.Observer.Status = ServiceStatusType.Stopped;
}
}","Saves the config, shuts down the instance and finally collapses the app domain.",1
1590,"private void OnStatistics() {
var handler = this.SignalStatistics;
if (handler != null) {
handler(this, this.ServiceDomain);
}
}",Called when a statistics signal comes through,1
1591,"private void OnHelp() {
var handler = this.SignalHelp;
if (handler != null) {
handler(this);
}
}",Called when a help signal comes through,1
1592,"private void OnWriteServiceConfigBegin() {
var handler = this.WriteServiceConfigBegin;
if (handler != null) {
handler(this);
}
}",Called just before requestin the service to write its configs,1
1593,"private void OnWriteServiceConfigEnd() {
var handler = this.WriteServiceConfigEnd;
if (handler != null) {
handler(this);
}
}",Called after the service config has been successfully written.,1
1594,"private void OnDisposeServiceBegin() {
var handler = this.DisposeServiceBegin;
if (handler != null) {
handler(this);
}
}",Called just before requesting the service to dispose and cleanup after itself,1
1595,"private void OnDisposeServiceEnd() {
var handler = this.DisposeServiceEnd;
if (handler != null) {
handler(this);
}
}",Called after the service has disposed itself.,1
1596,"private void OnUnloadServiceBegin() {
var handler = this.UnloadServiceBegin;
if (handler != null) {
handler(this);
}
}",Called before collapsing/unloading the service domain.,1
1597,"private void OnUnloadServiceEnd() {
var handler = this.UnloadServiceEnd;
if (handler != null) {
handler(this);
}
}",Called when the service domain has been successfully unloaded.,1
1598,"public void Start() {
if (this.Service != null) this.Service.Start();
}","A method to signify the instance should begin, loading it's configs and setting up connections & what not.",1
1599,"public void WriteConfig() {
if (this.Service != null) this.Service.WriteConfig();
}",Tells the instance the configs should now be written.,1
1600,"public void Dispose() {
if (this.Service != null) this.Service.Dispose();
}",Dispose of this instance. The AppDomain will be clonsed shortly afterwards.,1
1601,"public ServiceMessage PollService() {
ServiceMessage message = null;
if (this.Service != null) {
var polled = this.Service.PollService();
// Clone the message so we have no proxy to the other side.
message = new ServiceMessage() {
Name = polled.Name,
Arguments = polled.Arguments,
Stamp = polled.Stamp
};
}
return message;
}",Polls the service for a running status or other message.,1
1602,"public ServiceMessage ExecuteMessage(ServiceMessage message) {
ServiceMessage result = null;
if (this.Service != null) {
var polled = this.Service.ExecuteMessage(message);
// Clone the message so we have no proxy to the other side.
result = new ServiceMessage() {
Name = polled.Name,
Arguments = polled.Arguments,
Stamp = polled.Stamp
};
}
return result;
}",This will only ever handle very simple requests that require strings/integers for arguments,1
1603,"public ServiceMessage() {
this.Arguments = new Dictionary<String, String>();
this.Stamp = DateTime.Now;
}",Initializes the service message with the default values.,1
1604,"public ServiceObserver() {
this.Status = ServiceStatusType.Stopped;
this.PanicTask = new Timer(PanicTask_Tick, this, TimeSpan.FromMilliseconds(0), TimeSpan.FromMinutes(20));
}",Initializes the observer with the default values.,1
1605,"public ServicePackageManager() {
this.SourceRepositories = new ConcurrentDictionary<String, IPackageRepository>();
this.PackageManagerDispatch = new PackageManagerDispatch();
}",Initializes the service package manager with the default values.,1
1606,"protected void OnBeforeRepositoryInitialize() {
var handler = this.BeforeRepositoryInitialize;
if (handler != null) {
handler();
}
}","Called when the repository is initialized, just before",1
1607,"protected void OnBeforeSourcePackageFetch() {
var handler = this.BeforeSourcePackageFetch;
if (handler != null) {
handler();
}
}",Called before the source packages are fetched.,1
1608,"protected void OnBeforeLocalPackageFetch() {
var handler = this.BeforeLocalPackageFetch;
if (handler != null) {
handler();
}
}",Called before the source packages are fetched.,1
1609,"protected void OnRepositoryException(String hint, Exception e) {
var handler = this.RepositoryException;
if (handler != null) {
handler(hint, e);
}
}",Called when an exception occurs during a package operation,1
1610,"public ServiceSettings(IList<string> input) {
this.ServiceUpdateCore = true;
this.ServicePollingTimeout = Defines.DefaultServicePollingTimeout;
this.WriteServiceConfigTimeout = Defines.DefaultWriteServiceConfigTimeout;
this.DisposeServiceTimeout = Defines.DefaultDisposeServiceTimeout;
this.PackagesDefaultSourceRepositoryUri = Defines.PackagesDefaultSourceRepositoryUri;
this.ParseArguments(ArgumentHelper.ToArguments(input));
}",Initializes the settings with the default values and processes input as arguments,1
1611,"public Settings() {
this.Current = new SettingsData();
this.Minimum = new SettingsData();
this.Maximum = new SettingsData();
}",Initializes the various groups of settings,1
1612,"public SharedReferences() : base() {
this.Variables = SharedReferences._masterVariables;
this.Languages = SharedReferences._masterLanguages;
this.Security = SharedReferences._masterSecurity;
this.Events = SharedReferences._masterEvents;
}",Initializes the default references from the static controllers.,1
1613,"public override bool Connect() {
bool opened = true;
if (this.Connection == null || this.Connection.State == ConnectionState.Closed) {
if (this.Connection != null) {
this.Connection.Close();
this.Connection = null;
}
var dataSource = """";
if (this.Settings.Memory == true) {
dataSource = "":memory:"";
}
else if (this.Settings.Database != null) {
dataSource = this.Settings.Database + (this.Settings.Database.EndsWith("".sqlite"") == false ? "".sqlite"" : """");
}
SQLiteConnectionStringBuilder connectionBuilder = new SQLiteConnectionStringBuilder {
DataSource = dataSource,
Password = this.Settings.Password,
};
try {
this.Connection = new SQLiteConnection(connectionBuilder.ToString());
this.Connection.Open();
if (this.Connection.State != ConnectionState.Open) {
this.Connection.Close();
this.Connection = null;
}
}
catch {
opened = false;
}
}
return opened;
}",Opens the connection to the database.,1
1614,"public static List<String> Wordify(this String data) {
List<String> list = new List<String>();
String word = String.Empty;
int stack = 0;
bool escaped = false;
foreach (char input in data) {
if (input == ' ') {
if (stack == 0) {
list.Add(word);
word = String.Empty;
}
else {
word += ' ';
}
}
else if (input == 'n' && escaped == true) {
word += '\n';
escaped = false;
}
else if (input == 'r' && escaped == true) {
word += '\r';
escaped = false;
}
else if (input == 't' && escaped == true) {
word += '\t';
escaped = false;
}
else if (input == '""') {
if (escaped == false) {
if (stack == 0) {
stack++;
}
else {
stack--;
}
}
else {
word += '""';
}
}
else if (input == '\\') {
if (escaped == true) {
word += '\\';
escaped = false;
}
else {
escaped = true;
}
}
else {
word += input;
escaped = false;
}
}
list.Add(word);
return list;
}","Splits a string into words, preserving words inside quotes",1
1615,"public static List<String> WordWrap(this string text, int column) {
List<String> result = new List<String>(text.Split(' '));
for (int i = 0; i < result.Count - 1; i++) {
if (result[i].Length + result[i + 1].Length + 1 <= column) {
result[i] = String.Format(""{0} {1}"", result[i], result[i + 1]);
result.RemoveAt(i + 1);
i--;
}
}
return result;
}",Useful if you want to output a long string to the game and want all of the data outputed without losing any data. ]]>,1
1616,"public void TestRandomStringSuccess() {
List<string> generated = new List<string>();
for (var count = 0; count < 20; count++) {
generated.Add(Shared.Utils.StringExtensions.RandomString(30));
}
Assert.AreEqual(20, generated.Distinct().Count());
}",Tests calling random string with 20 calls won't produce a duplicate. If this simple test produces a collision then for our purposes,1
1617,"public void TestWordWrapSuccess() {
List<string> wrapped = ""Die Brsel eines Ksekuchen verzcken mich."".WordWrap(30);
Assert.AreEqual(2, wrapped.Count);
Assert.AreEqual(""Die Brsel eines Ksekuchen"", wrapped.First());
Assert.AreEqual(""verzcken mich."", wrapped.Last());
}",Tests that a string will be split into multiple strings for wrapping,1
1618,"public void TestRemoveDiacriticsSuccess() {
String removed = ""Die Brsel eines Ksekuchen verzcken mich."".RemoveDiacritics();
Assert.AreEqual(""Die Brosel eines Kasekuchen verzucken mich."", removed);
}",Tests that a string with diacritics is replaced.,1
1619,"public void TestRemoveLeetSpeekSuccess() {
String removed = ""P]-[0gu3"".RemoveLeetSpeek();
Assert.AreEqual(""PHOguE"", removed);
}",Tests that a poxy leet speek text will be converted to something some-what legible.,1
1620,"public void TestStripSuccess() {
String removed = ""P]-[0gu3 Brsel"".Strip();
Assert.AreEqual(""PHOguE Brosel"", removed);
}",Tests that a string with leet speek and diacritics will be stripped to a plain ASCII string,1
1621,"public void TestSanitizeDirectoryForwardSlashes() {
String sanitized = @""c:/projects/something/test/"".SanitizeDirectory();
Assert.AreEqual(""c-projects-something-test"", sanitized);
}",Tests a directory with forward slashes will be sanitized.,1
1622,"public void TestSanitizeDirectoryBackSlashes() {
String sanitized = @""c:\projects\something\test\"".SanitizeDirectory();
Assert.AreEqual(""c-projects-something-test"", sanitized);
}",Tests a directory/file name with back slashes will be sanitized.,1
1623,"public void TestUrlSlug() {
String slugged = ""http://forum.myrcon.com"".Slug();
Assert.AreEqual(""forum-myrcon-com"", slugged);
}","Tests a url is slugged, but this is a little off at the moment. I would expect ""forum-myrcon-com"" instead of the current result.",1
1624,"public override void Connect() {
if (this.MarkManager.RemoveExpiredMarks().IsValidMarkWindow() == true) {
this.MarkManager.Mark();
if (this.Options.Hostname != null && this.Options.Port != 0) {
try {
this.ReceivedBuffer = new byte[this.BufferSize];
this.PacketStream = new PacketStream();
this.SequenceNumber = 0;
this.ConnectionState = ConnectionState.ConnectionConnecting;
this.Client = new System.Net.Sockets.TcpClient {
NoDelay = true
};
this.Client.BeginConnect(this.Options.Hostname, this.Options.Port, this.ConnectedCallback, this);
}
catch (SocketException se) {
this.Shutdown(se);
}
catch (Exception e) {
this.Shutdown(e);
}
}
}
}","Attempts a connection to a server, provided we are not currently backing off from an offline server.",1
1625,"public override void Shutdown() {
if (this.Client != null) {
this.ShutdownConnection();
}
}","Shuts down the connection, closing streams etc.",1
1626,"public void TestBasicPacketRecievedByListener() {
MockTcpListener listener;
MockTcpClient client;
AutoResetEvent packetWait = new AutoResetEvent(false);
this.CreateAndConnect(35000, out listener, out client);
listener.PacketReceived += (sender, request) => { packetWait.Set(); };
client.Send(new MockPacket() {
Packet = {
RequestId = 1,
Origin = PacketOrigin.Client,
Type = PacketType.Request
},
Text = ""TestBasicPacketSend""
});
Assert.IsTrue(packetWait.WaitOne(1000));
}",Simple test to see if our listener ever recieves a packet.,1
1627,"public void TestBasicPacketDeserializedByListener() {
MockTcpListener listener;
MockTcpClient client;
MockPacket packet = null;
AutoResetEvent packetWait = new AutoResetEvent(false);
this.CreateAndConnect(35001, out listener, out client);
listener.PacketReceived += (sender, request) => {
packet = request;
packetWait.Set();
};
client.Send(new MockPacket() {
Packet = {
RequestId = 1,
Origin = PacketOrigin.Client,
Type = PacketType.Request
},
Text = ""TestBasicPacketSend""
});
Assert.IsTrue(packetWait.WaitOne(1000));
Assert.AreEqual(""Client Request 1 TestBasicPacketSend"", packet.Packet.DebugText);
}",Tests a packet is deserialized by the listener correctly.,1
1628,"public void TestBasicPacketListenerReply() {
MockTcpListener listener;
MockTcpClient client;
MockPacket packet = null;
AutoResetEvent packetWait = new AutoResetEvent(false);
this.CreateAndConnect(35002, out listener, out client);
listener.PacketReceived += (sender, request) => {
request.Packet.Type = PacketType.Response;
request.Text = ""OK"";
sender.Send(request);
};
client.PacketReceived += (sender, response) => {
packet = response as MockPacket;
packetWait.Set();
};
client.Send(new MockPacket() {
Packet = {
RequestId = 1,
Origin = PacketOrigin.Client,
Type = PacketType.Request
},
Text = ""TestBasicPacketSend""
});
Assert.IsTrue(packetWait.WaitOne(1000));
Assert.AreEqual(""Client Response 1 OK"", packet.Packet.DebugText);
}",Tests a packet can be manipulated by the mock tcp listener and returned & deserialized by the client.,1
1629,"public void TestAppendedToRoot() {
IConfig config = new Config().Create<MockSimpleConcrete>();
config.Append(new MockSimpleConcrete() {
Name = ""Phogue"",
Age = 100
});
Assert.AreEqual(""Phogue"", config.Root.First[""Name""].Value<String>());
Assert.AreEqual(100, config.Root.First[""Age""].Value<int>());
}",Tests data can be appended to the root,1
1630,"public void TestNullException() {
new Config().Append<MockSimpleConcrete>(null);
}",Tests an argument null exception is raised if null is passed into union.,1
1631,"public void TestIsFalsey() {
Assert.IsTrue(ArgumentHelper.IsFalsey(""false""));
Assert.IsTrue(ArgumentHelper.IsFalsey(""False""));
Assert.IsTrue(ArgumentHelper.IsFalsey(""0""));
Assert.IsFalse(ArgumentHelper.IsFalsey(""1""));
Assert.IsFalse(ArgumentHelper.IsFalsey(""True""));
Assert.IsFalse(ArgumentHelper.IsFalsey(""Literally anything else""));
}",Tests the four falsey strings will equate to false.,1
1632,"public void TestNumericSuccess() {
Assert.AreEqual(50.01F, ArgumentHelper.ParseNumeric(""50.01""));
}",Tests that a value is numeric and is returned. Ignored for now since no localization makes it fail on different systems around the world.,1
1633,"public void TestNumericFailureReturnDefault() {
Assert.AreEqual(49.99F, ArgumentHelper.ParseNumeric(""gg"", 49.99F));
}",Tests that if the input string isn't numeric then the default value will be returned.,1
1634,"public void TestToArgumentsEmptyList() {
var arguments = ArgumentHelper.ToArguments(new List<String>());
Assert.IsEmpty(arguments);
}",Tests an empty list will produce an empty arguments dictionary,1
1635,"public void TestToArgumentsEmptySingleValueInList() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""""
});
Assert.IsEmpty(arguments);
}",Tests an empty value in the string list will result in an empty arguments dictionary,1
1636,"public void TestToArgumentsEmptyKeyAtEnd() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-key"",
""value"",
""""
});
Assert.AreEqual(1, arguments.Count);
Assert.AreEqual(""value"", arguments[""key""]);
}",Tests an empty lone value acting as a key will be ignored from the end the list,1
1637,"public void TestToArgumentsEmptyKeyAtStart() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
"""",
""-key"",
""value""
});
Assert.AreEqual(1, arguments.Count);
Assert.AreEqual(""value"", arguments[""key""]);
}",Tests an empty value at the start of the string list will be ignored,1
1638,"public void TestToArgumentsEmptyKeySandwich() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-key1"",
""value1"",
"""",
""-key2"",
""value2"",
});
Assert.AreEqual(2, arguments.Count);
Assert.AreEqual(""value1"", arguments[""key1""]);
Assert.AreEqual(""value2"", arguments[""key2""]);
}",Tests an empty lone value acting as a key between two defined key-value's will be ignored,1
1639,"public void TestToArgumentsImpliedFlagEnabled() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-key""
});
Assert.IsNotEmpty(arguments);
Assert.AreEqual(""1"", arguments[""key""]);
}","Tests passing through a -key without a value will give it a value of ""1"" for flags implied as being ""on""",1
1640,"public void TestToArgumentsImpliedFlagEnabledUpdate() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-key"",
""value"",
""-key""
});
Assert.IsNotEmpty(arguments);
Assert.AreEqual(""1"", arguments[""key""]);
}","Tests passing through a -key without a value will give it a value of ""1"" for flags implied as being ""on""",1
1641,"public void TestToArgumentsExplicitValue() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-key"",
""value""
});
Assert.IsNotEmpty(arguments);
Assert.AreEqual(""value"", arguments[""key""]);
}",Tests passing through a -key with a value will set that key to value.,1
1642,"public void TestToArgumentsExplicitValueUpdate() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-key"",
""value1"",
""-key"",
""value2""
});
Assert.IsNotEmpty(arguments);
Assert.AreEqual(""value2"", arguments[""key""]);
}","Tests passing through a -key with a value will set that key to value, updating existing values if they already exist in the arguments",1
1643,"public void TestToArgumentsExplicitValueUpdateCaseInsensitive() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-key"",
""value1"",
""-Key"",
""value2""
});
Assert.IsNotEmpty(arguments);
Assert.AreEqual(""value2"", arguments[""key""]);
}","Tests passing through a -key with a value will set that key to value, updating existing values if they already exist in the arguments even if both keys were passed through with different case",1
1644,"public void TestToArgumentsMultipleValuesGeneratedKey() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-key1"",
""value1"",
""generated0"",
""generated1""
});
Assert.IsNotEmpty(arguments);
Assert.AreEqual(""value1"", arguments[""key1""]);
Assert.AreEqual(""generated0"", arguments[""0""]);
Assert.AreEqual(""generated1"", arguments[""1""]);
}","This is just a shorthand way of supplying arguments in an order, not named. We always treat the arguments as named arguments though.",1
1645,"public void TestToArgumentsMultipleValuesGeneratedKeySuffixedWithSetKey() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-key1"",
""value1"",
""generated0"",
""-key2"",
""value2""
});
Assert.IsNotEmpty(arguments);
Assert.AreEqual(""value1"", arguments[""key1""]);
Assert.AreEqual(""generated0"", arguments[""0""]);
Assert.AreEqual(""value2"", arguments[""key2""]);
}",Tests that a value requiring a generated key in the middle will,1
1646,"public void TestToArgumentsMultipleValuesGeneratedKeyPreviouslySet() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-0"",
""value0"",
""generated0""
});
Assert.IsNotEmpty(arguments);
Assert.AreEqual(""value0"", arguments[""0""]);
Assert.AreEqual(""generated0"", arguments[""1""]);
}","Tests that a named key ""0"" will maintain it's value when a generated key that would usually occupy ""0"" requires a key.",1
1647,"public void TestToArgumentsAlphaKeysValuesOrderingMaintained() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-a"",
""A"",
""-b"",
""B"",
""-c"",
""C""
});
List<String> values = new List<String>(arguments.Values);
Assert.AreEqual(""A"", values[0]);
Assert.AreEqual(""B"", values[1]);
Assert.AreEqual(""C"", values[2]);
}",This test ensures that ordered input will result in ordered output with dictionary values.,1
1648,"public void TestToArgumentsNumericKeysValuesOrderingMaintained() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""-1"",
""A"",
""-2"",
""B"",
""-3"",
""C""
});
List<String> values = new List<String>(arguments.Values);
Assert.AreEqual(""A"", values[0]);
Assert.AreEqual(""B"", values[1]);
Assert.AreEqual(""C"", values[2]);
}",This test ensures that ordered input will result in ordered output with dictionary values.,1
1649,"public void TestScrubAlphaNumericKeysUnchangedWhenOnlyNumeric() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""A"",
""B"",
""C""
});
arguments = ArgumentHelper.ScrubAlphaNumericKeys(arguments);
List<String> values = new List<String>(arguments.Values);
Assert.AreEqual(""A"", values[0]);
Assert.AreEqual(""B"", values[1]);
Assert.AreEqual(""C"", values[2]);
}","Tests that if all keys are numeric, then the arguments remain unchanged.",1
1650,"public void TestScrubAlphaNumericKeysRemovedNonNumericKeys() {
var arguments = ArgumentHelper.ToArguments(new List<String>() {
""--Password"",
""mySecretPassword"",
""A"",
""B"",
""C""
});
arguments = ArgumentHelper.ScrubAlphaNumericKeys(arguments);
List<String> values = new List<String>(arguments.Values);
Assert.AreEqual(""A"", values[0]);
Assert.AreEqual(""B"", values[1]);
Assert.AreEqual(""C"", values[2]);
}","Tests that if all keys are numeric, then the arguments remain unchanged.",1
1651,"public void TestIsKnownInPending() {
var state = new AsynchronousCommandStateModel();
var commandModel = new AsynchronousCommandModel() {
Command = new Command()
};
state.PendingCommandsQueue.Enqueue(commandModel);
Assert.IsTrue(state.IsKnown(commandModel.Command.CommandGuid));
}",Tests that if the command has not been picked up by the dispatch thread it will be known to the state model.,1
1652,"public void TestIsKnownInExecuted() {
var state = new AsynchronousCommandStateModel();
var commandModel = new AsynchronousCommandModel() {
Command = new Command()
};
state.ExecutedCommandsPool.TryAdd(commandModel.Command.CommandGuid, commandModel);
Assert.IsTrue(state.IsKnown(commandModel.Command.CommandGuid));
}",Tests if the command has been picked up by the dispatch thread and then executed it will be known to the state model,1
1653,"public void TestIsKnownInPendingAndExecuted() {
var state = new AsynchronousCommandStateModel();
var commandModel = new AsynchronousCommandModel() {
Command = new Command()
};
state.PendingCommandsQueue.Enqueue(commandModel);
state.ExecutedCommandsPool.TryAdd(commandModel.Command.CommandGuid, commandModel);
Assert.IsTrue(state.IsKnown(commandModel.Command.CommandGuid));
}","This state should be impossible to reach with normal operation, but the model supports this state so we test for it.",1
1654,"public void TestIsNotKnownInAny() {
var state = new AsynchronousCommandStateModel();
var commandModel = new AsynchronousCommandModel() {
Command = new Command()
};
Assert.IsFalse(state.IsKnown(commandModel.Command.CommandGuid));
}",Tests that a command will be unknown if it is not in any list.,1
1655,"public void TestAsyncBubbleCommand() {
String message = """";
AutoResetEvent resultWait = new AutoResetEvent(false);
MockAsynchronousCoreController mockController = (MockAsynchronousCoreController)new MockAsynchronousCoreController() {
BubbleObjects = new List<ICoreController>() {
new MockSynchronousCoreController().Execute()
}
}.Execute();
mockController.BeginBubble(
new Command() {
Name = ""AppendMessage"",
Origin = CommandOrigin.Local,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""TestAsyncBubbleCommand""
}
}
}
}
},
result => {
message = result.Message;
resultWait.Set();
}
);
Assert.IsTrue(resultWait.WaitOne(1000));
Assert.AreEqual(""SetMessage: TestAsyncBubbleCommand"", message);
}",Tests that bubbling a command with BeginBubble will in fact bubble the command and return a result.,1
1656,"public void TestAsyncTunnelCommand() {
String message = """";
AutoResetEvent resultWait = new AutoResetEvent(false);
MockAsynchronousCoreController mockController = (MockAsynchronousCoreController)new MockAsynchronousCoreController() {
TunnelObjects = new List<ICoreController>() {
new MockSynchronousCoreController().Execute()
}
}.Execute();
mockController.BeginTunnel(
new Command() {
Name = ""AppendMessage"",
Origin = CommandOrigin.Local,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""TestAsyncTunnelCommand""
}
}
}
}
},
result => {
message = result.Message;
resultWait.Set();
}
);
Assert.IsTrue(resultWait.WaitOne(1000));
Assert.AreEqual(""SetMessage: TestAsyncTunnelCommand"", message);
}",Tests that tunneling a command with BeginBubble will in fact tunnel the command and return a result.,1
1657,"public void TestSynchronousBubbleCommand() {
MockAsynchronousCoreController mockController = (MockAsynchronousCoreController)new MockAsynchronousCoreController() {
BubbleObjects = new List<ICoreController>() {
new MockSynchronousCoreController().Execute()
}
}.Execute();
ICommandResult result = mockController.Bubble(
new Command() {
Name = ""AppendMessage"",
Origin = CommandOrigin.Local,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""TestAsyncBubbleCommand""
}
}
}
}
}
);
Assert.AreEqual(""SetMessage: TestAsyncBubbleCommand"", result.Message);
}","Tests the Tunnel command will still block, waiting for the thread to return.",1
1658,"public void TestSynchronousTunnelCommand() {
MockAsynchronousCoreController mockController = (MockAsynchronousCoreController)new MockAsynchronousCoreController() {
TunnelObjects = new List<ICoreController>() {
new MockSynchronousCoreController().Execute()
}
}.Execute();
ICommandResult result = mockController.Tunnel(
new Command() {
Name = ""AppendMessage"",
Origin = CommandOrigin.Local,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""TestAsyncTunnelCommand""
}
}
}
}
}
);
Assert.AreEqual(""SetMessage: TestAsyncTunnelCommand"", result.Message);
}","Tests the Tunnel command will still block, waiting for the thread to return.",1
1659,"public void TestChainedAsyncBubbleCommand() {
String message = """";
AutoResetEvent resultWait = new AutoResetEvent(false);
MockAsynchronousCoreController mockController = (MockAsynchronousCoreController)new MockAsynchronousCoreController() {
BubbleObjects = new List<ICoreController>() {
new MockAsynchronousCoreController() {
BubbleObjects = new List<ICoreController>() {
new MockSynchronousCoreController().Execute()
}
}
}
}.Execute();
mockController.BeginBubble(
new Command() {
Name = ""AppendMessage"",
Origin = CommandOrigin.Local,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""TestAsyncBubbleCommand""
}
}
}
}
},
result => {
message = result.Message;
resultWait.Set();
}
);
Assert.IsTrue(resultWait.WaitOne(1000));
Assert.AreEqual(""SetMessage: TestAsyncBubbleCommand"", message);
}",Tests that bubbling a command with BeginBubble will in fact bubble the command and return a result. This test has the additional asynchronous controller between them.,1
1660,"public void TestChainedAsyncTunnelCommand() {
String message = """";
AutoResetEvent resultWait = new AutoResetEvent(false);
MockAsynchronousCoreController mockController = (MockAsynchronousCoreController)new MockAsynchronousCoreController() {
TunnelObjects = new List<ICoreController>() {
new MockAsynchronousCoreController() {
TunnelObjects = new List<ICoreController>() {
new MockSynchronousCoreController().Execute()
}
}
}
}.Execute();
mockController.BeginTunnel(
new Command() {
Name = ""AppendMessage"",
Origin = CommandOrigin.Local,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""TestAsyncTunnelCommand""
}
}
}
}
},
result => {
message = result.Message;
resultWait.Set();
}
);
Assert.IsTrue(resultWait.WaitOne(1000));
Assert.AreEqual(""SetMessage: TestAsyncTunnelCommand"", message);
}",Tests that tunneling a command with BeginBubble will in fact tunnel the command and return a result.This test has the additional asynchronous controller between them.,1
1661,"public void TestChainedSynchronousBubbleCommand() {
MockAsynchronousCoreController mockController = (MockAsynchronousCoreController)new MockAsynchronousCoreController() {
BubbleObjects = new List<ICoreController>() {
new MockAsynchronousCoreController() {
BubbleObjects = new List<ICoreController>() {
new MockSynchronousCoreController().Execute()
}
}
}
}.Execute();
ICommandResult result = mockController.Bubble(
new Command() {
Name = ""AppendMessage"",
Origin = CommandOrigin.Local,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""TestAsyncBubbleCommand""
}
}
}
}
}
);
Assert.AreEqual(""SetMessage: TestAsyncBubbleCommand"", result.Message);
}","Tests the Tunnel command will still block, waiting for the thread to return. This test has the additional asynchronous controller between them.",1
1662,"public void TestChainedSynchronousTunnelCommand() {
MockAsynchronousCoreController mockController = (MockAsynchronousCoreController)new MockAsynchronousCoreController() {
TunnelObjects = new List<ICoreController>() {
new MockAsynchronousCoreController() {
TunnelObjects = new List<ICoreController>() {
new MockSynchronousCoreController().Execute()
}
}
}
}.Execute();
ICommandResult result = mockController.Tunnel(
new Command() {
Name = ""AppendMessage"",
Origin = CommandOrigin.Local,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""TestAsyncTunnelCommand""
}
}
}
}
}
);
Assert.AreEqual(""SetMessage: TestAsyncTunnelCommand"", result.Message);
}","Tests the Tunnel command will still block, waiting for the thread to return. This test has the additional asynchronous controller between them.",1
1663,"public void TestAsyncDispose() {
AutoResetEvent disposeWait = new AutoResetEvent(false);
MockAsynchronousCoreController mockController = (MockAsynchronousCoreController)new MockAsynchronousCoreController() {
TunnelObjects = new List<ICoreController>() {
new MockSynchronousCoreController().Execute()
},
ExecuteQueuedCommandsFinished = () => disposeWait.Set()
}.Execute();
mockController.Dispose();
Assert.IsTrue(disposeWait.WaitOne(10000));
Assert.IsNull(mockController.AsyncStateModel);
}",Tests disposing the async controller will cancel out of the dispatch controller.,1
1664,"public void TestSuccessfullyAuthenticate() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
Assert.IsTrue(this.Valid.Authenticate(this.Valid.Id, token, TestAuthenticate.Identifer));
}",Tests all valid data will result in a successful authentication.,1
1665,"public void TestSuccessfullyAuthenticationTouchesTime() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
this.Valid.LastTouched = DateTime.Now.AddDays(-1);
this.Valid.Authenticate(this.Valid.Id, token, TestAuthenticate.Identifer);
Assert.GreaterOrEqual(this.Valid.LastTouched, DateTime.Now.AddMinutes(-1));
}",Tests all valid data will result in a successful authentication will set the LastTouched to now.,1
1666,"public void TestAlteringPasswordHashNegatesAccessToken() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
this.Valid.Account.PasswordHash = ""Reset My Password"";
Assert.IsFalse(this.Valid.Authenticate(this.Valid.Id, token, TestAuthenticate.Identifer));
}",Tests that if the account holders password hash is modified at all (even if the underlying password is the same) then the access token is essentially revoked.,1
1667,"public void TestDifferentIdentifierNegatesAccessToken() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
Assert.IsFalse(this.Valid.Authenticate(this.Valid.Id, token, ""different""));
}",Tests that a different identifier will negate the access token,1
1668,"public void TestMissmatchIdReturnsFalse() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
Assert.IsFalse(this.Valid.Authenticate(Guid.NewGuid(), token, TestAuthenticate.Identifer));
}",Tests that a different guid will fail authentication.,1
1669,"public void TestExpiredAccessTokenDenied() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
this.Valid.LastTouched = DateTime.Now.AddDays(-3);
Assert.IsFalse(this.Valid.Authenticate(this.Valid.Id, token, TestAuthenticate.Identifer));
}",Tests that an expired access token is not valid (2 days max),1
1670,"public void TestNulledTokenReturnsFalse() {
this.Valid.Generate(TestAuthenticate.Identifer);
Assert.IsFalse(this.Valid.Authenticate(Guid.NewGuid(), null, TestAuthenticate.Identifer));
}",Tests that passing in a null token results in a failed authentication,1
1671,"public void TestEmptyTokenReturnsFalse() {
this.Valid.Generate(TestAuthenticate.Identifer);
Assert.IsFalse(this.Valid.Authenticate(Guid.NewGuid(), """", TestAuthenticate.Identifer));
}",Tests that passing in an empty token results in a failed authentication,1
1672,"public void TestNulledIdentiferReturnsFalse() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
Assert.IsFalse(this.Valid.Authenticate(Guid.NewGuid(), token, null));
}",Tests that passing in a null identifer results in a failed authentication,1
1673,"public void TestEmptyIdentiferReturnsFalse() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
Assert.IsFalse(this.Valid.Authenticate(Guid.NewGuid(), token, """"));
}",Tests that passing in an empty identifer results in a failed authentication,1
1674,"public void TestNulledTokenHashReturnsFalse() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
this.Valid.TokenHash = null;
Assert.IsFalse(this.Valid.Authenticate(Guid.NewGuid(), token, TestAuthenticate.Identifer));
}",Tests that passing in a null token hash results in a failed authentication,1
1675,"public void TestEmptyTokenHashReturnsFalse() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
this.Valid.TokenHash = """";
Assert.IsFalse(this.Valid.Authenticate(Guid.NewGuid(), token, TestAuthenticate.Identifer));
}",Tests that passing in an empty token hash results in a failed authentication,1
1676,"public void TestNulledAccountReturnsFalse() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
this.Valid.Account = null;
Assert.IsFalse(this.Valid.Authenticate(Guid.NewGuid(), token, TestAuthenticate.Identifer));
}",Tests that passing in a null account results in a failed authentication,1
1677,"public void TestNulledPasswordHashReturnsFalse() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
this.Valid.Account.PasswordHash = null;
Assert.IsFalse(this.Valid.Authenticate(Guid.NewGuid(), token, TestAuthenticate.Identifer));
}",Tests that passing in a null password hash results in a failed authentication,1
1678,"public void TestEmptyPasswordHashReturnsFalse() {
var token = this.Valid.Generate(TestAuthenticate.Identifer);
this.Valid.Account.PasswordHash = """";
Assert.IsFalse(this.Valid.Authenticate(Guid.NewGuid(), token, TestAuthenticate.Identifer));
}",Tests that passing in an empty password hash results in a failed authentication,1
1679,"public void TestInsufficentWordsResultsInEmptyEvent() {
var called = false;
var protocol = new SecondGame();
protocol.ProtocolEvent += (protocol1, args) => { called = true; };
var request = new FrostbitePacket();
var response = new FrostbitePacket();
protocol.BanListListDispatchHandler(request, response);
Assert.IsFalse(called);
}",Tests that passing through no words results in an empty response not an exception.,1
1680,"public void TestBanlistWithIpBanPassedAndIgnored() {
var protocol = new SecondGame();
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""banList.list""
}
}
};
var response = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""OK"",
""name"",
""Phil_k"",
""perm"",
""0"",
""0"",
""Geoff"",
""ip"",
""127.0.0.1"",
""perm"",
""0"",
""0"",
""Geoff"",
""guid"",
""EA_12345678901234567890123456789012"",
""perm"",
""0"",
""0"",
""Geoff""
}
}
};
protocol.BanListListDispatchHandler(request, response);
Assert.AreEqual(2, protocol.State.Bans.Count);
}",Tests that passing through no words results in an empty response not an exception.,1
1681,"public void TestParseBanListItemName() {
var bans = SecondFrostbiteBanList.Parse(new List<String>() {
""name"",
""Phil_k"",
""perm"",
""0"",
""0"",
""Geoff"",
""ip"",
""127.0.0.1"",
""perm"",
""0"",
""0"",
""Geoff"",
""guid"",
""EA_12345678901234567890123456789012"",
""perm"",
""0"",
""0"",
""Geoff""
});
Assert.AreEqual(""Phil_k"", bans.First().Scope.Players.First().Name);
Assert.AreEqual(""EA_12345678901234567890123456789012"", bans.Last().Scope.Players.First().Uid);
}",Tests parsing,1
1682,"public void TestSuccessProtocolEventBubbledThrough() {
bool called = false;
this.Controller.Bubble = new SandboxProtocolCallbackProxy() {
ProtocolEvent = (args) => { called = true; }
};
((MockIntegrationTestProtocol)this.Controller.SandboxedProtocol).MockProtocolEvent(null);
Assert.IsTrue(called);
}","Tests that protocol events are passed through, provided the bubble attribute is set and has a delegate for the protocol event.",1
1683,"public void TestSuccessClientEventBubbledThrough() {
bool called = false;
this.Controller.Bubble = new SandboxProtocolCallbackProxy() {
ClientEvent = (args) => { called = true; }
};
((MockIntegrationTestProtocol)this.Controller.SandboxedProtocol).MockClientEvent(null);
Assert.IsTrue(called);
}","Tests that client events are passed through, provided the bubble attribute is set and has a delegate for the client event.",1
1684,"public void TestRepositoryCacheBuilt() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2""
}
});
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""2.0.0"",
Tags = ""Procon Potato Tag2"",
IsLatestVersion = true
}
}));
PackagesController packages = new PackagesController() {
LocalRepository = localRepository,
Cache = cache
};
packages.Poke();
Assert.IsNotNull(packages.Cache.Repositories.First(repository => repository.Uri == ""localhost""));
Assert.AreEqual(""A"", packages.Cache.Repositories.First(repository => repository.Uri == ""localhost"").Packages.First().Id);
Assert.AreEqual(PackageState.UpdateAvailable, packages.Cache.Repositories.First(repository => repository.Uri == ""localhost"").Packages.First().State);
}",Tests building the cache will be completed successfully,1
1685,"public void TestRepositoryCacheBuiltEventLogged() {
EventsController events = new EventsController();
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2""
}
});
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""2.0.0"",
Tags = ""Procon Potato Tag2"",
IsLatestVersion = true
}
}));
PackagesController packages = new PackagesController() {
LocalRepository = localRepository,
Cache = cache
};
packages.Shared.Events = events;
packages.Poke();
Assert.IsNotEmpty(events.LoggedEvents);
Assert.AreEqual(""PackagesCacheRebuilt"", events.LoggedEvents.First().Name);
Assert.AreEqual(""A"", events.LoggedEvents.First().Now.Repositories.First(repository => repository.Uri == ""localhost"").Packages.First().Id);
Assert.AreEqual(PackageState.UpdateAvailable, events.LoggedEvents.First().Now.Repositories.First(repository => repository.Uri == ""localhost"").Packages.First().State);
}",Tests that building the cache will log an event with the cached repository details.,1
1686,"public void TestGenerate() {
CertificateModel model = new CertificateModel();
// Delete the certificate if it exists.
Defines.CertificatesDirectoryCommandServerPfx.Delete();
// Create a new certificate
model.Generate();
// Certificate exists
Defines.CertificatesDirectoryCommandServerPfx.Refresh();
Assert.IsTrue(Defines.CertificatesDirectoryCommandServerPfx.Exists);
// Loads the certificates
var loadedCertificate = new X509Certificate2(Defines.CertificatesDirectoryCommandServerPfx.FullName, model.Password);
// Certificate can be loaded.
Assert.IsNotNull(loadedCertificate);
Assert.IsNotNull(loadedCertificate.PrivateKey);
}",Tests a certificate will be generated and can be read by .NET,1
1687,"public void TestDefaultSerialization() {
var original = new ClientEventArgs();
var serialized = JsonSerialization.Minimal.Serialize(original);
var deseralized = JsonSerialization.Minimal.Deserialize<ClientEventArgs>(serialized);
Assert.IsNotNull(deseralized.Then);
Assert.IsNotNull(deseralized.Now);
Assert.IsNotNull(deseralized.Stamp);
Assert.AreEqual(ConnectionState.ConnectionDisconnected, deseralized.ConnectionState);
Assert.AreEqual(ClientEventType.None, deseralized.EventType);
}",Tests a default serialization is successful,1
1688,"public void TestSingleDepthPopulationSerialization() {
var original = new ClientEventArgs() {
ConnectionState = ConnectionState.ConnectionLoggedIn,
EventType = ClientEventType.ClientConnectionStateChange,
Now = {
Actions = new List<INetworkAction>() {
new NetworkAction() {
Uid = Guid.Empty
}
},
Exceptions = new List<String>() {
""""
},
Packets = new List<IPacket>() {
new Packet() {
Stamp = new DateTime(2000, 10, 10, 10, 10, 10)
}
}
},
Then = {
Actions = new List<INetworkAction>() {
new NetworkAction() {
Uid = Guid.Empty
}
},
Exceptions = new List<String>() {
""""
},
Packets = new List<IPacket>() {
new Packet() {
Stamp = new DateTime(2000, 10, 10, 10, 10, 10)
}
}
}
};
var serialized = JsonSerialization.Minimal.Serialize(original);
var deseralized = JsonSerialization.Minimal.Deserialize<ClientEventArgs>(serialized);
Assert.IsNotNull(deseralized.Then);
Assert.IsNotNull(deseralized.Now);
Assert.IsNotNull(deseralized.Stamp);
Assert.AreEqual(ConnectionState.ConnectionLoggedIn, deseralized.ConnectionState);
Assert.AreEqual(ClientEventType.ClientConnectionStateChange, deseralized.EventType);
Assert.IsNotEmpty(deseralized.Then.Exceptions);
Assert.IsNotEmpty(deseralized.Then.Packets);
Assert.IsNotEmpty(deseralized.Then.Actions);
Assert.IsNotEmpty(deseralized.Now.Exceptions);
Assert.IsNotEmpty(deseralized.Now.Packets);
Assert.IsNotEmpty(deseralized.Now.Actions);
}",Tests a populated object with attributes immediately attached to the type will serialize successfully.,1
1689,"public void TestDefaultSerialization() {
var original = new ClientEventData();
var serialized = JsonSerialization.Minimal.Serialize(original);
var deseralized = JsonSerialization.Minimal.Deserialize<ClientEventData>(serialized);
Assert.IsNull(deseralized.Exceptions);
Assert.IsNull(deseralized.Packets);
Assert.IsNull(deseralized.Actions);
}",Tests a default serialization is successful,1
1690,"public void TestSingleDepthPopulationSerialization() {
var original = new ClientEventData() {
Actions = new List<INetworkAction>() {
new NetworkAction() {
Uid = Guid.Empty
}
},
Exceptions = new List<String>() {
""""
},
Packets = new List<IPacket>() {
new Packet() {
Stamp = new DateTime(2000, 10, 10, 10, 10, 10)
}
}
};
var serialized = JsonSerialization.Minimal.Serialize(original);
var deseralized = JsonSerialization.Minimal.Deserialize<ClientEventData>(serialized);
Assert.IsNotEmpty(deseralized.Exceptions);
Assert.IsNotEmpty(deseralized.Packets);
Assert.IsNotEmpty(deseralized.Actions);
}",Tests a populated object with attributes immediately attached to the type will serialize successfully.,1
1691,"public void TestCommandAttributeNameAliasFromCommandType() {
var command = new CommandDispatch() {
CommandType = CommandType.PotatoAddConnection
};
Assert.AreEqual(""PotatoAddConnection"", command.Name);
Assert.AreEqual(CommandType.PotatoAddConnection, command.CommandType);
}",Tests that a command type will pass on the value as a string to the Name attribute.,1
1692,"public void TestCommandAttributeParseInvalidCommandType() {
ICommandDispatch command = new CommandDispatch().ParseCommandType(""CustomCommand"");
Assert.AreEqual(""CustomCommand"", command.Name);
Assert.AreEqual(CommandType.None, command.CommandType);
}",Tests that if a command type is not valid during parsing the Name will at least be populated (good thing),1
1693,"public void TestCommandAttributeParseValidCommandType() {
ICommandDispatch command = new CommandDispatch().ParseCommandType(""PotatoAddConnection"");
Assert.AreEqual(""PotatoAddConnection"", command.Name);
Assert.AreEqual(CommandType.PotatoAddConnection, command.CommandType);
}",Tests the command type can be found from the string.,1
1694,"public void TestScopeNulledWhenNulled() {
IConfigCommand command = new Command() {
Scope = null
}.ToConfigCommand();
Assert.IsNull(command.Command.Scope);
}",Tests that the scope model is nulled out if the scope model in the source is also nulled out.,1
1695,"public void TestScopeNulledWhenBothEmpty() {
IConfigCommand command = new Command() {
Scope = {
ConnectionGuid = Guid.Empty,
PluginGuid = Guid.Empty
}
}.ToConfigCommand();
Assert.IsNull(command.Command.Scope);
}",Tests that the scope model is nulled out if the scope contains empty guid's,1
1696,"public void TestScopeMaintainedWhenConnectionGuidNotEmpty() {
Guid guid = Guid.NewGuid();
IConfigCommand command = new Command() {
Scope = {
ConnectionGuid = guid,
PluginGuid = Guid.Empty
}
}.ToConfigCommand();
Assert.IsNotNull(command.Command.Scope);
Assert.AreEqual(command.Command.Scope.ConnectionGuid, guid);
}",Tests that the scope model is nulled out if the scope contains empty guid's,1
1697,"public void TestScopeMaintainedWhenPluginGuidNotEmpty() {
Guid guid = Guid.NewGuid();
IConfigCommand command = new Command() {
Scope = {
ConnectionGuid = Guid.Empty,
PluginGuid = guid
}
}.ToConfigCommand();
Assert.IsNotNull(command.Command.Scope);
Assert.AreEqual(command.Command.Scope.PluginGuid, guid);
}",Tests that the scope model is nulled out if the scope contains empty guid's,1
1698,"public void TestAuthenticationNulled() {
IConfigCommand command = new Command() {
Authentication = new CommandAuthenticationModel() {
Uid = ""Never seen""
}
}.ToConfigCommand();
Assert.IsNull(command.Command.Authentication);
}",Tests the authentication will be nulled out when supplied with details,1
1699,"public void TestAuthenticationNulledWhenNulled() {
IConfigCommand command = new Command() {
Authentication = null
}.ToConfigCommand();
Assert.IsNull(command.Command.Authentication);
}",Tests the authentication will be nulled of the resulting config command when nulled to begin with,1
1700,"public void TestCommandDataDispose() {
var data = new CommandData() {
Content = new List<String>(),
Connections = new List<ConnectionModel>(),
Groups = new List<Core.Shared.Models.GroupModel>(),
Accounts = new List<AccountModel>(),
Permissions = new List<PermissionModel>(),
AccountPlayers = new List<AccountPlayerModel>(),
Variables = new List<VariableModel>(),
Languages = new List<LanguageModel>(),
TextCommands = new List<TextCommandModel>(),
TextCommandMatches = new List<TextCommandMatchModel>(),
Chats = new List<ChatModel>(),
Players = new List<PlayerModel>(),
Kills = new List<KillModel>(),
Spawns = new List<SpawnModel>(),
Kicks = new List<KickModel>(),
Bans = new List<BanModel>()
};
data.Dispose();
Assert.IsNull(data.Content);
Assert.IsNull(data.Connections);
Assert.IsNull(data.Groups);
Assert.IsNull(data.Accounts);
Assert.IsNull(data.Permissions);
Assert.IsNull(data.AccountPlayers);
Assert.IsNull(data.Variables);
Assert.IsNull(data.Languages);
Assert.IsNull(data.TextCommands);
Assert.IsNull(data.TextCommandMatches);
Assert.IsNull(data.Chats);
Assert.IsNull(data.Players);
Assert.IsNull(data.Kills);
Assert.IsNull(data.Spawns);
Assert.IsNull(data.Kicks);
Assert.IsNull(data.Bans);
}",Tests that all references are removed by emptying and nulling the lists.,1
1701,"public void TestNulledArguments() {
var result = ConfigController.Dispatch(""CommandServerGenerateCertificate"", null);
var password = result.Arguments[""Password""];
// Loads the certificates
var loadedCertificate = new X509Certificate2(Defines.CertificatesDirectoryCommandServerPfx.FullName, password);
// Certificate can be loaded with supplied password.
Assert.IsNotNull(loadedCertificate);
Assert.IsNotNull(loadedCertificate.PrivateKey);
}",Tests passing in nulled arguments is as good as passing in empty arguments,1
1702,"public void TestEmptyArguments() {
var result = ConfigController.Dispatch(""CommandServerGenerateCertificate"", new Dictionary<String, String>());
var password = result.Arguments[""Password""];
// Loads the certificates
var loadedCertificate = new X509Certificate2(Defines.CertificatesDirectoryCommandServerPfx.FullName, password);
// Certificate can be loaded with supplied password.
Assert.IsNotNull(loadedCertificate);
Assert.IsNotNull(loadedCertificate.PrivateKey);
}",Tests that pasing in empty arguments will generate a new password and the resulting certificate can be loaded with the password.,1
1703,"public void TestSuppliedPassword() {
const string password = ""TestSuppliedPassword"";
ConfigController.Dispatch(""CommandServerGenerateCertificate"", new Dictionary<String, String>() {
{ ""password"", password }
});
// Loads the certificates
var loadedCertificate = new X509Certificate2(Defines.CertificatesDirectoryCommandServerPfx.FullName, password);
// Certificate can be loaded with supplied password.
Assert.IsNotNull(loadedCertificate);
Assert.IsNotNull(loadedCertificate.PrivateKey);
}",Tests that a password can be supplied and this password will be used to generate the certificate,1
1704,"public void TestSuppliedPasswordReturnedInMessage() {
const string password = ""TestSuppliedPassword"";
var result = ConfigController.Dispatch(""CommandServerGenerateCertificate"", new Dictionary<String, String>() {
{ ""password"", password }
});
Assert.AreEqual(password, result.Arguments[""Password""]);
}",Tests a supplied password will be returned in the message from the command.,1
1705,"public void TestSerializeJson() {
var packet = CommandServerSerializer.CompleteResponsePacket(Mime.ApplicationJson, new CommandServerPacket(), new CommandResult() {
Now = {
Content = new List<String>() {
""A""
}
}
});
var array = (JContainer)JsonConvert.DeserializeObject(packet.Content);
Assert.AreEqual(""A"", array[""Now""][""Content""].First().Value<String>());
Assert.AreEqual(HttpStatusCode.OK, packet.StatusCode);
Assert.AreEqual(Mime.ApplicationJson, packet.Headers[HttpRequestHeader.ContentType]);
}",Tests that the completed json serialization can be deserialized again.,1
1706,"public void TestSerializeTextHtml() {
var packet = CommandServerSerializer.CompleteResponsePacket(Mime.TextHtml, new CommandServerPacket(), new CommandResult() {
Now = {
Content = new List<String>() {
""A""
}
}
});
Assert.AreEqual(""A"", packet.Content);
Assert.AreEqual(HttpStatusCode.OK, packet.StatusCode);
Assert.AreEqual(Mime.TextHtml, packet.Headers[HttpRequestHeader.ContentType]);
}",Tests the content from the packet matches the input serialization contwent (straight assignment),1
1707,"public void TestVariableEnabledPortThenEnabled() {
var commandServer = new CommandServerController();
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerPort,
3100
})
});
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerEnabled,
true
})
});
commandServer.Execute();
Assert.IsNotNull(commandServer.CommandServerListener);
Assert.IsNotNull(commandServer.CommandServerListener.Listener);
commandServer.Dispose();
}",Tests the listener can be setup if the port variable is set then the enabled variable.,1
1708,"public void TestVariableEnabledEnabledThenPort() {
var commandServer = new CommandServerController();
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerEnabled,
true
})
});
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerPort,
3200
})
});
commandServer.Execute();
Assert.IsNotNull(commandServer.CommandServerListener);
Assert.IsNotNull(commandServer.CommandServerListener.Listener);
commandServer.Dispose();
}","Tests the listener can be setup if the server is enabled, then the port is set.",1
1709,"public void TestVariableDisabled() {
var commandServer = new CommandServerController();
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerPort,
3300
})
});
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerEnabled,
true
})
});
commandServer.Execute();
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerEnabled,
false
})
});
Assert.IsNull(commandServer.CommandServerListener);
Assert.IsNotNull(commandServer.TunnelObjects);
commandServer.Dispose();
}",Tests that altering the command server enabled/disabled variable on an active listener will disable and null the listener.,1
1710,"public void TestEventLoggedOnConfiguredEnabled() {
var commandServer = new CommandServerController();
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerPort,
3400
})
});
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerEnabled,
true
})
});
commandServer.Execute();
Assert.IsNotEmpty(commandServer.Shared.Events.LoggedEvents);
Assert.AreEqual(GenericEventType.CommandServerStarted, commandServer.Shared.Events.LoggedEvents.First(e => e.GenericEventType == GenericEventType.CommandServerStarted).GenericEventType);
Assert.AreEqual(CommandResultType.Success, commandServer.Shared.Events.LoggedEvents.First(e => e.GenericEventType == GenericEventType.CommandServerStarted).CommandResultType);
Assert.IsTrue(commandServer.Shared.Events.LoggedEvents.First(e => e.GenericEventType == GenericEventType.CommandServerStarted).Success);
commandServer.Dispose();
}",Tests an event is logged when the command listener is started.,1
1711,"public void TestEventLoggedOnConfiguredDisabled() {
var commandServer = new CommandServerController();
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerPort,
3500
})
});
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerEnabled,
true
})
});
commandServer.Execute();
commandServer.Shared.Variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.CommandServerEnabled,
false
})
});
Assert.IsNotEmpty(commandServer.Shared.Events.LoggedEvents);
Assert.AreEqual(GenericEventType.CommandServerStopped, commandServer.Shared.Events.LoggedEvents.First(e => e.GenericEventType == GenericEventType.CommandServerStopped).GenericEventType);
Assert.AreEqual(CommandResultType.Success, commandServer.Shared.Events.LoggedEvents.First(e => e.GenericEventType == GenericEventType.CommandServerStarted).CommandResultType);
Assert.IsTrue(commandServer.Shared.Events.LoggedEvents.First(e => e.GenericEventType == GenericEventType.CommandServerStarted).Success);
commandServer.Dispose();
}",Tests an event is logged when the command listener is stopped.,1
1712,"public void TestBasicConnection() {
IDriver driver = new SqLiteDriver() {
Settings = new DriverSettings() {
Memory = true
}
};
Assert.IsTrue(driver.Connect());
driver.Close();
}",Tests we can load up an in-memory SQLite database,1
1713,"public void TestMonitoringIsEnabled() {
var service = new ServiceController();
Assert.IsTrue(AppDomain.MonitoringIsEnabled);
service.Dispose();
}",Tests that when creating a new service controllerit will enable the appdomain monitoring,1
1714,"public void TestNonNullProperties() {
var service = new ServiceController();
Assert.IsNotNull(service.Observer);
Assert.IsNotNull(service.Polling);
Assert.IsNotNull(service.WriteConfig);
Assert.IsNotNull(service.Arguments);
Assert.IsNotNull(service.Settings);
Assert.IsNotNull(service.Packages);
service.Dispose();
}",Tests the constructor initalizes the public properties of the controller,1
1715,"public void TestServiceProxyType() {
var service = new ServiceController();
Assert.AreEqual(typeof(ServiceLoaderProxy), service.ServiceLoaderProxyType);
service.Dispose();
}",Ensures the initial service loader proxy type,1
1716,"public void TestInitalServiceStateIsStopped() {
var service = new ServiceController();
Assert.AreEqual(ServiceStatusType.Stopped, service.Observer.Status);
service.Dispose();
}",Ensures the initial service state is stopped,1
1717,"public void TestStructureCreated() {
IConfig config = new Config().Create<MockSimpleConcrete>();
Assert.IsNotNull(config.Document);
Assert.IsNotNull(config.Document[""Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete""]);
Assert.IsNotNull(config.Document[""Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete""].Value<JArray>());
}",Tests that the namespace is setup correctly.,1
1718,"public void TestRootMatchesNamespace() {
IConfig config = new Config().Create<MockSimpleConcrete>();
Assert.AreEqual(config.Document[""Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete""], config.Root);
}",Tests the root is set to the maximum document value.,1
1719,"public void TestSuccess() {
var controller = new SandboxProtocolController();
controller.Create(this.Meta.Assembly.FullName, this.Meta.ProtocolTypes.FirstOrDefault(type => type.Type == ""MyrconTestProtocol8""));
Assert.IsNotNull(controller.SandboxedProtocol);
}","Tests that loading an assembly, creating a protocol from a type etc will not fail if correct information is passed through",1
1720,"public void TestSuccessReturnsTrue() {
var controller = new SandboxProtocolController();
var result = controller.Create(this.Meta.Assembly.FullName, this.Meta.ProtocolTypes.FirstOrDefault(type => type.Type == ""MyrconTestProtocol8""));
Assert.IsTrue(result);
Assert.IsNotNull(controller.SandboxedProtocol);
}",Tests that the return value of Create is true if the sandboxed protocol is loaded correctly.,1
1721,"public void TestFailureWhenAssemblyDoesNotExist() {
var controller = new SandboxProtocolController();
controller.Create(""Protocol.dll"", this.Meta.ProtocolTypes.FirstOrDefault(type => type.Type == ""MyrconTestProtocol8""));
Assert.IsNull(controller.SandboxedProtocol);
}",Passes in a fake path to load,1
1722,"public void TestFailureReturnsFalse() {
var controller = new SandboxProtocolController();
var result = controller.Create(""Protocol.dll"", this.Meta.ProtocolTypes.FirstOrDefault(type => type.Type == ""MyrconTestProtocol8""));
Assert.IsFalse(result);
Assert.IsNull(controller.SandboxedProtocol);
}",Tests that the return value of Create is false if the sandboxed protocol is not loaded correctly.,1
1723,"public void TestFailureWhenProtocolProviderDoesNotExist() {
var controller = new SandboxProtocolController();
controller.Create(this.Meta.Assembly.FullName, new ProtocolType() {
Provider = ""Fake"",
Type = ""MyrconTestProtocol8""
});
Assert.IsNull(controller.SandboxedProtocol);
}",Passes in an unknown provider,1
1724,"public void TestFailureWhenProtocolTypeDoesNotExist() {
var controller = new SandboxProtocolController();
controller.Create(this.Meta.Assembly.FullName, new ProtocolType() {
Provider = ""Myrcon"",
Type = ""Fake""
});
Assert.IsNull(controller.SandboxedProtocol);
}",Passes in an unknown provider,1
1725,"public void TestSqLiteMemoryDatabaseDisposed() {
DatabaseController database = OpenSqLiteDriver();
Assert.AreEqual(1, database.OpenDrivers.Count);
database.Dispose();
Assert.IsNull(database.OpenDrivers);
Assert.IsNull(database.AvailableDrivers);
Assert.IsNull(database.GroupedVariableListener);
}",Tests that disposing the database controller with an open driver will be closed and disposed of properly.,1
1726,"public void TestSqLiteMemoryDatabaseOpened() {
DatabaseController database = OpenSqLiteDriver();
Assert.AreEqual(1, database.OpenDrivers.Count);
}",Tests that a SQLite memory database can be opened by setting the appropriate variables,1
1727,"public void TestSqLiteMemoryDatabaseOpenedNamespaced() {
String @namespace = StringExtensions.RandomString(10);
DatabaseController database = OpenSqLiteDriver(@namespace);
Assert.AreEqual(1, database.OpenDrivers.Count);
}",Tests that a SQLite memory database can be opened by setting the appropriate variables,1
1728,"public void TestSqLiteQueryMissingNamespaced() {
// Setup the db on one namespace, but query another.
String databaseNamespace = StringExtensions.RandomString(10);
String queryNamespace = StringExtensions.RandomString(10);
DatabaseController database = OpenSqLiteDriver(databaseNamespace);
ICommandResult result = database.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.DatabaseQuery,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
queryNamespace
}
}
},
new CommandParameter() {
Data = {
Queries = new List<IDatabaseObject>() {
new Create().Collection(""Player"").Field(""Name"", new StringType()).Field(""Score"", new IntegerType()).Field(""Rank"", new IntegerType()).Field(""Kdr"", new FloatType())
}
}
}
}
});
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
Assert.AreEqual(false, result.Success);
}",Tests that a query will fail on a driver in a namespace that does not exist.,1
1729,"public void TestSqLiteSetupAndFindQueryNamespaced() {
String @namespace = StringExtensions.RandomString(10);
DatabaseController database = OpenSqLiteDriver(@namespace);
database.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.DatabaseQuery,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
@namespace
}
}
},
new CommandParameter() {
Data = {
Queries = new List<IDatabaseObject>() {
new Create().Collection(""Player"").Field(""Name"", new StringType()).Field(""Score"", new IntegerType()).Field(""Rank"", new IntegerType()).Field(""Kdr"", new FloatType()),
new Save().Collection(""Player"").Set(""Name"", ""Phogue"").Set(""Score"", 100).Set(""Rank"", 10).Set(""Kdr"", 1),
new Save().Collection(""Player"").Set(""Name"", ""Zaeed"").Set(""Score"", 15).Set(""Rank"", 20).Set(""Kdr"", 2),
new Save().Collection(""Player"").Set(""Name"", ""Duplicate"").Set(""Score"", 1000).Set(""Rank"", 100).Set(""Kdr"", 4),
new Save().Collection(""Player"").Set(""Name"", ""Duplicate"").Set(""Score"", 1000).Set(""Rank"", 100).Set(""Kdr"", 4)
}
}
}
}
});
ICommandResult result = database.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.DatabaseQuery,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
@namespace
}
}
},
new CommandParameter() {
Data = {
Queries = new List<IDatabaseObject>() {
new Find().Condition(""Name"", ""Zaeed"").Collection(""Player"")
}
}
}
}
});
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(true, result.Success);
Assert.AreEqual(new JArray() {
new JObject() {
new JProperty(""Name"", ""Zaeed""),
new JProperty(""Score"", 15.0),
new JProperty(""Rank"", 20.0),
new JProperty(""Kdr"", 2.0)
}
}.ToString(Formatting.None), ((CollectionValue) result.Now.Queries.First()).ToJArray().ToString(Formatting.None));
}",Tests that a database can be setup and queried in its own namespace (a plugin can setup its own db connection),1
1730,"public void TestMigrationDownFromLatest() {
var helper = new TestMigrationTrackerHelper();
helper.Migrations.SaveVersion(4);
helper.Migrations.Down();
Assert.AreEqual(4, helper.Counter);
Assert.AreEqual(0, helper.Tracker);
}","Tests that all down migrations are called when on the latest migration, essentially this would be used to ""uninstall""",1
1731,"public void TestMigrationDownFromLatestToSecond() {
var helper = new TestMigrationTrackerHelper();
helper.Migrations.SaveVersion(4);
helper.Migrations.Down(2);
Assert.AreEqual(2, helper.Counter);
Assert.AreEqual(2, helper.Tracker);
}",Tests we can specify what migration to go to,1
1732,"public void TestMigrationDownFromNothing() {
var helper = new TestMigrationTrackerHelper();
helper.Migrations.Down();
Assert.AreEqual(0, helper.Counter);
Assert.AreEqual(0, helper.Tracker);
}",Tests that migrations from no migrations will yield no migration calls,1
1733,"public void TestMigrationDownFromSecond() {
var helper = new TestMigrationTrackerHelper();
helper.Migrations.SaveVersion(2);
helper.Migrations.Down();
Assert.AreEqual(2, helper.Counter);
Assert.AreEqual(0, helper.Tracker);
}",Tests that migrations from a second migration can go to the first migration.,1
1734,"public void TestMigrationUpFromLatest() {
var helper = new TestMigrationTrackerHelper();
helper.Migrations.SaveVersion(4);
helper.Migrations.Up();
Assert.AreEqual(0, helper.Counter);
Assert.AreEqual(0, helper.Tracker);
}",Tests that migrations from the latest migration will yield no migration calls,1
1735,"public void TestMigrationUpFromNothing() {
var helper = new TestMigrationTrackerHelper();
helper.Migrations.Up();
Assert.AreEqual(4, helper.Counter);
Assert.AreEqual(4, helper.Tracker);
}",Tests that the initial migration (with no entries in the migrations table) will still call all the migrations.,1
1736,"public void TestMigrationUpFromNothingToSecond() {
var helper = new TestMigrationTrackerHelper();
helper.Migrations.Up(2);
Assert.AreEqual(2, helper.Counter);
Assert.AreEqual(2, helper.Tracker);
}",Tests we can specify what migration to go to,1
1737,"public void TestMigrationUpFromSecond() {
var helper = new TestMigrationTrackerHelper();
helper.Migrations.SaveVersion(2);
helper.Migrations.Up();
Assert.AreEqual(2, helper.Counter);
Assert.AreEqual(4, helper.Tracker);
}",Tests that migrations from a second migration can go to the latest migration.,1
1738,"public void TestComplexFromQuerySingle() {
var item = new CollectionValue() {
new DocumentValue().Set(""IntegerValue"", 1).Set(""LongValue"", 2).Set(""DoubleValue"", 3.5).Set(""StringValue"", ""Phogue"").Set(""DateTimeValue"", new DateTime(2013, 12, 19, 13, 38, 0)).Set(""SingleMockSimpleModel"", new Dictionary<String, Object>() {
{""Id"", 10},
{""Name"", ""Zaeed""}
}).Set(""MultipleMockSimpleModel"", new List<Object>() {
new Dictionary<String, Object>() {
{""Id"", 20},
{""Name"", ""Ike""}
},
new Dictionary<String, Object>() {
{""Id"", 30},
{""Name"", ""Phil""}
}
})
};
var models = MockComplexModel.FromQuery(item);
Assert.AreEqual(1, models.First().IntegerValue);
Assert.AreEqual(2, models.First().LongValue);
Assert.AreEqual(3.5D, models.First().DoubleValue);
Assert.AreEqual(""Phogue"", models.First().StringValue);
Assert.AreEqual(new DateTime(2013, 12, 19, 13, 38, 0), models.First().DateTimeValue);
Assert.AreEqual(10, models.First().SingleMockSimpleModel.Id);
Assert.AreEqual(""Zaeed"", models.First().SingleMockSimpleModel.Name);
Assert.AreEqual(20, models.First().MultipleMockSimpleModel.First().Id);
Assert.AreEqual(""Ike"", models.First().MultipleMockSimpleModel.First().Name);
Assert.AreEqual(30, models.First().MultipleMockSimpleModel.Last().Id);
Assert.AreEqual(""Phil"", models.First().MultipleMockSimpleModel.Last().Name);
}",Tests serialization to a single complex database model,1
1739,"public void TestComplexToSaveQuery() {
Save save = new MockComplexModel() {
IntegerValue = 1,
LongValue = 2,
DoubleValue = 3.5D,
StringValue = ""Phogue"",
DateTimeValue = new DateTime(2013, 12, 19, 14, 14, 0),
SingleMockSimpleModel = new MockSimpleModel() {
Id = 10,
Name = ""Zaeed""
},
MultipleMockSimpleModel = new List<MockSimpleModel>() {
new MockSimpleModel() {
Id = 20,
Name = ""Ike""
},
new MockSimpleModel() {
Id = 30,
Name = ""Phil""
}
}
}.ToSaveQuery();
var integerValue = save.ElementAt(0).First(value => value is NumericValue) as NumericValue;
var longValue = save.ElementAt(1).First(value => value is NumericValue) as NumericValue;
var doubleValue = save.ElementAt(2).First(value => value is NumericValue) as NumericValue;
var stringValue = save.ElementAt(3).First(value => value is StringValue) as StringValue;
var dateTimeValue = save.ElementAt(4).First(value => value is DateTimeValue) as DateTimeValue;
var documentValue = save.ElementAt(5).First(value => value is DocumentValue) as DocumentValue;
var documentValueDoubleValue = documentValue.ElementAt(0).First(value => value is NumericValue) as NumericValue;
var documentValueStringValue = documentValue.ElementAt(1).First(value => value is StringValue) as StringValue;
var collectionValue = save.ElementAt(6).First(value => value is CollectionValue) as CollectionValue;
var collectionValueFirstDocumentValueDoubleValue = collectionValue.ElementAt(0).ElementAt(0).First(value => value is NumericValue) as NumericValue;
var collectionValueFirstDocumentValueStringValue = collectionValue.ElementAt(0).ElementAt(1).First(value => value is StringValue) as StringValue;
var collectionValueLastDocumentValueDoubleValue = collectionValue.ElementAt(1).ElementAt(0).First(value => value is NumericValue) as NumericValue;
var collectionValueLastDocumentValueStringValue = collectionValue.ElementAt(1).ElementAt(1).First(value => value is StringValue) as StringValue;
Assert.AreEqual(1, integerValue.Long);
Assert.AreEqual(2, longValue.Long);
Assert.AreEqual(3.5D, doubleValue.Double);
Assert.AreEqual(""Phogue"", stringValue.Data);
Assert.AreEqual(new DateTime(2013, 12, 19, 14, 14, 0), dateTimeValue.Data);
Assert.AreEqual(10.0D, documentValueDoubleValue.Double);
Assert.AreEqual(""Zaeed"", documentValueStringValue.Data);
Assert.AreEqual(20.0D, collectionValueFirstDocumentValueDoubleValue.Double);
Assert.AreEqual(""Ike"", collectionValueFirstDocumentValueStringValue.Data);
Assert.AreEqual(30.0D, collectionValueLastDocumentValueDoubleValue.Double);
Assert.AreEqual(""Phil"", collectionValueLastDocumentValueStringValue.Data);
}",Tests a complex model can be serialized to a Save query,1
1740,"public void TestSimpleFromQueryMultiple() {
var item = new CollectionValue() {
new DocumentValue().Set(""Id"", 50).Set(""Name"", ""Phogue""),
new DocumentValue().Set(""Id"", 100).Set(""Name"", ""Zaeed"")
};
var models = MockSimpleModel.FromQuery(item);
Assert.AreEqual(50, models.First().Id);
Assert.AreEqual(""Phogue"", models.First().Name);
Assert.AreEqual(100, models.Last().Id);
Assert.AreEqual(""Zaeed"", models.Last().Name);
}",Tests serialization of multiple database model,1
1741,"public void TestSimpleFromQuerySingle() {
var item = new CollectionValue() {
new DocumentValue().Set(""Id"", 50).Set(""Name"", ""Phogue"")
};
var models = MockSimpleModel.FromQuery(item);
Assert.AreEqual(50, models.First().Id);
Assert.AreEqual(""Phogue"", models.First().Name);
}",Tests serialization to a single database model,1
1742,"public void TestSimpleToModifyQuery() {
Modify modify = new MockSimpleModel() {
Name = ""Phogue"",
Id = 10
}.ToModifyQuery();
var playerId = modify.First().First(value => value is NumericValue) as NumericValue;
var name = modify.Last().First(value => value is StringValue) as StringValue;
Assert.AreEqual(10, playerId.Long);
Assert.AreEqual(""Phogue"", name.Data);
}",Tests a simple model can be serialized to a Modify query,1
1743,"public void TestSimpleToSaveQuery() {
Save save = new MockSimpleModel() {
Name = ""Phogue"",
Id = 10
}.ToSaveQuery();
var playerId = save.First().First(value => value is NumericValue) as NumericValue;
var name = save.Last().First(value => value is StringValue) as StringValue;
Assert.AreEqual(10, playerId.Long);
Assert.AreEqual(""Phogue"", name.Data);
}",Tests a simple model can be serialized to a Save query,1
1744,"public void TestDescendantsAndSelfQueryTree() {
List<StringValue> values = new List<StringValue>() {
new StringValue() {
Data = ""0""
},
new StringValue() {
Data = ""1""
},
new StringValue() {
Data = ""2""
},
new StringValue() {
Data = ""3""
}
};
// Create a tree of values. We will want to flatten and find each value after.
IDatabaseObject query = new Find()
.Method(
values[0]
)
.Method(
values[1]
)
.Method(
new Drop()
.Field(
values[2]
.Method(
new Save()
.Field(
values[3]
)
)
)
);
List<StringValue> descendants = query.DescendantsAndSelf<StringValue>().ToList();
Assert.AreEqual(4, descendants.Count());
foreach (StringValue item in descendants) {
Assert.IsTrue(values.Contains(item)); }
}",Tests all descendants of a type can be extracted from a tree.,1
1745,"public void TestDescendantsAndSelfSingleValue() {
StringValue value = new StringValue() {
Data = ""0""
};
List<StringValue> descendants = value.DescendantsAndSelf<StringValue>().ToList();
Assert.AreEqual(1, descendants.Count());
Assert.AreEqual(value, descendants.First());
}","Tests that the ""self"" part of DescendantsAndSelf will be returned if it matches the type.",1
1746,"public void TestAllDateTimeConversionFailure() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""2014-04-14 13:50:59"",
""2014-04-11 03:23:13"",
""Invalid""
}
}
};
var items = parameter.All(typeof(DateTime)) as List<Object>;
Assert.IsNull(items);
}",Tests that if all values can't be converted to date/times then the result will return null.,1
1747,"public void TestFirstDateTimeConversionFailed() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Invalid""
}
}
};
Assert.AreEqual(default(DateTime), parameter.First<DateTime>());
}",Tests that the default is returned when a conversion does not exist for a given type.,1
1748,"public void TestFirstDateTimeConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""2014-04-14 13:50:59""
}
}
};
Assert.AreEqual(DateTime.Parse(""2014-04-14 13:50:59""), parameter.First<DateTime>());
}",Tests that we can pull and convert the first value from a list of strings to an date/time,1
1749,"public void TestHasManyDateTimeConversionFailed() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""2014-04-14 13:50:59"",
""2014-04-11 03:23:13"",
""Invalid""
}
}
};
Assert.IsFalse(parameter.HasMany<DateTime>());
}","Tests that if a single value in the string array cannot be converted to the date/time type then it does not ""have many"" of type date/time.",1
1750,"public void TestHasManyDateTimeConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""2014-04-14 13:50:59"",
""2014-04-11 03:23:13""
}
}
};
Assert.IsTrue(parameter.HasMany<DateTime>());
}","Tests that if an array of strings can be converted to the date/time type then it does ""have many"" of the type date/time.",1
1751,"public void TestHasOneIntegerConversionFailure() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""one""
}
}
};
Assert.IsFalse(parameter.HasOne<DateTime>());
}","Tests if no conversion exists for the string to the type then it does not ""have one"" of that type.",1
1752,"public void TestHasOneDateTimeConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""2014-04-14 13:50:59""
}
}
};
Assert.IsTrue(parameter.HasOne<DateTime>());
}","Tests that if a string can be converted to an date/time then the parameter does ""have one"" of type date/time.",1
1753,"public void TestHasOneDateTimeConversionSuccessWithMultiple() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""2014-04-14 13:50:59"",
""2014-04-11 03:23:13""
}
}
};
Assert.IsTrue(parameter.HasOne<DateTime>());
}","Tests that if a string can be converted to an date/time then the parameter does ""have one"" of type date/time even when multiple string exist",1
1754,"public void TestHasOneDateTimeConversionSuccessWithMultipleAndInvalid() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""2014-04-14 13:50:59"",
""Invalid""
}
}
};
Assert.IsTrue(parameter.HasOne<DateTime>());
}","Tests that if a string can be converted to an date/time then the parameter does ""have one"" of type date/time even when multiple string exist and anything beyond the first string is invalid",1
1755,"public void TestNullPasswordParameterException() {
this.Encrypted.Decrypt(null);
}",Tests a nulled output password will raise an exception,1
1756,"public void TestEmptyPasswordParameterException() {
this.Encrypted.Encrypt("""");
}",Tests an empty password will raise an exception,1
1757,"public void TestDecryptionFailsWithIncorrectPassword() {
this.Encrypted.Decrypt(""password1"");
Assert.IsNull(this.Encrypted.Command);
}",Tests that decryption will fail with an invalid password,1
1758,"public void TestJsonDeserialization() {
Command original = new Command() {
CommandType = CommandType.VariablesSet,
Authentication = {
Username = ""username"",
PasswordPlainText = ""password""
},
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""A""
}
}
},
new CommandParameter() {
Data = {
Content = new List<String>() {
""B""
}
}
}
}
};
ICommand deserialized = CommandServerSerializer.DeserializeCommand(new CommandServerPacket() {
Content = JsonConvert.SerializeObject(original),
Headers = new WebHeaderCollection() {
{ HttpRequestHeader.ContentType, Mime.ApplicationJson }
}
});
Assert.AreEqual(original.CommandType.ToString(), deserialized.Name);
Assert.AreEqual(original.Authentication.Username, deserialized.Authentication.Username);
Assert.AreEqual(original.Authentication.PasswordPlainText, deserialized.Authentication.PasswordPlainText);
Assert.IsNotEmpty(deserialized.Parameters);
}",Tests that a command deserialization can occur with json,1
1759,"public void TestJsonDeserializationEmptyParameterList() {
Command original = new Command() {
CommandType = CommandType.VariablesSet,
Authentication = {
Username = ""username"",
PasswordPlainText = ""password""
}
};
ICommand deserialized = CommandServerSerializer.DeserializeCommand(new CommandServerPacket() {
Content = JsonConvert.SerializeObject(original),
Headers = new WebHeaderCollection() {
{ HttpRequestHeader.ContentType, Mime.ApplicationJson }
}
});
Assert.AreEqual(original.CommandType.ToString(), deserialized.Name);
Assert.AreEqual(original.Authentication.Username, deserialized.Authentication.Username);
Assert.AreEqual(original.Authentication.PasswordPlainText, deserialized.Authentication.PasswordPlainText);
Assert.IsNull(deserialized.Parameters);
}",Tests that a command deserialization can occur with json and no parameters,1
1760,"public void TestIncorrectDeserialization() {
ICommand deserialized = CommandServerSerializer.DeserializeCommand(new CommandServerPacket() {
Content = ""this is junk text that won't be deserialized."",
Headers = new WebHeaderCollection() {
{ HttpRequestHeader.ContentType, Mime.ApplicationJson }
}
});
Assert.IsNull(deserialized);
}",Tests that deserializing incorrect data will result in a null command.,1
1761,"public void TestNulledResultForNulledCommand() {
Assert.IsNull(ConfigController.Dispatch(null, null));
}",Tests a null result when passing in a nulled command,1
1762,"public void TestNulledResultForUnknownCommand() {
Assert.IsNull(ConfigController.Dispatch(""This command does not exist"", null));
}",Tests a null result from passing in an unknown command,1
1763,"public void TestCheckByAccountUsernameIsIdentical() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now change the language of the account.
ICommandResult result = security.DispatchGroupCheck(new Command() {
Authentication = {
Username = ""Phogue""
}
}, ""GroupName"");
// Make sure it was successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
}",Tests that a single account's group will match if they are identical.,1
1764,"public void TestCheckByAccountUsernameIsNotIdentical() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""FirstGroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""FirstGroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAddGroup(""SecondGroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Ike"").SetOrigin(CommandOrigin.Local));
// Now change the language of the account.
ICommandResult result = security.DispatchGroupCheck(new Command() {
Authentication = {
Username = ""Phogue""
}
}, ""SecondGroupName"");
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Failed);
}",Tests that the the comparison fails against a different group to the executor,1
1765,"public void TestCheckByAccountUsernameFailsOnTargetAccountNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now change the language of the account.
ICommandResult result = security.DispatchGroupCheck(new Command() {
Authentication = {
Username = ""Phogue""
}
}, ""AccountDoesNotExist"");
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Failed);
}",Tests that the account will not be identical if the target account does not exist,1
1766,"public void TestCheckByAccountUsernameFailsOnSourceAccountNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now change the language of the account.
ICommandResult result = security.DispatchGroupCheck(new Command() {
Authentication = {
Username = ""AccountDoesNotExist""
}
}, ""GroupName"");
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Failed);
}",Tests that the account will not be identical if the source account does not exist,1
1767,"public void TestCheckByAccountUsernameIsIdentical() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Now add a user.
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
// Now change the language of the account.
ICommandResult result = security.DispatchIdentityCheck(new Command() {
Authentication = {
Username = ""Phogue""
}
}, ""Phogue"");
// Make sure it was successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
}",Tests that the command authentication will succeed against itself,1
1768,"public void TestCheckByAccountUsernameIsNotIdentical() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Ike""
})
});
// Now change the language of the account.
ICommandResult result = security.DispatchIdentityCheck(new Command() {
Authentication = {
Username = ""Phogue""
}
}, ""Ike"");
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Failed);
}",Tests that the command authentication will not succeed against another account,1
1769,"public void TestCheckByAccountUsernameFailsOnTargetAccountNotExist() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Now add a user.
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
// Now change the language of the account.
ICommandResult result = security.DispatchIdentityCheck(new Command() {
Authentication = {
Username = ""Phogue""
}
}, ""AccountDoesNotExist"");
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Failed);
}",Tests that the account will not be identical if the target account does not exist,1
1770,"public void TestCheckByAccountUsernameFailsOnSourceAccountNotExist() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Now add a user.
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
// Now change the language of the account.
ICommandResult result = security.DispatchIdentityCheck(new Command() {
Authentication = {
Username = ""AccountDoesNotExist""
}
}, ""Phogue"");
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Failed);
}",Tests that the account will not be identical if the source account does not exist,1
1771,"public void TestCheckByAccountPlayerIsIdentical() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Now add a user.
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountAddPlayer,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
CommonProtocolType.DiceBattlefield3,
""ABCDEF""
})
});
// Now change the language of the account.
ICommandResult result = security.DispatchIdentityCheck(new Command() {
Authentication = {
GameType = CommonProtocolType.DiceBattlefield3,
Uid = ""ABCDEF""
}
}, CommonProtocolType.DiceBattlefield3, ""ABCDEF"");
// Make sure it was successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
}",Tests that the command authentication will succeed against itself,1
1772,"public void TestCheckByAccountPlayerIsNotIdentical() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountAddPlayer,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
CommonProtocolType.DiceBattlefield3,
""ABCDEF""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Ike""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountAddPlayer,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Ike"",
CommonProtocolType.DiceBattlefield3,
""ZYXWVUT""
})
});
// Now change the language of the account.
ICommandResult result = security.DispatchIdentityCheck(new Command() {
Authentication = {
GameType = CommonProtocolType.DiceBattlefield3,
Uid = ""ABCDEF""
}
}, CommonProtocolType.DiceBattlefield3, ""ZYXWVUT"");
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Failed);
}",Tests that the command authentication will not succeed against another account,1
1773,"public void TestCheckByAccountPlayerFailsOnTargetAccountNotExist() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Now add a user.
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountAddPlayer,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
CommonProtocolType.DiceBattlefield3,
""ABCDEF""
})
});
ICommandResult result = security.DispatchIdentityCheck(new Command() {
Authentication = {
GameType = CommonProtocolType.DiceBattlefield3,
Uid = ""ABCDEF""
}
}, CommonProtocolType.DiceBattlefield3, ""DoesNotExist"");
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Failed);
}",Tests that the account will not be identical if the target account does not exist,1
1774,"public void TestCheckByAccountPlayerFailsOnSourceAccountNotExist() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Now add a user.
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountAddPlayer,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
CommonProtocolType.DiceBattlefield3,
""ABCDEF""
})
});
ICommandResult result = security.DispatchIdentityCheck(new Command() {
Authentication = {
GameType = CommonProtocolType.DiceBattlefield3,
Uid = ""DoesNotExist""
}
}, CommonProtocolType.DiceBattlefield3, ""ABCDEF"");
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Failed);
}",Tests that the account will not be identical if the source account does not exist,1
1775,"public void TestAllValuesDefaulted() {
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel(),
TokenHash = ""Something"",
LastTouched = DateTime.Now,
Id = Guid.NewGuid()
};
accessToken.Dispose();
Assert.IsNull(accessToken.Account);
Assert.IsNull(accessToken.TokenHash);
Assert.AreEqual(Guid.Empty, accessToken.Id);
}",Tests that all values are defaluted in the access token when disposed.,1
1776,"public void TestSuccess() {
var protocols = new ProtocolController();
protocols.Dispose();
Assert.IsNull(protocols.Protocols);
}",Tests all data is removed during dispose.,1
1777,"public void TestCommandServerDisposed() {
var commandServer = new CommandServerController();
commandServer.Dispose();
Assert.IsNull(commandServer.CommandServerListener);
Assert.IsNull(commandServer.TunnelObjects);
}",Tests variables are nulled during a dispose.,1
1778,"public void DeleteErrorsLogsDirectory() {
Defines.ErrorsLogsDirectory.Refresh();
if (Defines.ErrorsLogsDirectory.Exists == true) Defines.ErrorsLogsDirectory.Delete(true);
}",Deletes the errors logs directory if it exists.,1
1779,"public void TestDisposeServiceDispatchedSuccess() {
var disposed = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy() {
OnDisposeHandler = () => disposed = true
}
};
service.DisposeService();
Assert.IsTrue(disposed);
service.Dispose();
}",Tests the writeconfig method is called on the service loader proxy,1
1780,"public void TestServiceLoaderProxyNulled() {
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy()
};
service.DisposeService();
Assert.IsNull(service.ServiceLoaderProxy);
service.Dispose();
}",Tests the loader proxy is nulled after disposed,1
1781,"public void TestDisposeServiceDispatchedBeginDelegateCalled() {
var begin = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy(),
DisposeServiceBegin = controller => begin = true
};
service.DisposeService();
Assert.IsTrue(begin);
service.Dispose();
}",Tests that the WriteServiceConfigBegin delegate is called prior to writing the config.,1
1782,"public void TestDisposeServiceDispatchedEndDelegateCalled() {
var end = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy(),
DisposeServiceEnd = controller => end = true
};
service.DisposeService();
Assert.IsTrue(end);
service.Dispose();
}",Tests that the WriteServiceConfigBegin delegate is called after writing the config.,1
1783,"public void TestExceptionLogged() {
var service = new ServiceController() {
ServiceLoaderProxy = new MockNonSerializableServiceLoaderProxy()
};
service.DisposeService();
Assert.IsNotEmpty(Defines.ErrorsLogsDirectory.GetFiles());
Assert.Greater(Defines.ErrorsLogsDirectory.GetFiles().First().Length, 0);
service.Dispose();
}",Tests that exception that occur during config write will be captured and logged.,1
1784,"public void TestExceptionLoggedOnTimeout() {
var service = new ServiceController() {
ServiceLoaderProxy = new MockSlowServiceLoaderProxy() {
DisposeSleep = 500
},
Settings = {
DisposeServiceTimeout = 10
}
};
service.DisposeService();
Assert.IsNotEmpty(Defines.ErrorsLogsDirectory.GetFiles());
Assert.Greater(Defines.ErrorsLogsDirectory.GetFiles().First().Length, 0);
service.Dispose();
}",Tests that an exception will be logged when the maxmimum number of milliseconds for the task has exceeded.,1
1785,"public void TestCommandNulledAfterEncryption() {
IConfigCommand command = new ConfigCommand() {
Command = new Command() {
CommandType = CommandType.ConnectionQuery
}
};
command.Encrypt(TestEncrypt.Password);
Assert.IsNull(command.Command);
}",Tests that after encrypting the data the command will be nulled out.,1
1786,"public void TestNullPasswordParameterException() {
IConfigCommand command = new ConfigCommand() {
Command = new Command() {
CommandType = CommandType.ConnectionQuery
}
};
command.Encrypt(null);
}",Tests a nulled output password will raise an exception,1
1787,"public void TestEmptyPasswordParameterException() {
IConfigCommand command = new ConfigCommand() {
Command = new Command() {
CommandType = CommandType.ConnectionQuery
}
};
command.Encrypt("""");
}",Tests an empty password will raise an exception,1
1788,"public void TestEncryptedCanBeDecryptedInMemory() {
IConfigCommand command = new ConfigCommand() {
Command = new Command() {
CommandType = CommandType.ConnectionQuery
}
};
command.Encrypt(TestEncrypt.Password);
Assert.IsNull(command.Command);
command.Decrypt(TestEncrypt.Password);
Assert.IsNotNull(command.Command);
}","Simple full test showing a command can be encrypted, then decrypted when done so in memory.",1
1789,"public void TestEncryptedCanBeDecryptedInMemoryIntegrity() {
IConfigCommand command = new ConfigCommand() {
Command = new Command() {
CommandType = CommandType.ConnectionQuery
}
};
command.Encrypt(TestEncrypt.Password);
Assert.IsNull(command.Command);
command.Decrypt(TestEncrypt.Password);
Assert.AreEqual(CommandType.ConnectionQuery.ToString(), command.Command.Name);
}",Tests the integrity of the decrypted data,1
1790,"public void TestEncryptedCanBeDecryptedInMemoryIntegrityWithComplexPassword() {
const string password = ""G1cK6yn3muCor0kL1g"";
IConfigCommand command = new ConfigCommand() {
Command = new Command() {
CommandType = CommandType.ConnectionQuery
}
};
command.Encrypt(password);
Assert.IsNull(command.Command);
command.Decrypt(password);
Assert.AreEqual(CommandType.ConnectionQuery.ToString(), command.Command.Name);
}",Tests the integrity of the decrypted data,1
1791,"public void TestAllEnumConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Six"",
""Seven""
}
}
};
var items = (List<Object>)parameter.All(typeof (ExecutableEnum));
Assert.AreEqual(ExecutableEnum.Six, items[0]);
Assert.AreEqual(ExecutableEnum.Seven, items[1]);
}",Tests that we can convert all items in the array to an enum type.,1
1792,"public void TestFirstEnumConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Six""
}
}
};
Assert.AreEqual(ExecutableEnum.Six, parameter.First<ExecutableEnum>());
}",Tests that pulling the first value from a string list and converting it to a type enum will match.,1
1793,"public void TestHasManyEnumConversionFailed() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Six"",
""Seven"",
""Invalid""
}
}
};
Assert.IsFalse(parameter.HasMany<ExecutableEnum>());
}","Tests that if a single value in the string array cannot be converted to the enum type then it does not ""have many"" of that enum type.",1
1794,"public void TestHasManyEnumConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Six"",
""Seven""
}
}
};
Assert.IsTrue(parameter.HasMany<ExecutableEnum>());
}","Tests that if an array of strings can be converted to the enum type then it does ""have many"" of the enum type.",1
1795,"public void TestHasManyEnumNoConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Six"",
""Seven""
}
}
};
Assert.IsFalse(parameter.HasMany<ExecutableEnum>(false));
}",Tests that specifying no conversion will result in false to HasMany because the exact type of enum was not found.,1
1796,"public void TestHasOneEnumConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Six""
}
}
};
Assert.IsTrue(parameter.HasOne<ExecutableEnum>());
}","Tests that if a string can be converted to a passed in enumerator type then it does ""have one""",1
1797,"public void TestHasOneEnumConversionSuccessWithMultiple() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Six"",
""Seven""
}
}
};
Assert.IsTrue(parameter.HasOne<ExecutableEnum>());
}","Tests that if a string can be converted to a passed in enumerator type then it does ""have one"", even if there are multiples to pick from.",1
1798,"public void TestHasOneEnumConversionSuccessWithMultipleAndInvalid() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Six"",
""Invalid""
}
}
};
Assert.IsTrue(parameter.HasOne<ExecutableEnum>());
}","Tests that if a string can be converted to a passed in enumerator type then it does ""have one"", even if there are multiples to pick from and them multiples beyond the first one are wrong.",1
1799,"public void TestHasOneEnumNoConversionFailure() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Six""
}
}
};
Assert.IsFalse(parameter.HasOne<ExecutableEnum>(false));
}",Tests that passing in no conversion will result in a failure from since no exact type exists of the enum,1
1800,"public void TestEventsLogged() {
var events = new EventsController();
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded
});
Assert.AreEqual(1, events.LoggedEvents.Count);
}",Tests that events are logged correctly.,1
1801,"public void TestEventsLoggedDisposed() {
var events = new EventsController();
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded
});
events.Dispose();
Assert.IsNull(events.LoggedEvents);
}",Tests that the events are disposed of correctly.,1
1802,"public void TestEventsLoggedEventFired() {
var requestWait = new AutoResetEvent(false);
var events = new EventsController();
events.EventLogged += (sender, args) => requestWait.Set();
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded
});
// This shouldn't wait at all if the event was actually fired.
Assert.IsTrue(requestWait.WaitOne(60000));
}",Tests that an event is fired whenever an event is logged.,1
1803,"public void TestEventsNoParametersWrittenToFile() {
// The current time, to the second.
DateTime now = DateTime.Now;
// When the event was logged.
DateTime then = now.AddHours(-1);
// Then, rounded to the nearest hour.
var roundedThenHour = new DateTime(then.Year, then.Month, then.Day, then.Hour, 0, 0);
var events = new EventsController();
events.Shared.Variables.Tunnel(CommandBuilder.VariablesSet(CommonVariableNames.WriteLogEventsToFile, true.ToString()).SetOrigin(CommandOrigin.Local));
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded,
Scope = new CommandData() {
Accounts = new List<AccountModel>() {
new AccountModel() {
Username = ""Phogue""
}
}
},
Stamp = then
});
events.WriteEvents();
String logFileName = events.EventsLogFileName(roundedThenHour);
var logEvent = JsonConvert.DeserializeObject<GenericEvent>(File.ReadAllText(logFileName).Trim(',', '\r', '\n'));
Assert.IsTrue(logEvent.Success);
Assert.AreEqual(""SecurityGroupAdded"", logEvent.Name);
Assert.AreEqual(""Phogue"", logEvent.Scope.Accounts.First().Username);
}",Tests that events written with the method with no parameters,1
1804,"public void TestEventsSingleWrittenToFile() {
// The current time, to the second.
DateTime now = DateTime.Now;
// When the event was logged.
DateTime then = now.AddHours(-1);
// Then, rounded to the nearest hour.
var roundedThenHour = new DateTime(then.Year, then.Month, then.Day, then.Hour, 0, 0);
var events = new EventsController();
events.Shared.Variables.Tunnel(CommandBuilder.VariablesSet(CommonVariableNames.WriteLogEventsToFile, true.ToString()).SetOrigin(CommandOrigin.Local));
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded,
Scope = new CommandData() {
Accounts = new List<AccountModel>() {
new AccountModel() {
Username = ""Phogue""
}
}
},
Stamp = then
});
events.WriteEvents(now);
String logFileName = events.EventsLogFileName(roundedThenHour);
var logEvent = JsonConvert.DeserializeObject<GenericEvent>(File.ReadAllText(logFileName).Trim(',', '\r', '\n'));
Assert.IsTrue(logEvent.Success);
Assert.AreEqual(""SecurityGroupAdded"", logEvent.Name);
Assert.AreEqual(""Phogue"", logEvent.Scope.Accounts.First().Username);
}",Tests that an event that is one hour old (older than the five minute expire time) will be written to a log file.,1
1805,"public void TestEventsUnexpiredWrittenToFile() {
// The current time, to the second.
DateTime now = DateTime.Now;
// When the event was logged.
DateTime then = now.AddHours(-1);
// Then, rounded to the nearest hour.
var roundedThenHour = new DateTime(then.Year, then.Month, then.Day, then.Hour, 0, 0);
var events = new EventsController();
events.Shared.Variables.Tunnel(CommandBuilder.VariablesSet(CommonVariableNames.WriteLogEventsToFile, true.ToString()).SetOrigin(CommandOrigin.Local));
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded,
Scope = new CommandData() {
Accounts = new List<AccountModel>() {
new AccountModel() {
Username = ""Zaeed""
}
}
},
Stamp = now
});
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded,
Scope = new CommandData() {
Accounts = new List<AccountModel>() {
new AccountModel() {
Username = ""Phogue""
}
}
},
Stamp = then
});
events.WriteEvents(now);
String logFileName = events.EventsLogFileName(roundedThenHour);
var logEvent = JsonConvert.DeserializeObject<GenericEvent>(File.ReadAllText(logFileName).Trim(',', '\r', '\n'));
Assert.IsTrue(logEvent.Success);
Assert.AreEqual(""SecurityGroupAdded"", logEvent.Name);
Assert.AreEqual(""Phogue"", logEvent.Scope.Accounts.First().Username);
}","Tests that an expired event will be written to a log file, but a non-expired event will remain in memory.",1
1806,"public void TestEventsAfterEventIdExcludingExpired() {
var events = new EventsController();
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded,
Scope = new CommandData() {
Accounts = new List<AccountModel>() {
new AccountModel() {
Username = ""Phogue""
}
}
}
});
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded,
Scope = new CommandData() {
Accounts = new List<AccountModel>() {
new AccountModel() {
Username = ""Zaeed""
}
}
},
Stamp = DateTime.Now.AddHours(-1)
});
ICommandResult result = events.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.EventsFetchAfterEventId,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
0
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(1, result.Now.Events.Count);
Assert.AreEqual(""Phogue"", result.Now.Events.First().Scope.Accounts.First().Username);
}",Tests that an event will be returned if it is after a specific ID but not if it has expired.,1
1807,"public void TestEventsAfterEventIdInsufficientPermission() {
var events = new EventsController();
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded,
Scope = new CommandData() {
Accounts = new List<AccountModel>() {
new AccountModel() {
Username = ""Phogue""
}
}
}
});
ICommandResult result = events.Tunnel(new Command() {
Authentication = {
Username = ""Phogue""
},
Origin = CommandOrigin.Remote,
CommandType = CommandType.EventsFetchAfterEventId,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
0
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that fetching events after an id without the permission to do so will result in an insufficient error being returned.,1
1808,"public void TestEventsAfterEventIdSuccess() {
var events = new EventsController();
events.Log(new GenericEvent() {
Success = true,
GenericEventType = GenericEventType.SecurityGroupAdded,
Scope = new CommandData() {
Accounts = new List<AccountModel>() {
new AccountModel() {
Username = ""Phogue""
}
}
}
});
ICommandResult result = events.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.EventsFetchAfterEventId,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
0
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(1, result.Now.Events.Count);
Assert.AreEqual(""Phogue"", result.Now.Events.First().Scope.Accounts.First().Username);
}",Tests that an event will be returned if it is after a specific ID.,1
1809,"public void TestInsufficientPermissions() {
var pushEvents = new PushEventsController();
var result = pushEvents.Tunnel(CommandBuilder.EventsEstablishJsonStream(""id"", ""http://localhost/"", ""key"", 1, new List<String>() {
""EventName""
})
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that command authentication will fail if the user does not have permission to execute the command.,1
1810,"public void TestSuccess() {
var pushEvents = new PushEventsController();
pushEvents.Shared.Security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
pushEvents.Shared.Security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
pushEvents.Shared.Security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.EventsEstablishJsonStream, 5).SetOrigin(CommandOrigin.Local));
var result = pushEvents.Tunnel(CommandBuilder.EventsEstablishJsonStream(""id"", ""http://localhost/"", ""key"", 1, new List<String>() {
""EventName""
}).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests the command is successful if the user has required permissions,1
1811,"public void TestSuccessEndPointAdded() {
var pushEvents = new PushEventsController();
pushEvents.Execute();
pushEvents.Tunnel(CommandBuilder.EventsEstablishJsonStream(""id"", ""http://localhost/"", ""key"", 10, new List<String>() {
""EventName""
}).SetOrigin(CommandOrigin.Local));
Assert.AreEqual(""id"", pushEvents.EndPoints.First().Value.Id);
Assert.AreEqual(new Uri(""http://localhost/""), pushEvents.EndPoints.First().Value.Uri);
Assert.AreEqual(""key"", pushEvents.EndPoints.First().Value.StreamKey);
Assert.AreEqual(10, pushEvents.EndPoints.First().Value.Interval);
Assert.AreEqual(new List<String>() {
""EventName""
}, pushEvents.EndPoints.First().Value.InclusiveNames);
}",Tests that a successful command will result in a end point being added.,1
1812,"public void TestSuccessEndPointAddedWithInclusiveList() {
var pushEvents = new PushEventsController();
pushEvents.Execute();
pushEvents.Tunnel(CommandBuilder.EventsEstablishJsonStream(""id"", ""http://localhost/"", ""key"", 10, new List<String>() {
""EventOne"",
""EventTwo""
}).SetOrigin(CommandOrigin.Local));
Assert.AreEqual(""id"", pushEvents.EndPoints.First().Value.Id);
Assert.AreEqual(new Uri(""http://localhost/""), pushEvents.EndPoints.First().Value.Uri);
Assert.AreEqual(""key"", pushEvents.EndPoints.First().Value.StreamKey);
Assert.AreEqual(10, pushEvents.EndPoints.First().Value.Interval);
Assert.AreEqual(new List<String>() {
""EventOne"",
""EventTwo""
}, pushEvents.EndPoints.First().Value.InclusiveNames);
}",Tests a command will successful if the inclusive list has more than one item.,1
1813,"public void TestSuccessTwoEndPointsEstablished() {
var pushEvents = new PushEventsController();
pushEvents.Execute();
pushEvents.Tunnel(CommandBuilder.EventsEstablishJsonStream(""id1"", ""http://localhost/"", ""key1"", 10, new List<String>() {
""EventName1""
}).SetOrigin(CommandOrigin.Local));
pushEvents.Tunnel(CommandBuilder.EventsEstablishJsonStream(""id2"", ""http://lolcatshost/"", ""key2"", 20, new List<String>() {
""EventName2""
}).SetOrigin(CommandOrigin.Local));
Assert.AreEqual(2, pushEvents.EndPoints.Count);
}",Tests that two end points can be established (both unique),1
1814,"public void TestSuccessTwoEndPointsSaved() {
var pushEvents = new PushEventsController();
pushEvents.Execute();
pushEvents.Tunnel(CommandBuilder.EventsEstablishJsonStream(""id1"", ""http://localhost/"", ""key1"", 10, new List<String>() {
""EventName1""
}).SetOrigin(CommandOrigin.Local));
pushEvents.Tunnel(CommandBuilder.EventsEstablishJsonStream(""id2"", ""http://lolcatshost/"", ""key2"", 20, new List<String>() {
""EventName2""
}).SetOrigin(CommandOrigin.Local));
Assert.AreEqual(2, pushEvents.Shared.Variables.FlashVariables.First(archive => archive.Key.ToLower() == CommonVariableNames.EventsPushConfigGroups.ToString().ToLower()).Value.ToList<String>().Count);
}",Tests that two end points are saved to the config,1
1815,"public void TestSuccessPreviouslySetupWillReflash() {
var pushEvents = new PushEventsController();
// Set an existing value for the EventsPushConfigGroups
pushEvents.Shared.Variables.Tunnel(CommandBuilder.VariablesSet(CommonVariableNames.EventsPushConfigGroups, ""id1"").SetOrigin(CommandOrigin.Local));
pushEvents.Execute();
// Setup a end point to use previously set EventsPushConfigGroups id
pushEvents.Tunnel(CommandBuilder.EventsEstablishJsonStream(""id1"", ""http://localhost/"", ""key1"", 10, new List<String>() {
""EventName1""
}).SetOrigin(CommandOrigin.Local));
// This id should be set in the config.
Assert.AreEqual(1, pushEvents.Shared.Variables.FlashVariables.First(archive => archive.Key.ToLower() == CommonVariableNames.EventsPushConfigGroups.ToString().ToLower()).Value.ToList<String>().Count);
}","Bugfix where a config name already existed in EventsPushConfigGroups so the variable wouldn't be added and saved to the flash value. This logic made sense when dealing with archive values, because the value would always be there on next save, but it did mean that every second load the UI wouldn't hear from the loaded service because the EventsPushConfigGroups was never saved.",1
1816,"public void TestResultInsufficientPermissions() {
EventsController events = new EventsController();
ICommandResult result = events.Tunnel(CommandBuilder.EventsLog(new GenericEvent() {
Name = ""Nothing""
}).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that attempting the command without any users in the security controller will result in insufficient permissions,1
1817,"public void TestResultSuccess() {
EventsController events = new EventsController();
ICommandResult result = events.Tunnel(CommandBuilder.EventsLog(new GenericEvent() {
Name = ""Nothing""
}).SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that the packages can be fetched (or initiated a fetch) using the command with permissions.,1
1818,"public void TestExecutableBasicCustomSet() {
var tester = new ExecutableBasicTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
Name = ""CustomSet"",
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
50.ToString(CultureInfo.InvariantCulture)
}
}
}
}
});
Assert.AreEqual(tester.TestNumber, 50);
}",Tests a custom name of a method will be called.,1
1819,"public void TestExecutableBasicCustomSetInvalidTypeCast() {
var tester = new ExecutableBasicTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
Name = ""CustomSet"",
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
""cheese""
}
}
}
}
});
Assert.AreEqual(tester.TestNumber, 0);
}","Tests that even when a custom name is used, an invalid type cast will still ignore the method.",1
1820,"public void TestExecutableBasicCustomSetValidTypeCast() {
var tester = new ExecutableBasicTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
Name = ""CustomSet"",
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
""50""
}
}
}
}
});
Assert.AreEqual(tester.TestNumber, 50);
}","Tests that even when a custom name is used, a valid type cast will still be completed.",1
1821,"public void TestExecutableBasicGet() {
var tester = new ExecutableBasicTester() {
TestNumber = 33
};
ICommandResult result = tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesGet
});
// ICommandResult result = tester.Execute(Command.Local, new CommandExecutableAttribute() { CommandType = CommandType.VariablesGet });
Assert.AreEqual(tester.TestNumber, result.Now.Variables.First().ToType<int>());
}",Tests we can return a value from a command execution.,1
1822,"public void TestExecutableBasicSet() {
var tester = new ExecutableBasicTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
50.ToString(CultureInfo.InvariantCulture)
}
}
}
}
});
Assert.AreEqual(tester.TestNumber, 50);
}",Tests we can match and set a VariableModel in a executable class.,1
1823,"public void TestExecutableBasicSetInvalidTypeCast() {
var tester = new ExecutableBasicTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
""cheese""
}
}
}
}
});
Assert.AreEqual(tester.TestNumber, 0);
}",Tests that an invalid cast will ignore the method completely.,1
1824,"public void TestExecutableBasicSetValidTypeCast() {
var tester = new ExecutableBasicTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
""50""
}
}
}
}
});
Assert.AreEqual(tester.TestNumber, 50);
}",Tests that if a valid cast exists the value will be converted to match the signature of the method.,1
1825,"public void TestExecutableDisposedEvent() {
var requestWait = new AutoResetEvent(false);
var tester = new ExecutableBasicTester();
tester.Disposed += (sender, args) => requestWait.Set();
tester.Dispose();
Assert.IsTrue(requestWait.WaitOne(60000));
}",Tests that the disposed method is fired when an executable object is disposed.,1
1826,"public void TestExecutableEnumParser() {
var tester = new ExecutableEnumTester();
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
ExecutableEnum.Seven.ToString()
}
}
}
}
});
Assert.AreEqual(ExecutableEnum.Seven, tester.TestExecutableEnum);
}",Tests that a enumerator will be passed through with the same type.,1
1827,"public void TestExecutableEnumParserFlags() {
var tester = new ExecutableEnumTester();
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
ExecutableFlagsEnum.Three.ToString()
}
}
}
}
});
Assert.AreEqual(ExecutableFlagsEnum.Three, tester.TestExecutableFlagsEnum);
}",Tests that a flag enumerator will be passed through with the same type.,1
1828,"public void TestExecutableEnumParserTypeConversion() {
var tester = new ExecutableEnumTester();
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
""Eight""
}
}
}
}
});
Assert.AreEqual(ExecutableEnum.Eight, tester.TestExecutableEnum);
}",Tests that a string value will be converted to a enumerator.,1
1829,"public void TestExecutablePreviewSetPassThrough() {
var tester = new ExecutableExecutedTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
50.ToString(CultureInfo.InvariantCulture)
}
}
}
}
});
Assert.AreEqual(tester.TestNumber, 50);
Assert.AreEqual(tester.ExecutedTestValue, 100);
}",Tests we can match and set a VariableModel in a executable class.,1
1830,"public void TestExecutableOverrideSetObject() {
var tester = new ExecutableOverrideTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""166.7""
}
}
}
}
});
Assert.AreEqual(166, tester.TestNumber);
}",Tests that an overridden method can still be called with an object parameter in the signature. Ignored for now since no localization makes it fail on different systems around the world.,1
1831,"public void TestExecutableOverrideSetPrimitive() {
var tester = new ExecutableOverrideTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
50.ToString(CultureInfo.InvariantCulture)
}
}
}
}
});
Assert.AreEqual(50, tester.TestNumber);
}",Tests that an overridden method can still be called with a primitive signature.,1
1832,"public void TestExecutablePreviewSetCancel() {
var tester = new ExecutablePreviewTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
10.ToString(CultureInfo.InvariantCulture)
}
}
}
}
});
Assert.AreEqual(0, tester.TestNumber);
}",Tests we can match and set a VariableModel in a executable class.,1
1833,"public void TestExecutablePreviewSetPassThrough() {
var tester = new ExecutablePreviewTester() {
TestNumber = 0
};
tester.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
50.ToString(CultureInfo.InvariantCulture)
}
}
}
}
});
Assert.AreEqual(tester.TestNumber, 50);
}",Tests we can match and set a VariableModel in a executable class.,1
1834,"public void TestObservableStarted() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.ExecuteMessage(new ServiceMessage());
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}",Tests the service controller obserable object is set to Started,1
1835,"public void TestMethodCalledExecuteMessage() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.ExecuteMessage(new ServiceMessage());
Assert.IsTrue(((MockServiceLoaderProxy)service.ServiceLoaderProxy).OnExecuteMessage);
service.Dispose();
}",Tests the service ExecuteMessage method is called shortly after instantiation,1
1836,"public void TestResultMessageProcessed() {
var signaled = false;
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy),
SignalResult = (controller, message) => signaled = true
};
service.Start();
((MockServiceLoaderProxy)service.ServiceLoaderProxy).ExecuteResultMessage = new ServiceMessage() {
Name = ""result""
};
service.ExecuteMessage(new ServiceMessage());
Assert.IsTrue(signaled);
service.Dispose();
}",Tests result is processed after executing a message,1
1837,"public void TestFileDoesNotExist() {
var certificate = new CertificateController();
Assert.IsFalse(certificate.Load(Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""DoesNotExist.pfx"")));
Assert.IsNull(certificate.Certificate);
}",Tests that a certificate will not load if the certificate does not exist.,1
1838,"public void TestNoPassword() {
var certificate = new CertificateController();
Assert.IsTrue(certificate.Load(Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""NoPassword.pfx"")));
Assert.IsNotNull(certificate.Certificate.PrivateKey);
}",Tests that a certificate can be loaded when it requires no password.,1
1839,"public void TestNoPasswordButPasswordSupplied() {
var certificate = new CertificateController();
Assert.IsFalse(certificate.Load(Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""NoPassword.pfx""), ""This is a password that isn't needed""));
Assert.IsNull(certificate.Certificate);
}","Tests that a certificate will not be loaded if the certificate requires no password, but a password is supplied.",1
1840,"public void TestPassword() {
var certificate = new CertificateController();
Assert.IsTrue(certificate.Load(Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""Password.pfx""), ""password1""));
Assert.IsNotNull(certificate.Certificate.PrivateKey);
}",Tests that a certificate can be loaded when when it requires a password.,1
1841,"public void TestPasswordButNoPasswordSupplied() {
var certificate = new CertificateController();
Assert.IsFalse(certificate.Load(Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""Password.pfx"")));
Assert.IsNull(certificate.Certificate);
}","Tests that a certificate will not be loaded when when it requires a password, but the password supplied is incorrect.",1
1842,"public void TestPasswordButIncorrectPasswordSupplied() {
var certificate = new CertificateController();
Assert.IsFalse(certificate.Load(Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""Password.pfx""), ""incorrect password""));
Assert.IsNull(certificate.Certificate);
}","Tests that a certificate will not be loaded when when it requires a password, but the password supplied isn't supplied.",1
1843,"public void TestEventLoggedOnFileDoesNotExist() {
var events = new EventsController();
var certificate = new CertificateController() {
Shared = {
Events = events
}
};
Assert.IsFalse(certificate.Load(Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""DoesNotExist.pfx"")));
Assert.IsNotEmpty(events.LoggedEvents);
Assert.IsFalse(events.LoggedEvents.First(e => e.Name == GenericEventType.CommandServerStarted.ToString()).Success);
}",Tests that an event will be logged when attempting to load a certificate that does not exist.,1
1844,"public void TestEventLoggedOnNoPasswordButPasswordSupplied() {
var events = new EventsController();
var certificate = new CertificateController() {
Shared = {
Events = events
}
};
Assert.IsFalse(certificate.Load(Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""NoPassword.pfx""), ""This is a password that isn't needed""));
Assert.IsNotEmpty(events.LoggedEvents);
Assert.IsFalse(events.LoggedEvents.First(e => e.Name == GenericEventType.CommandServerStarted.ToString()).Success);
}",Tests that an event is logged when a password is supplied to a certificate that does not require a password.,1
1845,"public void TestEventLoggedOnPasswordButNoPasswordSupplied() {
var events = new EventsController();
var certificate = new CertificateController() {
Shared = {
Events = events
}
};
Assert.IsFalse(certificate.Load(Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""Password.pfx"")));
Assert.IsNotEmpty(events.LoggedEvents);
Assert.IsFalse(events.LoggedEvents.First(e => e.Name == GenericEventType.CommandServerStarted.ToString()).Success);
}",Tests that an event is logged when no password is supplied for a certificate that requires a password.,1
1846,"public void TestEventLoggedOnPasswordButIncorrectPasswordSupplied() {
var events = new EventsController();
var certificate = new CertificateController() {
Shared = {
Events = events
}
};
Assert.IsFalse(certificate.Load(Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""Password.pfx""), ""incorrect password""));
Assert.IsNotEmpty(events.LoggedEvents);
Assert.IsFalse(events.LoggedEvents.First(e => e.Name == GenericEventType.CommandServerStarted.ToString()).Success);
}",Tests that an event is logged when an incorrect password is supplied for a certificate,1
1847,"public void TestExactMatchSuccess() {
var language = (LanguageController)new LanguageController().Execute();
var config = language.FindOptimalLanguageConfig(""en-GB"");
Assert.AreEqual(""en-GB"", config.LanguageModel.LanguageCode);
}",Tests that providing the exact language code gives us the exact language we're looking for.,1
1848,"public void TestDifferentCaseMatchSuccess() {
var language = (LanguageController)new LanguageController().Execute();
var config = language.FindOptimalLanguageConfig(""en-gb"");
Assert.AreEqual(""en-GB"", config.LanguageModel.LanguageCode);
}",Tests that providing the exact language code gives us the exact language we're looking for.,1
1849,"public void TestKickPhogueCommaMorpheus() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick phogue, morpheus(aut)"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerMorpheus
}, new List<MapModel>());
}",Kicks Phogue and morpheus using a comma to seperate the two items.,1
1850,"public void TestComplexKickPlayersEqualToPing() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick players with ping equal to 50"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue
}, new List<MapModel>());
}",Kick everyone with a ping equal to a specific number,1
1851,"public void TestComplexKickPlayersGreaterThanPing() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick players with ping greater than 300"", TextCommandKick, new List<PlayerModel>() {
PlayerEBassie,
PlayerZaeed,
PlayerPhogueIsAButterfly
}, new List<MapModel>());
}",Kick everyone with a ping greater than a specific number.,1
1852,"public void TestComplexKickPlayersGreaterThanorEqualToPing() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick players with ping gteq 300"", TextCommandKick, new List<PlayerModel>() {
PlayerEBassie,
PlayerZaeed,
PlayerPhogueIsAButterfly,
PlayerPapaCharlie9
}, new List<MapModel>());
}",Kick everyone with a ping greater than a specific number.,1
1853,"public void TestComplexKickPlayersLessThanOrEqualToPing() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick players with ping lteq 100"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerSayaNishino,
PlayerMrDiacritic,
PlayerImisnew2
}, new List<MapModel>());
}",Kick everything with a ping less than or equal to a specific number.,1
1854,"public void TestComplexKickPlayersLessThanPing() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick players with ping less than 100"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerSayaNishino,
PlayerMrDiacritic
}, new List<MapModel>());
}",Kick everything with a ping less than a specific number.,1
1855,"public void TestComplexKickPlayersWithinRangeOfPing() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick players with ping gteq 50 and ping lteq 100"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerImisnew2
}, new List<MapModel>());
}",Kick everyone within a range of pings,1
1856,"public void TestComplexKickPlayersWithinRangeOfPingAndScoreEqualTo1000() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick players with ping gteq 50 and ping lteq 100 and score = 1000"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue
}, new List<MapModel>());
}",Kick everyone within a range of pings and a score equal to a set number.,1
1857,"public void TestKickEveryoneWithExclusionOnPhoguePhilImpliedJoin() {
TextCommandController textCommandController = CreateTextCommandController();
AssertCommandPlayerListMapList(textCommandController, ""kick everyone but not phogue phil"", TextCommandKick, textCommandController.Connection.ProtocolState.Players.Values.Except(new List<PlayerModel>() {
PlayerPhogue,
PlayerPhilK
}).ToList(), new List<MapModel>());
}",Tests that sets won't be combined if not all of the types match.,1
1858,"public void TestKickPhoguePhilkImpliedJoin() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick phogue phil"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerPhilK
}, new List<MapModel>());
}","Kicks Phogue and Philk with no joining character, implying a join into a single list.",1
1859,"public void TestKickPhoguePhilkImpliedJoinGarbageIke() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick phogue phil garbage ike"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerPhilK,
PlayerIke
}, new List<MapModel>());
}",Tests combining a set with a single thing of a matching type with a garbage separator that will be thrown out during reduction.,1
1860,"public void TestKickPhoguePhilkImpliedJoinGarbageIkeZaeedImpliedJoin() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick phogue phil, zaeed ike"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerPhilK,
PlayerIke,
PlayerZaeed
}, new List<MapModel>());
}",Tests combining two sets of information by placing a garbage string between two sets which will be thrown out during reduction.,1
1861,"public void TestKickPhoguePhilkImpliedJoinWithImpliedJoinPortValdez() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick phogue phil port valdez"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerPhilK
}, new List<MapModel>() {
MapPortValdez
});
}",Tests that sets won't be combined if not all of the types match.,1
1862,"public void TestKickPhoguePhilkImpliedJoinWithLogicalAndJoinIke() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick phogue phil and ike"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerPhilK,
PlayerIke
}, new List<MapModel>());
}",Tests combining a set with a single thing of a matching type with a logical and join,1
1863,"public void TestKickPhoguePhilkImpliedJoinWithLogicalAndJoinIkeZaeedImpliedJoin() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick phogue phil and zaeed ike"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerPhilK,
PlayerIke,
PlayerZaeed
}, new List<MapModel>());
}",Tests combining two sets of information using a logical and join.,1
1864,"public void TestKickPhoguePhilkLogicalAndJoin() {
AssertCommandPlayerListMapList(CreateTextCommandController(), ""kick phogue and phil"", TextCommandKick, new List<PlayerModel>() {
PlayerPhogue,
PlayerPhilK
}, new List<MapModel>());
}",Kicks Phogue and Philk using a logical join between the two things.,1
1865,"public void TestNullTokenReturnedWhenAccountEmpty() {
AccessTokenModel accessToken = new AccessTokenModel();
var token = accessToken.Generate(TestGenerate.Identifer);
Assert.IsNull(token);
}",Tests a null (no) token is returned if no one owns the access token.,1
1866,"public void TestNullTokenReturnedWhenAccountHashNull() {
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
PasswordHash = null
}
};
var token = accessToken.Generate(TestGenerate.Identifer);
Assert.IsNull(token);
}",Tests a null (no) token is returned if some one owns the token but they have no password hash set.,1
1867,"public void TestNullTokenReturnedWhenAccountHashEmpty() {
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
PasswordHash = """"
}
};
var token = accessToken.Generate(TestGenerate.Identifer);
Assert.IsNull(token);
}",Tests a null (no) token is returned if some one owns the token but they have an empty password hash set.,1
1868,"public void TestNullTokenReturnedWhenIdentiferNull() {
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
PasswordHash = ""password""
}
};
var token = accessToken.Generate(null);
Assert.IsNull(token);
}",Tests a null (no) token is returned if the identifer is nulled out,1
1869,"public void TestNullTokenReturnedWhenIdentiferEmpty() {
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
PasswordHash = ""password""
}
};
var token = accessToken.Generate("""");
Assert.IsNull(token);
}",Tests a null (no) token is returned if the identifer is empty,1
1870,"public void TestGoodTokenReturnedWhenAllCredentialsPassed() {
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
PasswordHash = ""password""
}
};
var token = accessToken.Generate(""192.168.1.1"");
Assert.IsNotNull(token);
}",Tests a token is returned when all required credentials exist.,1
1871,"public void TestReturnedTokenIsRandom() {
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
PasswordHash = ""password""
}
};
var tokenA = accessToken.Generate(""192.168.1.1"");
var tokenB = accessToken.Generate(""192.168.1.1"");
Assert.IsNotNull(tokenA);
Assert.IsNotNull(tokenB);
Assert.AreNotEqual(tokenA, tokenB);
}",Simply tests with identical credentials that two random tokens are generated.,1
1872,"public void TestLastTouchedResetToCurrentDateTime() {
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
PasswordHash = ""password""
},
LastTouched = DateTime.Now.AddDays(-1)
};
var token = accessToken.Generate(""192.168.1.1"");
Assert.IsNotNull(token);
Assert.GreaterOrEqual(accessToken.LastTouched, DateTime.Now.AddMinutes(-1));
}",Tests the last touched parameter is set,1
1873,"public void TestByTokenIdDoesNotExist() {
Guid tokenId = Guid.NewGuid();
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""Phogue"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", tokenId, ""Token Hash"", DateTime.Now).SetOrigin(CommandOrigin.Local));
AccountModel account = security.GetAccount(Guid.NewGuid());
// Validate the account was not found
Assert.IsNull(account);
}","Tests that if no account exists with the specified access token, no account is returned.",1
1874,"public void TestAddNewCachedSourceRepository() {
var packages = new ServicePackageManager();
Assert.IsEmpty(packages.SourceRepositories);
IPackageRepository repository = packages.GetCachedSourceRepository(Defines.PackagesDirectory.FullName);
Assert.AreEqual(Defines.PackagesDirectory.FullName, repository.Source);
}",Tests that an empty repository source cache will have a new repository made and added to the cache.,1
1875,"public void TestRepositoryPulledFromCache() {
var sources = new ConcurrentDictionary<String, IPackageRepository>();
sources.TryAdd(Defines.PackagesDirectory.FullName, PackageRepositoryFactory.Default.CreateRepository(Defines.PackagesDirectory.FullName));
var packages = new ServicePackageManager() {
SourceRepositories = sources
};
Assert.IsNotEmpty(packages.SourceRepositories);
Assert.AreEqual(1, packages.SourceRepositories.Count);
IPackageRepository repository = packages.GetCachedSourceRepository(Defines.PackagesDirectory.FullName);
Assert.AreEqual(Defines.PackagesDirectory.FullName, repository.Source);
Assert.AreEqual(1, packages.SourceRepositories.Count);
}",Tests that a source repository will be pulled from the source cache,1
1876,"public void CleanPackagesDirectory() {
this.TestGetProtocolAssembliesDirectory.Refresh();
if (this.TestGetProtocolAssembliesDirectory.Exists) {
this.TestGetProtocolAssembliesDirectory.Delete(true);
}
this.TestGetProtocolAssembliesDirectory.Create();
}",Clears out all files in the packages directory and ensures the packages directory is created.,1
1877,"public void TestAllProtocolAssembliesFilesFoundInPackageRoot() {
var dll = new FileInfo(Path.Combine(this.TestGetProtocolAssembliesDirectory.FullName, ""Something.Protocols.Something"", ""Something.Protocols.Something.dll""));
if (dll.Directory != null) dll.Directory.Create();
File.WriteAllText(dll.FullName, @""binary"");
var protocols = new ProtocolController() {
PackagesDirectory = this.TestGetProtocolAssembliesDirectory
};
var files = protocols.GetProtocolAssemblies();
Assert.AreEqual(1, files.Count);
Assert.AreEqual(dll.FullName, files.First().FullName);
}","Tests that a file matching the pattern ""*.Protocols.*.dll"" is found",1
1878,"public void TestNonProtocolAssemblyNotDiscovered() {
var dll = new FileInfo(Path.Combine(this.TestGetProtocolAssembliesDirectory.FullName, ""Something.Protocols.Something"", ""Something.Protocols.Something.dll""));
var json = new FileInfo(Path.Combine(this.TestGetProtocolAssembliesDirectory.FullName, ""Something.Protocols.Something"", ""Something.Protocols.Something.json""));
if (dll.Directory != null) dll.Directory.Create();
File.WriteAllText(dll.FullName, @""binary"");
File.WriteAllText(json.FullName, @""{ }"");
var protocols = new ProtocolController() {
PackagesDirectory = this.TestGetProtocolAssembliesDirectory
};
var files = protocols.GetProtocolAssemblies();
Assert.AreEqual(1, files.Count);
Assert.AreEqual(dll.FullName, files.First().FullName);
}","Tests that anything not matching the file pattern ""*.Protocols.*.dll"" is not found",1
1879,"public void CleanPackagesDirectory() {
this.TestTestGetProtocolPackages.Refresh();
if (this.TestTestGetProtocolPackages.Exists) {
this.TestTestGetProtocolPackages.Delete(true);
}
this.TestTestGetProtocolPackages.Create();
}",Clears out all files in the packages directory and ensures the packages directory is created.,1
1880,"public void TestPackageDirectoryReturnedSingleDepth() {
DirectoryInfo package = new DirectoryInfo(Path.Combine(this.TestTestGetProtocolPackages.FullName, ""Something.Protocols.Something""));
var dll = new FileInfo(Path.Combine(package.FullName, ""Something.Protocols.Something.dll""));
if (dll.Directory != null) dll.Directory.Create();
File.WriteAllText(dll.FullName, @""binary"");
var protocols = new ProtocolController() {
PackagesDirectory = this.TestTestGetProtocolPackages
};
var packages = protocols.GetProtocolPackages(new List<FileInfo>() { dll });
Assert.AreEqual(1, packages.Count);
Assert.AreEqual(package.FullName, packages.First().FullName);
}",Tests that the package directory will be returned at a single depth,1
1881,"public void TestPackageDirectoryReturnedSecondDepth() {
DirectoryInfo package = new DirectoryInfo(Path.Combine(this.TestTestGetProtocolPackages.FullName, ""Something.Protocols.Something""));
var dll = new FileInfo(Path.Combine(package.FullName, ""SubDirectory"", ""Something.Protocols.Something.dll""));
if (dll.Directory != null) dll.Directory.Create();
File.WriteAllText(dll.FullName, @""binary"");
var protocols = new ProtocolController() {
PackagesDirectory = this.TestTestGetProtocolPackages
};
var packages = protocols.GetProtocolPackages(new List<FileInfo>() { dll });
Assert.AreEqual(1, packages.Count);
Assert.AreEqual(package.FullName, packages.First().FullName);
}",Tests the package directory will be returned if the assembly is in a sub directory of the package,1
1882,"public void TestLatestPackagePathReturned() {
DirectoryInfo latest = new DirectoryInfo(Path.Combine(this.TestTestGetProtocolPackages.FullName, ""Something.Protocols.Something.2.0.0""));
DirectoryInfo oldest = new DirectoryInfo(Path.Combine(this.TestTestGetProtocolPackages.FullName, ""Something.Protocols.Something.1.0.0""));
var latestDll = new FileInfo(Path.Combine(latest.FullName, ""SubDirectory"", ""Something.Protocols.Something.dll""));
if (latestDll.Directory != null) latestDll.Directory.Create();
File.WriteAllText(latestDll.FullName, @""binary"");
var oldestDll = new FileInfo(Path.Combine(oldest.FullName, ""SubDirectory"", ""Something.Protocols.Something.dll""));
if (oldestDll.Directory != null) oldestDll.Directory.Create();
File.WriteAllText(oldestDll.FullName, @""binary"");
var protocols = new ProtocolController() {
PackagesDirectory = this.TestTestGetProtocolPackages
};
var packages = protocols.GetProtocolPackages(new List<FileInfo>() { latestDll, oldestDll });
Assert.AreEqual(1, packages.Count);
Assert.AreEqual(latest.FullName, packages.First().FullName);
}","Tests that if multiple versions of identical packages exist, we will get the latest version returned.",1
1883,"public void TestAllGuidConversionFailure() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""9D2B0228-4D0D-4C23-8B49-01A698857709"",
""f380eb1e-1438-48c0-8c3d-ad55f2d40538"",
""Invalid""
}
}
};
var items = parameter.All(typeof(Guid)) as List<Object>;
Assert.IsNull(items);
}",Tests that if all values can't be converted to guids then the result will return null.,1
1884,"public void TestFirstGuidConversionFailed() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Invalid""
}
}
};
Assert.AreEqual(default(Guid), parameter.First<Guid>());
}",Tests that the default is returned when a conversion does not exist for a given type.,1
1885,"public void TestFirstGuidConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""9D2B0228-4D0D-4C23-8B49-01A698857709""
}
}
};
Assert.AreEqual(new Guid(""9D2B0228-4D0D-4C23-8B49-01A698857709""), parameter.First<Guid>());
}",Tests that we can pull and convert the first value from a list of strings to an guid,1
1886,"public void TestHasManyGuidConversionFailed() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""9D2B0228-4D0D-4C23-8B49-01A698857709"",
""f380eb1e-1438-48c0-8c3d-ad55f2d40538"",
""Invalid""
}
}
};
Assert.IsFalse(parameter.HasMany<Guid>());
}","Tests that if a single value in the string array cannot be converted to the guid type then it does not ""have many"" of type guid.",1
1887,"public void TestHasManyGuidConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""9D2B0228-4D0D-4C23-8B49-01A698857709"",
""f380eb1e-1438-48c0-8c3d-ad55f2d40538""
}
}
};
Assert.IsTrue(parameter.HasMany<Guid>());
}","Tests that if an array of strings can be converted to the guid type then it does ""have many"" of the type guid.",1
1888,"public void TestHasOneIntegerConversionFailure() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""one""
}
}
};
Assert.IsFalse(parameter.HasOne<Guid>());
}","Tests if no conversion exists for the string to the type then it does not ""have one"" of that type.",1
1889,"public void TestHasOneGuidConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""9D2B0228-4D0D-4C23-8B49-01A698857709""
}
}
};
Assert.IsTrue(parameter.HasOne<Guid>());
}","Tests that if a string can be converted to an guid then the parameter does ""have one"" of type guid.",1
1890,"public void TestHasOneGuidConversionSuccessWithMultiple() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""9D2B0228-4D0D-4C23-8B49-01A698857709"",
""f380eb1e-1438-48c0-8c3d-ad55f2d40538""
}
}
};
Assert.IsTrue(parameter.HasOne<Guid>());
}","Tests that if a string can be converted to an guid then the parameter does ""have one"" of type guid even when multiple string exist",1
1891,"public void TestHasOneGuidConversionSuccessWithMultipleAndInvalid() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""9D2B0228-4D0D-4C23-8B49-01A698857709"",
""Invalid""
}
}
};
Assert.IsTrue(parameter.HasOne<Guid>());
}","Tests that if a string can be converted to an guid then the parameter does ""have one"" of type guid even when multiple string exist and anything beyond the first string is invalid",1
1892,"public static List<ICommandParameter> ObjectListToContentList(List<Object> parameters) {
return parameters.Select(param => new CommandParameter() {
Data = {
Content = new List<string>() {
param.ToString()
}
}
}).Cast<ICommandParameter>().ToList();
}",This is implemented to convert from the old method of parsing parameters to the new.,1
1893,"public void TestAllIntegerConversionFailure() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1"",
""2"",
""Invalid""
}
}
};
var items = parameter.All(typeof (int)) as List<Object>;
Assert.IsNull(items);
}",Tests that if all values can't be converted to integers then the result will return null.,1
1894,"public void TestFirstIntegerConversionFailed() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""Invalid""
}
}
};
Assert.AreEqual(default(int), parameter.First<int>());
}",Tests that the default is returned when a conversion does not exist for a given type.,1
1895,"public void TestFirstIntegerConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1""
}
}
};
Assert.AreEqual(1, parameter.First<int>());
}",Tests that we can pull and convert the first value from a list of strings to an integer,1
1896,"public void TestHasManyIntegerConversionFailed() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1"",
""2"",
""Invalid""
}
}
};
Assert.IsFalse(parameter.HasMany<int>());
}","Tests that if a single value in the string array cannot be converted to the integer type then it does not ""have many"" of type integer.",1
1897,"public void TestHasManyIntegerConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1"",
""2""
}
}
};
Assert.IsTrue(parameter.HasMany<int>());
}","Tests that if an array of strings can be converted to the integer type then it does ""have many"" of the type integer.",1
1898,"public void TestHasOneIntegerConversionFailure() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""one""
}
}
};
Assert.IsFalse(parameter.HasOne<int>());
}","Tests if no conversion exists for the string to the type then it does not ""have one"" of that type.",1
1899,"public void TestHasOneIntegerConversionSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1""
}
}
};
Assert.IsTrue(parameter.HasOne<int>());
}","Tests that if a string can be converted to an integer then the parameter does ""have one"" of type integer.",1
1900,"public void TestHasOneIntegerConversionSuccessWithMultiple() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1"",
""2""
}
}
};
Assert.IsTrue(parameter.HasOne<int>());
}","Tests that if a string can be converted to an integer then the parameter does ""have one"" of type integer even when multiple string exist",1
1901,"public void TestHasOneIntegerConversionSuccessWithMultipleAndInvalid() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1"",
""Invalid""
}
}
};
Assert.IsTrue(parameter.HasOne<int>());
}","Tests that if a string can be converted to an integer then the parameter does ""have one"" of type integer even when multiple string exist and anything beyond the first string is invalid",1
1902,"public void DeleteTestPathDirectory() {
this.TestPath.Refresh();
if (this.TestPath.Exists == true) {
this.TestPath.Delete(true);
}
this.TestPath.Create();
}",Deletes the errors logs directory if it exists.,1
1903,"public void TestMetaFileSetOnObject() {
var meta = new ProtocolAssemblyMetadata();
meta.Load(this.TestPath.FullName);
Assert.AreEqual(Path.Combine(this.TestPath.FullName, ""Myrcon.Protocols.Frostbite.json""), meta.Meta.FullName);
}",Tests the meta file path is set correctly,1
1904,"public void TestAssemblyFileSetOnObject() {
var assembly = new ProtocolAssemblyMetadata();
assembly.Load(this.TestPath.FullName);
Assert.AreEqual(Path.Combine(this.TestPath.FullName, ""Myrcon.Protocols.Frostbite.dll""), assembly.Assembly.FullName);
}",Tests the assembly file path is set correctly,1
1905,"public void TestFailureWhenDllFileNotFound() {
File.WriteAllText(Path.Combine(this.TestPath.FullName, ""Myrcon.Protocols.Frostbite.json""), ""{}"");
var result = new ProtocolAssemblyMetadata().Load(this.TestPath.FullName);
Assert.IsFalse(result);
}",Tests the load will fail when no dll is found,1
1906,"public void TestFailureWhenJsonFileNotFound() {
File.WriteAllText(Path.Combine(this.TestPath.FullName, ""Myrcon.Protocols.Frostbite.dll""), ""binary"");
var result = new ProtocolAssemblyMetadata().Load(this.TestPath.FullName);
Assert.IsFalse(result);
}",Tests the load will fail when no json is found,1
1907,"public void TestJsonIntegrity() {
foreach (var file in Directory.EnumerateFiles(TestLoad.ConfigDirectory, ""*.json"", SearchOption.AllDirectories)) {
var config = ProtocolConfigLoader.Load<ProtocolConfigModel>(file);
Assert.IsNotNull(config, ""Failed to load config {0}. Validate json structure."", Path.GetFileName(file));
}
}",Checks all configs can be loaded (no json errors),1
1908,"public void TestMapGamemodeIntegrity() {
foreach (var file in Directory.EnumerateFiles(TestLoad.ConfigDirectory, ""*.json"", SearchOption.AllDirectories)) {
var config = ProtocolConfigLoader.Load<ProtocolConfigModel>(file);
foreach (var map in config.MapPool) {
Assert.IsNotNull(map.GameMode, ""Missing game mode for map {0} {1}"", map.Name, map.FriendlyName);
}
}
}",Loads all game configs and ensures all maps have a game mode.,1
1909,"public void TestSingleDocumentNotNull() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA.Directory);
Assert.IsNotNull(config.Document);
}",Tests that the document is populated after loading,1
1910,"public void TestSingleRootNotNull() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA.Directory);
Assert.IsNotNull(config.Root);
}",Tests that the root is populated after loading,1
1911,"public void TestSingleRootSetToFilePath() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA.Directory);
Assert.AreEqual(""Phogue"", config.Root.First[""Name""].Value<String>());
Assert.AreEqual(100, config.Root.First[""Age""].Value<int>());
}",Tests that the root element is set if a property exists with the same filename.,1
1912,"public void TestUnionedDocumentNotNull() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
File.WriteAllText(this.ConfigFileB.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.AlternativeName"""": [ { """"Name"""":""""Ike"""", """"Age"""": 10 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA.Directory);
Assert.IsNotNull(config.Document);
}",Tests that the document is populated after loading,1
1913,"public void TestUnionedRootNotNull() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
File.WriteAllText(this.ConfigFileB.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.AlternativeName"""": [ { """"Name"""":""""Ike"""", """"Age"""": 10 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA.Directory);
Assert.IsNotNull(config.Root);
}",Tests that the root is populated after loading,1
1914,"public void TestUnionedRootSetToFirstFilePath() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
File.WriteAllText(this.ConfigFileB.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.AlternativeName"""": [ { """"Name"""":""""Ike"""", """"Age"""": 10 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA.Directory);
Assert.AreEqual(""Ike"", config.Root.First[""Name""].Value<String>());
Assert.AreEqual(10, config.Root.First[""Age""].Value<int>());
}",Tests that the root element is set if a property exists with the same filename. Files are loaded in alphabetical order.,1
1915,"public void TestUnionedDocumentContainsAlternativeToRoot() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
File.WriteAllText(this.ConfigFileB.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.AlternativeName"""": [ { """"Name"""":""""Ike"""", """"Age"""": 10 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA.Directory);
Assert.AreEqual(""Phogue"", config.Document[""Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete""].First[""Name""].Value<String>());
Assert.AreEqual(100, config.Document[""Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete""].First[""Age""].Value<int>());
}",Tests that the document contains the alternative data,1
1916,"public void TestUnionedWithIdenticalNamespaces() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
File.WriteAllText(this.ConfigFileB.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Ike"""", """"Age"""": 10 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA.Directory);
Assert.AreEqual(""Ike"", config.Root.First[""Name""].Value<String>());
Assert.AreEqual(10, config.Root.First[""Age""].Value<int>());
Assert.AreEqual(""Phogue"", config.Root.Last[""Name""].Value<String>());
Assert.AreEqual(100, config.Root.Last[""Age""].Value<int>());
}",Tests that the root element is set if a property exists with the same filename.,1
1917,"public void TestNullException() {
new Config().Load((DirectoryInfo)null);
}",Tests an argument null exception is raised if null is passed into union.,1
1918,"public void TestDocumentNotNull() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA);
Assert.IsNotNull(config.Document);
}",Tests that the document is populated after loading,1
1919,"public void TestRootNotNullWithMatchingProperty() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA);
Assert.IsNotNull(config.Root);
}",Tests that the root is populated after loading,1
1920,"public void TestRootNotNullWithoutMatchingProperty() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"This.Type.Does.Not.Exist"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA);
Assert.IsNotNull(config.Root);
}",Tests that the root is still populated even if no matching property is found. It will then get the first property in the document.,1
1921,"public void TestRootNotNullEmptyFile() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ }"");
IConfig config = new Config().Load(this.ConfigFileA);
Assert.IsNotNull(config.Root);
}",Tests that the root is still populated even if the resulting document is empty.,1
1922,"public void TestRootNotNullNotArray() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"This.Type.Does.Not.Exist"""": { """"Name"""":""""Phogue"""", """"Age"""": 100 } }"");
IConfig config = new Config().Load(this.ConfigFileA);
Assert.IsNotNull(config.Root);
}",Tests that the root is still populated even if the first property is not an array,1
1923,"public void TestRootSetToFilePath() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"Name"""":""""Phogue"""", """"Age"""": 100 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA);
Assert.AreEqual(""Phogue"", config.Root.First[""Name""].Value<String>());
Assert.AreEqual(100, config.Root.First[""Age""].Value<int>());
}",Tests that the root element is set if a property exists with the same filename.,1
1924,"public void TestInvalidJsonParsingNotNullRoot() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"N 100 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA);
Assert.IsNotNull(config.Root);
}",Tests that invalid json will result in an empty document/root,1
1925,"public void TestInvalidJsonParsingNotNullDocument() {
File.WriteAllText(this.ConfigFileA.FullName, @""{ """"Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"""": [ { """"N 100 } ] }"");
IConfig config = new Config().Load(this.ConfigFileA);
Assert.IsNotNull(config.Document);
}",Tests that invalid json will result in an empty document/root,1
1926,"public void TestNullException() {
new Config().Load((FileInfo) null);
}",Tests an argument null exception is raised if null is passed into union.,1
1927,"public void CleanPackagesDirectory() {
this.TestLoadProtocolsMetadataDirectory.Refresh();
if (this.TestLoadProtocolsMetadataDirectory.Exists) {
this.TestLoadProtocolsMetadataDirectory.Delete(true);
}
this.TestLoadProtocolsMetadataDirectory.Create();
}",TestLoadProtocolsMetadataDirectory Clears out all files in the packages directory and ensures the packages directory is created.,1
1928,"public void TestLoadedWithSingleVersionOfPackage() {
DirectoryInfo package = new DirectoryInfo(Path.Combine(this.TestLoadProtocolsMetadataDirectory.FullName, ""Something.Protocols.Something""));
var dll = new FileInfo(Path.Combine(package.FullName, ""lib"", ""Something.Protocols.Something.dll""));
if (dll.Directory != null) dll.Directory.Create();
File.WriteAllText(dll.FullName, @""binary"");
var json = new FileInfo(Path.Combine(package.FullName, ""Content"", ""Something.Protocols.Something.json""));
if (json.Directory != null) json.Directory.Create();
File.WriteAllText(json.FullName, @""{ }"");
var protocols = new ProtocolController() {
PackagesDirectory = this.TestLoadProtocolsMetadataDirectory
};
protocols.LoadProtocolsMetadata();
Assert.AreEqual(1, protocols.Protocols.Count);
}",Tests that a protocol is loaded from a protocol package,1
1929,"public void TestProtocolVariablesLoaded() {
DirectoryInfo package = new DirectoryInfo(Path.Combine(this.TestLoadProtocolsMetadataDirectory.FullName, ""Something.Protocols.Something""));
var dll = new FileInfo(Path.Combine(package.FullName, ""lib"", ""Something.Protocols.Something.dll""));
if (dll.Directory != null) dll.Directory.Create();
File.WriteAllText(dll.FullName, @""binary"");
var json = new FileInfo(Path.Combine(package.FullName, ""Content"", ""Something.Protocols.Something.json""));
if (json.Directory != null) json.Directory.Create();
File.WriteAllText(json.FullName, @""{ """"ProtocolTypes"""": [ { """"Provider"""": """"Myrcon"""",""""Name"""": """"Battlefield 4"""",""""Type"""": """"DiceBattlefield4"""" } ] }"");
var protocols = new ProtocolController() {
PackagesDirectory = this.TestLoadProtocolsMetadataDirectory
};
protocols.LoadProtocolsMetadata();
Assert.AreEqual(""DiceBattlefield4"", protocols.Protocols.First().ProtocolTypes.First().Type);
}","We only test the process is succesful, loading protocol metadata is tested elsewhere.",1
1930,"public void TestSingleProtocolLoadedWithMultipleVersionsOfPackage() {
DirectoryInfo newest = new DirectoryInfo(Path.Combine(this.TestLoadProtocolsMetadataDirectory.FullName, ""Something.Protocols.Something.2.0.0""));
DirectoryInfo oldest = new DirectoryInfo(Path.Combine(this.TestLoadProtocolsMetadataDirectory.FullName, ""Something.Protocols.Something.1.0.0""));
var newestdll = new FileInfo(Path.Combine(newest.FullName, ""lib"", ""Something.Protocols.Something.dll""));
if (newestdll.Directory != null) newestdll.Directory.Create();
File.WriteAllText(newestdll.FullName, @""binary"");
var newestjson = new FileInfo(Path.Combine(newest.FullName, ""Content"", ""Something.Protocols.Something.json""));
if (newestjson.Directory != null) newestjson.Directory.Create();
File.WriteAllText(newestjson.FullName, @""{ }"");
var oldestdll = new FileInfo(Path.Combine(oldest.FullName, ""lib"", ""Something.Protocols.Something.dll""));
if (oldestdll.Directory != null) oldestdll.Directory.Create();
File.WriteAllText(oldestdll.FullName, @""binary"");
var oldestjson = new FileInfo(Path.Combine(oldest.FullName, ""Content"", ""Something.Protocols.Something.json""));
if (oldestjson.Directory != null) oldestjson.Directory.Create();
File.WriteAllText(oldestjson.FullName, @""{ }"");
var protocols = new ProtocolController() {
PackagesDirectory = this.TestLoadProtocolsMetadataDirectory
};
protocols.LoadProtocolsMetadata();
Assert.AreEqual(1, protocols.Protocols.Count);
}",Tests that a single protocol will be loaded when multiple versions of the package are available.,1
1931,"public void TestLatestLoadedLoadedWithMultipleVersionsOfPackage() {
DirectoryInfo newest = new DirectoryInfo(Path.Combine(this.TestLoadProtocolsMetadataDirectory.FullName, ""Something.Protocols.Something.2.0.0""));
DirectoryInfo oldest = new DirectoryInfo(Path.Combine(this.TestLoadProtocolsMetadataDirectory.FullName, ""Something.Protocols.Something.1.0.0""));
var newestdll = new FileInfo(Path.Combine(newest.FullName, ""lib"", ""Something.Protocols.Something.dll""));
if (newestdll.Directory != null) newestdll.Directory.Create();
File.WriteAllText(newestdll.FullName, @""binary"");
var newestjson = new FileInfo(Path.Combine(newest.FullName, ""Content"", ""Something.Protocols.Something.json""));
if (newestjson.Directory != null) newestjson.Directory.Create();
File.WriteAllText(newestjson.FullName, @""{ }"");
var oldestdll = new FileInfo(Path.Combine(oldest.FullName, ""lib"", ""Something.Protocols.Something.dll""));
if (oldestdll.Directory != null) oldestdll.Directory.Create();
File.WriteAllText(oldestdll.FullName, @""binary"");
var oldestjson = new FileInfo(Path.Combine(oldest.FullName, ""Content"", ""Something.Protocols.Something.json""));
if (oldestjson.Directory != null) oldestjson.Directory.Create();
File.WriteAllText(oldestjson.FullName, @""{ }"");
var protocols = new ProtocolController() {
PackagesDirectory = this.TestLoadProtocolsMetadataDirectory
};
protocols.LoadProtocolsMetadata();
Assert.AreEqual(newest.FullName, protocols.Protocols.First().Directory.FullName);
}",Tests the latest version of the packag is loaded.,1
1932,"public void TestDeutschLocalizationControllerGetFirstDepthSearch() {
var language = (LanguageController)new LanguageController().Execute();
ICommandResult result = language.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.LanguageLocalize,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""de-DE"",
""Potato.Core.Test"",
""TestName""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""PotatoCoreTestDeutschTestValue"", result.Now.Content.First());
}",Tests that the non-default language can still be searched.,1
1933,"public void TestEnglishLocalizationControllerGet() {
var language = (LanguageController)new LanguageController().Execute();
ICommandResult result = language.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.LanguageLocalize,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""en-GB"",
""Potato.Core.Test.Localization"",
""TestName""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""PotatoCoreTestLocalizationEnglishTestValue"", result.Now.Content.First());
}",Tests that we can pull out the value of a key in a specific namespace.,1
1934,"public void TestEnglishLocalizationControllerGetCorrectFormat() {
var language = (LanguageController)new LanguageController().Execute();
ICommandResult result = language.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.LanguageLocalize,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""en-GB""
}
}
},
new CommandParameter() {
Data = {
Content = new List<String>() {
""Potato.Core.Test.Localization""
}
}
},
new CommandParameter() {
Data = {
Content = new List<String>() {
""TestFormat""
}
}
},
new CommandParameter() {
Data = {
Content = new List<String>() {
""World""
}
}
}
}
//TestHelpers.ObjectListToContentList(new List<Object>() { ""en-GB"", ""Potato.Core.Test.Localization"", ""TestFormat"", new object[] { ""World"" } })
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""Hello World!"", result.Now.Content.First());
}",Tests the command to change the default language.,1
1935,"public void TestEnglishLocalizationControllerGetDoesNotExistWhenNoDefaultPresent() {
var language = (LanguageController)new LanguageController().Execute();
language.Default = null;
ICommandResult result = language.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.LanguageLocalize,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""zu-ZU"",
""Potato.Core.Test.Localization"",
""TestKey""
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests localization will fail if the language code does not exist and no fallback is available.,1
1936,"public void TestEnglishLocalizationControllerGetDoesNotExist() {
var language = (LanguageController)new LanguageController().Execute();
ICommandResult result = language.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.LanguageLocalize,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""zu-ZU"",
""Potato.Core.Test.Localization"",
""TestName""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""PotatoCoreTestLocalizationEnglishTestValue"", result.Now.Content.First());
}",Tests a non-existant language code will fall back to the default (english),1
1937,"public void TestEnglishLocalizationControllerGetFirstDepthSearch() {
var language = (LanguageController)new LanguageController().Execute();
ICommandResult result = language.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.LanguageLocalize,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""en-GB"",
""Potato.Core.Test"",
""TestName""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""PotatoCoreTestEnglishTestValue"", result.Now.Content.First());
}",Tests that if the same key exists in the localization file,1
1938,"public void TestEnglishLocalizationControllerGetIncorrectFormat() {
var language = (LanguageController)new LanguageController().Execute();
ICommandResult result = language.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.LanguageLocalize,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""en-GB"",
""Potato.Core.Test.Localization"",
""TestFormat""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual("""", result.Now.Content.First());
}",Tests the command to change the default language.,1
1939,"public void TestEnglishLocalizationControllerGetInsufficientPermission() {
var language = (LanguageController)new LanguageController() {
Shared = {
Security = new SecurityController().Execute() as SecurityController
}
}.Execute();
ICommandResult result = language.Tunnel(new Command() {
CommandType = CommandType.LanguageLocalize,
Authentication = {
Username = ""Phogue""
},
Origin = CommandOrigin.Remote,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""en-GB"",
""Potato.Core.Test.Localization"",
""TestKey""
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a localization cannot be fetched if the user does not have permission to so.,1
1940,"public void TestEnglishLocalizationDefaultEnglish() {
var language = (LanguageController)new LanguageController().Execute();
Assert.AreEqual(""PotatoCoreTestEnglishTestValue"", language.Default.Localize(""Potato.Core.Test"", ""TestName""));
}",Tests that english is loaded the default language.,1
1941,"public void TestLanguageSetDefaultLanguage() {
var language = (LanguageController)new LanguageController().Execute();
language.Shared.Variables.Set(new Command() {
Origin = CommandOrigin.Local
}, CommonVariableNames.LocalizationDefaultLanguageCode, ""de-DE"");
Assert.AreEqual(""de-DE"", language.Default.LanguageModel.LanguageCode);
}",Tests the command to change the default language.,1
1942,"public void TestLogErrorSuccess() {
ServiceControllerHelpers.LogUnhandledException(""None"", new Exception(""Nothing""));
Assert.IsNotEmpty(Defines.ErrorsLogsDirectory.GetFiles());
Assert.Greater(Defines.ErrorsLogsDirectory.GetFiles().First().Length, 0);
}",Tests that an error will be logged to the errors log directory. We just test that a file exists and isn't 0 bytes.,1
1943,"public void TestInstallDispatchedEntryStatusIsStopped() {
var merged = false;
var service = new ServiceController() {
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, uri, packageId) => { merged = true; }
},
Observer = {
Status = ServiceStatusType.Stopped
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.MergePackage(""localhost"", ""id"");
Assert.IsTrue(merged);
service.Dispose();
}",Tests the package dispatched for install if the entry status is set to Stopped,1
1944,"public void TestInstallDispatchedEntryStatusIsStarted() {
var merged = false;
var service = new ServiceController() {
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, uri, packageId) => { merged = true; }
},
Observer = {
Status = ServiceStatusType.Started
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.MergePackage(""localhost"", ""id"");
Assert.IsTrue(merged);
service.Dispose();
}",Tests the package dispatched for install if the entry status is set to Started,1
1945,"public void TestFromStoppedEndsAsStarted() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Observer = {
Status = ServiceStatusType.Stopped
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.MergePackage(""localhost"", ""id"");
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}",Tests that from a stopped state the eventual state is Started,1
1946,"public void TestInstallCleanDispatched() {
var dispatcher = new MockPackageManagerDispatch();
var sources = new ConcurrentDictionary<String, IPackageRepository>();
sources.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
IsLatestVersion = true
}
}));
var packages = new ServicePackageManager() {
LocalRepository = new MockPackageRepository() {
Uri = Defines.PackagesDirectory.FullName
},
PackageManagerDispatch = dispatcher,
SourceRepositories = sources
};
packages.MergePackage(""localhost"", ""A"");
Assert.IsTrue(dispatcher.DispatchedInstallPackage);
}",Tests that a package will be installed when a merge package request is sent and the package is not currently installed.,1
1947,"public void TestUpdateDispatched() {
var dispatcher = new MockPackageManagerDispatch();
var sources = new ConcurrentDictionary<String, IPackageRepository>();
sources.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""2.0.0"",
IsLatestVersion = true
}
}));
var packages = new ServicePackageManager() {
LocalRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0""
}
}) {
Uri = Defines.PackagesDirectory.FullName
},
PackageManagerDispatch = dispatcher,
SourceRepositories = sources
};
packages.MergePackage(""localhost"", ""A"");
Assert.IsTrue(dispatcher.DispatchedUpdatePackage);
}",Tests that a package will be updated if a newer version is available,1
1948,"public void TestInstallAlreadyExistsCanceled() {
var canceled = false;
var sources = new ConcurrentDictionary<String, IPackageRepository>();
sources.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
IsLatestVersion = true
}
}));
var packages = new ServicePackageManager() {
LocalRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0""
}
}) {
Uri = Defines.PackagesDirectory.FullName
},
SourceRepositories = sources,
PackageActionCanceled = packageId => canceled = true,
PackageManagerDispatch = new MockPackageManagerDispatch()
};
packages.MergePackage(""localhost"", ""A"");
Assert.IsTrue(canceled);
}",Tests that the action is canceled if the package with the same version is already installed.,1
1949,"public void TestPackageMissing() {
var missing = false;
var sources = new ConcurrentDictionary<String, IPackageRepository>();
sources.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0""
}
}));
var packages = new ServicePackageManager() {
LocalRepository = new MockPackageRepository() {
Uri = Defines.PackagesDirectory.FullName
},
SourceRepositories = sources,
PackageMissing = packageId => missing = true,
PackageManagerDispatch = new MockPackageManagerDispatch()
};
packages.MergePackage(""localhost"", ""B"");
Assert.IsTrue(missing);
}",Tests that a delegate will be called if the package id is missing from a source,1
1950,"public void TestBeforeRepositoryInitialize() {
var before = false;
var packages = new ServicePackageManager() {
BeforeRepositoryInitialize = () => before = true,
PackageManagerDispatch = new MockPackageManagerDispatch()
};
packages.MergePackage(""localhost"", ""A"");
Assert.IsTrue(before);
}",Tests the initialize delegate is called when merging a package,1
1951,"public void TestBeforeSourcePackageFetch() {
var before = false;
var sources = new ConcurrentDictionary<String, IPackageRepository>();
sources.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0""
}
}));
var packages = new ServicePackageManager() {
LocalRepository = new MockPackageRepository() {
Uri = Defines.PackagesDirectory.FullName
},
SourceRepositories = sources,
BeforeSourcePackageFetch = () => before = true,
PackageManagerDispatch = new MockPackageManagerDispatch()
};
packages.MergePackage(""localhost"", ""A"");
Assert.IsTrue(before);
}",Tests the before source package fetch delegate is called when merging a package.,1
1952,"public void TestOnBeforeLocalPackageFetch() {
var before = false;
var sources = new ConcurrentDictionary<String, IPackageRepository>();
sources.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0""
}
}));
var packages = new ServicePackageManager() {
LocalRepository = new MockPackageRepository() {
Uri = Defines.PackagesDirectory.FullName
},
SourceRepositories = sources,
BeforeLocalPackageFetch = () => before = true,
PackageManagerDispatch = new MockPackageManagerDispatch()
};
packages.MergePackage(""localhost"", ""A"");
Assert.IsTrue(before);
}",Tests the before local package fetch delegate is called when merging a package.,1
1953,"public void TestSimpleCommandSuccess() {
CommandServerPacket packet = null;
CommandServerController commandServer = new CommandServerController() {
CommandServerListener = new CommandServerListener()
};
commandServer.OnPacketReceived(new MockCommandServerClient() {
SentCallback = wrapper => { packet = wrapper as CommandServerPacket; }
}, new CommandServerPacket() {
Headers = new WebHeaderCollection() {
{ HttpRequestHeader.ContentType, Mime.ApplicationJson }
},
Content = JsonConvert.SerializeObject(new Command() {
CommandType = CommandType.VariablesSet
})
});
Assert.IsNotNull(packet);
Assert.AreEqual(HttpStatusCode.OK, packet.StatusCode);
}","Tests that a simple command will be passed and a success status code will be returned, even though the authentication would have failed.",1
1954,"public void TestMalformedRequestReturnsBadRequest() {
CommandServerPacket packet = null;
CommandServerController commandServer = new CommandServerController() {
CommandServerListener = new CommandServerListener()
};
commandServer.OnPacketReceived(new MockCommandServerClient() {
SentCallback = wrapper => { packet = wrapper as CommandServerPacket; }
}, new CommandServerPacket() {
Content = ""ike"" // Subtle.
});
Assert.IsNotNull(packet);
Assert.AreEqual(HttpStatusCode.BadRequest, packet.StatusCode);
}",Tests that sending through malformed data will result in a bad request status code,1
1955,"public void TestAuthenticationSuccess() {
CommandServerPacket packet = null;
CommandServerController commandServer = new CommandServerController() {
CommandServerListener = new CommandServerListener()
};
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountSetPassword,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
""password""
})
});
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.SecurityAccountAuthenticate,
1
})
});
commandServer.OnPacketReceived(new MockCommandServerClient() {
SentCallback = wrapper => { packet = wrapper as CommandServerPacket; }
}, new CommandServerPacket() {
Headers = new WebHeaderCollection() {
{ HttpRequestHeader.ContentType, Mime.ApplicationJson }
},
Content = JsonConvert.SerializeObject(new Command() {
CommandType = CommandType.VariablesSet,
Authentication = {
Username = ""Phogue"",
PasswordPlainText = ""password""
}
})
});
Assert.IsNotNull(packet);
var responseCommandResult = JsonConvert.DeserializeObject<CommandResult>(packet.Content);
Assert.IsTrue(responseCommandResult.Success);
Assert.AreEqual(CommandResultType.Continue, responseCommandResult.CommandResultType);
}",Tests that authentication will be successful if the correct credentials are supplied.,1
1956,"public void TestAuthenticationFailed() {
CommandServerPacket packet = null;
CommandServerController commandServer = new CommandServerController() {
CommandServerListener = new CommandServerListener()
};
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountSetPassword,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
""password""
})
});
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.SecurityAccountAuthenticate,
1
})
});
commandServer.OnPacketReceived(new MockCommandServerClient() {
SentCallback = wrapper => { packet = wrapper as CommandServerPacket; }
}, new CommandServerPacket() {
Headers = new WebHeaderCollection() {
{ HttpRequestHeader.ContentType, Mime.ApplicationJson }
},
Content = JsonConvert.SerializeObject(new Command() {
CommandType = CommandType.VariablesSet,
Authentication = {
Username = ""Phogue"",
PasswordPlainText = ""incorrect password""
}
})
});
Assert.IsNotNull(packet);
var responseCommandResult = JsonConvert.DeserializeObject<CommandResult>(packet.Content);
Assert.IsFalse(responseCommandResult.Success);
Assert.AreEqual(CommandResultType.Failed, responseCommandResult.CommandResultType);
}",Tests that authentication will fail if the incorrect credentials are supplied.,1
1957,"public void TestCommandTunnelled() {
ICommand propogatedCommand = null;
CommandServerController commandServer = new CommandServerController() {
CommandServerListener = new CommandServerListener(),
TunnelObjects = new List<ICoreController>() {
new MockCommandHandler() {
PropogateHandlerCallback = command => { propogatedCommand = command; }
}
}
};
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountSetPassword,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
""password""
})
});
commandServer.Shared.Security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.SecurityAccountAuthenticate,
1
})
});
commandServer.OnPacketReceived(new MockCommandServerClient(), new CommandServerPacket() {
Headers = new WebHeaderCollection() {
{ HttpRequestHeader.ContentType, Mime.ApplicationJson }
},
Content = JsonConvert.SerializeObject(new Command() {
CommandType = CommandType.VariablesSet,
Authentication = {
Username = ""Phogue"",
PasswordPlainText = ""password""
}
})
});
Assert.IsNotNull(propogatedCommand);
Assert.AreEqual(CommandType.VariablesSet.ToString(), propogatedCommand.Name);
}",Tests that authenticated commands will be passed through to the tunnelled objects.,1
1958,"public void TestResponseConnectionClose() {
CommandServerPacket packet = null;
CommandServerController commandServer = new CommandServerController() {
CommandServerListener = new CommandServerListener()
};
commandServer.OnPacketReceived(new MockCommandServerClient() {
SentCallback = wrapper => { packet = wrapper as CommandServerPacket; }
}, new CommandServerPacket() {
Headers = new WebHeaderCollection() {
{ HttpRequestHeader.ContentType, Mime.ApplicationJson }
},
Content = JsonConvert.SerializeObject(new Command() {
CommandType = CommandType.VariablesSet
})
});
Assert.IsNotNull(packet);
Assert.AreEqual(""close"", packet.Headers[HttpRequestHeader.Connection]);
}",Tests that the header will include a connection close argument.,1
1959,"public void TestAvailableBuilderEmptyRepository() {
var packages = new List<PackageWrapperModel>();
new AvailableCacheBuilder() {
Cache = packages,
Source = new List<IPackage>() {
new DataServicePackage() {
Id = ""TestAvailableBuilderEmptyRepository"",
Version = ""1.0.0""
}
}
}.Build();
Assert.IsNotEmpty(packages);
Assert.AreEqual(PackageState.NotInstalled, packages.First().State);
}",Tests that the available builder will add packages marking them as NotInstalled.,1
1960,"public void TestAvailableBuilderInstalledRepositoryIdenticalVersions() {
var packages = new List<PackageWrapperModel>() {
new PackageWrapperModel() {
State = PackageState.Installed,
Installed = new PackageModel() {
Id = ""TestAvailableBuilderInstalledRepositoryIdenticalVersions"",
Version = ""1.0.0""
}
}
};
new AvailableCacheBuilder() {
Cache = packages,
Source = new List<IPackage>() {
new DataServicePackage() {
Id = ""TestAvailableBuilderInstalledRepositoryIdenticalVersions"",
Version = ""1.0.0""
}
}
}.Build();
Assert.IsNotEmpty(packages);
Assert.AreEqual(PackageState.Installed, packages.First().State);
}",Tests that the available builder will update existing packages maintaining an installed status if versions match,1
1961,"public void TestAvailableBuilderInstalledRepositoryNewerVersions() {
var packages = new List<PackageWrapperModel>() {
new PackageWrapperModel() {
State = PackageState.Installed,
Installed = new PackageModel() {
Id = ""TestAvailableBuilderInstalledRepositoryNewerVersions"",
Version = ""1.0.0""
}
}
};
new AvailableCacheBuilder() {
Cache = packages,
Source = new List<IPackage>() {
new DataServicePackage() {
Id = ""TestAvailableBuilderInstalledRepositoryNewerVersions"",
Version = ""2.0.0""
}
}
}.Build();
Assert.IsNotEmpty(packages);
Assert.AreEqual(PackageState.UpdateAvailable, packages.First().State);
}",Tests that the available builder will update existing packages maintaining an installed status if versions match,1
1962,"public void TestInstalledBuilderEmptyRepository() {
List<PackageWrapperModel> packages = new List<PackageWrapperModel>();
new InstalledCacheBuilder() {
Cache = packages,
Source = new List<IPackage>() {
new DataServicePackage() {
Id = ""TestInstalledBuilderEmptyRepository"",
Version = ""1.0.0""
}
}
}.Build();
Assert.IsEmpty(packages);
}",Tests that the repository will remain empty as it cannot validate the installed packages belong to it.,1
1963,"public void TestInstalledBuilderAvailableRepositoryIdenticalVersions() {
var packages = new List<PackageWrapperModel>() {
new PackageWrapperModel() {
State = PackageState.NotInstalled,
Available = new PackageModel() {
Id = ""TestInstalledBuilderAvailableRepositoryIdenticalVersions"",
Version = ""1.0.0""
}
}
};
new InstalledCacheBuilder() {
Cache = packages,
Source = new List<IPackage>() {
new DataServicePackage() {
Id = ""TestInstalledBuilderAvailableRepositoryIdenticalVersions"",
Version = ""1.0.0""
}
}
}.Build();
Assert.IsNotEmpty(packages);
Assert.AreEqual(PackageState.Installed, packages.First().State);
}",Tests that the repository will be set to installed (not update available) if the available package exists and has an identical version.,1
1964,"public void TestInstalledBuilderAvailableRepositoryNewerVersions() {
var packages = new List<PackageWrapperModel>() {
new PackageWrapperModel() {
State = PackageState.NotInstalled,
Available = new PackageModel() {
Id = ""TestInstalledBuilderAvailableRepositoryNewerVersions"",
Version = ""2.0.0""
}
}
};
new InstalledCacheBuilder() {
Cache = packages,
Source = new List<IPackage>() {
new DataServicePackage() {
Id = ""TestInstalledBuilderAvailableRepositoryNewerVersions"",
Version = ""1.0.0""
}
}
}.Build();
Assert.IsNotEmpty(packages);
Assert.AreEqual(PackageState.UpdateAvailable, packages.First().State);
}",Tests that the repository will be set to UpdateAvailable if the available package exists and has a newer version.,1
1965,"public void TestOrphanedBuilderEmptyRepository() {
List<PackageWrapperModel> packages = new List<PackageWrapperModel>();
new OrphanedCacheBuilder() {
Cache = packages,
Source = new List<IPackage>() {
new DataServicePackage() {
Id = ""TestOrphanedBuilderEmptyRepository"",
Version = ""1.0.0""
}
}
}.Build();
Assert.IsNotEmpty(packages);
Assert.AreEqual(PackageState.Installed, packages.First().State);
}",Tests that an orphaned package will be added to the repository,1
1966,"public void TestOrphanedBuilderAvailableRepositoryNewerVersion() {
var packages = new List<PackageWrapperModel>() {
new PackageWrapperModel() {
State = PackageState.NotInstalled,
Available = new PackageModel() {
Id = ""TestOrphanedBuilderAvailableRepositoryNewerVersion"",
// Even though it's newer it will be ignored as we've told the orphan builder
// that this package is unknown to us.
Version = ""2.0.0""
}
}
};
new OrphanedCacheBuilder() {
Cache = packages,
Source = new List<IPackage>() {
new DataServicePackage() {
Id = ""TestOrphanedBuilderAvailableRepositoryNewerVersion"",
Version = ""1.0.0""
}
}
}.Build();
Assert.IsNotEmpty(packages);
Assert.AreEqual(PackageState.Installed, packages.First().State);
}","The initial state of the repository should never be hit during normal operation, but if for some reason it will be corrected by the orphaned builder. The fact that we have the available package from the source means that the package isn't orphaned.",1
1967,"public void CleanPackagesDirectory() {
if (Defines.PackagesDirectory.Exists == true) Defines.PackagesDirectory.Delete(true);
Defines.PackagesDirectory.Create();
Directory.CreateDirectory(PackagesExists100Path);
}",Clears out all files in the packages directory and ensures the packages directory is created.,1
1968,"public void TestDirectoryExistsOneDeep() {
var directory = new DirectoryInfo(Path.Combine(PackagesExists100Path, ""SubDirectoryA""));
directory.Create();
var path = Defines.PackageContainingPath(directory.FullName);
Assert.AreEqual(PackagesExists100Path, path.FullName);
}",Tests a sub directory in the packages directory will correctly find the packages path,1
1969,"public void TestDirectoryExistsTwoDeep() {
var directory = new DirectoryInfo(Path.Combine(PackagesExists100Path, ""SubDirectoryA"", ""SubDirectoryB""));
directory.Create();
var path = Defines.PackageContainingPath(directory.FullName);
Assert.AreEqual(PackagesExists100Path, path.FullName);
}",Tests a two deep sub directory in the packages directory will correctly find the packages path,1
1970,"public void TestFileExistsRoot() {
var file = new FileInfo(Path.Combine(PackagesExists100Path, ""A.txt""));
file.Create().Close();
var path = Defines.PackageContainingPath(file.FullName);
Assert.AreEqual(PackagesExists100Path, path.FullName);
}",Tests a file in the package root path will be found,1
1971,"public void TestFileExistsOneDeep() {
var file = new FileInfo(Path.Combine(PackagesExists100Path, ""SubDirectoryA"", ""A.txt""));
if (file.Directory != null) file.Directory.Create();
file.Create().Close();
var path = Defines.PackageContainingPath(file.FullName);
Assert.AreEqual(PackagesExists100Path, path.FullName);
}",Tests a file in a sub directory in the packages directory will correctly find the packages path,1
1972,"public void TestFileExistsTwoDeep() {
var file = new FileInfo(Path.Combine(PackagesExists100Path, ""SubDirectoryA"", ""SubDirectoryB"", ""A.txt""));
if (file.Directory != null) file.Directory.Create();
file.Create().Close();
var path = Defines.PackageContainingPath(file.FullName);
Assert.AreEqual(PackagesExists100Path, path.FullName);
}",Tests a file in a two-deep sub directory in the packages directory will correctly find the packages path,1
1973,"public void TestDoesNotExistStopAtBaseDirectory() {
var path = Defines.PackageContainingPath(""does-not-exist"");
Assert.AreEqual(Defines.BaseDirectory.FullName, path.FullName);
}",Tests that a path that does not exist will travel up to find the base directory.,1
1974,"public void TestPackageGroupSetupLinear() {
var variables = new VariableController();
var @namespace = """";
var packages = new PackagesController() {
Shared = {
Variables = variables
}
}.Execute() as PackagesController;
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, VariableModel.NamespaceVariableName(@namespace, CommonVariableNames.PackagesRepositoryUri), ""path-to-repository"");
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, CommonVariableNames.PackagesConfigGroups, new List<String>() {
@namespace
});
Assert.IsNotEmpty(packages.Cache.Repositories);
Assert.AreEqual(""path-to-repository"", packages.Cache.Repositories.FirstOrDefault().Uri);
}",Tests the grouped repository setting can be setup via variables.,1
1975,"public void TestPackageGroupSetupOrderReversed() {
var variables = new VariableController();
var @namespace = """";
var packages = new PackagesController() {
Shared = {
Variables = variables
}
}.Execute() as PackagesController;
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, CommonVariableNames.PackagesConfigGroups, new List<String>() {
@namespace
});
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, VariableModel.NamespaceVariableName(@namespace, CommonVariableNames.PackagesRepositoryUri), ""path-to-repository"");
Assert.IsNotEmpty(packages.Cache.Repositories);
Assert.AreEqual(""path-to-repository"", packages.Cache.Repositories.FirstOrDefault().Uri);
}","Tests the grouped repository setting can be setup via variables, with the group being set first then the group name added to the known group spaces",1
1976,"public void TestDispose() {
PackagesController packages = new PackagesController();
packages.Dispose();
Assert.IsNull(packages.GroupedVariableListener);
Assert.IsNull(packages.LocalRepository);
Assert.IsNull(packages.Cache);
}",Tests variables are nulled during a dispose.,1
1977,"public void TestResultInsufficientPermissions() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesFetchPackages().SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that attempting the command without any users in the security controller will result in insufficient permissions,1
1978,"public void TestResultSuccess() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesFetchPackages().SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that the packages can be fetched (or initiated a fetch) using the command with permissions.,1
1979,"public void TestResultInsufficientPermissions() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesMergePackage(""id"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that attempting the command without any users in the security controller will result in insufficient permissions,1
1980,"public void TestResultInvalidParameter() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesMergePackage("""").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
}",Tests that supplying an empty package id will result in an invalid parameter,1
1981,"public void TestResultDoesNotExists() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesMergePackage(""this-does-not-exist"").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests that supplying a package id we have no knowledge of will result in a DoesNotExists error.,1
1982,"public void TestResultAlreadyExists() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2""
}
});
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2""
}
}));
cache.Build(localRepository);
PackagesController packages = new PackagesController() {
Cache = cache
};
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesMergePackage(""A"").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.AlreadyExists, result.CommandResultType);
}",Tests that updating/installing a package with an identical version will result in an AlreadyExists error.,1
1983,"public void TestResultUninstalledSuccess() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository();
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2"",
IsLatestVersion = true
}
}));
cache.Build(localRepository);
PackagesController packages = new PackagesController() {
Cache = cache
};
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesMergePackage(""A"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests the merge command will succeed if the package is not currently installed.,1
1984,"public void TestResultUpdateAvailableSuccess() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Potato Tag2""
}
});
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""2.0.0"",
Tags = ""Procon Potato Tag2"",
IsLatestVersion = true
}
}));
cache.Build(localRepository);
PackagesController packages = new PackagesController() {
Cache = cache
};
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesMergePackage(""A"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests the merge command will succeed if an update is available for the package.,1
1985,"public void TestResultInsufficientPermissions() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesUninstallPackage(""id"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that attempting the command without any users in the security controller will result in insufficient permissions,1
1986,"public void TestResultInvalidParameter() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesUninstallPackage("""").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
}",Tests that supplying an empty package id will result in an invalid parameter,1
1987,"public void TestResultDoesNotExists() {
PackagesController packages = new PackagesController();
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesUninstallPackage(""this-does-not-exist"").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests that supplying a package id we have no knowledge of will result in a DoesNotExists error.,1
1988,"public void TestResultAlreadyExists() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository();
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2"",
IsLatestVersion = true
}
}));
cache.Build(localRepository);
PackagesController packages = new PackagesController() {
Cache = cache
};
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesUninstallPackage(""A"").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.AlreadyExists, result.CommandResultType);
}",Tests uninstalling a package that is available but not currently installed will result in a AlreadyExists error.,1
1989,"public void TestResultInstalledSuccess() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2""
}
});
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2""
}
}));
cache.Build(localRepository);
PackagesController packages = new PackagesController() {
Cache = cache
};
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesUninstallPackage(""A"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests the merge command will succeed if the package is currently installed.,1
1990,"public void TestResultUpdateAvailableSuccess() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2""
}
});
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""2.0.0"",
Tags = ""Procon Potato Tag2""
}
}));
cache.Build(localRepository);
PackagesController packages = new PackagesController() {
Cache = cache
};
ICommandResult result = packages.Tunnel(CommandBuilder.PackagesUninstallPackage(""A"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests the uninstall command will succeed if an update is available for the package.,1
1991,"public void CleanPackagesDirectory() {
Defines.PackagesDirectory.Delete(true);
Defines.PackagesDirectory.Create();
}",Clears out all files in the packages directory and ensures the packages directory is created.,1
1992,"public void PackageDirectoryDoesNotExist() {
String path = Defines.PackageVersionDirectory(Defines.PackagesDirectory.FullName, ""does-not-exist"");
Assert.IsNull(path);
}",Tests that a package directory will not be found if it does not exist.,1
1993,"public void PackageDirectoryExists() {
String packagePath = Path.Combine(Defines.PackagesDirectory.FullName, ""Exists.1.0.0"");
Directory.CreateDirectory(packagePath);
String path = Defines.PackageVersionDirectory(Defines.PackagesDirectory.FullName, ""Exists"");
Assert.AreEqual(packagePath, path);
}",Tests that a package directory can be found,1
1994,"public void PackageLatestVersionDirectoryExists() {
String oldest = Path.Combine(Defines.PackagesDirectory.FullName, ""Exists.1.0.0"");
String latest = Path.Combine(Defines.PackagesDirectory.FullName, ""Exists.1.1.0"");
Directory.CreateDirectory(oldest);
Directory.CreateDirectory(latest);
String path = Defines.PackageVersionDirectory(Defines.PackagesDirectory.FullName, ""Exists"");
Assert.AreEqual(latest, path);
}",Tests that the latest version of a package is found,1
1995,"public void PackageLatestVersionDirectoryExistsInRange() {
for (var offset = 0; offset < 20; offset++) {
Directory.CreateDirectory(Path.Combine(Defines.PackagesDirectory.FullName, String.Format(""Exists.1.0.{0}"", offset)));
}
String latest = Path.Combine(Defines.PackagesDirectory.FullName, ""Exists.9.1.0"");
Directory.CreateDirectory(latest);
String path = Defines.PackageVersionDirectory(Defines.PackagesDirectory.FullName, ""Exists"");
Assert.AreEqual(latest, path);
}",Tests that the latest version of a package is found from a range of packages,1
1996,"public void InvalidSemanticVersionIsIgnored() {
String latest = Path.Combine(Defines.PackagesDirectory.FullName, ""Exists.1.0.0"");
String invalid = Path.Combine(Defines.PackagesDirectory.FullName, ""Exists.9.j.0"");
Directory.CreateDirectory(latest);
Directory.CreateDirectory(invalid);
String path = Defines.PackageVersionDirectory(Defines.PackagesDirectory.FullName, ""Exists"");
Assert.AreEqual(latest, path);
}",Tests that an invalid semantic version is ignored,1
1997,"public void InvalidSemanticVersionIsIgnoredInRange() {
String latest = Path.Combine(Defines.PackagesDirectory.FullName, ""Exists.1.0.0"");
Directory.CreateDirectory(latest);
for (var offset = 0; offset < 20; offset++) {
Directory.CreateDirectory(Path.Combine(Defines.PackagesDirectory.FullName, String.Format(""Exists.2.j.{0}"", offset)));
}
String path = Defines.PackageVersionDirectory(Defines.PackagesDirectory.FullName, ""Exists"");
Assert.AreEqual(latest, path);
}",Tests that an invalid semantic version is ignored,1
1998,"public void TestSettingsRender() {
CorePluginController plugins = (CorePluginController)new CorePluginController().Execute();
// Enable the single plugin that was loaded, otherwise it won't recieve any tunneled
// commands.
plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
ICommandResult result = plugins.Tunnel(new Command() {
Name = ""/settings"",
// We're cheating a little bit here and just saying the command came from
// ""local"" as in it was generated by Potato itself.
Origin = CommandOrigin.Local
});
// The content below will be rendered in the UI sandbox
// The UI will catch href and load the next page with the results of that command.
Assert.AreEqual(""<h2>Settings</h2><b>Output of the variable!</b>Player1 (Score: 100)<br/>Player2 (Score: 250)<br/>"", result.Now.Content.First());
}",You should note the fully qualified names within PluginUserInterface.Pages.SettingsPageView.tt,1
1999,"public void TestStoppedHealthyServiceInPanicWillRestart() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = true
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Panic();
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}",Tests that a healthy service that has been stopped for 20 minutes will attempt a startup and succeed,1
2000,"public void TestStoppedHealthyServiceInPanicWillNotUpdateWithUpdatesDisabled() {
var merged = false;
var service = new ServiceController() {
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, uri, packageId) => merged = true
},
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy),
Observer = {
Status = ServiceStatusType.None
}
};
service.Panic();
Assert.IsFalse(merged);
service.Dispose();
}","Tests that the initial restart a panic will do will not update if updates are set to false. This is considered a healthy instance that was stopped for a long period of time, but is being started again.",1
2001,"public void TestCorruptedServiceInPanicWillOverrideDisabledUpdates() {
var merged = false;
var service = new ServiceController() {
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, uri, packageId) => merged = true
},
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockNonSerializableServiceLoaderProxy),
Observer = {
Status = ServiceStatusType.None
}
};
service.Panic();
Assert.IsTrue(merged);
service.Dispose();
}",Tests that a corrupted service in panic that does not load initially will override the disabled core updates and check for a core update.,1
2002,"public void TestCorruptedServiceInPanicWillOverrideDisabledUpdatesAndRecover() {
var merged = false;
ServiceController service = null;
service = new ServiceController() {
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, uri, packageId) => {
merged = true;
// ReSharper disable AccessToModifiedClosure
// We only do this to keep the test concise.
if (service != null) {
service.ServiceLoaderProxyType = typeof(MockServiceLoaderProxy);
}
// ReSharper restore AccessToModifiedClosure
}
},
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockNonSerializableServiceLoaderProxy),
Observer = {
Status = ServiceStatusType.None
}
};
service.Panic();
Assert.IsTrue(merged);
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}","Tests that a corrupted service in panic that does not load initially will override the disabled core updates and check for a core update, which resolves a problem and successfully loads the service. This is the ideal path for a panic to resolve itself.",1
2003,"public void TestInsufficentWordsResultsInEmptyEvent() {
var called = false;
var protocol = new SecondGame();
protocol.ProtocolEvent += (protocol1, args) => { called = true; };
var request = new FrostbitePacket();
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsFalse(called);
}",Tests that passing through no words results in an empty response not an exception.,1
2004,"public void TestWords4NotABooleanResultsInEmptyEvent() {
var called = false;
var protocol = new SecondGame();
protocol.ProtocolEvent += (protocol1, args) => { called = true; };
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""a"",
""b"",
""c"",
""d"",
""e""
}
}
};
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsFalse(called);
}","Tests that passing through a value not convertable to a boolean for words[4] will result in an empty response, not an exception.",1
2005,"public void TestPassingThroughCorrectFormatResultsInEvent() {
var called = false;
var protocol = new SecondGame();
protocol.State.Players.TryAdd(""EA_1"", new PlayerModel() {
Name = ""Phogue"",
Uid = ""EA_1"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.State.Players.TryAdd(""EA_2"", new PlayerModel() {
Name = ""Zaeed"",
Uid = ""EA_2"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.ProtocolEvent += (protocol1, args) => { called = true; };
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""player.onKill"",
""Phogue"",
""Zaeed"",
""Fairyfloss"",
""true""
}
}
};
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsTrue(called);
}","Tests that passing through a correctly formatted event will result in no error, even if none of the data exists.",1
2006,"public void TestAKnownItemResultsInThatItemInTheKillerInventory() {
var called = false;
var protocol = new SecondGame();
protocol.State.Players.TryAdd(""EA_1"", new PlayerModel() {
Name = ""Phogue"",
Uid = ""EA_1"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.State.Players.TryAdd(""EA_2"", new PlayerModel() {
Name = ""Zaeed"",
Uid = ""EA_2"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.State.Items.TryAdd(""fairyfloss"", new ItemModel() {
Name = ""fairyfloss"",
FriendlyName = ""Fairy Floss, the perfect sniper rifle""
});
protocol.ProtocolEvent += (protocol1, args) => {
called = true;
Assert.AreEqual(""fairyfloss"", args.Now.Kills.First().Now.Players.First().Inventory.Now.Items.First().Name);
Assert.AreEqual(""Fairy Floss, the perfect sniper rifle"", args.Now.Kills.First().Now.Players.First().Inventory.Now.Items.First().FriendlyName);
};
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""player.onKill"",
""Phogue"",
""Zaeed"",
""fairyfloss"",
""true""
}
}
};
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsTrue(called);
}",Tests a known item will be looked up and added to the killers inventory,1
2007,"public void TestAnUnknownItemResultsInThatItemInTheKillerInventory() {
var called = false;
var protocol = new SecondGame();
protocol.State.Players.TryAdd(""EA_1"", new PlayerModel() {
Name = ""Phogue"",
Uid = ""EA_1"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.State.Players.TryAdd(""EA_2"", new PlayerModel() {
Name = ""Zaeed"",
Uid = ""EA_2"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.ProtocolEvent += (protocol1, args) => {
called = true;
Assert.AreEqual(""fairyfloss"", args.Now.Kills.First().Now.Players.First().Inventory.Now.Items.First().Name);
Assert.IsEmpty(args.Now.Kills.First().Now.Players.First().Inventory.Now.Items.First().FriendlyName);
};
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""player.onKill"",
""Phogue"",
""Zaeed"",
""fairyfloss"",
""true""
}
}
};
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsTrue(called);
}",Tests the inventory item is simply coalesced with a new item and data in the packet,1
2008,"public void TestAKnownPlayerWillBeUsedAsTheKiller() {
var called = false;
var protocol = new SecondGame();
protocol.State.Players.TryAdd(""EA_1"", new PlayerModel() {
Name = ""Phogue"",
Uid = ""EA_1"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.State.Players.TryAdd(""EA_2"", new PlayerModel() {
Name = ""Zaeed"",
Uid = ""EA_2"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.ProtocolEvent += (protocol1, args) => {
called = true;
Assert.AreEqual(""EA_1"", args.Now.Kills.First().Now.Players.First().Uid);
Assert.AreEqual(""Phogue"", args.Now.Kills.First().Now.Players.First().Name);
Assert.AreEqual(100, args.Now.Kills.First().Now.Players.First().Score);
};
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""player.onKill"",
""Phogue"",
""Zaeed"",
""fairyfloss"",
""true""
}
}
};
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsTrue(called);
}",Tests that a killer will be looked up by their name and that player object used as the killer,1
2009,"public void TestAnUnknownPlayerKillerWillResultInNoEvent() {
var called = false;
var protocol = new SecondGame();
protocol.State.Players.TryAdd(""EA_2"", new PlayerModel() {
Name = ""Zaeed"",
Uid = ""EA_2"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.ProtocolEvent += (protocol1, args) => {
called = true;
};
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""player.onKill"",
""Phogue"",
""Zaeed"",
""fairyfloss"",
""true""
}
}
};
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsFalse(called);
}",Tests that if a player cannot be found in the state with a given name then no event will be raised.,1
2010,"public void TestAKnownKillerWillHaveTheirKillsIncremented() {
var called = false;
var protocol = new SecondGame();
protocol.State.Players.TryAdd(""EA_1"", new PlayerModel() {
Name = ""Phogue"",
Uid = ""EA_1"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.State.Players.TryAdd(""EA_2"", new PlayerModel() {
Name = ""Zaeed"",
Uid = ""EA_2"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.ProtocolEvent += (protocol1, args) => {
called = true;
Assert.AreEqual(""EA_1"", args.Now.Kills.First().Now.Players.First().Uid);
Assert.AreEqual(6, args.Now.Kills.First().Now.Players.First().Kills);
};
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""player.onKill"",
""Phogue"",
""Zaeed"",
""fairyfloss"",
""true""
}
}
};
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsTrue(called);
}",Tests that a known killer will have their kills incremented by 1 for the kill,1
2011,"public void TestAKnownPlayerWillBeUsedAsTheVictim() {
var called = false;
var protocol = new SecondGame();
protocol.State.Players.TryAdd(""EA_1"", new PlayerModel() {
Name = ""Phogue"",
Uid = ""EA_1"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.State.Players.TryAdd(""EA_2"", new PlayerModel() {
Name = ""Zaeed"",
Uid = ""EA_2"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.ProtocolEvent += (protocol1, args) => {
called = true;
Assert.AreEqual(""EA_2"", args.Now.Kills.First().Scope.Players.First().Uid);
Assert.AreEqual(""Zaeed"", args.Now.Kills.First().Scope.Players.First().Name);
Assert.AreEqual(100, args.Now.Kills.First().Scope.Players.First().Score);
};
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""player.onKill"",
""Phogue"",
""Zaeed"",
""fairyfloss"",
""true""
}
}
};
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsTrue(called);
}",Tests that a victim will be looked up by their name and that player object used as the victim,1
2012,"public void TestAnUnknownPlayerVictimWillResultInNoEvent() {
var called = false;
var protocol = new SecondGame();
protocol.State.Players.TryAdd(""EA_2"", new PlayerModel() {
Name = ""Phogue"",
Uid = ""EA_1"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.ProtocolEvent += (protocol1, args) => {
called = true;
};
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""player.onKill"",
""Phogue"",
""Zaeed"",
""fairyfloss"",
""true""
}
}
};
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsFalse(called);
}",Tests that if a player cannot be found in the state with a given name then no event will be raised.,1
2013,"public void TestAKnownVictimWillHaveTheirDeathsIncremented() {
var called = false;
var protocol = new SecondGame();
protocol.State.Players.TryAdd(""EA_1"", new PlayerModel() {
Name = ""Phogue"",
Uid = ""EA_1"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.State.Players.TryAdd(""EA_2"", new PlayerModel() {
Name = ""Zaeed"",
Uid = ""EA_2"",
Score = 100,
Kills = 5,
Deaths = 5
});
protocol.ProtocolEvent += (protocol1, args) => {
called = true;
Assert.AreEqual(""EA_2"", args.Now.Kills.First().Scope.Players.First().Uid);
Assert.AreEqual(6, args.Now.Kills.First().Scope.Players.First().Deaths);
};
var request = new FrostbitePacket() {
Packet = new Packet() {
Words = new List<String>() {
""player.onKill"",
""Phogue"",
""Zaeed"",
""fairyfloss"",
""true""
}
}
};
var response = new FrostbitePacket();
protocol.PlayerOnKillDispatchHandler(request, response);
Assert.IsTrue(called);
}",Tests that a known victim will have their kills incremented by 1 for the kill,1
2014,"public void TestEnabledPluginSavedToConfig() {
Guid connectionGuid = Guid.NewGuid();
Guid onePluginGuid = Guid.NewGuid();
Guid twoPluginGuid = Guid.NewGuid();
ICorePluginController plugins = new CorePluginController() {
Connection = new ConnectionController() {
ConnectionModel = new ConnectionModel() {
ConnectionGuid = connectionGuid
}
},
LoadedPlugins = new List<PluginModel>() {
new PluginModel() {
Name = ""One"",
IsEnabled = false,
PluginGuid = onePluginGuid
},
new PluginModel() {
Name = ""Two"",
IsEnabled = true,
PluginGuid = twoPluginGuid
}
}
};
IConfig config = new Config().Create<CorePluginController>();
plugins.WriteConfig(config);
config.Save(this.ConfigFile);
// Now load up the config and ensure it saved what we wanted it too.
var loadConfig = new Config();
loadConfig.Load(this.ConfigFile);
var commands = loadConfig.RootOf<CorePluginController>().Children<JObject>().Select(item => item.ToObject<IConfigCommand>(JsonSerialization.Minimal)).ToList();
Assert.AreEqual(""PluginsEnable"", commands[0].Command.Name);
Assert.AreEqual(connectionGuid, commands[0].Command.Scope.ConnectionGuid);
Assert.AreEqual(twoPluginGuid, commands[0].Command.Scope.PluginGuid);
}",Tests that an enabled plugin will have the enabled command saved to the config,1
2015,"public void TestPluginDisable() {
var security = new SecurityController();
var plugins = (CorePluginController)new CorePluginController() {
Shared = {
Security = security
}
}.Execute();
plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
ICommandResult result = plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsDisable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that a plugin can be Disabled if the parameter matches up to an existing plugin and the user has permission,1
2016,"public void TestPluginDisableAlreadyDisabled() {
var security = new SecurityController();
var plugins = (CorePluginController)new CorePluginController() {
Shared = {
Security = security
}
}.Execute();
ICommandResult result = plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsDisable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.Failed, result.CommandResultType);
}",Tests that a plugin will return false if it is already disabled,1
2017,"public void TestPluginDisableCommandSuccessful() {
var security = new SecurityController();
var plugins = (CorePluginController)new CorePluginController() {
Shared = {
Security = security
}
}.Execute();
// The plugin will be disabled right now.
ICommandResult result = plugins.Tunnel(new Command() {
Name = ""TestPluginsDisabledCommandResult"",
Authentication = {
Username = ""Phogue""
},
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Return Message""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Continue, result.CommandResultType);
Assert.AreEqual("""", result.Message);
}",Tests that disabling a plugin will allow commands within that plugin to be executed.,1
2018,"public void TestPluginDisableDoesNotExist() {
var security = new SecurityController();
var plugins = (CorePluginController)new CorePluginController() {
Shared = {
Security = security
}
}.Execute();
ICommandResult result = plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsDisable,
Scope = {
PluginGuid = Guid.NewGuid()
}
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests that a plugin will return a DoesNotExist message if the player guid does not match up to any loaded plugin,1
2019,"public void TestPluginDisableInsufficientPermission() {
var security = new SecurityController();
var plugins = (CorePluginController)new CorePluginController() {
Shared = {
Security = security
}
}.Execute();
ICommandResult result = plugins.Tunnel(new Command() {
Origin = CommandOrigin.Remote,
Authentication = {
Username = ""Phogue""
},
CommandType = CommandType.PluginsDisable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a plugin cannot be disabled if the user has insufficient permissions to do so.,1
2020,"public void TestPluginEnable() {
var security = new SecurityController();
var plugins = (CorePluginController)new CorePluginController() {
Shared = {
Security = security
}
}.Execute();
ICommandResult result = plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
//plugins.Dispose();
}",Tests that a plugin can be enabled if the parameter matches up to an existing plugin and the user has permission,1
2021,"public void TestPluginEnableAlreadyEnabled() {
var security = new SecurityController();
var plugins = (CorePluginController)new CorePluginController() {
Shared = {
Security = security
}
}.Execute();
plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
ICommandResult result = plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.Failed, result.CommandResultType);
}",Tests that a plugin will return false if it is already enabled,1
2022,"public void TestPluginEnableCommandSuccessful() {
var security = new SecurityController();
var plugins = (CorePluginController)new CorePluginController() {
Shared = {
Security = security
}
}.Execute();
ICommandResult result = plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
result = plugins.Tunnel(new Command() {
Name = ""TestPluginsEnabledCommandResult"",
Authentication = {
Username = ""Phogue""
},
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Return Message""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""Return Message"", result.Message);
}",Tests that enabling a plugin will allow commands within that plugin to be executed.,1
2023,"public void TestPluginEnableDoesNotExist() {
var security = new SecurityController();
var plugins = (CorePluginController)new CorePluginController() {
Shared = {
Security = security
}
}.Execute();
ICommandResult result = plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = Guid.NewGuid()
}
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests that a plugin will return a DoesNotExist message if the player guid does not match up to any loaded plugin,1
2024,"public void TestPluginEnableInsufficientPermission() {
var security = new SecurityController();
var plugins = (CorePluginController)new CorePluginController() {
Shared = {
Security = security
}
}.Execute();
ICommandResult result = plugins.Tunnel(new Command() {
Origin = CommandOrigin.Remote,
Authentication = {
Username = ""Phogue""
},
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a plugin cannot be enabled if the user has insufficient permissions to do so.,1
2025,"public void TestPluginsIsolationAllowedWriteAccessToLogsDirectory() {
TestPluginsIsolationWriteToDirectory(Defines.LogsDirectory.FullName, true, CommandResultType.Success);
}",Tests that a plugin can write to the plugins directory.,1
2026,"public void TestPluginsIsolationCleanCurrentAppDomain() {
var plugins = (CorePluginController)new CorePluginController().Execute();
plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
// Send a command to ensure the appdomain actually has a functional copy of the TestPlugin
// assembly loaded.
ICommandResult result = plugins.Tunnel(new Command() {
Name = ""TestPluginsIsolationCleanCurrentAppDomain"",
Authentication = {
Username = ""Phogue""
},
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Return Message""
})
});
// Validate the return, this will assert if the command wasn't executed implying the // assembly isn't loaded in the other app domain.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""Return Message"", result.Message);
// Now make sure our current appdomain is clean of the test plugin
foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies()) {
Assert.IsFalse(assembly.FullName.Contains(""Myrcon.Plugins.Test""));
}
}",Makes sure the plugin is not loaded into the current appdomain.,1
2027,"public void TestPluginsSerializationCommandResult() {
var plugins = (CorePluginController)new CorePluginController().Execute();
plugins.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = plugins.LoadedPlugins.First().PluginGuid
}
});
ICommandResult result = plugins.Tunnel(new Command() {
Name = ""TestPluginsSerializationCommandResult"",
Authentication = {
Username = ""Phogue""
},
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Return Message""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""Return Message"", result.Message);
}",Makes sure executing a command across the appdomain will serialize the basic command result across the app domain.,1
2028,"public void TestPollingRecievedMessage() {
var signaled = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy() {
WaitingMessage = new ServiceMessage() {
Name = ""help""
}
},
SignalBegin = (controller, message) => { signaled = true; },
Settings = {
ServiceUpdateCore = false
},
Observer = {
Status = ServiceStatusType.Started
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Polling_Tick(null);
Assert.IsTrue(signaled);
service.Dispose();
}",Tests that a waiting message from the instance will be fetched and dispatched to the message handler.,1
2029,"public void TestPollingRecievedMessageDoesNotRestart() {
var stopped = false;
var started = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy() {
WaitingMessage = new ServiceMessage() {
Name = ""help""
}
},
Settings = {
ServiceUpdateCore = false
},
Observer = {
Status = ServiceStatusType.Started,
StatusChange = (observer, type) => {
if (type == ServiceStatusType.Started) started = true;
if (type == ServiceStatusType.Stopped) stopped = true;
}
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Polling_Tick(null);
Assert.IsFalse(stopped);
Assert.IsFalse(started);
service.Dispose();
}",Tests that fetching a messae from the instance will not result in a restart,1
2030,"public void TestNotPolledWhenServiceIsStopped() {
var signaled = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy() {
WaitingMessage = new ServiceMessage() {
Name = ""help""
}
},
SignalBegin = (controller, message) => { signaled = true; },
Settings = {
ServiceUpdateCore = false
},
Observer = {
Status = ServiceStatusType.Stopped
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Polling_Tick(null);
Assert.IsFalse(signaled);
service.Dispose();
}",Tests the proxy isn't nagged when the service is currently stopped,1
2031,"public void TestNotPolledWhenServiceProxyIsNull() {
var signaled = false;
var service = new ServiceController() {
SignalBegin = (controller, message) => { signaled = true; },
Settings = {
ServiceUpdateCore = false
},
Observer = {
Status = ServiceStatusType.Started
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Polling_Tick(null);
Assert.IsFalse(signaled);
service.Dispose();
}",Simple condition to make sure messages are not processed from an imaginary proxy.,1
2032,"public void TestExceptionLoggedWhenPollingThrowsException() {
var service = new ServiceController() {
ServiceLoaderProxy = new MockNonSerializableServiceLoaderProxy(),
Settings = {
ServiceUpdateCore = false
},
Observer = {
Status = ServiceStatusType.Started
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Polling_Tick(null);
Assert.IsNotEmpty(Defines.ErrorsLogsDirectory.GetFiles());
Assert.Greater(Defines.ErrorsLogsDirectory.GetFiles().First().Length, 0);
service.Dispose();
}",Tests an exception is logged if an exception occurs when fetching the message from the instance.,1
2033,"public void TestServiceRestartWhenPollingThrowsException() {
var stopped = false;
var started = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockNonSerializableServiceLoaderProxy(),
Settings = {
ServiceUpdateCore = false
},
Observer = {
Status = ServiceStatusType.Started,
StatusChange = (observer, type) => {
if (type == ServiceStatusType.Started) started = true;
if (type == ServiceStatusType.Stopped) stopped = true;
}
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Polling_Tick(null);
Assert.IsTrue(stopped);
Assert.IsTrue(started);
service.Dispose();
}",Tests the service is restarted when an exception occurs while polling for a message.,1
2034,"public void TestPotatoCommandScopeNoScope() {
var variables = new VariableController();
var instance = (PotatoController)new PotatoController() {
Shared = {
Variables = variables,
Security = new SecurityController(),
Events = new EventsController(),
Languages = new LanguageController()
}
}.Execute();
((ProtocolController)instance.Protocols).Protocols.Add(new ProtocolAssemblyMetadata() {
Directory = new DirectoryInfo(AppDomain.CurrentDomain.BaseDirectory),
Assembly = new FileInfo(""MockProtocol.dll""),
ProtocolTypes = new List<IProtocolType>() {
new ProtocolType() {
Name = ""Mock Protocol"",
Provider = ""Myrcon"",
Type = ""MockProtocol""
}
}
});
instance.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PotatoAddConnection,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Myrcon"",
""MockProtocol"",
""1.1.1.1"",
27516,
""password"",
""""
})
});
// Tests that there is at least one connection.
Assert.AreEqual(1, instance.Connections.Count);
ICommandResult result = instance.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""key"",
""value""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""value"", variables.Get(""key"", ""default value""));
instance.Dispose();
}",Tests that providing no connection scope will tunnel the command over all executable objects in the instance. The VariableModel should be set.,1
2035,"public void TestPotatoCommandScopeWithConnectionScope() {
var variables = new VariableController();
var instance = (PotatoController)new PotatoController() {
Shared = {
Variables = variables,
Security = new SecurityController(),
Events = new EventsController(),
Languages = new LanguageController()
}
}.Execute();
((ProtocolController)instance.Protocols).Protocols.Add(new ProtocolAssemblyMetadata() {
Directory = new DirectoryInfo(AppDomain.CurrentDomain.BaseDirectory),
Assembly = new FileInfo(""MockProtocol.dll""),
ProtocolTypes = new List<IProtocolType>() {
new ProtocolType() {
Name = ""Mock Protocol"",
Provider = ""Myrcon"",
Type = ""MockProtocol""
}
}
});
instance.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PotatoAddConnection,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Myrcon"",
""MockProtocol"",
""1.1.1.1"",
27516,
""password"",
""""
})
});
// Tests that there is at least one connection.
Assert.AreEqual(1, instance.Connections.Count);
ICommandResult result = instance.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Scope = {
ConnectionGuid = instance.Connections.First().ConnectionModel.ConnectionGuid
},
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""key"",
""value""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Continue, result.CommandResultType);
Assert.AreEqual(""default value"", variables.Get(""key"", ""default value""));
instance.Dispose();
}",Tests that VariableModel will not set on the instance as it will bypass the instance executable objects and execute only on the connection.,1
2036,"public void TestPotatoConfigWritten() {
var instance = (PotatoController)new PotatoController() {
Shared = {
Variables = new VariableController().Execute() as VariableController,
Security = new SecurityController().Execute() as SecurityController,
Events = new EventsController().Execute() as EventsController,
Languages = new LanguageController().Execute() as LanguageController
}
}.Execute();
instance.Shared.Variables.Tunnel(CommandBuilder.VariablesSet(CommonVariableNames.PotatoConfigPassword, ""PotatoConfigurationPassword"").SetOrigin(CommandOrigin.Local));
instance.Connections.Add(new ConnectionController() {
ConnectionModel = new ConnectionModel() {
ProtocolType = new ProtocolType() {
Name = ""Mock Protocol"",
Provider = ""Myrcon"",
Type = ""MockProtocol""
},
Hostname = ""1.1.1.1"",
Port = 27516,
Arguments = """",
Password = ""password""
}
});
instance.WriteConfig();
var loadConfig = new Config();
loadConfig.Load(ConfigFileInfo);
var configCommand = loadConfig.RootOf<PotatoController>().Children<JObject>().Select(item => item.ToObject<IConfigCommand>(JsonSerialization.Minimal)).ToList().Last();
configCommand.Decrypt(""PotatoConfigurationPassword"");
Assert.AreEqual(""PotatoAddConnection"", configCommand.Command.Name);
Assert.AreEqual(""Myrcon"", configCommand.Command.Parameters[0].First<String>());
Assert.AreEqual(""MockProtocol"", configCommand.Command.Parameters[1].First<String>());
Assert.AreEqual(""1.1.1.1"", configCommand.Command.Parameters[2].First<String>());
Assert.AreEqual(""27516"", configCommand.Command.Parameters[3].First<String>());
Assert.AreEqual(""password"", configCommand.Command.Parameters[4].First<String>());
Assert.AreEqual("""", configCommand.Command.Parameters[5].First<String>());
instance.Dispose();
}",We test individual controllers configs in other unit tests.,1
2037,"public void TestPotatoDispose() {
var requestWait = new AutoResetEvent(false);
var instance = (PotatoController)new PotatoController() {
Shared = {
Variables = new VariableController(),
Security = new SecurityController(),
Events = new EventsController(),
Languages = new LanguageController()
}
}.Execute();
// Add a single connection, just so we can validate that it has been removed.
instance.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PotatoAddConnection,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""MockProtocol"",
""1.1.1.1"",
27516,
""password"",
""""
})
});
instance.Disposed += (sender, args) => requestWait.Set();
instance.Dispose();
Assert.IsTrue(requestWait.WaitOne(60000));
// Now validate everything is nulled.
// We test if each object has been disposed of with its own unit test elsewhere.
Assert.IsNull(instance.Shared.Variables);
Assert.IsNull(instance.Shared.Security);
Assert.IsNull(instance.Shared.Events);
Assert.IsNull(instance.Shared.Languages);
Assert.IsNull(instance.CommandServer);
Assert.IsNull(instance.Connections);
Assert.IsNull(instance.Packages);
Assert.IsNull(instance.Tasks);
Assert.IsNull(instance.PushEvents);
}",The controllers have their own individual dispose methods that are tested.,1
2038,"public void TestPotatoAddConnectionDuplicate() {
var instance = (PotatoController)new PotatoController().Execute();
instance.Connections.Add(new ConnectionController() {
ConnectionModel = new ConnectionModel() {
ProtocolType = new ProtocolType() {
Name = ""Mock Protocol"",
Provider = ""Myrcon"",
Type = ""MockProtocol""
},
Hostname = ""1.1.1.1"",
Port = 27516
}
});
((ProtocolController)instance.Protocols).Protocols.Add(new ProtocolAssemblyMetadata() {
Directory = new DirectoryInfo(AppDomain.CurrentDomain.BaseDirectory),
Assembly = new FileInfo(""MockProtocol.dll""),
ProtocolTypes = new List<IProtocolType>() {
new ProtocolType() {
Name = ""Mock Protocol"",
Provider = ""Myrcon"",
Type = ""MockProtocol""
}
}
});
// Now readd the same connection we just added.
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoAddConnection(""Myrcon"", ""MockProtocol"", ""1.1.1.1"", 27516, ""password"", """").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.AlreadyExists, result.CommandResultType);
instance.Dispose();
}",Tests that we cannot add the same connection twice.,1
2039,"public void TestPotatoAddConnectionExceedMaximumConnectionLimit() {
var variables = new VariableController();
var instance = (PotatoController)new PotatoController() {
Shared = {
Variables = variables
}
}.Execute();
// Lower the maximum connections to nothing
variables.Set(new Command() {
Origin = CommandOrigin.Local
}, CommonVariableNames.MaximumProtocolConnections, 0);
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoAddConnection(""Myrcon"", ""MockProtocol"", ""1.1.1.1"", 27516, ""password"", """").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.LimitExceeded, result.CommandResultType);
Assert.AreEqual(0, instance.Connections.Count);
instance.Dispose();
}",Tests that a connection cannot be added if would go over the maximum connection limit imposed by a VariableModel.,1
2040,"public void TestPotatoAddConnectionProtocolTypeDoesNotExist() {
var instance = (PotatoController)new PotatoController().Execute();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoAddConnection(""Myrcon"", ""la la la"", ""1.1.1.1"", 27516, ""password"", """").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
instance.Dispose();
}",Tests we receive a DoesNotExist status when a game type is not supported (or exist..),1
2041,"public void TestPotatoAddConnectionInsufficientPermissions() {
var instance = (PotatoController)new PotatoController().Execute();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoAddConnection(""Myrcon"", ""MockProtocol"", ""1.1.1.1"", 27516, ""password"", """").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
Assert.AreEqual(0, instance.Connections.Count);
instance.Dispose();
}",Tests a remote command to add a connection will fail if the username supplied does not have permissions to add the connection.,1
2042,"public void TestPotatoAddConnectionSuccess() {
var instance = (PotatoController)new PotatoController().Execute();
((ProtocolController)instance.Protocols).Protocols.Add(new ProtocolAssemblyMetadata() {
Directory = new DirectoryInfo(AppDomain.CurrentDomain.BaseDirectory),
Assembly = new FileInfo(""MockProtocol.dll""),
ProtocolTypes = new List<IProtocolType>() {
new ProtocolType() {
Name = ""Mock Protocol"",
Provider = ""Myrcon"",
Type = ""MockProtocol""
}
}
});
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoAddConnection(""Myrcon"", ""MockProtocol"", ""1.1.1.1"", 27516, ""password"", """").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(1, instance.Connections.Count);
instance.Dispose();
}",Tests that a connection can be added.,1
2043,"public void TestResultInsufficientPermissions() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoPing().SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
instance.Dispose();
}",Tests that attempting the command without any users in the security controller will result in insufficient permissions,1
2044,"public void TestResultSuccess() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoPing().SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
instance.Dispose();
}",Tests that given permission the command will return as successful,1
2045,"public void TestResultSuccessUptimeReturned() {
PotatoController instance = new PotatoController() {
InstantiatedStamp = DateTime.Now.AddSeconds(-5)
};
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoPing().SetOrigin(CommandOrigin.Local));
Assert.GreaterOrEqual(int.Parse(result.Now.Content.First()), 5000);
instance.Dispose();
}",Tests that an offset from the time started up until the command will be returned in milliseconds.,1
2046,"public void TestPotatoRemoveConnectionByGuidSuccess() {
var instance = (PotatoController)new PotatoController().Execute();
instance.Connections.Add(new ConnectionController() {
ConnectionModel = new ConnectionModel() {
ProtocolType = new ProtocolType() {
Name = ""Mock Protocol"",
Provider = ""Myrcon"",
Type = ""MockProtocol""
},
Hostname = ""1.1.1.1"",
Port = 27516
}
});
// Make sure we have at least one connection added.
Assert.AreEqual(1, instance.Connections.Count);
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoRemoveConnection(instance.Connections.First().ConnectionModel.ConnectionGuid).SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(0, instance.Connections.Count);
instance.Dispose();
}",Tests that a connection can be removed.,1
2047,"public void TestPotatoRemoveConnectionDoesNotExist() {
var instance = (PotatoController)new PotatoController().Execute();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoRemoveConnection(""Myrcon"", ""MockProtocol"", ""1.1.1.1"", 27516).SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
instance.Dispose();
}",Tests that a DoesNotExist error is returned when trying to remove a connection on an empty instance object.,1
2048,"public void TestPotatoRemoveConnectionInsufficientPermissions() {
var instance = (PotatoController)new PotatoController().Execute();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoRemoveConnection(""Myrcon"", ""MockProtocol"", ""1.1.1.1"", 27516).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
Assert.AreEqual(0, instance.Connections.Count);
instance.Dispose();
}",Tests a remote command to remove a connection will fail if the username supplied does not have permissions to add the connection.,1
2049,"public void TestPotatoRemoveConnectionByDetailsSuccess() {
var instance = (PotatoController)new PotatoController().Execute();
instance.Connections.Add(new ConnectionController() {
ConnectionModel = new ConnectionModel() {
ProtocolType = new ProtocolType() {
Name = ""Mock Protocol"",
Provider = ""Myrcon"",
Type = ""MockProtocol""
},
Hostname = ""1.1.1.1"",
Port = 27516
}
});
// Make sure we have at least one connection added.
Assert.IsNotEmpty(instance.Connections);
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoRemoveConnection(""Myrcon"", ""MockProtocol"", ""1.1.1.1"", 27516).SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.IsEmpty(instance.Connections);
instance.Dispose();
}",Tests that a connection can be removed.,1
2050,"public void TestResultInsufficientPermissions() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoServiceMergePackage(""localhost"", ""id"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
instance.Dispose();
}",Tests that attempting the command without any users in the security controller will result in insufficient permissions,1
2051,"public void TestResultInvalidParameterUri() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoServiceMergePackage("""", ""id"").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
instance.Dispose();
}",Tests that passing in an empty uri will result in an invalid parameter status,1
2052,"public void TestResultInvalidParameterPackageId() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoServiceMergePackage(""localhost"", """").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
instance.Dispose();
}",Tests that passing in an empty packageId will result in an invalid parameter status,1
2053,"public void TestResultSuccess() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoServiceMergePackage(""localhost"", ""id"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
instance.Dispose();
}",Tests that with permissions the result will be a success.,1
2054,"public void TestMessageLogged() {
PotatoController instance = new PotatoController();
instance.Tunnel(CommandBuilder.PotatoServiceMergePackage(""localhost"", ""id"").SetOrigin(CommandOrigin.Local));
Assert.IsNotNull(instance.ServiceMessage);
Assert.AreEqual(""merge"", instance.ServiceMessage.Name);
Assert.AreEqual(""localhost"", instance.ServiceMessage.Arguments[""uri""]);
Assert.AreEqual(""id"", instance.ServiceMessage.Arguments[""packageid""]);
instance.Dispose();
}",Tests that a service message is set when successfully executing a merge package command.,1
2055,"public void TestEventLogged() {
EventsController events = new EventsController();
PotatoController instance = new PotatoController {
Shared = {
Events = events
}
};
instance.Tunnel(CommandBuilder.PotatoServiceMergePackage(""localhost"", ""id"").SetOrigin(CommandOrigin.Local));
Assert.IsNotEmpty(events.LoggedEvents);
Assert.AreEqual(""PotatoServiceMergePackage"", events.LoggedEvents.First().Name);
instance.Dispose();
}",Tests that an event is logged for a restart when successfully executing a restart command.,1
2056,"public void TestResultInsufficientPermissions() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoServiceRestart().SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
instance.Dispose();
}",Tests that attempting the command without any users in the security controller will result in insufficient permissions,1
2057,"public void TestResultSuccess() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoServiceRestart().SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
instance.Dispose();
}",Tests that with permissions the result will be a success.,1
2058,"public void TestMessageLogged() {
PotatoController instance = new PotatoController();
instance.Tunnel(CommandBuilder.PotatoServiceRestart().SetOrigin(CommandOrigin.Local));
Assert.IsNotNull(instance.ServiceMessage);
Assert.AreEqual(""restart"", instance.ServiceMessage.Name);
instance.Dispose();
}",Tests that a service message is set when successfully executing a restart command.,1
2059,"public void TestEventLogged() {
EventsController events = new EventsController();
PotatoController instance = new PotatoController {
Shared = {
Events = events
}
};
instance.Tunnel(CommandBuilder.PotatoServiceRestart().SetOrigin(CommandOrigin.Local));
Assert.IsNotEmpty(events.LoggedEvents);
Assert.AreEqual(""PotatoServiceRestarting"", events.LoggedEvents.First().Name);
instance.Dispose();
}",Tests that an event is logged for a restart when successfully executing a restart command.,1
2060,"public void TestResultInsufficientPermissions() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoServiceUninstallPackage(""id"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
instance.Dispose();
}",Tests that attempting the command without any users in the security controller will result in insufficient permissions,1
2061,"public void TestResultInvalidParameterPackageId() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoServiceUninstallPackage("""").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
instance.Dispose();
}",Tests that passing in an empty packageId will result in an invalid parameter status,1
2062,"public void TestResultSuccess() {
PotatoController instance = new PotatoController();
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoServiceUninstallPackage(""id"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
instance.Dispose();
}",Tests that with permissions the result will be a success.,1
2063,"public void TestMessageLogged() {
PotatoController instance = new PotatoController();
instance.Tunnel(CommandBuilder.PotatoServiceUninstallPackage(""id"").SetOrigin(CommandOrigin.Local));
Assert.IsNotNull(instance.ServiceMessage);
Assert.AreEqual(""uninstall"", instance.ServiceMessage.Name);
Assert.AreEqual(""id"", instance.ServiceMessage.Arguments[""packageid""]);
instance.Dispose();
}",Tests that a service message is set when successfully executing a merge package command.,1
2064,"public void TestEventLogged() {
EventsController events = new EventsController();
PotatoController instance = new PotatoController {
Shared = {
Events = events
}
};
instance.Tunnel(CommandBuilder.PotatoServiceUninstallPackage(""id"").SetOrigin(CommandOrigin.Local));
Assert.IsNotEmpty(events.LoggedEvents);
Assert.AreEqual(""PotatoServiceUninstallPackage"", events.LoggedEvents.First().Name);
instance.Dispose();
}",Tests that an event is logged for a restart when successfully executing a restart command.,1
2065,"public IProtocolSetupResult Setup(IProtocolSetup setup) {
throw new NotImplementedException();
}","Sets up the protocol, initializing the client",1
2066,"public void AttemptConnection() {
throw new NotImplementedException();
}",Attempts a connection to the server.,1
2067,"public void TestDefaultSerialization() {
var original = new ProtocolEventArgs();
var serialized = JsonSerialization.Minimal.Serialize(original);
var deseralized = JsonSerialization.Minimal.Deserialize<ProtocolEventArgs>(serialized);
Assert.IsNotNull(deseralized.Now);
Assert.IsNotNull(deseralized.Then);
Assert.IsNotNull(deseralized.Stamp);
Assert.IsNotNull(deseralized.StateDifference);
Assert.IsNotNull(deseralized.ProtocolType);
Assert.AreEqual(ProtocolEventType.None, deseralized.ProtocolEventType);
}",Tests a default serialization is successful,1
2068,"public void TestSingleDepthPopulationSerialization() {
var original = new ProtocolEventArgs() {
Now = {
Bans = new List<BanModel>() {
new BanModel()
},
Chats = new List<ChatModel>() {
new ChatModel()
},
Items = new List<ItemModel>() {
new ItemModel()
},
Kicks = new List<KickModel>() {
new KickModel()
},
Kills = new List<KillModel>() {
new KillModel()
},
Moves = new List<MoveModel>() {
new MoveModel()
},
Players = new List<PlayerModel>() {
new PlayerModel()
},
Points = new List<Point3DModel>() {
new Point3DModel()
},
Settings = new List<Settings>() {
new Settings()
},
Spawns = new List<SpawnModel>() {
new SpawnModel()
}
},
Then = {
Bans = new List<BanModel>() {
new BanModel()
},
Chats = new List<ChatModel>() {
new ChatModel()
},
Items = new List<ItemModel>() {
new ItemModel()
},
Kicks = new List<KickModel>() {
new KickModel()
},
Kills = new List<KillModel>() {
new KillModel()
},
Moves = new List<MoveModel>() {
new MoveModel()
},
Players = new List<PlayerModel>() {
new PlayerModel()
},
Points = new List<Point3DModel>() {
new Point3DModel()
},
Settings = new List<Settings>() {
new Settings()
},
Spawns = new List<SpawnModel>() {
new SpawnModel()
}
},
StateDifference = new ProtocolStateDifference(),
ProtocolEventType = ProtocolEventType.ProtocolBanlistUpdated,
ProtocolType = new ProtocolType(),
Stamp = new DateTime(2000, 10, 10, 10, 10, 10)
};
var serialized = JsonSerialization.Minimal.Serialize(original);
var deseralized = JsonSerialization.Minimal.Deserialize<ProtocolEventArgs>(serialized);
Assert.IsNotEmpty(deseralized.Now.Bans);
Assert.IsNotEmpty(deseralized.Now.Chats);
Assert.IsNotEmpty(deseralized.Now.Items);
Assert.IsNotEmpty(deseralized.Now.Kicks);
Assert.IsNotEmpty(deseralized.Now.Kills);
Assert.IsNotEmpty(deseralized.Now.Moves);
Assert.IsNotEmpty(deseralized.Now.Players);
Assert.IsNotEmpty(deseralized.Now.Points);
Assert.IsNotEmpty(deseralized.Now.Settings);
Assert.IsNotEmpty(deseralized.Now.Spawns);
Assert.IsNotEmpty(deseralized.Then.Bans);
Assert.IsNotEmpty(deseralized.Then.Chats);
Assert.IsNotEmpty(deseralized.Then.Items);
Assert.IsNotEmpty(deseralized.Then.Kicks);
Assert.IsNotEmpty(deseralized.Then.Kills);
Assert.IsNotEmpty(deseralized.Then.Moves);
Assert.IsNotEmpty(deseralized.Then.Players);
Assert.IsNotEmpty(deseralized.Then.Points);
Assert.IsNotEmpty(deseralized.Then.Settings);
Assert.IsNotEmpty(deseralized.Then.Spawns);
Assert.IsNotNull(deseralized.ProtocolType);
Assert.IsNotNull(deseralized.StateDifference);
Assert.AreEqual(new DateTime(2000, 10, 10, 10, 10, 10), deseralized.Stamp);
Assert.AreEqual(ProtocolEventType.ProtocolBanlistUpdated, deseralized.ProtocolEventType);
}",Tests a populated object with attributes immediately attached to the type will serialize successfully.,1
2069,"public void TestDefaultSerialization() {
var original = new ProtocolEventData();
var serialized = JsonSerialization.Minimal.Serialize(original);
var deseralized = JsonSerialization.Minimal.Deserialize<ProtocolEventData>(serialized);
Assert.IsNull(deseralized.Bans);
Assert.IsNull(deseralized.Chats);
Assert.IsNull(deseralized.Items);
Assert.IsNull(deseralized.Kicks);
Assert.IsNull(deseralized.Kills);
Assert.IsNull(deseralized.Moves);
Assert.IsNull(deseralized.Players);
Assert.IsNull(deseralized.Points);
Assert.IsNull(deseralized.Settings);
Assert.IsNull(deseralized.Spawns);
}",Tests a default serialization is successful,1
2070,"public void TestSingleDepthPopulationSerialization() {
var original = new ProtocolEventData() {
Bans = new List<BanModel>() {
new BanModel()
},
Chats = new List<ChatModel>() {
new ChatModel()
},
Items = new List<ItemModel>() {
new ItemModel()
},
Kicks = new List<KickModel>() {
new KickModel()
},
Kills = new List<KillModel>() {
new KillModel()
},
Moves = new List<MoveModel>() {
new MoveModel()
},
Players = new List<PlayerModel>() {
new PlayerModel()
},
Points = new List<Point3DModel>() {
new Point3DModel()
},
Settings = new List<Settings>() {
new Settings()
},
Spawns = new List<SpawnModel>() {
new SpawnModel()
}
};
var serialized = JsonSerialization.Minimal.Serialize(original);
var deseralized = JsonSerialization.Minimal.Deserialize<ProtocolEventData>(serialized);
Assert.IsNotEmpty(deseralized.Bans);
Assert.IsNotEmpty(deseralized.Chats);
Assert.IsNotEmpty(deseralized.Items);
Assert.IsNotEmpty(deseralized.Kicks);
Assert.IsNotEmpty(deseralized.Kills);
Assert.IsNotEmpty(deseralized.Moves);
Assert.IsNotEmpty(deseralized.Players);
Assert.IsNotEmpty(deseralized.Points);
Assert.IsNotEmpty(deseralized.Settings);
Assert.IsNotEmpty(deseralized.Spawns);
}",Tests a populated object with attributes immediately attached to the type will serialize successfully.,1
2071,"public void TestIsolationSuccessOnLoad() {
var instance = (PotatoController)new PotatoController().Execute();
var meta = ((ProtocolController)instance.Protocols).Protocols.First(m => m.Name == ""Myrcon.Protocols.Test"");
var protocol = meta.ProtocolTypes.First(p => p.Type == ""MockProtocol"");
// Now readd the same connection we just added.
ICommandResult result = instance.Tunnel(CommandBuilder.PotatoAddConnection(protocol.Provider, protocol.Type, ""1.1.1.1"", 27516, ""password"", """").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
// Now make sure our current appdomain is clean of the test plugin
foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies()) {
Assert.IsFalse(assembly.FullName.Contains(""Myrcon.Protocols.Test""));
}
instance.Dispose();
}",Tests that simply loading a protocol does not load the assembly into the current AppDomain.,1
2072,"public void TestInsufficientPermissions() {
var protocols = new ProtocolController();
ICommandResult result = protocols.Tunnel(CommandBuilder.ProtocolsCheckSupportedProtocol(""Myrcon"", CommonProtocolType.DiceBattlefield4).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a remote call with no permissions will result in an InsufficientPermissions status,1
2073,"public void TestSuccess() {
var item = new ProtocolType() {
Name = ""Battlefield 4"",
Provider = ""Myrcon"",
Type = CommonProtocolType.DiceBattlefield4
};
var protocols = new ProtocolController {
Protocols = new List<IProtocolAssemblyMetadata>() {
new ProtocolAssemblyMetadata() {
ProtocolTypes = new List<IProtocolType>() {
item
}
}
}
};
ICommandResult result = protocols.Tunnel(CommandBuilder.ProtocolsCheckSupportedProtocol(""Myrcon"", CommonProtocolType.DiceBattlefield4).SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests the command is successful and the supported protocols are returned.,1
2074,"public void TestProtocolTypesReturned() {
var item = new ProtocolType() {
Name = ""Battlefield 4"",
Provider = ""Myrcon"",
Type = CommonProtocolType.DiceBattlefield4
};
var protocols = new ProtocolController {
Protocols = new List<IProtocolAssemblyMetadata>() {
new ProtocolAssemblyMetadata() {
ProtocolTypes = new List<IProtocolType>() {
item
}
}
}
};
ICommandResult result = protocols.Tunnel(CommandBuilder.ProtocolsCheckSupportedProtocol(""Myrcon"", CommonProtocolType.DiceBattlefield4).SetOrigin(CommandOrigin.Local));
Assert.AreEqual(item, result.Now.ProtocolTypes.First());
}",Tests the command is successful and the supported protocols are returned.,1
2075,"public void TestFailureDoesNotExist() {
var protocols = new ProtocolController();
ICommandResult result = protocols.Tunnel(CommandBuilder.ProtocolsCheckSupportedProtocol(""Myrcon"", CommonProtocolType.DiceBattlefield4).SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests the command fails with DoesNotExist status when the protocol is not supported.,1
2076,"public void TestInsufficientPermissions() {
var protocols = new ProtocolController();
ICommandResult result = protocols.Tunnel(CommandBuilder.ProtocolsFetchSupportedProtocols().SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a remote call with no permissions will result in an InsufficientPermissions status,1
2077,"public void TestSuccess() {
var protocols = new ProtocolController();
ICommandResult result = protocols.Tunnel(CommandBuilder.ProtocolsFetchSupportedProtocols().SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests the command is successful and the supported protocols are returned.,1
2078,"public void TestProtocolTypesReturned() {
var item = new ProtocolType() {
Name = ""Battlefield 4"",
Provider = ""Myrcon"",
Type = ""DiceBattlefield4""
};
var protocols = new ProtocolController {
Protocols = new List<IProtocolAssemblyMetadata>() {
new ProtocolAssemblyMetadata() {
ProtocolTypes = new List<IProtocolType>() {
item
}
}
}
};
ICommandResult result = protocols.Tunnel(CommandBuilder.ProtocolsFetchSupportedProtocols().SetOrigin(CommandOrigin.Local));
Assert.AreEqual(item, result.Now.ProtocolTypes.First());
}",Tests the command is successful and the supported protocols are returned.,1
2079,"public void TestEventsPushControllerDispose() {
var variables = new VariableController();
var events = new EventsController();
var pushEvents = (PushEventsController)new PushEventsController() {
Shared = {
Variables = variables,
Events = events
}
}.Execute();
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, CommonVariableNames.EventsPushUri, ""http://localhost/pushme.php"");
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, CommonVariableNames.EventPushIntervalSeconds, 10);
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, CommonVariableNames.EventPushInclusiveNames, new List<String>() { ""EventName"" });
// Validate the end point has been added.
Assert.IsTrue(pushEvents.EndPoints.ContainsKey(String.Empty));
Assert.AreEqual(""http://localhost/pushme.php"", pushEvents.EndPoints[String.Empty].Uri.ToString());
Assert.AreEqual(10, pushEvents.EndPoints[String.Empty].Interval);
events.Log(new GenericEvent() {
Name = ""EventName"",
Message = ""Yo.""
});
Assert.AreEqual(1, pushEvents.EndPoints[String.Empty].EventsStream.Count);
pushEvents.Dispose();
Assert.IsNull(pushEvents.EndPoints);
Assert.IsNull(pushEvents.Tasks);
}",Tests that all variables are nulled during a dispose.,1
2080,"public void TestEventsPushControllerMultipleEndPointsRandomVariableAssignmentA() {
TestEventsPushControllerMultipleEndPointsRandomVariableAssignment(100);
}","Tests that we can setup three end points, one without a namespace and two with namespaces with the settings of each set in a random order.",1
2081,"public void TestEventsPushControllerMultipleEndPointsRandomVariableAssignmentB() {
TestEventsPushControllerMultipleEndPointsRandomVariableAssignment(98279872);
}","Tests that we can setup three end points, one without a namespace and two with namespaces with the settings of each set in a random order.",1
2082,"public void TestEventsPushControllerMultipleEndPointsRandomVariableAssignmentC() {
TestEventsPushControllerMultipleEndPointsRandomVariableAssignment(5674353);
}","Tests that we can setup three end points, one without a namespace and two with namespaces with the settings of each set in a random order.",1
2083,"public void TestEventsPushControllerNamespacedSingleEndPointBackwardSetting() {
String pushConfigGroupName = StringExtensions.RandomString(10);
var variables = new VariableController();
var events = new EventsController();
var pushEvents = (PushEventsController)new PushEventsController() {
Shared = {
Variables = variables,
Events = events
}
}.Execute();
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, CommonVariableNames.EventsPushConfigGroups, new List<String>() {
pushConfigGroupName
});
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, VariableModel.NamespaceVariableName(pushConfigGroupName, CommonVariableNames.EventsPushUri), ""http://localhost/pushme.php"");
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, VariableModel.NamespaceVariableName(pushConfigGroupName, CommonVariableNames.EventPushIntervalSeconds), 20);
Assert.IsTrue(pushEvents.EndPoints.ContainsKey(pushConfigGroupName));
Assert.AreEqual(""http://localhost/pushme.php"", pushEvents.EndPoints[pushConfigGroupName].Uri.ToString());
Assert.AreEqual(20, pushEvents.EndPoints[pushConfigGroupName].Interval);
}","Tests the VariableModel group setting for controller will setup a end point. The test will setup the config group first, then actually setup the group config options. It's a little backwards, but it needs to be able to handle setting the variables in any order.",1
2084,"public void TestEventsPushControllerNamespacedSingleEndPointForwardSetting() {
String pushConfigGroupName = StringExtensions.RandomString(10);
var variables = new VariableController();
var events = new EventsController();
var pushEvents = (PushEventsController)new PushEventsController() {
Shared = {
Variables = variables,
Events = events
}
}.Execute();
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, VariableModel.NamespaceVariableName(pushConfigGroupName, CommonVariableNames.EventsPushUri), ""http://localhost/pushme.php"");
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, VariableModel.NamespaceVariableName(pushConfigGroupName, CommonVariableNames.EventPushIntervalSeconds), 20);
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, CommonVariableNames.EventsPushConfigGroups, new List<String>() {
pushConfigGroupName
});
Assert.IsTrue(pushEvents.EndPoints.ContainsKey(pushConfigGroupName));
Assert.AreEqual(""http://localhost/pushme.php"", pushEvents.EndPoints[pushConfigGroupName].Uri.ToString());
Assert.AreEqual(20, pushEvents.EndPoints[pushConfigGroupName].Interval);
}","Tests the VariableModel group setting for controller will setup a end point. The test will setup a push end point group config, then change the groups VariableModel. This would be the 'ideal' method of setting up a group as all of the information is available for a group when it is setup.",1
2085,"public void TestVariablesSetPriorToPushEventsControllerExecution() {
String pushConfigGroupName = StringExtensions.RandomString(10);
var variables = new VariableController();
variables.Tunnel(CommandBuilder.VariablesSet(VariableModel.NamespaceVariableName(pushConfigGroupName, CommonVariableNames.EventsPushUri), ""http://localhost/pushme.php"").SetOrigin(CommandOrigin.Local));
variables.Tunnel(CommandBuilder.VariablesSet(VariableModel.NamespaceVariableName(pushConfigGroupName, CommonVariableNames.EventPushIntervalSeconds), ""20"").SetOrigin(CommandOrigin.Local));
variables.Tunnel(CommandBuilder.VariablesSet(CommonVariableNames.EventsPushConfigGroups, pushConfigGroupName).SetOrigin(CommandOrigin.Local));
var events = new EventsController();
var pushEvents = (PushEventsController)new PushEventsController() {
Shared = {
Variables = variables,
Events = events
}
}.Execute();
Assert.IsTrue(pushEvents.EndPoints.ContainsKey(pushConfigGroupName));
Assert.AreEqual(""http://localhost/pushme.php"", pushEvents.EndPoints[pushConfigGroupName].Uri.ToString());
Assert.AreEqual(20, pushEvents.EndPoints[pushConfigGroupName].Interval);
}","Tests that variables can be set prior to executing the push events controller, which will still setup the controller correctly.",1
2086,"public void TestEventsPushControllerSingleEndPointNoNamespace() {
var variables = new VariableController();
var events = new EventsController();
var pushEvents = (PushEventsController)new PushEventsController() {
Shared = {
Variables = variables,
Events = events
}
}.Execute();
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, CommonVariableNames.EventsPushUri, ""http://localhost/pushme.php"");
variables.Set(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet
}, CommonVariableNames.EventPushIntervalSeconds, 20);
Assert.IsTrue(pushEvents.EndPoints.ContainsKey(String.Empty));
Assert.AreEqual(""http://localhost/pushme.php"", pushEvents.EndPoints[String.Empty].Uri.ToString());
Assert.AreEqual(20, pushEvents.EndPoints[String.Empty].Interval);
}",Tests the VariableModel group setting for controller will setup a end point with no namespace or changes to the configs VariableModel.,1
2087,"public void TestPushEventsAppendSuccess() {
var pushEndPoint = new PushEventsEndPoint() {
InclusiveNames = new List<String>() {
""EventName""
}
};
pushEndPoint.Append(new GenericEvent() {
Name = ""EventName"",
Message = ""Yo.""
});
Assert.AreEqual(1, pushEndPoint.EventsStream.Count);
}",Tests that an event can be pushed onot the stream.,1
2088,"public void TestPushEventsAppendNonInclusiveEventNotPushed() {
var pushEndPoint = new PushEventsEndPoint() {
InclusiveNames = new List<String>() {
""EventName""
}
};
pushEndPoint.Append(new GenericEvent() {
Name = ""DifferentEventName"",
Message = ""Yo.""
});
Assert.AreEqual(0, pushEndPoint.EventsStream.Count);
}",Tests that an event not in the inclusive names will not be added.,1
2089,"public void TestPushEventsDisposedEventIsRemoved() {
var pushEndPoint = new PushEventsEndPoint();
var genericEventArgs = new GenericEvent() {
Message = ""What up?""
};
pushEndPoint.Append(genericEventArgs);
genericEventArgs.Dispose();
Assert.AreEqual(0, pushEndPoint.EventsStream.Count);
}",Tests that an event that is disposed will also be removed from the stream. Even if the stream has not been pushed yet.,1
2090,"public void TestPushEventsRequestFailCleanupOccurs() {
var requestWait = new AutoResetEvent(false);
var pushEndPoint = new PushEventsEndPoint() {
InclusiveNames = new List<String>() {
""EventName""
}
};
pushEndPoint.Append(new GenericEvent() {
Name = ""EventName"",
Message = ""What up?""
});
pushEndPoint.PushCompleted += sender => requestWait.Set();
pushEndPoint.Push();
Assert.IsTrue(requestWait.WaitOne(10000));
Assert.AreEqual(0, pushEndPoint.EventsStream.Count);
}",Tests that even when a request fails it will still remove the events from the stream.,1
2091,"public void TestPushEventsRequestJsonSerialization() {
var builder = new StringBuilder();
TextWriter writer = new StringWriter(builder);
PushEventsEndPoint.WriteSerializedEventsRequest(writer, Mime.ApplicationJson, new PushEventsRequest() {
Events = new List<IGenericEvent>() {
new GenericEvent() {
Message = ""What up?""
}
}
});
var deserialized = JsonSerialization.Minimal.Deserialize<PushEventsRequest>(new JsonTextReader(new StringReader(builder.ToString())));
Assert.AreEqual(""What up?"", deserialized.Events.First().Message);
}",Simply tests if the ApplicationJson mime type is passed in we will recieve json back from the function.,1
2092,"public void TestRedefineBuildsPlayerOutliers() {
var state = new ProtocolState();
state.Players.TryAdd(""1"", new PlayerModel() {
Uid = ""1"",
Kills = 2
});
state.Players.TryAdd(""2"", new PlayerModel() {
Uid = ""2"",
Kills = 4
});
state.Players.TryAdd(""3"", new PlayerModel() {
Uid = ""3"",
Kills = 4
});
state.Players.TryAdd(""4"", new PlayerModel() {
Uid = ""4"",
Kills = 4
});
state.Players.TryAdd(""5"", new PlayerModel() {
Uid = ""5"",
Kills = 5
});
state.Players.TryAdd(""6"", new PlayerModel() {
Uid = ""6"",
Kills = 5
});
state.Players.TryAdd(""7"", new PlayerModel() {
Uid = ""7"",
Kills = 7
});
state.Players.TryAdd(""8"", new PlayerModel() {
Uid = ""8"",
Kills = 9
});
state.Redefine();
Assert.AreEqual(""Kills"", state.Players[""8""].Outliers.First().Field);
Assert.AreEqual(5.0f, state.Players[""8""].Outliers.First().Mean);
Assert.AreEqual(2.0f, state.Players[""8""].Outliers.First().StandardDeviation);
Assert.AreEqual(2.0f, state.Players[""8""].Outliers.First().Deviations);
Assert.AreEqual(9.0f, state.Players[""8""].Outliers.First().Value);
}",Tests that player information is built after set from blank,1
2093,"public void TestCacheBuildEmptyLocalRepository() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository();
cache.Build(localRepository);
Assert.IsEmpty(cache.Repositories.SelectMany(repository => repository.Packages));
}",Tests that building with no repository and an empty local repository will result in zero package wrappers.,1
2094,"public void TestCacheBuildOrphanedLocalRepository() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository(
new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2""
}
}
);
cache.Build(localRepository);
Assert.IsNotEmpty(cache.Repositories.First(repository => repository.IsOrphanage == true).Packages);
Assert.AreEqual(""A"", cache.Repositories.First(repository => repository.IsOrphanage == true).Packages.First().Id);
Assert.AreEqual(PackageState.Installed, cache.Repositories.First(repository => repository.IsOrphanage == true).Packages.First().State);
}",Tests that building with a local repository with packages will orphan these packages because no remote repositories have been included.,1
2095,"public void TestExceptionOnCacheBuildAttachedToRepositoryModel() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository();
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockExceptionPackageRepository());
// Now successfully build the repository..
cache.Build(localRepository);
Assert.AreEqual(""GetPackages Exception"", cache.Repositories.First(repository => repository.IsOrphanage == false).CacheError);
}",Tests that an exception thrown during the cache rebuild source repository fetch will be attached to the model,1
2096,"public void TestLastCacheBuildErrorNulled() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository();
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2"",
IsLatestVersion = true
}
}));
cache.Repositories.First(repository => repository.IsOrphanage == false).CacheError = ""Error!!"";
// Now successfully build the repository..
cache.Build(localRepository);
Assert.IsNull(cache.Repositories.First(repository => repository.IsOrphanage == false).CacheError);
}",Tests the last cache build error is nulled when the repository is successfully built.,1
2097,"public void TestLastCacheBuildStampSet() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository();
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2"",
IsLatestVersion = true
}
}));
// Now successfully build the repository..
cache.Build(localRepository);
Assert.Greater(cache.Repositories.First(repository => repository.IsOrphanage == false).CacheStamp, DateTime.Now.AddSeconds(-5));
}",Tests the stamp on the repository model is set on building the cache.,1
2098,"public void TestCacheBuildSingleRemoteRepositoryEmptyLocalRepository() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository();
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2"",
IsLatestVersion = true
}
}));
cache.Build(localRepository);
Assert.IsNotEmpty(cache.Repositories.SelectMany(repository => repository.Packages));
Assert.AreEqual(""A"", cache.Repositories.SelectMany(repository => repository.Packages).First().Id);
Assert.AreEqual(PackageState.NotInstalled, cache.Repositories.SelectMany(repository => repository.Packages).First().State);
}",Tests that a single package is available for installing from a remote source with nothing installed locally.,1
2099,"public void TestCacheBuildSingleRemoteRepositoryInstalledLocalRepository() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2""
}
});
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2"",
IsLatestVersion = true
}
}));
cache.Build(localRepository);
Assert.IsNotEmpty(cache.Repositories.SelectMany(repository => repository.Packages));
Assert.AreEqual(""A"", cache.Repositories.SelectMany(repository => repository.Packages).First().Id);
Assert.AreEqual(PackageState.Installed, cache.Repositories.SelectMany(repository => repository.Packages).First().State);
}",Tests that a single package is installed from a remote source with the package installed locally.,1
2100,"public void TestCacheBuildSingleRemoteRepositoryUpdateAvailableLocalRepository() {
var cache = new RepositoryCache();
var localRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0"",
Tags = ""Procon Potato Tag2""
}
});
cache.Add(""localhost"");
cache.SourceRepositories.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""2.0.0"",
Tags = ""Procon Potato Tag2"",
IsLatestVersion = true
}
}));
cache.Build(localRepository);
Assert.IsNotEmpty(cache.Repositories.SelectMany(repository => repository.Packages));
Assert.AreEqual(""A"", cache.Repositories.SelectMany(repository => repository.Packages).First().Id);
Assert.AreEqual(PackageState.UpdateAvailable, cache.Repositories.SelectMany(repository => repository.Packages).First().State);
}",Tests that a single package is installed locally with a newer version available on the remote repository will show as update available.,1
2101,"public void TestCacheClearEmptyRepositoryListMaintainOrphanedRepository() {
var cache = new RepositoryCache();
cache.Clear();
Assert.IsNotEmpty(cache.Repositories);
Assert.IsNotNull(cache.Repositories.First(repository => repository.IsOrphanage == true));
}",Tests clearing repositories will maintain the package orphanage when the repository list is empty.,1
2102,"public void TestCacheClearSingleRepositoryListMaintainOrphanedRepository() {
var cache = new RepositoryCache();
cache.Add(""localhost"");
cache.Clear();
Assert.IsNotEmpty(cache.Repositories);
Assert.IsNotNull(cache.Repositories.First(repository => repository.IsOrphanage == true));
}",Tests clearing repositories will maintain the package orphanage when a repository exists in the list.,1
2103,"public void TestUseCommandResultContentType() {
var contentType = CommandServerSerializer.ResponseContentType(new Command() {
Result = new CommandResult() {
ContentType = Mime.ApplicationJson
}
});
Assert.AreEqual(Mime.ApplicationJson, contentType);
}",Tests that the result content type is returned if supplied.,1
2104,"public void TestNulledCommandResultContentType() {
var contentType = CommandServerSerializer.ResponseContentType(new Command() {
Result = new CommandResult() {
ContentType = null
},
Request = new HttpCommandRequest() {
Tags = new Dictionary<String, String>() {
{ HttpRequestHeader.ContentType.ToString(), Mime.ApplicationJson }
}
}
});
Assert.AreEqual(Mime.ApplicationJson, contentType);
}",Tests the request content type is used if the request result content type isn't specified.,1
2105,"public void TestNulledCommandResult() {
var contentType = CommandServerSerializer.ResponseContentType(new Command() {
Result = null,
Request = new HttpCommandRequest() {
Tags = new Dictionary<String, String>() {
{ HttpRequestHeader.ContentType.ToString(), Mime.ApplicationJson }
}
}
});
Assert.AreEqual(Mime.ApplicationJson, contentType);
}",Tests the request content type is used if the request result is null.,1
2106,"public void TestRequestAndResponseALlNullApplicationXml() {
var contentType = CommandServerSerializer.ResponseContentType(new Command() {
Result = null,
Request = new HttpCommandRequest() {
Tags = new Dictionary<String, String>() {
}
}
});
Assert.AreEqual(Mime.ApplicationJson, contentType);
}",Tests that supplying a nulled result and not supplying a header will result in ApplicationJson,1
2107,"public void TestRootOfSingleProperty() {
IConfig config = new Config().Create<MockSimpleConcrete>();
var root = config.RootOf<MockSimpleConcrete>();
Assert.AreEqual(""Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"", ((JProperty)root.Parent).Name);
}",Tests that a root can be fetched from an existing type,1
2108,"public void TestRootOfMultipleProperties() {
IConfig config = new Config().Create<MockSimpleConcrete>();
config.Document.Add(new JProperty(""Potato.Core.Shared.Test.TestConfig.Mocks.DoesNotExist"", new JArray()));
var root = config.RootOf<MockSimpleConcrete>();
Assert.AreEqual(""Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"", ((JProperty)root.Parent).Name);
}",Tests that a root can be fetched when multiple properties exist on the document,1
2109,"public void TestRootOfNotCreatedForProperty() {
IConfig config = new Config().Create<MockSimpleConcrete>();
config.Document.Add(new JProperty(""Potato.Core.Shared.Test.TestConfig.TestRootOf"", new JArray()));
var root = config.RootOf<TestRootOf>();
Assert.AreEqual(""Potato.Core.Shared.Test.TestConfig.TestRootOf"", ((JProperty)root.Parent).Name);
}",Tests that a root can be found of a type that the document was not originally created for.,1
2110,"public void TestRootOfNonExistantPropertyReturnsNotNull() {
IConfig config = new Config().Create<MockSimpleConcrete>();
var root = config.RootOf<TestRootOf>();
Assert.IsNotNull(root);
}",Tests that a root can be found of a type that the document was not originally created for.,1
2111,"public void TestExplicitTypeRootOfSingleProperty() {
IConfig config = new Config().Create<MockSimpleConcrete>();
var root = config.RootOf(typeof(MockSimpleConcrete));
Assert.AreEqual(""Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"", ((JProperty)root.Parent).Name);
}",Tests that a root can be fetched from an existing type,1
2112,"public void TestExplicitTypeRootOfMultipleProperties() {
IConfig config = new Config().Create<MockSimpleConcrete>();
config.Document.Add(new JProperty(""Potato.Core.Shared.Test.TestConfig.Mocks.DoesNotExist"", new JArray()));
var root = config.RootOf(typeof(MockSimpleConcrete));
Assert.AreEqual(""Potato.Core.Shared.Test.TestConfig.Mocks.MockSimpleConcrete"", ((JProperty)root.Parent).Name);
}",Tests that a root can be fetched when multiple properties exist on the document,1
2113,"public void TestExplicitTypeRootOfNotCreatedForProperty() {
IConfig config = new Config().Create<MockSimpleConcrete>();
config.Document.Add(new JProperty(""Potato.Core.Shared.Test.TestConfig.TestRootOf"", new JArray()));
var root = config.RootOf(typeof(TestRootOf));
Assert.AreEqual(""Potato.Core.Shared.Test.TestConfig.TestRootOf"", ((JProperty)root.Parent).Name);
}",Tests that a root can be found of a type that the document was not originally created for.,1
2114,"public void TestExplicitTypeRootOfNonExistantPropertyReturnsNotNull() {
IConfig config = new Config().Create<MockSimpleConcrete>();
var root = config.RootOf(typeof(TestRootOf));
Assert.IsNotNull(root);
}",Tests that a root can be found of a type that the document was not originally created for.,1
2115,"public void TestTypeNullException() {
new Config().RootOf((Type)null);
}",Tests an argument null exception is raised if null is passed into RootOf.,1
2116,"public void TestStringNullException() {
new Config().RootOf((String)null);
}",Tests an argument null exception is raised if null is passed into RootOf.,1
2117,"public void TestShutdownSandboxedNulledAfterShutdown() {
var controller = new SandboxProtocolController() {
SandboxedProtocol = new MockIntegrationTestProtocol()
};
controller.Shutdown();
Assert.IsNull(controller.SandboxedProtocol);
}",Tests the SandboxedProtocol is nulled after a shutdown.,1
2118,"public void TestEmptyDocumentCreatesFile() {
IConfig config = new Config();
config.Save(this.ConfigFileA);
this.ConfigFileA.Refresh();
Assert.IsTrue(this.ConfigFileA.Exists);
}","Tests that an empty config will save an empty file, but the file will be created",1
2119,"public void TestSimpleDocumentCreatesFile() {
IConfig config = new Config() {
Document = new JObject() {
new JProperty(""Hello"", ""World!"")
}
};
config.Save(this.ConfigFileA);
this.ConfigFileA.Refresh();
Assert.IsTrue(this.ConfigFileA.Exists);
}",Tests that a single item in the config will be saved to file.,1
2120,"public void TestSimpleDocumentCanDeserialize() {
IConfig config = new Config() {
Document = new JObject() {
new JProperty(""Hello"", ""World!"")
}
};
config.Save(this.ConfigFileA);
JObject deseralized = JsonConvert.DeserializeObject(File.ReadAllText(this.ConfigFileA.FullName)) as JObject;
Assert.IsNotNull(deseralized);
Assert.AreEqual(""World!"", deseralized[""Hello""].Value<String>());
}",Tests that a single item in the config will be saved to file can be loaded once again.,1
2121,"public void TestNullException() {
IConfig config = new Config();
config.Save(null);
}",Tests an argument null exception is raised if null is passed into save.,1
2122,"public void TestFileExistsInBaseDirectory() {
List<String> paths = Defines.SearchPaths(""Potato.Service.Shared.Test.dll"", new List<String>() {
Defines.BaseDirectory.FullName
});
Assert.IsNotEmpty(paths);
}",Tests a file can be found in the base directory,1
2123,"public void TestFileDoesNotExist() {
List<String> paths = Defines.SearchPaths(""lulz.dll"", new List<String>() {
Defines.BaseDirectory.FullName
});
Assert.IsEmpty(paths);
}",Tests a file can be found in the base directory,1
2124,"public void TestFileExistsInPackagesDirectory() {
DirectoryInfo directory = new DirectoryInfo(Path.Combine(Defines.PackagesDirectory.FullName, ""Exists.1.0.0"", ""lib"", ""net40""));
FileInfo file = new FileInfo(Path.Combine(directory.FullName, ""Potato.Core.txt""));
directory.Create();
File.WriteAllText(file.FullName, ""Test Output"");
List<String> paths = Defines.SearchPaths(file.Name, new List<String>() {
directory.FullName
});
Assert.IsNotEmpty(paths);
}",Tests that a file will be found in the packages folder,1
2125,"public void TestFileExistsInPackagesAndBaseDirectory() {
DirectoryInfo directory = new DirectoryInfo(Path.Combine(Defines.PackagesDirectory.FullName, ""Exists.1.0.0"", ""lib"", ""net40""));
FileInfo file = new FileInfo(Path.Combine(directory.FullName, ""Potato.Core.txt""));
directory.Create();
File.WriteAllText(file.FullName, ""Test Output"");
File.WriteAllText(Path.Combine(Defines.BaseDirectory.FullName, ""Potato.Core.txt""), ""Test Output"");
List<String> paths = Defines.SearchPaths(file.Name, new List<String>() {
Defines.BaseDirectory.FullName,
directory.FullName
});
Assert.IsNotEmpty(paths);
Assert.AreEqual(2, paths.Count);
}",Tests that a file will be found in the packages folder and base directory,1
2126,"public void TestSecurityDispose() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.VariablesSet,
77
})
});
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermissionDescription(""GroupName"", CommandType.VariablesSet.ToString(), ""Description!"").SetOrigin(CommandOrigin.Local));
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountSetPassword,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
""password""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountSetPreferredLanguageCode,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
""de-DE""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountAddPlayer,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
CommonProtocolType.DiceBattlefield3,
""ABCDEF""
})
});
GroupModel group = security.Groups.Last();
AccountModel account = group.Accounts.First();
PermissionModel permission = group.Permissions.First(p => p.Name == CommandType.VariablesSet.ToString());
AccountPlayerModel accountPlayer = account.Players.First();
security.Dispose();
// Test that all the lists and data within each item has been nulled.
Assert.IsNull(security.Groups);
Assert.IsNull(group.Name);
Assert.IsNull(group.Permissions);
Assert.IsNull(group.Accounts);
Assert.IsNull(account.Username);
Assert.IsNull(account.PreferredLanguageCode);
Assert.IsNull(account.PasswordHash);
Assert.IsNull(account.Players);
Assert.IsNull(account.Group);
Assert.AreEqual(CommandType.None, permission.CommandType);
Assert.IsNull(permission.Name);
Assert.IsNull(permission.Authority);
Assert.IsNull(permission.Traits);
Assert.IsNull(permission.Description);
Assert.AreEqual(CommonProtocolType.None, accountPlayer.ProtocolType);
Assert.IsNull(accountPlayer.Uid);
Assert.IsNull(accountPlayer.Account);
}","Tests that when disposing of the security object, all other items are cleaned up.",1
2127,"public void TestSecurityLoadConfig() {
var saveSecurity = new SecurityController();
saveSecurity.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
saveSecurity.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""CustomPermission"",
22
})
});
saveSecurity.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.VariablesSet,
77
})
});
saveSecurity.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.VariablesSetA,
88
})
});
saveSecurity.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
saveSecurity.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountSetPassword,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
""password""
})
});
saveSecurity.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.Parse(""f380eb1e-1438-48c0-8c3d-ad55f2d40538""), ""Token Hash"", DateTime.Parse(""2024-04-14 20:51:00 PM"")).SetOrigin(CommandOrigin.Local));
saveSecurity.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountSetPreferredLanguageCode,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
""de-DE""
})
});
saveSecurity.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountAddPlayer,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
CommonProtocolType.DiceBattlefield3,
""ABCDEF""
})
});
// Save a config of the security controller
var saveConfig = new Config();
saveConfig.Create(typeof(SecurityController));
saveSecurity.WriteConfig(saveConfig);
saveConfig.Save(ConfigFileInfo);
// Load the config in a new config.
var loadSecurity = (SecurityController)new SecurityController().Execute();
var loadConfig = new Config();
loadConfig.Load(ConfigFileInfo);
loadSecurity.Execute(loadConfig);
var lastGroup = loadSecurity.Groups.LastOrDefault(group => @group.Name == ""GroupName"") ?? new GroupModel();
Assert.AreEqual(""Guest"", loadSecurity.Groups.First().Name);
Assert.AreEqual(""GroupName"", loadSecurity.Groups.Last().Name);
Assert.AreEqual(22, lastGroup.Permissions.First(permission => permission.Name == ""CustomPermission"").Authority);
Assert.AreEqual(77, lastGroup.Permissions.First(permission => permission.Name == CommandType.VariablesSet.ToString()).Authority);
Assert.AreEqual(88, lastGroup.Permissions.First(permission => permission.Name == CommandType.VariablesSetA.ToString()).Authority);
Assert.AreEqual(""Phogue"", loadSecurity.Groups.SelectMany(group => group.Accounts).First().Username);
Assert.AreEqual(Guid.Parse(""f380eb1e-1438-48c0-8c3d-ad55f2d40538""), loadSecurity.Groups.SelectMany(group => group.Accounts).First().AccessTokens.First().Value.Id);
Assert.AreEqual(""Token Hash"", loadSecurity.Groups.SelectMany(group => group.Accounts).First().AccessTokens.First().Value.TokenHash);
Assert.AreEqual(DateTime.Parse(""2024-04-14 20:51:00 PM""), loadSecurity.Groups.SelectMany(group => group.Accounts).First().AccessTokens.First().Value.LastTouched);
Assert.AreEqual(""de-DE"", loadSecurity.Groups.Last().Accounts.First().PreferredLanguageCode);
Assert.AreEqual(CommonProtocolType.DiceBattlefield3, loadSecurity.Groups.SelectMany(group => group.Accounts).SelectMany(account => account.Players).First().ProtocolType);
Assert.AreEqual(""ABCDEF"", loadSecurity.Groups.SelectMany(group => group.Accounts).SelectMany(account => account.Players).First().Uid);
// Now validate that we can authenticate against the loaded in password
ICommandResult result = loadSecurity.Tunnel(CommandBuilder.SecurityAccountAuthenticate(""Phogue"", ""password"", String.Empty).SetOrigin(CommandOrigin.Local));
// Validate that we could authenticate with our new password.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
}",Tests that a config can be successfully loaded,1
2128,"public void TestSecurityWriteConfig() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""CustomPermission"",
22
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.VariablesSet,
77
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.VariablesSetA,
88
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""Phogue""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountSetPassword,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
""password""
})
});
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.Parse(""f380eb1e-1438-48c0-8c3d-ad55f2d40538""), ""Token Hash"", DateTime.Parse(""2024-04-14 20:51:00 PM"")).SetOrigin(CommandOrigin.Local));
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountSetPreferredLanguageCode,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
""de-DE""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountAddPlayer,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
CommonProtocolType.DiceBattlefield3,
""ABCDEF""
})
});
// Save a config of the language controller
var saveConfig = new Config();
saveConfig.Create(typeof(SecurityController));
security.WriteConfig(saveConfig);
saveConfig.Save(ConfigFileInfo);
// Load the config in a new config.
var loadConfig = new Config();
loadConfig.Load(ConfigFileInfo);
var commands = loadConfig.RootOf<SecurityController>().Children<JObject>().Select(item => item.ToObject<IConfigCommand>(JsonSerialization.Minimal)).ToList();
Assert.AreEqual(""SecurityAddGroup"", commands[0].Command.Name);
Assert.AreEqual(""Guest"", commands[0].Command.Parameters[0].First<String>());
Assert.AreEqual(""SecurityAddGroup"", commands[1].Command.Name);
Assert.AreEqual(""GroupName"", commands[1].Command.Parameters[0].First<String>());
Assert.AreEqual(""SecurityGroupSetPermission"", commands[2].Command.Name);
Assert.AreEqual(""GroupName"", commands[2].Command.Parameters[0].First<String>());
Assert.AreEqual(CommandType.VariablesSet.ToString(), commands[2].Command.Parameters[1].First<String>());
Assert.AreEqual(""77"", commands[2].Command.Parameters[2].First<String>());
Assert.AreEqual(""SecurityGroupSetPermission"", commands[3].Command.Name);
Assert.AreEqual(""GroupName"", commands[3].Command.Parameters[0].First<String>());
Assert.AreEqual(CommandType.VariablesSetA.ToString(), commands[3].Command.Parameters[1].First<String>());
Assert.AreEqual(""88"", commands[3].Command.Parameters[2].First<String>());
Assert.AreEqual(""SecurityGroupSetPermission"", commands[4].Command.Name);
Assert.AreEqual(""GroupName"", commands[4].Command.Parameters[0].First<String>());
Assert.AreEqual(""CustomPermission"", commands[4].Command.Parameters[1].First<String>());
Assert.AreEqual(""22"", commands[4].Command.Parameters[2].First<String>());
Assert.AreEqual(""SecurityGroupAddAccount"", commands[5].Command.Name);
Assert.AreEqual(""GroupName"", commands[5].Command.Parameters[0].First<String>());
Assert.AreEqual(""Phogue"", commands[5].Command.Parameters[1].First<String>());
Assert.AreEqual(""SecurityAccountSetPasswordHash"", commands[6].Command.Name);
Assert.AreEqual(""Phogue"", commands[6].Command.Parameters[0].First<String>());
// We can only test if this isn't null as it contains a random salt and resulting hash.
Assert.IsNotNull(commands[6].Command.Parameters[1].First<String>());
Assert.AreEqual(""SecurityAccountSetPreferredLanguageCode"", commands[7].Command.Name);
Assert.AreEqual(""Phogue"", commands[7].Command.Parameters[0].First<String>());
Assert.AreEqual(""de-DE"", commands[7].Command.Parameters[1].First<String>());
Assert.AreEqual(""SecurityAccountAddPlayer"", commands[8].Command.Name);
Assert.AreEqual(""Phogue"", commands[8].Command.Parameters[0].First<String>());
Assert.AreEqual(CommonProtocolType.DiceBattlefield3, commands[8].Command.Parameters[1].First<String>());
Assert.AreEqual(""ABCDEF"", commands[8].Command.Parameters[2].First<String>());
Assert.AreEqual(""SecurityAccountAppendAccessToken"", commands[9].Command.Name);
Assert.AreEqual(""Phogue"", commands[9].Command.Parameters[0].First<String>());
Assert.AreEqual(Guid.Parse(""f380eb1e-1438-48c0-8c3d-ad55f2d40538""), commands[9].Command.Parameters[1].First<Guid>());
Assert.AreEqual(""Token Hash"", commands[9].Command.Parameters[2].First<String>());
Assert.AreEqual(DateTime.Parse(""2024-04-14 20:51:00 PM""), commands[9].Command.Parameters[3].First<DateTime>());
}",Tests that a config can be written in a specific format.,1
2129,"public void TestAddSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now add a player to the ""Phogue"" account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""Phogue"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
// Validate the player was added successfully.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.AreEqual(security.Groups.SelectMany(group => group.Accounts).SelectMany(account => account.Players).First().ProtocolType, CommonProtocolType.DiceBattlefield3);
Assert.AreEqual(security.Groups.SelectMany(group => group.Accounts).SelectMany(account => account.Players).First().Uid, ""ABCDEF"");
}",Tests that a player can be added to an account.,1
2130,"public void TestEmptyUidFailure() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now add a player to the ""Phogue"" account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""Phogue"", CommonProtocolType.DiceBattlefield3, String.Empty).SetOrigin(CommandOrigin.Local));
// Validate the player was added successfully.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Tests that a player cannot be added with a zero length UID.,1
2131,"public void TestExistingPlayerMoved() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""PapaCharlie9"").SetOrigin(CommandOrigin.Local));
// Now add a player to the ""Phogue"" account.
security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""Phogue"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
// Now add the same player to the ""PapaCharlie9"" account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""PapaCharlie9"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
// Validate the command was a success and the player is attached to the ""PapaCharlie9"" account
// and no longer attached to the ""Phogue"" account.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.IsNull(security.Groups.SelectMany(group => group.Accounts).Where(account => account.Username == ""Phogue"").SelectMany(account => account.Players).FirstOrDefault());
Assert.AreEqual(security.Groups.SelectMany(group => group.Accounts).Where(account => account.Username == ""PapaCharlie9"").SelectMany(account => account.Players).First().ProtocolType, CommonProtocolType.DiceBattlefield3);
Assert.AreEqual(security.Groups.SelectMany(group => group.Accounts).Where(account => account.Username == ""PapaCharlie9"").SelectMany(account => account.Players).First().Uid, ""ABCDEF"");
}",Tests that a player will be re-assigned to another account if the player already exists.,1
2132,"public void TestInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""PapaCharlie9"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that we cannot add a player to an account if we don't have permission to do so.,1
2133,"public void TestInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.NewGuid(), ""TokenHash"", DateTime.Now)
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that we cannot set the password of an account if we do not have permission to do so.,1
2134,"public void TestAccountDoesNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now append the token onto the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""DoesNotExist"", Guid.NewGuid(), ""TokenHash"", DateTime.Now).SetOrigin(CommandOrigin.Local));
// Validate that we could not set a password and the result returned false.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests we get an empty command result back if the account we try to set a password on does not exist.,1
2135,"public void TestEmptyId() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now append the token onto the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.Empty, ""TokenHash"", DateTime.Now).SetOrigin(CommandOrigin.Local));
// Validate that we could not set a password and the result returned false.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Validates that a token cannot be appended with an empty guid,1
2136,"public void TestEmptyTokenHash() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now append the token onto the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.NewGuid(), """", DateTime.Now).SetOrigin(CommandOrigin.Local));
// Validate that we could not set a password and the result returned false.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Validates that a token cannot be appended with an empty TokenHash,1
2137,"public void TestExpiredToken() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now append the token onto the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.NewGuid(), ""TokenHash"", DateTime.Now.AddDays(-3)).SetOrigin(CommandOrigin.Local));
// Validate that we could not set a password and the result returned false.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Validates that a token cannot be appended with an expired touched time,1
2138,"public void TestSetSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now append the token onto the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.NewGuid(), ""TokenHash"", DateTime.Now).SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
}",Tests that appending a new valid token hash returns success,1
2139,"public void TestSetSuccessAppearsInAccountTokens() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now append the token onto the account.
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.NewGuid(), ""TokenHash"", DateTime.Now).SetOrigin(CommandOrigin.Local));
Assert.IsNotEmpty(security.Groups.SelectMany(group => group.Accounts).First(account => account.Username == ""Phogue"").AccessTokens);
}",Tests that setting a new token appears in the list of tokens for the account.,1
2140,"public void TestSetSuccessIdenticalIdsOverwriteWithNewData() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
Guid id = Guid.NewGuid();
// Now append the token onto the account.
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", id, ""TokenHashOne"", DateTime.Now).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", id, ""TokenHashTwo"", DateTime.Now).SetOrigin(CommandOrigin.Local));
Assert.AreEqual(""TokenHashTwo"", security.Groups.SelectMany(group => @group.Accounts).First(account => account.Username == ""Phogue"").AccessTokens.First().Value.TokenHash);
}","Tests that multiple token id's won't exist, but instead later tokens will overwrite the token hash",1
2141,"public void TestAddingTooManyTokensCullsTheTokenList() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
Guid oldest = Guid.NewGuid();
// The default limit is 5. I figured I should test with the defaults.
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", oldest, ""TokenHashOldest"", DateTime.Now.AddHours(-1)).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.NewGuid(), ""TokenHashOne"", DateTime.Now).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.NewGuid(), ""TokenHashTwo"", DateTime.Now).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.NewGuid(), ""TokenHashThree"", DateTime.Now).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.NewGuid(), ""TokenHashFour"", DateTime.Now).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", Guid.NewGuid(), ""TokenHashFive"", DateTime.Now).SetOrigin(CommandOrigin.Local));
// Test that we have the maximum and the oldest token isn't in the list.
Assert.AreEqual(5, security.Groups.SelectMany(group => @group.Accounts).First(account => account.Username == ""Phogue"").AccessTokens.Count);
Assert.IsNull(security.Groups.SelectMany(group => @group.Accounts).First(account => account.Username == ""Phogue"").AccessTokens.Where(token => token.Key == oldest).Select(token => token.Value).FirstOrDefault());
}",Tests adding above the maximum amount of token hashes will cull the list of the oldest token,1
2142,"public void TestAuthenticationSuccess() {
String generatedAuthenticatePassword = StringExtensions.RandomString(10);
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""Phogue"", generatedAuthenticatePassword).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityAccountAuthenticate, 50).SetOrigin(CommandOrigin.Local));
// Now authenticate against an empty security object which has no accounts.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticate(""Phogue"", generatedAuthenticatePassword, String.Empty).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
// Validate that we get nothing back.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests authentication is successful when correct details are supplied,1
2143,"public void TestAccountGroupReturnedInResult() {
String generatedAuthenticatePassword = StringExtensions.RandomString(10);
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""Phogue"", generatedAuthenticatePassword).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityAccountAuthenticate, 50).SetOrigin(CommandOrigin.Local));
// Now authenticate against an empty security object which has no accounts.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticate(""Phogue"", generatedAuthenticatePassword, String.Empty).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
// Validate that we get nothing back.
Assert.AreEqual(""Phogue"", result.Scope.Accounts.First().Username);
Assert.AreEqual(""GroupName"", result.Scope.Groups.First().Name);
}",Tests that authentication returns the users account and group when successful.,1
2144,"public void TestAccountDoesNotExist() {
String generatedAuthenticatePassword = StringExtensions.RandomString(10);
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""ThisExists"").SetOrigin(CommandOrigin.Local));
// Now authenticate against an empty security object which has no accounts.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticate(""DoesNotExist"", generatedAuthenticatePassword, String.Empty).SetOrigin(CommandOrigin.Local));
// Validate that we get nothing back.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.Failed, result.CommandResultType);
}",Tests that authentication returns nothing if an account does not exist.,1
2145,"public void TestInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""Phogue"", ""password"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticate(""Phogue"", ""password"", String.Empty).SetOrigin(CommandOrigin.Local).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that the account cannot be authenticated against if the account does not have permissions to authenticate in the first place.,1
2146,"public void TestUnsetPassword() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now send an empty password through to authenticate against.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticate(""Phogue"", String.Empty, String.Empty).SetOrigin(CommandOrigin.Local));
// Validate that we couldn't login because the server does not have a password set for it yet.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.Failed, result.CommandResultType);
}",Validates that we can't login to an account that has not had a password setup for it yet.,1
2147,"public void TestAuthenticationSuccessTokenGenerated() {
String generatedAuthenticatePassword = StringExtensions.RandomString(10);
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""Phogue"", generatedAuthenticatePassword).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityAccountAuthenticate, 50).SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticate(""Phogue"", generatedAuthenticatePassword, ""192.168.1.1"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsNotEmpty(result.Scope.AccessTokens);
}",Tests we get a token back when authenticating with an identifier.,1
2148,"public void TestAuthenticationSuccessCanThenAuthenticateWithToken() {
String generatedAuthenticatePassword = StringExtensions.RandomString(10);
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""Phogue"", generatedAuthenticatePassword).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityAccountAuthenticate, 50).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityAccountAuthenticateToken, 50).SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticate(""Phogue"", generatedAuthenticatePassword, ""192.168.1.1"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
AccessTokenTransportModel token = result.Scope.AccessTokens.First();
result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticateToken(token.Id, token.Token, ""192.168.1.1"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Token = token.Token,
TokenId = token.Id
}));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that we can authenticate with the token that was generated.,1
2149,"public void TestAuthenticationFailureWhenAuthenticateWithTokenDifferentIdentifier() {
String generatedAuthenticatePassword = StringExtensions.RandomString(10);
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""Phogue"", generatedAuthenticatePassword).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityAccountAuthenticate, 50).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityAccountAuthenticateToken, 50).SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticate(""Phogue"", generatedAuthenticatePassword, ""192.168.1.1"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
AccessTokenTransportModel token = result.Scope.AccessTokens.First();
result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticateToken(token.Id, token.Token, ""192.168.1.2"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Token = token.Token,
TokenId = token.Id
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.Failed, result.CommandResultType);
}","This is tested more thoroughly elsewhere, but this is just testing the entire process.",1
2150,"public void TestInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticateToken(Guid.NewGuid(), ""TokenHash"", ""id"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that we cannot set the password of an account if we do not have permission to do so.,1
2151,"public void TestCannotAuthenticateAgainstEmptyTokenList() {
const string identifier = ""192.168.1.1"";
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now validate that we can authenticate against the newly appended token hash
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticateToken(Guid.NewGuid(), ""token"", identifier).SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.Failed, result.CommandResultType);
}",Tests that a generic Failed is returned if the user has no tokens attached to them.,1
2152,"public void TestCannotAuthenticateAgainstDifferentTokenId() {
const string identifier = ""192.168.1.1"";
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
Username = ""Phogue"",
PasswordHash = ""MyPasswordHash""
}
};
var token = accessToken.Generate(identifier);
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPasswordHash(""Phogue"", ""MyPasswordHash"").SetOrigin(CommandOrigin.Local));
// Now append the token onto the account.
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", accessToken.Id, accessToken.TokenHash, accessToken.LastTouched).SetOrigin(CommandOrigin.Local));
// Now validate that we can authenticate against the newly appended token hash
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticateToken(Guid.NewGuid(), token, identifier).SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.Failed, result.CommandResultType);
}",Tests that a generic Failed is returned if the token id does not exist,1
2153,"public void TestSetSuccessCanAuthenticateAgainst() {
const string identifier = ""192.168.1.1"";
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
Username = ""Phogue"",
PasswordHash = ""MyPasswordHash""
}
};
var token = accessToken.Generate(identifier);
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPasswordHash(""Phogue"", ""MyPasswordHash"").SetOrigin(CommandOrigin.Local));
// Now append the token onto the account.
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", accessToken.Id, accessToken.TokenHash, accessToken.LastTouched).SetOrigin(CommandOrigin.Local));
// Now validate that we can authenticate against the newly appended token hash
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticateToken(accessToken.Id, token, identifier).SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
}",Tests that setting a new token can be validated against.,1
2154,"public void TestModifiedPasswordHashAfterSettingInvalidatesToken() {
const string identifier = ""192.168.1.1"";
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
Username = ""Phogue"",
PasswordHash = ""MyPasswordHash""
}
};
var token = accessToken.Generate(identifier);
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPasswordHash(""Phogue"", ""MyPasswordHash"").SetOrigin(CommandOrigin.Local));
// Now append the token onto the account.
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", accessToken.Id, accessToken.TokenHash, accessToken.LastTouched).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPasswordHash(""Phogue"", ""MyModifiedPasswordHash"").SetOrigin(CommandOrigin.Local));
// Now validate that we can authenticate against the newly appended token hash
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticateToken(accessToken.Id, token, identifier).SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.Failed, result.CommandResultType);
}","Tests that setting an access token, then changing a password hash will invalidate the token.",1
2155,"public void TestModifiedIdentiferAfterSettingInvalidatesToken() {
const string identifier = ""192.168.1.1"";
AccessTokenModel accessToken = new AccessTokenModel() {
Account = new AccountModel() {
Username = ""Phogue"",
PasswordHash = ""MyPasswordHash""
}
};
var token = accessToken.Generate(identifier);
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPasswordHash(""Phogue"", ""MyPasswordHash"").SetOrigin(CommandOrigin.Local));
// Now append the token onto the account.
security.Tunnel(CommandBuilder.SecurityAccountAppendAccessToken(""Phogue"", accessToken.Id, accessToken.TokenHash, accessToken.LastTouched).SetOrigin(CommandOrigin.Local));
// Now validate that we can authenticate against the newly appended token hash
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountAuthenticateToken(accessToken.Id, token, ""192.168.1.2"").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.Failed, result.CommandResultType);
}","Tests that setting an access token, but attempting to authenticate with a different identifier will result in failed authentication",1
2156,"public void TestAccountDoesNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""ThisExists"").SetOrigin(CommandOrigin.Local));
// Now change the password of the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""DoesNotExist"", ""password"").SetOrigin(CommandOrigin.Local));
// Validate that we could not set a password and the result returned false.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests we get an empty command result back if the account we try to set a password on does not exist.,1
2157,"public void TestAccountInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""Phogue"", ""password"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}","Tests that we cannot set the password of an account if we do not have permission to do so. Thinking about this, we may need to write this to allow users to set their own passwords. This should be done within the SecurityController to determine if a CommandName can edit it's own account details.",1
2158,"public void TestEmptyPassword() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now change the password of the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""Phogue"", String.Empty).SetOrigin(CommandOrigin.Local));
// Validate that we could not set a password and the result returned false.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Validates that we can't set an empty password.,1
2159,"public void TestInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountSetPasswordHash(""Phogue"", BCrypt.Net.BCrypt.HashPassword(""password"", BCrypt.Net.BCrypt.GenerateSalt()))
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}","Tests that we cannot set the password of an account if we do not have permission to do so. Thinking about this, we may need to write this to allow users to set their own passwords. This should be done within the SecurityController to determine if a CommandName can edit it's own account details.",1
2160,"public void TestAccountDoesNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now change the password of the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountSetPasswordHash(""DoesNotExist"", BCrypt.Net.BCrypt.HashPassword(""password"", BCrypt.Net.BCrypt.GenerateSalt())).SetOrigin(CommandOrigin.Local));
// Validate that we could not set a password and the result returned false.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests we get an empty command result back if the account we try to set a password on does not exist.,1
2161,"public void TestEmptyPassword() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now change the password of the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountSetPasswordHash(""Phogue"", String.Empty).SetOrigin(CommandOrigin.Local));
// Validate that we could not set a password and the result returned false.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Validates that we can't set an empty password.,1
2162,"public void TestInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Ike"").SetOrigin(CommandOrigin.Local));
// Now change the language of the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountSetPreferredLanguageCode(""Ike"", ""de-DE"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that an account cannot set the preferred language of another account unless they have permission to do so.,1
2163,"public void TestOwnAccount() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountSetPreferredLanguageCode(""Phogue"", ""de-DE"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue"" })
);
// Make sure it was successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.AreEqual(security.Groups.Last().Accounts.First().PreferredLanguageCode, ""de-DE"");
}","Tests that an account can set their own preferred language, even if their group does not have permission to do so.",1
2164,"public void TestLanguageDoesNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now change the language of the account.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityAccountSetPreferredLanguageCode(""Phogue"", ""zu-ZU"").SetOrigin(CommandOrigin.Local));
// Make sure it was successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""zu-ZU"", security.Groups.Last().Accounts.First().PreferredLanguageCode);
}",Tests that setting a language code that does not exist will still set the preferred language code of the account to whatever the string was.,1
2165,"public void TestSecurityAddGroup() {
var security = new SecurityController();
// Add a group.
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Make sure it was successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(security.Groups.Last().Name, ""GroupName"");
}",Testing that we can add a simple group.,1
2166,"public void TestSecurityAddGroupDuplicateGroupName() {
var security = new SecurityController();
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Test that the group was initially added.
Assert.AreEqual(security.Groups.Last().Name, ""GroupName"");
// Now readd the same group name.
result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Test the second result, make sure it failed.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.AlreadyExists);
}",Testing that two groups with identical names can't be added to the security model.,1
2167,"public void TestSecurityAddGroupEmptyGroupName() {
var security = new SecurityController();
// Add a group with an empty name.
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
String.Empty
})
});
// Make sure adding an empty group fails.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Testing that a group with an empty name can't be added to the security model.,1
2168,"public void TestSecurityAddGroupInsufficientPermission() {
var security = new SecurityController();
// Add a group.
ICommandResult result = security.Tunnel(new Command() {
CommandType = CommandType.SecurityAddGroup,
Authentication = {
Username = ""Phogue""
},
Origin = CommandOrigin.Remote,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a group cannot be added unless the user has sufficient permissions to do so.,1
2169,"public void TestSecurityGroupsCopyPermissions() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""FirstGroupName""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""SecondGroupName""
})
});
// Test that the groups were initially added.
Assert.IsNotNull(security.Groups.FirstOrDefault(group => @group.Name == ""FirstGroupName""));
Assert.IsNotNull(security.Groups.FirstOrDefault(group => @group.Name == ""SecondGroupName""));
// Setup two permissions on the first group.
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""FirstGroupName"",
CommandType.VariablesSet,
77
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""FirstGroupName"",
CommandType.VariablesSetA,
88
})
});
var firstGroup = security.Groups.FirstOrDefault(group => @group.Name == ""FirstGroupName"") ?? new GroupModel();
var secondGroup = security.Groups.FirstOrDefault(group => @group.Name == ""SecondGroupName"") ?? new GroupModel();
// Validate original permissions were added.
Assert.AreEqual(firstGroup.Permissions.First(permission => permission.Name == CommandType.VariablesSet.ToString()).Authority, 77);
Assert.AreEqual(firstGroup.Permissions.First(permission => permission.Name == CommandType.VariablesSetA.ToString()).Authority, 88);
Assert.IsNull(secondGroup.Permissions.First(permission => permission.Name == CommandType.VariablesSet.ToString()).Authority);
Assert.IsNull(secondGroup.Permissions.First(permission => permission.Name == CommandType.VariablesSetA.ToString()).Authority);
// Now copy the permissions from the first group, to the other group.
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupCopyPermissions,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""FirstGroupName"",
""SecondGroupName""
})
});
// Now make sure the user was initially added.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.AreEqual(secondGroup.Permissions.First(permission => permission.Name == CommandType.VariablesSet.ToString()).Authority, 77);
Assert.AreEqual(secondGroup.Permissions.First(permission => permission.Name == CommandType.VariablesSetA.ToString()).Authority, 88);
}",Tests that permissions will be copied from one group to another.,1
2170,"public void TestSecurityGroupsCopyPermissionsInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""FirstGroupName""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""SecondGroupName""
})
});
ICommandResult result = security.Tunnel(new Command() {
CommandType = CommandType.SecurityGroupCopyPermissions,
Authentication = {
Username = ""Phogue""
},
Origin = CommandOrigin.Remote,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""FirstGroupName"",
""SecondGroupName""
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests the command to add an account failes if the user has insufficient privileges.,1
2171,"public void TestSecurityGroupsCopyPermissionsSourceDoesNotExist() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""SecondGroupName""
})
});
// Test that the group was initially added.
Assert.IsNotNull(security.Groups.FirstOrDefault(group => @group.Name == ""SecondGroupName""));
// Now copy the permissions from the first group, to the other group.
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupCopyPermissions,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""FirstGroupName"",
""SecondGroupName""
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.DoesNotExists);
}",Tests that the correct error message is returned when permissions can't be copied from a source group because the source group does not exist.,1
2172,"public void TestSecurityGroupsSetCustomPermission() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Test that the group was initially added.
Assert.AreEqual(security.Groups.Last().Name, ""GroupName"");
// Now set the kick permission
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
""CustomPermission"",
50
})
});
// Make sure setting the kick permission was successfull.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.AreEqual(security.Groups.Last().Permissions.First(permission => permission.Name == ""CustomPermission"").Authority, 50);
}",Tests that a custom permission can be set against a group.,1
2173,"public void TestSecurityGroupsSetPermissionDynamicallyCreate() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Test that the group was initially added.
Assert.AreEqual(security.Groups.Last().Name, ""GroupName"");
// Remove the kick permission.
security.Groups.Last().Permissions.RemoveAll(permission => permission.Name == CommandType.VariablesSet.ToString());
// Validate the kick permission does not exist.
Assert.IsNull(security.Groups.Last().Permissions.FirstOrDefault(permission => permission.Name == CommandType.VariablesSet.ToString()));
// Now set the kick permission
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.VariablesSet,
50
})
});
// Make sure setting the kick permission was successfull.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.AreEqual(security.Groups.Last().Permissions.First(permission => permission.Name == CommandType.VariablesSet.ToString()).Authority, 50);
}",Checks that if a permission is not in the list (usually if we add to CommandName enum) that the permission will be created and set.,1
2174,"public void TestSecurityGroupsSetPermissionSettingOwnSetPermissionToNothingDenied() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""Phogue"", ""Password"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityGroupSetPermission, 50).SetOrigin(CommandOrigin.Local));
// Now attempt to revoke our permission to set a permission
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityGroupSetPermission, 0).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue"",
PasswordPlainText = ""password""
}));
// Make sure the command just nulls out. It couldn't find anything to even try to set the permission.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
}",Tests that a user can't revoke their groups permission to set permissions. They will need to get another group to do this.,1
2175,"public void TestSecurityGroupsSetPermissionSettingOwnAuthenticateToNothingDenied() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountSetPassword(""Phogue"", ""Password"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityGroupSetPermission, 50).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityAccountAuthenticate, 50).SetOrigin(CommandOrigin.Local));
// Now attempt to revoke our permission to authenticate with the system
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityAccountAuthenticate, 0).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue"",
PasswordPlainText = ""password""
}));
// Make sure the command just nulls out. It couldn't find anything to even try to set the permission.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
}",Tests that a user can't revoke their groups permission to set authenticate. They will need to get another group to do this.,1
2176,"public void TestSecurityGroupsSetPermissionInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
ICommandResult result = security.Tunnel(new Command() {
CommandType = CommandType.SecurityGroupSetPermission,
Authentication = {
Username = ""Phogue""
},
Origin = CommandOrigin.Remote,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.VariablesSet,
50
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests the command to add an account failes if the user has insufficient privileges.,1
2177,"public void TestSecurityGroupsSetPermissionTypeConvert() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Test that the group was initially added.
Assert.AreEqual(security.Groups.Last().Name, ""GroupName"");
// Now set the kick permission
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName"",
CommandType.VariablesSet.ToString(),
60
})
});
// Make sure setting the kick permission was successfull.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.AreEqual(security.Groups.Last().Permissions.First(permission => permission.Name == CommandType.VariablesSet.ToString()).Authority, 60);
}","Testing if ""Kick"" will be converted since this value will be serialized.",1
2178,"public void TestSecurityRemoveGroup() {
var security = new SecurityController();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Test that the group was initially added.
Assert.AreEqual(security.Groups.Last().Name, ""GroupName"");
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityRemoveGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Make sure it was successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(security.Groups.Count, 1);
}",Testing that a group can be removed by its name.,1
2179,"public void TestRemoveGroupByLocalSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityRemoveGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
// Make sure it was successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that a group can be removed if executed locally,1
2180,"public void TestRemoveOwnGroupFailure() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityRemoveGroup, 1).SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityRemoveGroup(""GroupName"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
}",Tests that a user cannot remove their own group,1
2181,"public void TestSecurityRemoveGuestGroup() {
var security = new SecurityController();
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityRemoveGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Guest""
})
});
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
Assert.AreEqual(security.Groups.Count, 1);
}",Tests that removing the guest account will fail.,1
2182,"public void TestSecurityRemoveGroupEmptyGroupName() {
var security = new SecurityController();
// Add a group with an empty name.
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityRemoveGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
String.Empty
})
});
// Make sure adding an empty group fails.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Testing that you can't remove a group name that is empty.,1
2183,"public void TestSecurityRemoveGroupNotExists() {
var security = new SecurityController();
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityRemoveGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""GroupName""
})
});
// Make sure it was not successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.DoesNotExists);
}",Testing that you can't remove a group that does not exist and provides correct errors.,1
2184,"public void TestAddSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
// Now add the user.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Make sure the account was successfully created.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.AreEqual(security.Groups.SelectMany(group => group.Accounts).First().Username, ""Phogue"");
}",Tests that adding a simpel account can be completed.,1
2185,"public void TestEmptyUsername() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
// Now add the user.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", String.Empty).SetOrigin(CommandOrigin.Local));
// Make sure the account was successfully created.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Tests that an account cannot be added if the username is empty.,1
2186,"public void TestExistingName() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""FirstGroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAddGroup(""SecondGroupName"").SetOrigin(CommandOrigin.Local));
// Now add the user.
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""FirstGroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now move the user to the second group.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""SecondGroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Make sure setting the kick permission was successfull.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.IsNull(security.Groups.Where(group => group.Name == ""FirstGroupName"").SelectMany(group => group.Accounts).FirstOrDefault());
Assert.AreEqual(security.Groups.Where(group => group.Name == ""SecondGroupName"").SelectMany(group => group.Accounts).First().Username, ""Phogue"");
}",Tests that adding an account with a duplicate username will move the user to the new group.,1
2187,"public void TestExistingNameCaseInsensitive() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""FirstGroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAddGroup(""SecondGroupName"").SetOrigin(CommandOrigin.Local));
// Now add the user.
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""FirstGroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now move the user to the second group.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""SecondGroupName"", ""PHOGUE"").SetOrigin(CommandOrigin.Local));
// Make sure setting the kick permission was successfull.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.IsNull(security.Groups.Where(group => group.Name == ""FirstGroupName"").SelectMany(group => group.Accounts).FirstOrDefault());
Assert.AreEqual(security.Groups.Where(group => group.Name == ""SecondGroupName"").SelectMany(group => group.Accounts).First().Username, ""Phogue"");
}","Tests that adding an account with a duplicate username will move the user to the new group, even if the supplied move name has a different case to the original name",1
2188,"public void TestGroupDoesNotExist() {
var security = new SecurityController();
// Add the user.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""NonExistentGroup"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Make sure the command returned nothing
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests that adding a simpel account can be completed.,1
2189,"public void TestGroupGuest() {
var security = new SecurityController();
// Add the user.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""Guest"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Make sure the command returned nothing
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
}",Tests that adding an account to a guest group will fail.,1
2190,"public void TestInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests the command to add an account failes if the user has insufficient privileges.,1
2191,"public void TestInsufficientPermissions() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a remote call with no permissions will result in an InsufficientPermissions status,1
2192,"public void TestGroupDoesNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""ThisIsValid"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""ThisIsNotValid"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}","Tests that attempting to set a group that does not exist to administrator permissions will fail with a status of ""DoesNotExist""",1
2193,"public void TestSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
// Make sure it was not successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that setting the permissions of the group to administrator will succeed,1
2194,"public void TestPermissionsTraitAppended() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
var group = security.Groups.First(item => item.Name == ""GroupName"");
Assert.AreEqual(new List<String>() { PermissionTraitsType.Boolean }, group.Permissions.First(permission => permission.CommandType == CommandType.VariablesSet).Traits);
}",Tests that a trait is appended to the list for a permission,1
2195,"public void TestPermissionsTraitAppendedDistinctValues() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
var group = security.Groups.First(item => item.Name == ""GroupName"");
Assert.AreEqual(new List<String>() { PermissionTraitsType.Boolean }, group.Permissions.First(permission => permission.CommandType == CommandType.VariablesSet).Traits);
}",Tests that appending the same trait twice will not result in two items,1
2196,"public void TestPermissionsCustomTraitAppended() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), ""Custom Trait"").SetOrigin(CommandOrigin.Local));
var group = security.Groups.First(item => item.Name == ""GroupName"");
Assert.AreEqual(new List<String>() { PermissionTraitsType.Boolean, ""Custom Trait"" }, group.Permissions.First(permission => permission.CommandType == CommandType.VariablesSet).Traits);
}",Tests custom trait appended,1
2197,"public void TestCustomPermissionsCustomTraitAppended() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", ""Custom Permission"", ""Custom Trait"").SetOrigin(CommandOrigin.Local));
var group = security.Groups.First(item => item.Name == ""GroupName"");
Assert.AreEqual(new List<String>() { ""Custom Trait"" }, group.Permissions.First(permission => permission.Name == ""Custom Permission"").Traits);
}",Tests custom trait on custom permission appended,1
2198,"public void TestInsufficientPermissions() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupRemovePermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a remote call with no permissions will result in an InsufficientPermissions status,1
2199,"public void TestGroupDoesNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""ThisIsValid"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupRemovePermissionTrait(""ThisIsNotValid"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}","Tests that attempting to set a group that does not exist to administrator permissions will fail with a status of ""DoesNotExist""",1
2200,"public void TestSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupRemovePermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
// Make sure it was not successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that setting the permissions of the group to administrator will succeed,1
2201,"public void TestPermissionsTraitRemoved() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupRemovePermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
var group = security.Groups.First(item => item.Name == ""GroupName"");
Assert.AreEqual(new List<String>(), group.Permissions.First(permission => permission.CommandType == CommandType.VariablesSet).Traits);
}",Tests that a trait is removed to the list for a permission,1
2202,"public void TestPermissionsTraitRemovedAlreadyRemoved() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupRemovePermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupRemovePermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), PermissionTraitsType.Boolean).SetOrigin(CommandOrigin.Local));
var group = security.Groups.First(item => item.Name == ""GroupName"");
Assert.AreEqual(new List<String>(), group.Permissions.First(permission => permission.CommandType == CommandType.VariablesSet).Traits);
}",Tests that removing a trait twice will still be successful (no errors or funny business),1
2203,"public void TestPermissionsCustomTraitAppended() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), ""Custom Trait"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupRemovePermissionTrait(""GroupName"", CommandType.VariablesSet.ToString(), ""Custom Trait"").SetOrigin(CommandOrigin.Local));
var group = security.Groups.First(item => item.Name == ""GroupName"");
Assert.AreEqual(new List<String>() { PermissionTraitsType.Boolean }, group.Permissions.First(permission => permission.CommandType == CommandType.VariablesSet).Traits);
}",Tests custom trait removed,1
2204,"public void TestCustomPermissionsCustomTraitAppended() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAppendPermissionTrait(""GroupName"", ""Custom Permission"", ""Custom Trait"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupRemovePermissionTrait(""GroupName"", ""Custom Permission"", ""Custom Trait"").SetOrigin(CommandOrigin.Local));
var group = security.Groups.First(item => item.Name == ""GroupName"");
Assert.AreEqual(new List<String>(), group.Permissions.First(permission => permission.Name == ""Custom Permission"").Traits);
}",Tests custom trait on custom permission appended,1
2205,"public void TestInsufficientPermissions() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupSetPermissionDescription(""GroupName"", CommandType.VariablesSet.ToString(), ""Description!"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a remote call with no permissions will result in an InsufficientPermissions status,1
2206,"public void TestGroupDoesNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""ThisIsValid"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupSetPermissionDescription(""ThisIsNotValid"", CommandType.VariablesSet.ToString(), ""Description!"").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}","Tests that attempting to set a group that does not exist to administrator permissions will fail with a status of ""DoesNotExist""",1
2207,"public void TestSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityGroupSetPermissionDescription(""GroupName"", CommandType.VariablesSet.ToString(), ""Description!"").SetOrigin(CommandOrigin.Local));
// Make sure it was not successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that setting the permissions of the group to administrator will succeed,1
2208,"public void TestPermissionsdescriptionAppended() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermissionDescription(""GroupName"", CommandType.VariablesSet.ToString(), ""Description!"").SetOrigin(CommandOrigin.Local));
var group = security.Groups.First(item => item.Name == ""GroupName"");
Assert.AreEqual(""Description!"", group.Permissions.First(permission => permission.CommandType == CommandType.VariablesSet).Description);
}",Tests that a description is appended to the list for a permission,1
2209,"public void TestCustomPermissionsCustomdescriptionAppended() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermissionDescription(""GroupName"", ""Custom Permission"", ""Description!"").SetOrigin(CommandOrigin.Local));
var group = security.Groups.First(item => item.Name == ""GroupName"");
Assert.AreEqual(""Description!"", group.Permissions.First(permission => permission.Name == ""Custom Permission"").Description);
}",Tests custom description on custom permission appended,1
2210,"public void TestZeroedAuthorityEqualsNoPermissions() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.VariablesSet, 0).SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityQueryPermission(CommandType.VariablesSet, ""DoesNotExist"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a group with 0 authority in a permission is equal to having no permission set at all (null),1
2211,"public void TestZeroedAuthorityEqualsNoPermissionsCaseInsensitive() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.VariablesSet, 0).SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityQueryPermission(CommandType.VariablesSet, ""DoesNotExist"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""PHOGUE""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a group with 0 authority in a permission is equal to having no permission set at all (null),1
2212,"public void TestDetailsNoAuthorityByPlayerDetailsAsGuest() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""FirstGroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""FirstGroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""FirstGroupName"", CommandType.VariablesSet, 100).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""Phogue"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityQueryPermission(CommandType.VariablesSet, CommonProtocolType.DiceBattlefield3, ""ABCDEF"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
GameType = CommonProtocolType.DiceBattlefield3,
Uid = ""0123456789""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that no authority set for a permission will result in a simple insufficient permission error.,1
2213,"public void TestDetailsLessAuthorityByPlayerDetailsAsGuest() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""FirstGroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""FirstGroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""FirstGroupName"", CommandType.VariablesSet, 100).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""Phogue"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""Guest"", CommandType.VariablesSet, 50).SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityQueryPermission(CommandType.VariablesSet, CommonProtocolType.DiceBattlefield3, ""ABCDEF"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
GameType = CommonProtocolType.DiceBattlefield3,
Uid = ""0123456789""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientAuthority, result.CommandResultType);
}",Tests that a guest account with less authority against an established account with more authority will fail.,1
2214,"public void TestDetailsMoreAuthorityByPlayerDetailsAsGuest() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""FirstGroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""FirstGroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""FirstGroupName"", CommandType.VariablesSet, 100).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""Phogue"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""Guest"", CommandType.VariablesSet, 200).SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityQueryPermission(CommandType.VariablesSet, CommonProtocolType.DiceBattlefield3, ""ABCDEF"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
GameType = CommonProtocolType.DiceBattlefield3,
Uid = ""0123456789""
})
);
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that a guest with more authority will be successful against an established account with less authority.,1
2215,"public void TestDetailsPluginOrigin() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""FirstGroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""FirstGroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""FirstGroupName"", CommandType.VariablesSet, 100).SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""Phogue"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityQueryPermission(CommandType.VariablesSet, ""DoesNotExist"")
.SetOrigin(CommandOrigin.Plugin)
);
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that a security check will succeed if the origin is a plugin and no further details about who executed the command are sent through.,1
2216,"public void TestSecurityRemoveAccountModel() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Test that the group was initially added.
Assert.AreEqual(security.Groups.Last().Accounts.First().Username, ""Phogue"");
ICommandResult result = security.Tunnel(CommandBuilder.SecurityRemoveAccount(""Phogue"").SetOrigin(CommandOrigin.Local));
// Make sure it was successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(0, security.Groups.Last().Accounts.Count);
}",Testing that an account can be removed by its name.,1
2217,"public void TestRemoveAccountByLocalSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityRemoveAccount(""Phogue"").SetOrigin(CommandOrigin.Local));
// Make sure the command failed. The user cannot remove their own account.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that an account can be removed if the command is locally called,1
2218,"public void TestRemoveOwnAccountFailure() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupSetPermission(""GroupName"", CommandType.SecurityRemoveAccount, 1).SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecurityRemoveAccount(""Phogue"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
// Make sure the command failed. The user cannot remove their own account.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Tests that an account will not be removed if the owner is attempting to remove it.,1
2219,"public void TestSecurityRemoveAccountEmptyAccountUsername() {
var security = new SecurityController();
// Add a group with an empty name.
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityRemoveAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
String.Empty
})
});
// Make sure adding an empty group fails.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
}",Testing that you can't remove a group name that is empty.,1
2220,"public void TestSecurityRemoveAccountInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Test that the group was initially added.
Assert.AreEqual(security.Groups.Last().Accounts.First().Username, ""Phogue"");
ICommandResult result = security.Tunnel(CommandBuilder.SecurityRemoveAccount(""Phogue"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
// Make sure it was successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests the command to add a player to an account fails if the user has insufficient privileges.,1
2221,"public void TestSecurityRemoveAccountNotExists() {
var security = new SecurityController();
ICommandResult result = security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityRemoveAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue""
})
});
// Make sure it was not successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.DoesNotExists);
}",Testing that you can't remove a group that does not exist and provides correct errors.,1
2222,"public void TestRemoveSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
// Now add a player to the ""Phogue"" account.
security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""Phogue"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
// Now remove the player.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityRemovePlayer(CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
// Validate the command was a success and the player is not attached to any accounts.
// and no longer attached to the ""Phogue"" account.
Assert.IsTrue(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.Success);
Assert.IsNull(security.Groups.SelectMany(group => group.Accounts).Where(account => account.Username == ""Phogue"").SelectMany(account => account.Players).FirstOrDefault());
}",Tests that a player can be removed if the player exists.,1
2223,"public void TestDoesNotExist() {
var security = new SecurityController();
// Remove a player, though no accounts/players/groups exist.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityRemovePlayer(CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
// Validate the command failed and returned the correct error status.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.DoesNotExists);
Assert.IsNull(security.Groups.SelectMany(group => group.Accounts).SelectMany(account => account.Players).FirstOrDefault());
}",Tests that a player will not be removed as well as returning the valid errors if the player does not exist.,1
2224,"public void TestEmptyUid() {
var security = new SecurityController();
// Remove a player, though no accounts/players/groups exist.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityRemovePlayer(CommonProtocolType.DiceBattlefield3, String.Empty).SetOrigin(CommandOrigin.Local));
// Validate the command failed and returned the correct error status.
Assert.IsFalse(result.Success);
Assert.AreEqual(result.CommandResultType, CommandResultType.InvalidParameter);
Assert.IsNull(security.Groups.SelectMany(group => group.Accounts).SelectMany(account => account.Players).FirstOrDefault());
}",Tests that a player cannot be removed if it has a zero length UID.,1
2225,"public void TestInsufficientPermission() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityGroupAddAccount(""GroupName"", ""Phogue"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecurityAccountAddPlayer(""GroupName"", CommonProtocolType.DiceBattlefield3, ""ABCDEF"").SetOrigin(CommandOrigin.Local));
// Now remove the player.
ICommandResult result = security.Tunnel(CommandBuilder.SecurityRemovePlayer(CommonProtocolType.DiceBattlefield3, ""ABCDEF"")
.SetOrigin(CommandOrigin.Remote)
.SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
})
);
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Ensures a player cannot be removed if the account does not have permission to do so.,1
2226,"public void TestInsufficientPermissions() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecuritySetPredefinedAdministratorsPermissions(""GroupName"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a remote call with no permissions will result in an InsufficientPermissions status,1
2227,"public void TestGroupDoesNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""ThisIsValid"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecuritySetPredefinedAdministratorsPermissions(""ThisIsNotValid"").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}","Tests that attempting to set a group that does not exist to administrator permissions will fail with a status of ""DoesNotExist""",1
2228,"public void TestGuestGroupFailure() {
var security = new SecurityController();
ICommandResult result = security.Tunnel(CommandBuilder.SecuritySetPredefinedAdministratorsPermissions(""Guest"").SetOrigin(CommandOrigin.Local));
// Make sure it was not successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
}",Tests that setting the permissions of the guest group to administrator will fail,1
2229,"public void TestSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecuritySetPredefinedAdministratorsPermissions(""GroupName"").SetOrigin(CommandOrigin.Local));
// Make sure it was not successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that setting the permissions of the group to administrator will succeed,1
2230,"public void TestPermissionsSet() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecuritySetPredefinedAdministratorsPermissions(""GroupName"").SetOrigin(CommandOrigin.Local));
var group = security.Groups.FirstOrDefault(item => item.Name == ""GroupName"");
Assert.IsNotNull(group);
group.Permissions.ForEach(item => Assert.AreEqual(2, item.Authority));
}",Tests that all permissions will be set to 2 for the administrator group,1
2231,"public void TestInsufficientPermissions() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecuritySetPredefinedStreamPermissions(""GroupName"").SetOrigin(CommandOrigin.Remote).SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a remote call with no permissions will result in an InsufficientPermissions status,1
2232,"public void TestGroupDoesNotExist() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""ThisIsValid"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecuritySetPredefinedStreamPermissions(""ThisIsNotValid"").SetOrigin(CommandOrigin.Local));
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}","Tests that attempting to set a group that does not exist to administrator permissions will fail with a status of ""DoesNotExist""",1
2233,"public void TestGuestGroupFailure() {
var security = new SecurityController();
ICommandResult result = security.Tunnel(CommandBuilder.SecuritySetPredefinedStreamPermissions(""Guest"").SetOrigin(CommandOrigin.Local));
// Make sure it was not successful.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
}",Tests that setting the permissions of the guest group to administrator will fail,1
2234,"public void TestSuccess() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
ICommandResult result = security.Tunnel(CommandBuilder.SecuritySetPredefinedStreamPermissions(""GroupName"").SetOrigin(CommandOrigin.Local));
// Make sure it was not successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that setting the permissions of the group to administrator will succeed,1
2235,"public void TestPermissionsSetToOneOrNull() {
var security = new SecurityController();
security.Tunnel(CommandBuilder.SecurityAddGroup(""GroupName"").SetOrigin(CommandOrigin.Local));
security.Tunnel(CommandBuilder.SecuritySetPredefinedStreamPermissions(""GroupName"").SetOrigin(CommandOrigin.Local));
var group = security.Groups.FirstOrDefault(item => item.Name == ""GroupName"");
List<CommandType> permissions = new List<CommandType>() {
CommandType.PotatoPing,
CommandType.SecurityAccountAuthenticate,
CommandType.EventsEstablishJsonStream,
CommandType.PotatoQuery,
CommandType.ProtocolsFetchSupportedProtocols,
CommandType.PackagesFetchPackages,
CommandType.ConnectionQuery,
CommandType.NetworkProtocolQueryBans,
CommandType.NetworkProtocolQueryMapPool,
CommandType.NetworkProtocolQueryMaps,
CommandType.NetworkProtocolQueryPlayers,
CommandType.NetworkProtocolQuerySettings
};
Assert.IsNotNull(group);
foreach (var permission in group.Permissions.Where(item => permissions.Contains(item.CommandType) == true)) {
Assert.AreEqual(1, permission.Authority);
}
foreach (var permission in group.Permissions.Where(item => !permissions.Contains(item.CommandType) == true)) {
Assert.IsNull(permission.Authority);
}
}",Tests that all permissions have been set to 1 or null for this group,1
2236,"public void TestInitialValues() {
var message = new ServiceMessage();
Assert.IsNotNull(message.Arguments);
Assert.IsNotNull(message.Stamp);
}",Tests the initial properties are setup,1
2237,"public void TestDispose() {
var message = new ServiceMessage();
message.Dispose();
Assert.IsNull(message.Arguments);
Assert.IsNull(message.Name);
}",Tests values are nulled out on dispose,1
2238,"public void TestInitalValues() {
var observer = new ServiceObserver();
Assert.AreEqual(ServiceStatusType.Stopped, observer.Status);
// Test that we are ""down""
Assert.GreaterOrEqual(observer.StopTime, DateTime.Now.AddSeconds(-5));
Assert.GreaterOrEqual(observer.Downtime(), TimeSpan.FromSeconds(0));
// Test that we are not ""up""
Assert.IsNull(observer.StartTime);
Assert.AreEqual(new TimeSpan(0), observer.Uptime());
}",Tests the initial values are set when instantiating a new observer.,1
2239,"public void TestPanicNotInitiatedUnderFifteenMinutes() {
var paniced = false;
var observer = new ServiceObserver() {
Panic = () => { paniced = true; }
};
// We've only been down for less than a second so it shouldn't fire.
observer.PanicTask_Tick(null);
Assert.IsFalse(paniced);
}",Tests that if the downtime has not exceeded fifteen minutes the panic callback will not be called.,1
2240,"public void TestPanicDowntimeOverFifteenMinutes() {
var paniced = false;
var observer = new ServiceObserver() {
Panic = () => { paniced = true; },
StopTime = DateTime.Now.AddMinutes(-16)
};
// We've only been down for less than a second so it shouldn't fire.
observer.PanicTask_Tick(null);
Assert.IsTrue(paniced);
}",Tests that if the downtime has exceeded fifteen minutes the panic callback will be called.,1
2241,"public void TestInitialValues() {
var settings = new ServiceSettings();
Assert.IsTrue(settings.ServiceUpdateCore);
Assert.AreEqual(Defines.PackagesDefaultSourceRepositoryUri, settings.PackagesDefaultSourceRepositoryUri);
}",Tests that the initial values are setup for service settings,1
2242,"public void TestServiceSettingsOverrideServiceUpdateCore() {
var settings = new ServiceSettings(new List<String>() {
""-ServiceUpdateCore"",
""false""
});
Assert.IsFalse(settings.ServiceUpdateCore);
Assert.AreEqual(Defines.DefaultServicePollingTimeout, settings.ServicePollingTimeout);
Assert.AreEqual(Defines.PackagesDefaultSourceRepositoryUri, settings.PackagesDefaultSourceRepositoryUri);
}",Tests that passing in a ServiceUpdateCore attribute will override the settings value.,1
2243,"public void TestServiceSettingsOverrideServicePollingTimeout() {
var settings = new ServiceSettings(new List<String>() {
""-ServicePollingTimeout"",
""10""
});
Assert.IsTrue(settings.ServiceUpdateCore);
Assert.AreEqual(10, settings.ServicePollingTimeout);
Assert.AreEqual(Defines.PackagesDefaultSourceRepositoryUri, settings.PackagesDefaultSourceRepositoryUri);
}",Tests that passing in a ServicePollingTimeout attribute will override the settings value.,1
2244,"public void TestServiceSettingsOverridePackagesDefaultSourceRepositoryUri() {
var settings = new ServiceSettings(new List<String>() {
""-PackagesDefaultSourceRepositoryUri"",
""localhost""
});
Assert.IsTrue(settings.ServiceUpdateCore);
Assert.AreEqual(Defines.DefaultServicePollingTimeout, settings.ServicePollingTimeout);
Assert.AreEqual(""localhost"", settings.PackagesDefaultSourceRepositoryUri);
}",Tests that passing in a PackagesDefaultSourceRepositoryUri attribute will override the settings value.,1
2245,"public void TestNullMessageReturnsFalse() {
var service = new ServiceController();
Assert.IsFalse(service.SignalMessage(null));
service.Dispose();
}",Tests that passing in a null parameter will return false.,1
2246,"public void TestNopMessageReturnsTrue() {
var service = new ServiceController();
Assert.IsTrue(service.SignalMessage(new ServiceMessage() {
Name = ""nop""
}));
service.Dispose();
}",Tests that passing in a nop message will return true,1
2247,"public void TestJunkMessageReturnsFalse() {
var service = new ServiceController();
Assert.IsFalse(service.SignalMessage(new ServiceMessage() {
Name = ""junk""
}));
service.Dispose();
}",Tests that passing in a junk message will return false,1
2248,"public void TestStartMessageReturnsTrue() {
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
}
};
Assert.IsTrue(service.SignalMessage(new ServiceMessage() {
Name = ""start""
}));
service.Dispose();
}",Tests that passing in a start message will return true,1
2249,"public void TestStopMessageReturnsTrue() {
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
}
};
Assert.IsTrue(service.SignalMessage(new ServiceMessage() {
Name = ""stop""
}));
service.Dispose();
}",Tests that passing in a stop message will return true,1
2250,"public void TestRestartMessageReturnsTrue() {
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
}
};
Assert.IsTrue(service.SignalMessage(new ServiceMessage() {
Name = ""restart""
}));
service.Dispose();
}",Tests that passing in a restart message will return true,1
2251,"public void TestMergeMessageReturnsTrue() {
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
}
};
Assert.IsTrue(service.SignalMessage(new ServiceMessage() {
Name = ""merge""
}));
service.Dispose();
}",Tests that passing in a merge message will return true,1
2252,"public void TestUninstallMessageReturnsTrue() {
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
}
};
Assert.IsTrue(service.SignalMessage(new ServiceMessage() {
Name = ""uninstall""
}));
service.Dispose();
}",Tests that passing in a uninstall message will return true,1
2253,"public void TestHelpMessageReturnsTrue() {
var service = new ServiceController();
Assert.IsTrue(service.SignalMessage(new ServiceMessage() {
Name = ""help""
}));
service.Dispose();
}",Tests that passing in a help message will return true,1
2254,"public void TestStatsMessageReturnsTrue() {
var service = new ServiceController();
Assert.IsTrue(service.SignalMessage(new ServiceMessage() {
Name = ""stats""
}));
service.Dispose();
}",Tests that passing in a stats message will return true,1
2255,"public void TestStatisticsMessageReturnsTrue() {
var service = new ServiceController();
Assert.IsTrue(service.SignalMessage(new ServiceMessage() {
Name = ""statistics""
}));
service.Dispose();
}",Tests that passing in a statistics message will return true,1
2256,"public void TestMergeMessageWithParametersCallsMerge() {
var merged = false;
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
},
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, uri, packageId) => { merged = true; }
}
};
service.SignalMessage(new ServiceMessage() {
Name = ""merge"",
Arguments = new Dictionary<string, string>() {
{ ""uri"", ""localhost"" },
{ ""packageid"", ""id"" }
}
});
Assert.IsTrue(merged);
service.Dispose();
}",Tests that passing in a merge message with the correct parameters will call the packages merge,1
2257,"public void TestUninstallMessageWithParametersCallsMerge() {
var uninstall = false;
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
},
Packages = new MockServicePackageManager() {
PackageUninstalled = (sender, uri, packageId) => { uninstall = true; }
}
};
service.SignalMessage(new ServiceMessage() {
Name = ""uninstall"",
Arguments = new Dictionary<string, string>() {
{ ""packageid"", ""id"" }
}
});
Assert.IsTrue(uninstall);
service.Dispose();
}",Tests that passing in a merge message with the correct parameters will call the packages merge,1
2258,"public void TestSignalBeginCallback() {
var signaled = false;
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
},
SignalBegin = (controller, message) => signaled = true
};
service.SignalMessage(new ServiceMessage() {
Name = ""help""
});
Assert.IsTrue(signaled);
service.Dispose();
}",Tests the signal begin callback is called,1
2259,"public void TestSignalEndCallback() {
var signaled = false;
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
},
SignalEnd = (controller, message, seconds) => signaled = true
};
service.SignalMessage(new ServiceMessage() {
Name = ""help""
});
Assert.IsTrue(signaled);
service.Dispose();
}",Tests the signal end callback is called,1
2260,"public void TestSignalParameterError() {
var error = false;
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
},
SignalParameterError = (controller, list) => error = true
};
service.SignalMessage(new ServiceMessage() {
Name = ""merge"",
Arguments = new Dictionary<string, string>() {
{ ""uri"", ""localhost"" }
}
});
Assert.IsTrue(error);
service.Dispose();
}",Tests an error callback is called when a parameter is missing from a signal message that requires parameters,1
2261,"public void TestSignalStatisticsCallback() {
var signaled = false;
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
},
SignalStatistics = (controller, message) => signaled = true
};
service.SignalMessage(new ServiceMessage() {
Name = ""statistics""
});
Assert.IsTrue(signaled);
service.Dispose();
}",Tests the signal statistics callback is called,1
2262,"public void TestSignalHelpCallback() {
var signaled = false;
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
},
SignalHelp = controller => signaled = true
};
service.SignalMessage(new ServiceMessage() {
Name = ""help""
});
Assert.IsTrue(signaled);
service.Dispose();
}",Tests the signal help callback is called,1
2263,"public void TestSignalResultCallback() {
var signaled = false;
var service = new ServiceController() {
Settings = {
ServiceUpdateCore = false
},
SignalResult = (controller, message) => signaled = true
};
service.SignalMessage(new ServiceMessage() {
Name = ""result""
});
Assert.IsTrue(signaled);
service.Dispose();
}",Tests the signal result callback is called,1
2264,"public void TestStartedFromNone() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy),
Observer = {
Status = ServiceStatusType.None
}
};
service.Restart();
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}",Tests the started is the final status from None status,1
2265,"public void TestStartedFromStarted() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy),
Observer = {
Status = ServiceStatusType.Started
}
};
service.Restart();
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}",Tests the started is the final status from Started status,1
2266,"public void TestStartedFromStarting() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy),
Observer = {
Status = ServiceStatusType.Starting
}
};
service.Restart();
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}",Tests the started is the final status from Starting status,1
2267,"public void TestStartedFromStopped() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy),
Observer = {
Status = ServiceStatusType.Stopped
}
};
service.Restart();
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}",Tests the started is the final status from Stopped status,1
2268,"public void TestStartedFromStopping() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy),
Observer = {
Status = ServiceStatusType.Stopping
}
};
service.Restart();
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}",Tests the started is the final status from Stopping status,1
2269,"public void TestServiceDomainCreated() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Start();
Assert.IsNotNull(service.ServiceDomain);
service.Dispose();
}",Tests the app domain is created during start,1
2270,"public void TestStartIgnoredOnNonStoppedStatus() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy),
Observer = {
Status = ServiceStatusType.Started
}
};
service.Start();
Assert.IsNull(service.ServiceDomain);
service.Dispose();
}",Tests that if the status is anything other that Stopped then nothing will occur when starting the appdomain.,1
2271,"public void TestMethodCalledCreate() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Start();
Assert.IsTrue(((MockServiceLoaderProxy)service.ServiceLoaderProxy).OnCreate);
service.Dispose();
}",Tests the service Create method is called shortly after instantiation,1
2272,"public void TestMethodCalledArguments() {
var service = new ServiceController() {
Arguments = new List<String>() {
""A"",
""B""
},
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Start();
Assert.AreEqual(service.Arguments, ((MockServiceLoaderProxy)service.ServiceLoaderProxy).OnParseCommandLineArguments);
service.Dispose();
}",Tests the service arguments are passed in shortly after instantiation,1
2273,"public void TestMethodCalledStarted() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Start();
Assert.IsTrue(((MockServiceLoaderProxy)service.ServiceLoaderProxy).OnStart);
service.Dispose();
}",Tests the service Start method is called shortly after instantiation,1
2274,"public void TestObservableStarted() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.Start();
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}",Tests the service controller obserable object is set to Started,1
2275,"public void TestExceptionLogged() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockNonSerializableServiceLoaderProxy)
};
service.Start();
Assert.IsNotEmpty(Defines.ErrorsLogsDirectory.GetFiles());
Assert.Greater(Defines.ErrorsLogsDirectory.GetFiles().First().Length, 0);
service.Dispose();
}",Tests that if an exception occurs during Start() it will be logged to file.,1
2276,"public void TestAllKnownTypeSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1"",
""Anything"",
""Nothing""
}
}
};
List<String> items = ((List<Object>) parameter.All(typeof (String), false)).Cast<String>().ToList();
Assert.AreEqual(""1"", items[0]);
Assert.AreEqual(""Anything"", items[1]);
Assert.AreEqual(""Nothing"", items[2]);
}",Tests that we can pull all the values out of a known type without conversion.,1
2277,"public void TestFirstKnownTypeSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1"",
""Anything"",
""Nothing""
}
}
};
Assert.AreEqual(""1"", parameter.First<String>(false));
}","Tests that we can pull the first value out of a known type, no conversion required.",1
2278,"public void TestHashManyKnownTypeSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1"",
""Anything"",
""Nothing""
}
}
};
Assert.IsTrue(parameter.HasMany<String>(false));
}",Tests that we can have many of a type that is known i nthe Data of the command parameter.,1
2279,"public void TestHashOneKnownTypeSuccess() {
var parameter = new CommandParameter() {
Data = {
Content = new List<String>() {
""1"",
""Anything"",
""Nothing""
}
}
};
Assert.IsTrue(parameter.HasOne<String>(false));
}",Tests that we can have one of a type that is known i nthe Data of the command parameter.,1
2280,"public void TestTextCommandParsingExecute() {
var textCommands = new TextCommandController() {
//Languages = languages,
Connection = new ConnectionController() {
Protocol = new SandboxProtocolController() {
SandboxedProtocol = new MockProtocol() {
Additional = """",
Password = """"
}
}
}.Execute() as ConnectionController
};
textCommands.Execute();
textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsRegister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = Guid.NewGuid(),
PluginCommand = ""Command1"",
Commands = new List<String>() {
""ExecuteTest""
}
}
}
}
}
}
});
Assert.AreEqual(1, textCommands.TextCommands.Count);
Assert.AreEqual(""ExecuteTest"", textCommands.TextCommands.First().Commands.First());
ICommandResult result = textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsExecute,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""ExecuteTest stuff""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that a text command can be executed,1
2281,"public void TestTextCommandParsingExecuteInsufficientPermissions() {
var textCommands = new TextCommandController() {
Shared = {
Security = new SecurityController().Execute() as SecurityController
}
};
ICommandResult result = textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Remote,
Authentication = {
Username = ""Phogue""
},
CommandType = CommandType.TextCommandsExecute,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""!test something something something dark side""
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests a text command cannot be executed without sufficient permissions,1
2282,"public void TestTextCommandParsingExecuteUsePreferredLanguage() {
var security = (SecurityController)new SecurityController().Execute();
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAddGroup,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""TestGroup""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupAddAccount,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""TestGroup"",
""Phogue""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountAddPlayer,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
CommonProtocolType.DiceBattlefield3,
""EA_63A9F96745B22DFB509C558FC8B5C50F""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityAccountSetPreferredLanguageCode,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""Phogue"",
""de-DE""
})
});
security.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.SecurityGroupSetPermission,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""TestGroup"",
CommandType.TextCommandsExecute,
100
})
});
var textCommands = new TextCommandController() {
Shared = {
Security = security
},
//Languages = languages,
Connection = new ConnectionController() {
Protocol = new SandboxProtocolController() {
SandboxedProtocol = new MockProtocol() {
Additional = """",
Password = """"
}
}
}.Execute() as ConnectionController
};
textCommands.Execute();
textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsRegister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = Guid.NewGuid(),
PluginCommand = ""Command1"",
Commands = new List<String>() {
""ExecuteTest""
}
}
}
}
}
}
});
Assert.AreEqual(1, textCommands.TextCommands.Count);
Assert.AreEqual(""ExecuteTest"", textCommands.TextCommands.First().Commands.First());
ICommandResult result = textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Plugin,
Authentication = {
Username = ""Phogue""
},
CommandType = CommandType.TextCommandsExecute,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""ExecuteTest stuff""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that the parser will use the persons preferred language when executing a command.,1
2283,"public void TestTextCommandParsingPreview() {
var textCommands = new TextCommandController() {
//Languages = languages,
Connection = new ConnectionController() {
Protocol = new SandboxProtocolController() {
SandboxedProtocol = new MockProtocol() {
Additional = """",
Password = """"
}
}
}.Execute() as ConnectionController
};
textCommands.Execute();
textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsRegister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = Guid.NewGuid(),
PluginCommand = ""Command1"",
Commands = new List<String>() {
""ExecuteTest""
}
}
}
}
}
}
});
Assert.AreEqual(1, textCommands.TextCommands.Count);
Assert.AreEqual(""ExecuteTest"", textCommands.TextCommands.First().Commands.First());
ICommandResult result = textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsPreview,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""ExecuteTest stuff""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
}",Tests that a text command can be executed,1
2284,"public void TestTextCommandParsingPreviewInsufficientPermissions() {
var textCommands = new TextCommandController() {
Shared = {
Security = new SecurityController().Execute() as SecurityController
}
};
ICommandResult result = textCommands.Tunnel(new Command() {
CommandType = CommandType.TextCommandsPreview,
Authentication = {
Username = ""Phogue""
},
Origin = CommandOrigin.Remote,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""!test something something something dark side""
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests a text command cannot be previewed without sufficient permissions,1
2285,"public void TestTextCommandRegister() {
var textCommands = new TextCommandController();
ICommandResult result = textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsRegister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = Guid.NewGuid(),
PluginCommand = ""Command1"",
Commands = new List<String>() {
""RegisterTest""
}
}
}
}
}
}
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(1, textCommands.TextCommands.Count);
Assert.AreEqual(""RegisterTest"", textCommands.TextCommands.First().Commands.First());
}",Tests that we can register a command via the command interface.,1
2286,"public void TestTextCommandRegisterDuplication() {
var textCommands = new TextCommandController();
var guid = Guid.NewGuid();
textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsRegister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = guid,
PluginCommand = ""Command1"",
Commands = new List<String>() {
""RegisterTest""
}
}
}
}
}
}
});
ICommandResult result = textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsRegister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = guid,
PluginCommand = ""Command1"",
Commands = new List<String>() {
""RegisterTest""
}
}
}
}
}
}
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.AlreadyExists, result.CommandResultType);
Assert.AreEqual(1, textCommands.TextCommands.Count);
}",Tests that adding the same command twice (same plugin uid & plugin command) will only succeed the first time around.,1
2287,"public void TestTextCommandRegisterInsufficientPermission() {
var textCommands = new TextCommandController();
ICommandResult result = textCommands.Tunnel(new Command() {
Authentication = {
Username = ""Phogue""
},
Origin = CommandOrigin.Remote,
CommandType = CommandType.TextCommandsRegister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = Guid.NewGuid(),
PluginCommand = ""Command1"",
Commands = new List<String>() {
""RegisterTest""
}
}
}
}
}
}
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that commands can only be executed if the user has sufficient permissions.,1
2288,"public void TestTextCommandUnregister() {
var textCommands = new TextCommandController();
var guid = Guid.NewGuid();
textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsRegister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = guid,
PluginCommand = ""Command1"",
Commands = new List<String>() {
""RegisterTest""
}
}
}
}
}
}
});
// Test that the initial command was entered before we attempt to remove it.
Assert.AreEqual(1, textCommands.TextCommands.Count);
Assert.AreEqual(""RegisterTest"", textCommands.TextCommands.First().Commands.First());
ICommandResult result = textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsUnregister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = guid,
PluginCommand = ""Command1""
}
}
}
}
}
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(0, textCommands.TextCommands.Count);
}",Tests that a command can successfully remove a text command.,1
2289,"public void TestTextCommandUnregisterDoesNotExist() {
var textCommands = new TextCommandController();
ICommandResult result = textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsUnregister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = Guid.NewGuid(),
PluginCommand = ""Command1""
}
}
}
}
}
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.DoesNotExists, result.CommandResultType);
}",Tests the unregister command fails with the correct status if the command does not exist.,1
2290,"public void TestTextCommandUnregisterInsufficientPermission() {
var textCommands = new TextCommandController();
var guid = Guid.NewGuid();
textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsRegister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = guid,
PluginCommand = ""Command1"",
Commands = new List<String>() {
""RegisterTest""
}
}
}
}
}
}
});
// Test that the initial command was entered before we attempt to remove it.
Assert.AreEqual(1, textCommands.TextCommands.Count);
Assert.AreEqual(""RegisterTest"", textCommands.TextCommands.First().Commands.First());
ICommandResult result = textCommands.Tunnel(new Command() {
Authentication = {
Username = ""Phogue""
},
Origin = CommandOrigin.Remote,
CommandType = CommandType.TextCommandsUnregister,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
TextCommands = new List<TextCommandModel>() {
new TextCommandModel() {
PluginGuid = guid,
PluginCommand = ""Command1"",
Commands = new List<String>() {
""RegisterTest""
}
}
}
}
}
}
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a command cannot be unregistered without the correct permissions to do so.,1
2291,"protected ConnectionController CreateConnection() {
ISandboxProtocolController protocol = new SandboxProtocolController() {
SandboxedProtocol = new MockGame()
};
protocol.Setup(new ProtocolSetup() {
Hostname = ""localhost"",
Port = 9000
});
ConnectionController connection = new ConnectionController() {
// This won't actually connect to anything.
// It's just a mock so the GameState is available to be modified.
// See MockGame for all the mock data we create.
Protocol = protocol
};
// 1. When this is called you will see the constructor in the plugin executed.
// Potato.Examples.TextCommands.Program connection.Execute();
// Note: Enable the single plugin that was loaded, otherwise it won't recieve any tunneled commands or events.
// 2. When this is executed you will see a GenericEvent fired. Place your breakpoint in
// Potato.Examples.TextCommands.Program.GenericEvent -> PluginsPluginEnabled
connection.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.PluginsEnable,
Scope = {
PluginGuid = connection.Plugins.LoadedPlugins.First().PluginGuid
}
});
return connection;
}",The plugin will be enabled during this process.,1
2292,"public void TestBasicCommand() {
ConnectionController connection = this.CreateConnection();
// 3. Execute a text command. This could come from in game text or via the daemon.
// When executed from in game the command built is identical but the content is
// the in game text said and this text must be prefixed with ""!, @ or #""
connection.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsExecute,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<string>() {
// You should see zero players and other attributes from this
""blah!""
}
}
}
}
});
}","We just test here that ""test ..."" will eventually execute the command Set a breakpoint within Potato.Examples.TextCommands.TestCommand",1
2293,"public void TestTextCommandControllerDispose() {
var textCommands = new TextCommandController();
var testCommand = new TextCommandModel() {
Commands = new List<String>() {
""DisposeTest""
}
};
textCommands.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.TextCommandsRegister,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
testCommand
})
});
textCommands.Dispose();
Assert.IsNull(textCommands.TextCommands);
Assert.IsNull(textCommands.Connection);
}",Tests that the text command controller will clean itself up.,1
2294,"public void TestTextCommandDispose() {
var testCommand = new TextCommandModel() {
Commands = new List<String>() {
""DisposeTest""
}
};
testCommand.Dispose();
Assert.AreEqual(TextCommandParserType.Fuzzy, testCommand.Parser);
Assert.AreEqual(Guid.Empty, testCommand.PluginGuid);
Assert.IsNull(testCommand.PluginCommand);
Assert.IsNull(testCommand.Description);
Assert.IsNull(testCommand.Commands);
}","Tests that a text command will clean itself up correctly, at least to a point where the command would become inert.",1
2295,"public void TestStart() {
ThrottledStream<int> stream = new ThrottledStream<int>();
stream.Start();
Assert.IsTrue(stream.Running);
Assert.IsNotNull(stream.IntervalTick);
}",Tests that running start will set the stream to running and create the interval timer,1
2296,"public void TestStop() {
ThrottledStream<int> stream = new ThrottledStream<int>();
stream.Stop();
Assert.IsFalse(stream.Running);
Assert.IsNull(stream.IntervalTick);
Assert.IsNull(stream.FlushTo);
}",Tests that calling stop will ultimately set the running property to false and null the interval tick.,1
2297,"public void TestStopWhileRunning() {
ThrottledStream<int> stream = new ThrottledStream<int>() {
FlushTo = items => {
}
};
stream.Start();
stream.Stop();
Assert.IsFalse(stream.Running);
Assert.IsNull(stream.IntervalTick);
Assert.IsNull(stream.FlushTo);
}",Tests that calling stop will ultimately set the running property to false and null the interval tick.,1
2298,"public void TestFlushToIsCalled() {
AutoResetEvent reset = new AutoResetEvent(false);
bool isFlushToCalled = false;
ThrottledStream<int> stream = new ThrottledStream<int>() {
Interval = new TimeSpan(0, 0, 0, 0, 10),
FlushTo = items => {
isFlushToCalled = true;
reset.Set();
}
};
stream.Start();
stream.Call(1);
Assert.IsTrue(reset.WaitOne(500));
Assert.IsTrue(isFlushToCalled);
}",Tests that a short interval will result in the flush to method being called when 1 item is on the list.,1
2299,"public void TestFlushToCorrectOrder() {
AutoResetEvent reset = new AutoResetEvent(false);
List<int> flushedItems = new List<int>();
ThrottledStream<int> stream = new ThrottledStream<int>() {
Interval = new TimeSpan(0, 0, 0, 0, 100),
FlushTo = items => {
flushedItems = items;
reset.Set();
}
};
stream.Start();
stream.Call(1);
stream.Call(2);
stream.Call(3);
Assert.IsTrue(reset.WaitOne(500));
Assert.AreEqual(new List<int>() { 1, 2, 3 }, flushedItems);
}",Tests that items will come out of the flush to in the same order they went in as,1
2300,"public void TestIgnoredWhenNotRunning() {
ThrottledStream<int> stream = new ThrottledStream<int>();
stream.Call(1);
Assert.IsEmpty(stream.Items);
}",Tests that an item will not be enqueued if the stream is not marked as running.,1
2301,"public void TestPushedWhenRunning() {
ThrottledStream<int> stream = new ThrottledStream<int>() {
Running = true
};
stream.Call(1);
Assert.IsNotEmpty(stream.Items);
}",Tests that an item will be pushed if the stream is marked as running,1
2302,"public void TestMergeTwoBranchesWithIdenticalRootNode() {
Tree tree = Tree.Union(
BranchBuilder.ProtocolCanKillPlayer(),
BranchBuilder.ProtocolKnowsWhenPlayerKillPlayer()
);
Assert.AreEqual(1, tree.Count);
Assert.IsTrue(tree.BuildAndTest(new ProtocolAgent(), new CanFlow(), new KillGoal(), new PlayerAgent()));
Assert.IsTrue(tree.BuildAndTest(new ProtocolAgent(), new KnowsWhenFlow(), new PlayerAgent(), new KillGoal(), new PlayerAgent()));
}",Tests the root identical node will be merged properly,1
2303,"public void TestMergeTwoBranchesWithIdenticalRootNodeTestWithBuiltBranch() {
Tree tree = Tree.Union(
BranchBuilder.ProtocolCanKillPlayer(),
BranchBuilder.ProtocolKnowsWhenPlayerKillPlayer()
);
Assert.IsTrue(tree.Test(BranchBuilder.ProtocolCanKillPlayer()));
}","Tests that two trees can be combined, then tested with the the built branch.",1
2304,"public void TestMergeTwoBranchesWithDifferentRootNode() {
Tree tree = Tree.Union(
BranchBuilder.ProtocolCanKillPlayer(),
BranchBuilder.ProtocolKnowsWhenPlayerKillPlayer(),
BranchBuilder.ProtocolKnowsWhenPlayerChatToEveryone(),
BranchBuilder.ProtocolKnowsWhenPlayerChatToGroup()
);
Assert.IsTrue(tree.Test(BranchBuilder.ProtocolCanKillPlayer()));
Assert.IsTrue(tree.Test(BranchBuilder.ProtocolKnowsWhenPlayerChatToEveryone()));
}",Tests with two different root nodes will merge correctly,1
2305,"public void TestMergeTwoBranchesWithDifferentRootNodeMissingNode() {
Tree tree = Tree.Union(
BranchBuilder.ProtocolCanKillPlayer(),
BranchBuilder.ProtocolKnowsWhenPlayerKillPlayer(),
// BranchBuilder.ProtocolKnowsWhenPlayerChatToEveryone(),
BranchBuilder.ProtocolKnowsWhenPlayerChatToGroup()
);
Assert.IsTrue(tree.Test(BranchBuilder.ProtocolCanKillPlayer()));
Assert.IsFalse(tree.Test(BranchBuilder.ProtocolKnowsWhenPlayerChatToEveryone()));
}",Tests with two different root nodes will merge and test correctly,1
2306,"public void TestMergeTwoBranchesWithDifferentRootNodeMissingRootNode() {
Tree tree = Tree.Union(
// BranchBuilder.ProtocolCanKillPlayer(),
BranchBuilder.ProtocolKnowsWhenPlayerKillPlayer(),
BranchBuilder.ProtocolKnowsWhenPlayerChatToEveryone(),
BranchBuilder.ProtocolKnowsWhenPlayerChatToGroup()
);
Assert.IsFalse(tree.Test(BranchBuilder.ProtocolCanKillPlayer()));
Assert.IsTrue(tree.Test(BranchBuilder.ProtocolKnowsWhenPlayerChatToEveryone()));
}",Tests with two different root nodes will merge and test correctly,1
2307,"public void TestEmptyBranches() {
ITruth truth = this.CreateTree();
Assert.IsTrue(truth.BuildAndTest());
}",Tests that supplying no branches says the branch exists Useful for polling leaf nodes.,1
2308,"public void TestTwoDepthTruth() {
ITruth truth = this.CreateTree();
Assert.IsTrue(truth.BuildAndTest(new ProtocolAgent(), new CanFlow()));
}",Simple tests two-deep to ensure the basics of the tree work.,1
2309,"public void TestTwoDepthFalse() {
ITruth truth = this.CreateTree();
Assert.IsFalse(truth.BuildAndTest(new ProtocolAgent(), new ProtocolAgent()));
}",Simple test two-deep to ensure the basics of the tree work. The given branches should not exists in our static test.,1
2310,"public void TestPotatoCanDoChatsToGroupTruth() {
ITruth truth = this.CreateTree();
Assert.IsTrue(truth.BuildAndTest(new ProtocolAgent(), new CanFlow(), new ChatGoal(), new ToFlow(), new GroupAgent()));
}","Tests full branch out of ""Potato CanDo Chats To Group""",1
2311,"public void TestPotatoCanDoChatsToGroupSubstitutedFalse() {
ITruth truth = this.CreateTree();
Assert.IsFalse(truth.BuildAndTest(new ProtocolAgent(), new KnowsWhenFlow(), new ChatGoal(), new ToFlow(), new GroupAgent()));
}",Substitute one element of the branch which should ensure this is false,1
2312,"public void TestInstallDispatchedEntryStatusIsStopped() {
var uninstalled = false;
var service = new ServiceController() {
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, uri, packageId) => { uninstalled = true; }
},
Observer = {
Status = ServiceStatusType.Stopped
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.UninstallPackage(""id"");
Assert.IsTrue(uninstalled);
service.Dispose();
}",Tests the package dispatched for install if the entry status is set to Stopped,1
2313,"public void TestInstallDispatchedEntryStatusIsStarted() {
var uninstalled = false;
var service = new ServiceController() {
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, uri, packageId) => { uninstalled = true; }
},
Observer = {
Status = ServiceStatusType.Started
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.UninstallPackage(""id"");
Assert.IsTrue(uninstalled);
service.Dispose();
}",Tests the package dispatched for install if the entry status is set to Started,1
2314,"public void TestFromStoppedEndsAsStarted() {
var service = new ServiceController() {
Packages = new MockServicePackageManager(),
Observer = {
Status = ServiceStatusType.Stopped
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.UninstallPackage(""id"");
Assert.AreEqual(ServiceStatusType.Started, service.Observer.Status);
service.Dispose();
}",Tests that from a stopped state the eventual state is Started,1
2315,"public void TestUninstallDispatched() {
var dispatcher = new MockPackageManagerDispatch();
var sources = new ConcurrentDictionary<String, IPackageRepository>();
sources.TryAdd(""localhost"", new MockPackageRepository());
var packages = new ServicePackageManager() {
LocalRepository = new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0""
}
}) {
Uri = Defines.PackagesDirectory.FullName
},
PackageManagerDispatch = dispatcher,
SourceRepositories = sources
};
packages.UninstallPackage(""A"");
Assert.IsTrue(dispatcher.DispatchedUninstallPackage);
}",Tests that a package will be updated if a newer version is available,1
2316,"public void TestPackageMissing() {
var missing = false;
var sources = new ConcurrentDictionary<String, IPackageRepository>();
sources.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0""
}
}));
var packages = new ServicePackageManager() {
LocalRepository = new MockPackageRepository() {
Uri = Defines.PackagesDirectory.FullName
},
SourceRepositories = sources,
PackageMissing = packageId => missing = true,
PackageManagerDispatch = new MockPackageManagerDispatch()
};
packages.UninstallPackage(""B"");
Assert.IsTrue(missing);
}",Tests that a delegate will be called if the package id is missing from a source,1
2317,"public void TestBeforeRepositoryInitialize() {
var before = false;
var packages = new ServicePackageManager() {
BeforeRepositoryInitialize = () => before = true,
PackageManagerDispatch = new MockPackageManagerDispatch()
};
packages.UninstallPackage(""A"");
Assert.IsTrue(before);
}",Tests the initialize delegate is called when merging a package,1
2318,"public void TestOnBeforeLocalPackageFetch() {
var before = false;
var sources = new ConcurrentDictionary<String, IPackageRepository>();
sources.TryAdd(""localhost"", new MockPackageRepository(new List<IPackage>() {
new DataServicePackage() {
Id = ""A"",
Version = ""1.0.0""
}
}));
var packages = new ServicePackageManager() {
LocalRepository = new MockPackageRepository() {
Uri = Defines.PackagesDirectory.FullName
},
SourceRepositories = sources,
BeforeLocalPackageFetch = () => before = true,
PackageManagerDispatch = new MockPackageManagerDispatch()
};
packages.UninstallPackage(""A"");
Assert.IsTrue(before);
}",Tests the before local package fetch delegate is called when merging a package.,1
2319,"public void TestCombiningUniqueRootElements() {
IConfig a = new Config() {
Document = new JObject() {
new JProperty(""A"", new JArray())
}
};
IConfig b = new Config() {
Document = new JObject() {
new JProperty(""B"", new JArray())
}
};
IConfig c = a.Union(b);
Assert.IsNotNull(c.Document[""A""]);
Assert.IsNotNull(c.Document[""B""]);
}",Tests that unique root elements that exist in a and b will both appear in c.,1
2320,"public void TestCombiningIdenticalRootElements() {
IConfig a = new Config() {
Document = new JObject() {
new JProperty(""identical"", new JArray() {
new JObject() {
new JProperty(""keyA"", ""valueA"")
}
})
}
};
IConfig b = new Config() {
Document = new JObject() {
new JProperty(""identical"", new JArray() {
new JObject() {
new JProperty(""keyB"", ""valueB"")
}
})
}
};
IConfig c = a.Union(b);
Assert.AreEqual(""valueA"", c.Document[""identical""].First[""keyA""].Value<String>());
Assert.AreEqual(""valueB"", c.Document[""identical""].Last[""keyB""].Value<String>());
}",Tests that unique root elements that exist in a and b will both appear in c.,1
2321,"public void TestNullException() {
IConfig config = new Config();
config.Union(null);
}",Tests an argument null exception is raised if null is passed into union.,1
2322,"public void TestServiceDomainNulled() {
var service = new ServiceController() {
ServiceDomain = AppDomain.CreateDomain(""Potato.Instance""),
};
service.UnloadService();
Assert.IsNull(service.ServiceDomain);
service.Dispose();
}",Tests the loader proxy is nulled after unloading,1
2323,"public void TestUnloadServiceDispatchedBeginDelegateCalled() {
var begin = false;
var service = new ServiceController() {
ServiceDomain = AppDomain.CreateDomain(""Potato.Instance""),
UnloadServiceBegin = controller => begin = true
};
service.UnloadService();
Assert.IsTrue(begin);
service.Dispose();
}",Tests that the WriteServiceConfigBegin delegate is called prior to writing the config.,1
2324,"public void TestUnloadServiceDispatchedEndDelegateCalled() {
var end = false;
var service = new ServiceController() {
ServiceDomain = AppDomain.CreateDomain(""Potato.Instance""),
UnloadServiceEnd = controller => end = true
};
service.UnloadService();
Assert.IsTrue(end);
service.Dispose();
}",Tests that the WriteServiceConfigBegin delegate is called after writing the config.,1
2325,"public void TestExceptionLogged() {
var service = new ServiceController() {
ServiceDomain = AppDomain.CreateDomain(""Potato.Instance""),
UnloadServiceBegin = controller => {
throw new Exception(""Empty"");
},
Process = new MockProcess()
};
service.UnloadService();
Assert.IsNotEmpty(Defines.ErrorsLogsDirectory.GetFiles());
Assert.Greater(Defines.ErrorsLogsDirectory.GetFiles().First().Length, 0);
service.Dispose();
}",Tests that exception that occur during config write will be captured and logged.,1
2326,"public void TestExceptionKillsProcess() {
var process = new MockProcess();
var service = new ServiceController() {
ServiceDomain = AppDomain.CreateDomain(""Potato.Instance""),
UnloadServiceBegin = controller => {
throw new Exception(""Empty"");
},
Process = process
};
service.UnloadService();
Assert.IsTrue(process.OnKill);
service.Dispose();
}",Tests that exception that occur during config write will be captured and logged.,1
2327,"public void TestPackageCoreUpdateDispatched() {
var merged = false;
var service = new ServiceController() {
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, packageId, version) => { merged = true; }
},
Settings = {
ServiceUpdateCore = true
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.UpdateCore();
Assert.IsTrue(merged);
service.Dispose();
}",Tests that a stopped service controller will issue the call to update the core,1
2328,"public void TestUpdateNotCalledWhenSettingIsFalse() {
var merged = false;
var service = new ServiceController() {
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, packageId, version) => { merged = true; }
},
Settings = {
ServiceUpdateCore = false
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.UpdateCore();
Assert.IsFalse(merged);
service.Dispose();
}",Tests that no update call will occur if the ServiceUpdateCore setting is set to false.,1
2329,"public void TestUpdateNotCalledWhenStatusIsStarted() {
var merged = false;
var service = new ServiceController() {
Packages = new MockServicePackageManager() {
PackageInstalled = (sender, packageId, version) => { merged = true; }
},
Settings = {
ServiceUpdateCore = true
},
Observer = {
Status = ServiceStatusType.Started
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.UpdateCore();
Assert.IsFalse(merged);
service.Dispose();
}",Tests that no update call will occur if the service state is anything other than Stopped,1
2330,"public void TestBuildNamespaceVariableKeyEmptyNamespace() {
Assert.AreEqual(""CommandServerEnabled"", VariableModel.NamespaceVariableName("""", CommonVariableNames.CommandServerEnabled));
}",Tests that an empty namespace will result in the common VariableModel name being returned.,1
2331,"public void TestBuildNamespaceVariableKeyWithNamespace() {
Assert.AreEqual(""my.namespace.CommandServerEnabled"", VariableModel.NamespaceVariableName(""my.namespace"", CommonVariableNames.CommandServerEnabled));
}",Tests that a key is generated correctly with a dot seperator when a namespace is passed in.,1
2332,"public void TestDispose() {
var variables = new VariableController();
variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""VolatileKey"",
""value""
})
});
variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSetA,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""ArchiveKey"",
""value""
})
});
VariableModel volatileVariable = variables.VolatileVariables.Values.First();
variables.Dispose();
// Test that all the lists and data within each item has been nulled.
Assert.IsNull(variables.VolatileVariables);
Assert.IsNull(volatileVariable.Name);
Assert.IsNull(volatileVariable.Value);
}","Tests that when disposing of the variables object, all other items are cleaned up.",1
2333,"public void TestDynamicCreationCommonVariableKey() {
var variables = new VariableController();
// Validate the VariableModel does not exist first.
Assert.IsNull(variables.VolatileVariables.Values.FirstOrDefault(v => v.Name == CommonVariableNames.TextCommandPrivatePrefix.ToString()));
// Fetch the VariableModel. This should create and add the VariableModel.
variables.Variable(CommonVariableNames.TextCommandPrivatePrefix);
// Now validate that the VariableModel has been added.
Assert.IsNotNull(variables.VolatileVariables.Values.First(v => v.Name == CommonVariableNames.TextCommandPrivatePrefix.ToString()));
}",Tests that a VariableModel will be created and added if it does not exist to begin with.,1
2334,"public void TestDynamicCreationStringKey() {
String key = ""TestDynamicCreation"" + StringExtensions.RandomString(20);
var variables = new VariableController();
// Validate the VariableModel does not exist first.
Assert.IsNull(variables.VolatileVariables.Values.FirstOrDefault(v => v.Name == key));
// Fetch the VariableModel. This should create and add the VariableModel.
variables.Variable(key);
// Now validate that the VariableModel has been added.
Assert.IsNotNull(variables.VolatileVariables.Values.First(v => v.Name == key));
}",Tests that a VariableModel will be created and added if it does not exist to begin with.,1
2335,"public void TestLoadConfig() {
var saveVariables = (VariableController)new VariableController().Execute();
saveVariables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSetA,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""KeyToWriteString"",
""this is a string""
})
});
saveVariables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSetA,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""KeyToWriteInteger"",
1
})
});
saveVariables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""KeyToNotWrite"",
""This shouldn't appear in the saved file.""
})
});
saveVariables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSetA,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.MaximumProtocolConnections,
10
})
});
// Save a config of the variables controller
var saveConfig = new Config();
saveConfig.Create(typeof (VariableController));
saveVariables.WriteConfig(saveConfig);
saveConfig.Save(ConfigFileInfo);
// Load the config in a new config.
var loadVariables = (VariableController)new VariableController().Execute();
var loadConfig = new Config();
loadConfig.Load(ConfigFileInfo);
loadVariables.Execute(loadConfig);
Assert.AreEqual(""this is a string"", loadVariables.ArchiveVariables.Values.First(v => v.Name == ""KeyToWriteString"").ToType<String>());
Assert.AreEqual(1, loadVariables.ArchiveVariables.Values.First(v => v.Name == ""KeyToWriteInteger"").ToType<int>());
Assert.AreEqual(10, loadVariables.ArchiveVariables.Values.First(v => v.Name == ""MaximumProtocolConnections"").ToType<int>());
}",Tests that a config can be successfully loaded,1
2336,"public void TestWriteConfig() {
var variables = (VariableController)new VariableController().Execute();
variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSetA,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""NameToWriteString"",
""this is a string""
})
});
variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSetA,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""NameToWriteInteger"",
1
})
});
// Empty strings should not be written. No point saving nothing.
variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSetA,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""NameToignore"",
""""
})
});
variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""NameToNotWrite"",
""This shouldn't appear in the saved file.""
})
});
variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSetA,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
CommonVariableNames.MaximumProtocolConnections,
10
})
});
// Save a config of the variables controller
var saveConfig = new Config();
saveConfig.Create(typeof (VariableController));
variables.WriteConfig(saveConfig);
saveConfig.Save(ConfigFileInfo);
// Load the config in a new config.
var loadConfig = new Config();
loadConfig.Load(ConfigFileInfo);
var commands = loadConfig.RootOf<VariableController>().Children<JObject>().Select(item => item.ToObject<IConfigCommand>(JsonSerialization.Minimal)).ToList();
// Order is not maintained so we can only check that the values in some disorder are output.
// Nope, not perfect.
foreach (var command in commands) {
Assert.AreEqual(""VariablesSetA"", command.Command.Name);
Assert.IsTrue(new List<String>() { ""NameToWriteString"", ""NameToWriteInteger"", ""MaximumProtocolConnections"" }.Contains(command.Command.Parameters[0].First<String>()));
Assert.IsTrue(new List<String>() { ""this is a string"", ""1"", ""10"" }.Contains(command.Command.Parameters[1].First<String>()));
}
}",Tests that a config can be written in a specific format.,1
2337,"public void TestNoPassword() {
var variables = new VariableController();
var certificate = new CertificateController() {
Shared = {
Variables = variables
}
};
variables.Variable(CommonVariableNames.CommandServerCertificatePath).Value = Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""NoPassword.pfx"");
certificate.Execute();
Assert.IsNotNull(certificate.Certificate);
Assert.IsNotNull(certificate.Certificate.PrivateKey);
}",Tests that a certificate can be loaded when it requires no password.,1
2338,"public void TestPassword() {
var variables = new VariableController();
var certificate = new CertificateController() {
Shared = {
Variables = variables
}
};
variables.Variable(CommonVariableNames.CommandServerCertificatePath).Value = Path.Combine(Defines.BaseDirectory.FullName, ""Remote"", ""Certificates"", ""Password.pfx"");
variables.Variable(CommonVariableNames.CommandServerCertificatePassword).Value = ""password1"";
certificate.Execute();
Assert.IsNotNull(certificate.Certificate);
Assert.IsNotNull(certificate.Certificate.PrivateKey);
}",Tests that a certificate can be loaded when when it requires a password.,1
2339,"public void TestBlank() {
var variables = new VariableController();
variables.ParseArguments(new List<String>());
Assert.AreEqual(0, variables.VolatileVariables.Count);
}",Tests that parsing no arguments results in no variables.,1
2340,"public void TestParseMixedMultiple() {
var variables = new VariableController();
variables.ParseArguments(@""-key1 """"value1"""" -key2 -key3 2"".Wordify());
VariableModel variableOne = variables.Get(new Command() {
Origin = CommandOrigin.Local
}, ""key1"").Now.Variables.First();
VariableModel variableTwo = variables.Get(new Command() {
Origin = CommandOrigin.Local
}, ""key2"").Now.Variables.First();
VariableModel variableThree = variables.Get(new Command() {
Origin = CommandOrigin.Local
}, ""key3"").Now.Variables.First();
Assert.AreEqual(""value1"", variableOne.ToType(String.Empty));
Assert.IsTrue(variableOne.Readonly);
Assert.AreEqual(true, variableTwo.ToType(false));
Assert.IsTrue(variableTwo.Readonly);
Assert.AreEqual(2, variableThree.ToType(0));
Assert.IsTrue(variableThree.Readonly);
}","Parses: -key1 ""value1"" -key2 -key3 2 Expects: key1: ""value1"", readonly Expects: key2: true, readonly Expects: key3: 2, readonly",1
2341,"public void TestParseMultiple() {
var variables = new VariableController();
variables.ParseArguments(@""-key1 """"value1"""" -key2 2"".Wordify());
VariableModel variableOne = variables.Get(new Command() {
Origin = CommandOrigin.Local
}, ""key1"").Now.Variables.First();
VariableModel variableTwo = variables.Get(new Command() {
Origin = CommandOrigin.Local
}, ""key2"").Now.Variables.First();
Assert.AreEqual(""value1"", variableOne.ToType(String.Empty));
Assert.IsTrue(variableOne.Readonly);
Assert.AreEqual(2, variableTwo.ToType(0));
Assert.IsTrue(variableTwo.Readonly);
}","Parses: -key1 ""value1"" -key2 2 Expects: key1: ""value1"", readonly Expects: key2: 2, readonly",1
2342,"public void TestParseSingle() {
var variables = new VariableController();
variables.ParseArguments(@""-key """"value"""""".Wordify());
VariableModel variableModel = variables.Get(new Command() {
Origin = CommandOrigin.Local
}, ""key"").Now.Variables.First();
Assert.AreEqual(""value"", variableModel.ToType(String.Empty));
Assert.IsTrue(variableModel.Readonly);
}","Parses: -key ""value"" Expects: key: ""value"", readonly",1
2343,"public void TestParseSingleFlag() {
var variables = new VariableController();
variables.ParseArguments(@""-key"".Wordify());
VariableModel variableModel = variables.Get(new Command() {
Origin = CommandOrigin.Local
}, ""key"").Now.Variables.First();
Assert.IsTrue(variableModel.ToType(false));
Assert.IsTrue(variableModel.Readonly);
}","Parses: -key Expects: key: true, readonly",1
2344,"public void TestEmptyValueWithDefault() {
var variables = new VariableController();
variables.VolatileVariables.TryAdd(""key"", new VariableModel() {
Name = ""key"",
Value = """"
});
Assert.AreEqual(10, variables.VolatileVariables.Values.First().ToType(10));
}",Validates that getting a VariableModel value directly with an invalid cast will fallback to the default value.,1
2345,"public void TestValue() {
var variables = new VariableController();
variables.VolatileVariables.TryAdd(""key"", new VariableModel() {
Name = ""key"",
Value = ""value""
});
ICommandResult result = variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesGet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""key""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""value"", result.Now.Variables.First().ToType(String.Empty));
}",Fetches a simple VariableModel from the VariableModel controller.,1
2346,"public void TestValueCommonName() {
var variables = new VariableController();
variables.VolatileVariables.TryAdd(CommonVariableNames.MaximumProtocolConnections.ToString().ToLowerInvariant(), new VariableModel() {
Name = CommonVariableNames.MaximumProtocolConnections.ToString(),
Value = ""value""
});
var value = variables.Tunnel(CommandBuilder.VariablesGet(CommonVariableNames.MaximumProtocolConnections).SetOrigin(CommandOrigin.Local)).Now.Variables.First().ToType<String>();
Assert.AreEqual(""value"", value);
}",Tests fetching a VariableModel by a common name,1
2347,"public void TestValueComplexValue() {
var variables = new VariableController();
variables.VolatileVariables.TryAdd(""key"", new VariableModel() {
Name = ""key"",
Value = new VariableComplexValue() {
PropertyOne = 1,
PropertyTwo = ""two""
}
});
VariableComplexValue value = variables.Get(new Command() {
Origin = CommandOrigin.Local
}, ""key"").Now.Variables.First().ToType<VariableComplexValue>();
Assert.AreEqual(1, value.PropertyOne);
Assert.AreEqual(""two"", value.PropertyTwo);
}",Fetches the complex value from,1
2348,"public void TestValueEmptyKey() {
var variables = new VariableController();
variables.VolatileVariables.TryAdd(""key"", new VariableModel() {
Name = ""key"",
Value = new VariableModel() {
Name = ""key"",
Value = ""value""
}
});
ICommandResult result = variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesGet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
String.Empty
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
}",Tests that passing an empty key to the Get parameter will return an error.,1
2349,"public void TestInsufficientPermission() {
var variables = new VariableController() {
Shared = {
Security = new SecurityController().Execute() as SecurityController,
}
};
variables.VolatileVariables.TryAdd(""key"", new VariableModel() {
Name = ""key"",
Value = new VariableModel() {
Name = ""key"",
Value = ""value""
}
});
ICommandResult result = variables.Tunnel(new Command() {
CommandType = CommandType.VariablesGet,
Authentication = {
Username = ""Phogue""
},
Origin = CommandOrigin.Remote,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""key""
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that a user without correct permissions to fetch a VariableModel will get an error.,1
2350,"public void TestInvalidTypeCastNoDefault() {
var variables = new VariableController();
variables.VolatileVariables.TryAdd(""key"", new VariableModel() {
Name = ""key"",
Value = new VariableModel() {
Name = ""key"",
Value = ""10!""
}
});
Assert.AreNotEqual(10, variables.Get<int>(""key""));
}",Validates that if no cast is possible and no default is supplied the value will not equal what we expect.,1
2351,"public void TestInvalidTypeCastWithDefault() {
var variables = new VariableController();
variables.VolatileVariables.TryAdd(""key"", new VariableModel() {
Name = ""key"",
Value = new VariableModel() {
Name = ""key"",
Value = ""10!""
}
});
Assert.AreEqual(10, variables.Get(""key"", 10));
}",Validates that the default value will be used if no cast is possible.,1
2352,"public void TesValueValidTypeCast() {
var variables = new VariableController();
variables.VolatileVariables.TryAdd(""key"", new VariableModel() {
Name = ""key"",
Value = new VariableModel() {
Name = ""key"",
Value = ""10""
}
});
Assert.AreEqual(10, variables.Get<int>(""key""));
}",Validates that if a valid cast exists then then the VariableModel will be cast to that type.,1
2353,"public void TestComplexValue() {
var variables = new VariableController();
variables.SetA(new Command() {
Origin = CommandOrigin.Local
}, ""key"", new VariableComplexValue() {
PropertyOne = 1,
PropertyTwo = ""two""
});
var value = variables.ArchiveVariables.Values.First(v => v.Name == ""key"").ToType<VariableComplexValue>();
Assert.AreEqual(1, value.PropertyOne);
Assert.AreEqual(""two"", value.PropertyTwo);
}",Fetches the complex value from the archive.,1
2354,"public void TestValue() {
var variables = new VariableController();
ICommandResult result = variables.Tunnel(CommandBuilder.VariablesSet(""key"", ""value"").SetOrigin(CommandOrigin.Local));
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""value"", variables.Get(""key"", String.Empty));
}","Tests that we can set a value, getting the successful flag back from the command.",1
2355,"public void TestCaseInsensitive() {
var variables = new VariableController();
ICommandResult result = variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""key"",
""TestVariablesSetValueCaseInsensitive""
})
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""TestVariablesSetValueCaseInsensitive"", variables.Get(""Key"", String.Empty));
Assert.AreEqual(""TestVariablesSetValueCaseInsensitive"", variables.Get(""KEY"", String.Empty));
Assert.AreEqual(""TestVariablesSetValueCaseInsensitive"", variables.Get(""keY"", String.Empty));
Assert.AreEqual(""TestVariablesSetValueCaseInsensitive"", variables.Get(""Key"", String.Empty));
}",Tests that setting a VariableModel will fetch/set as case insensitive,1
2356,"public void TestEmptyKeyValue() {
var variables = new VariableController();
// Set the value of a empty key
ICommandResult result = variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
String.Empty,
""value""
})
});
// Validate that the command failed (can't have an empty key)
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InvalidParameter, result.CommandResultType);
Assert.AreEqual(0, variables.VolatileVariables.Count);
}",Tests that an empty key will result in a invalid parameter.,1
2357,"public void TestInsufficientPermission() {
var variables = new VariableController() {
Shared = {
Security = new SecurityController().Execute() as SecurityController
}
};
ICommandResult result = variables.Tunnel(new Command() {
Authentication = {
Username = ""Phogue""
},
Origin = CommandOrigin.Remote,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""key"",
""value""
})
});
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Tests that setting a VariableModel will fail if the user does not have permission.,1
2358,"public void TestOverrideExisting() {
var variables = new VariableController();
variables.VolatileVariables.TryAdd(""key"", new VariableModel() {
Name = ""key"",
Value = ""initial value""
});
// Set the value of a empty key
ICommandResult result = variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""key"",
""modified value""
})
});
// Validate that the command failed (can't have an empty key)
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""modified value"", variables.Get(""key"", String.Empty));
}",Tests that setting an existing VariableModel will succeed (different code branch because it does not need to be added first),1
2359,"public void TestReadOnly() {
var variables = new VariableController();
variables.VolatileVariables.TryAdd(""key"", new VariableModel() {
Name = ""key"",
Value = ""value"",
Readonly = true
});
// Set the value of a empty key
ICommandResult result = variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = TestHelpers.ObjectListToContentList(new List<Object>() {
""key"",
""modified value""
})
});
// Validate that the command failed (can't have an empty key)
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.Failed, result.CommandResultType);
Assert.AreEqual(""value"", variables.Get(""key"", String.Empty));
}",Tests setting a read only VariableModel returns an error and the VariableModel remains unchanged.,1
2360,"public void TestValueStringList() {
var variables = new VariableController();
// Set the value of a empty key
ICommandResult result = variables.Tunnel(new Command() {
Origin = CommandOrigin.Local,
CommandType = CommandType.VariablesSet,
Parameters = new List<ICommandParameter>() {
new CommandParameter() {
Data = {
Content = new List<String>() {
""key""
}
}
},
new CommandParameter() {
Data = {
Content = new List<String>() {
""value1"",
""value2""
}
}
}
}
});
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.IsNotNull(variables.Get<List<String>>(""key""));
Assert.AreEqual(""value1"", variables.Get<List<String>>(""key"").First());
Assert.AreEqual(""value2"", variables.Get<List<String>>(""key"").Last());
}",Tests that we can set a VariableModel to a list of strings via a command.,1
2361,"public void TestValue() {
var variables = new VariableController();
// Set an archive variable
ICommandResult result = variables.Tunnel(CommandBuilder.VariablesSetA(""key"", ""value"").SetOrigin(CommandOrigin.Local));
// Validate that the command was successful and the key was set to the passed value.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""value"", variables.Get(""key"", String.Empty));
Assert.AreEqual(""value"", variables.ArchiveVariables.Values.First(v => v.Name == ""key"").ToType<String>());
}","Sets a value for the archive, follows same code path as Set, but sets the same VariableModel in VariablesArchive.",1
2362,"public void TestInsufficientPermission() {
var variables = new VariableController();
ICommandResult result = variables.Tunnel(CommandBuilder.VariablesSetA(""key"", ""value"").SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}).SetOrigin(CommandOrigin.Remote));
// Validate the command failed because we don't have permissions to execute it.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Checks that a user must have permission to set a archive VariableModel.,1
2363,"public void TestCommonNameValue() {
var variables = new VariableController();
// Set an archive variable
variables.Tunnel(CommandBuilder.VariablesSetA(CommonVariableNames.MaximumProtocolConnections, ""value"").SetOrigin(CommandOrigin.Local));
// Validate that the command was successful and the key was set to the passed value.
Assert.AreEqual(""value"", variables.Get(CommonVariableNames.MaximumProtocolConnections, String.Empty));
Assert.AreEqual(""value"", variables.ArchiveVariables.Values.First(v => v.Name == CommonVariableNames.MaximumProtocolConnections.ToString()).ToType<String>());
}",Sets a value for the archive using the common name enum.,1
2364,"public void TestOverrideExisting() {
var variables = new VariableController();
// Set an archive variable
ICommandResult result = variables.Tunnel(CommandBuilder.VariablesSetA(""key"", ""value"").SetOrigin(CommandOrigin.Local));
// Validate that initially setting the VariableModel is successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""value"", variables.Get(""key"", String.Empty));
Assert.AreEqual(""value"", variables.ArchiveVariables.Values.First(v => v.Name == ""key"").ToType<String>());
result = variables.Tunnel(CommandBuilder.VariablesSetA(""key"", ""changed value"").SetOrigin(CommandOrigin.Local));
// Validate that we changed changed an existing VariableModel value.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""changed value"", variables.Get(""key"", String.Empty));
Assert.AreEqual(""changed value"", variables.ArchiveVariables.Values.First(v => v.Name == ""key"").ToType<String>());
}",Checks that we can override the value of an existing key in the VariableModel archive.,1
2365,"public void TestRemovesFlashVariable() {
var variables = new VariableController();
// Set a flash variable.
variables.Tunnel(CommandBuilder.VariablesSetF(""key"", ""value"").SetOrigin(CommandOrigin.Local));
// Set a archive value
variables.Tunnel(CommandBuilder.VariablesSetA(""key"", ""value"").SetOrigin(CommandOrigin.Local));
// Validate archive value exists and flash value does not.
Assert.IsEmpty(variables.FlashVariables);
Assert.IsNotEmpty(variables.ArchiveVariables);
}",Tests that setting an archive value will remove it from the flash variables list.,1
2366,"public void TestValue() {
var variables = new VariableController();
// Set an archive variable
ICommandResult result = variables.Tunnel(CommandBuilder.VariablesSetF(""key"", ""value"").SetOrigin(CommandOrigin.Local));
// Validate that the command was successful and the key was set to the passed value.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""value"", variables.Get(""key"", String.Empty));
Assert.AreEqual(""value"", variables.FlashVariables.Values.First(v => v.Name == ""key"").ToType<String>());
}","Sets a value for the archive, follows same code path as Set, but sets the same VariableModel in VariablesArchive.",1
2367,"public void TestInsufficientPermission() {
var variables = new VariableController();
ICommandResult result = variables.Tunnel(CommandBuilder.VariablesSetF(""key"", ""value"").SetAuthentication(new CommandAuthenticationModel() {
Username = ""Phogue""
}).SetOrigin(CommandOrigin.Remote));
// Validate the command failed because we don't have permissions to execute it.
Assert.IsFalse(result.Success);
Assert.AreEqual(CommandResultType.InsufficientPermissions, result.CommandResultType);
}",Checks that a user must have permission to set a archive VariableModel.,1
2368,"public void TestCommonNameValue() {
var variables = new VariableController();
// Set an archive variable
variables.Tunnel(CommandBuilder.VariablesSetF(CommonVariableNames.MaximumProtocolConnections, ""value"").SetOrigin(CommandOrigin.Local));
// Validate that the command was successful and the key was set to the passed value.
Assert.AreEqual(""value"", variables.Get(CommonVariableNames.MaximumProtocolConnections, String.Empty));
Assert.AreEqual(""value"", variables.FlashVariables.Values.First(v => v.Name == CommonVariableNames.MaximumProtocolConnections.ToString()).ToType<String>());
}",Sets a value for the archive using the common name enum.,1
2369,"public void TestOverrideExisting() {
var variables = new VariableController();
// Set an archive variable
ICommandResult result = variables.Tunnel(CommandBuilder.VariablesSetF(""key"", ""value"").SetOrigin(CommandOrigin.Local));
// Validate that initially setting the VariableModel is successful.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""value"", variables.Get(""key"", String.Empty));
Assert.AreEqual(""value"", variables.FlashVariables.Values.First(v => v.Name == ""key"").ToType<String>());
result = variables.Tunnel(CommandBuilder.VariablesSetF(""key"", ""changed value"").SetOrigin(CommandOrigin.Local));
// Validate that we changed changed an existing VariableModel value.
Assert.IsTrue(result.Success);
Assert.AreEqual(CommandResultType.Success, result.CommandResultType);
Assert.AreEqual(""changed value"", variables.Get(""key"", String.Empty));
Assert.AreEqual(""changed value"", variables.FlashVariables.Values.First(v => v.Name == ""key"").ToType<String>());
}",Checks that we can override the value of an existing key in the VariableModel archive.,1
2370,"public void TestRemovesArchiveVariable() {
var variables = new VariableController();
// Set a archive variable.
variables.Tunnel(CommandBuilder.VariablesSetA(""key"", ""value"").SetOrigin(CommandOrigin.Local));
// Set a flash value
variables.Tunnel(CommandBuilder.VariablesSetF(""key"", ""value"").SetOrigin(CommandOrigin.Local));
// Validate archive value exists and flash value does not.
Assert.IsEmpty(variables.ArchiveVariables);
Assert.IsNotEmpty(variables.FlashVariables);
}",Tests that setting an archive value will remove it from the flash variables list.,1
2371,"public void TestWriteConfigTickPassedTroughToMessage() {
var signaled = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy(),
WriteServiceConfigBegin = (controller) => { signaled = true; },
Settings = {
ServiceUpdateCore = false
},
Observer = {
Status = ServiceStatusType.Started
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.WriteConfig_Tick(null);
Assert.IsTrue(signaled);
service.Dispose();
}",Tests that the write config message is dispatched from the write config tick when the service is started,1
2372,"public void TestNotWrittenWhenServiceIsStopped() {
var signaled = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy(),
SignalBegin = (controller, message) => { signaled = true; },
Settings = {
ServiceUpdateCore = false
},
Observer = {
Status = ServiceStatusType.Stopped
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.WriteConfig_Tick(null);
Assert.IsFalse(signaled);
service.Dispose();
}",Tests the proxy isn't nagged when the service is currently stopped,1
2373,"public void TestNotWrittenWhenServiceProxyIsNull() {
var signaled = false;
var service = new ServiceController() {
SignalBegin = (controller, message) => { signaled = true; },
Settings = {
ServiceUpdateCore = false
},
Observer = {
Status = ServiceStatusType.Started
},
ServiceLoaderProxyType = typeof(MockServiceLoaderProxy)
};
service.WriteConfig_Tick(null);
Assert.IsFalse(signaled);
service.Dispose();
}",Simple condition to make sure messages are not processed from an imaginary proxy.,1
2374,"public void TestConfigWriteDispatchedSuccess() {
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy()
};
service.WriteServiceConfig();
Assert.IsTrue(((MockServiceLoaderProxy)service.ServiceLoaderProxy).OnWriteConfig);
service.Dispose();
}",Tests the writeconfig method is called on the service loader proxy,1
2375,"public void TestConfigWriteDispatchedBeginDelegateCalled() {
var begin = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy(),
WriteServiceConfigBegin = controller => begin = true
};
service.WriteServiceConfig();
Assert.IsTrue(begin);
service.Dispose();
}",Tests that the WriteServiceConfigBegin delegate is called prior to writing the config.,1
2376,"public void TestConfigWriteDispatchedEndDelegateCalled() {
var end = false;
var service = new ServiceController() {
ServiceLoaderProxy = new MockServiceLoaderProxy(),
WriteServiceConfigEnd = controller => end = true
};
service.WriteServiceConfig();
Assert.IsTrue(end);
service.Dispose();
}",Tests that the WriteServiceConfigBegin delegate is called after writing the config.,1
2377,"public void TestExceptionLogged() {
var service = new ServiceController() {
ServiceLoaderProxy = new MockNonSerializableServiceLoaderProxy()
};
service.WriteServiceConfig();
Assert.IsNotEmpty(Defines.ErrorsLogsDirectory.GetFiles());
Assert.Greater(Defines.ErrorsLogsDirectory.GetFiles().First().Length, 0);
service.Dispose();
}",Tests that exception that occur during config write will be captured and logged.,1
2378,"public void TestExceptionLoggedOnTimeout() {
var service = new ServiceController() {
ServiceLoaderProxy = new MockSlowServiceLoaderProxy() {
WriteConfigSleep = 500
},
Settings = {
WriteServiceConfigTimeout = 10
}
};
service.WriteServiceConfig();
Assert.IsNotEmpty(Defines.ErrorsLogsDirectory.GetFiles());
Assert.Greater(Defines.ErrorsLogsDirectory.GetFiles().First().Length, 0);
service.Dispose();
}",Tests that an exception will be logged when the maxmimum number of milliseconds for the task has exceeded.,1
2379,"public TextCommandController() {
this.Shared = new SharedReferences();
this.TextCommands = new List<TextCommandModel>();
this.CommandDispatchers.AddRange(new List<ICommandDispatch>() {
new CommandDispatch() {
CommandType = CommandType.TextCommandsExecute,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""text"",
Type = typeof(String)
}
},
Handler = this.TextCommandsExecute
},
new CommandDispatch() {
CommandType = CommandType.TextCommandsPreview,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""text"",
Type = typeof(String)
}
},
Handler = this.TextCommandsPreview
},
new CommandDispatch() {
CommandType = CommandType.TextCommandsRegister,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""textCommand"",
Type = typeof(TextCommandModel)
}
},
Handler = this.TextCommandsRegister
},
new CommandDispatch() {
CommandType = CommandType.TextCommandsUnregister,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""textCommand"",
Type = typeof(TextCommandModel)
}
},
Handler = this.TextCommandsUnregister
}
});
}",Creates new controller with the default attributes set,1
2380,"public override void Dispose() {
foreach (TextCommandModel textCommand in this.TextCommands) {
textCommand.Dispose();
}
this.TextCommands.Clear();
this.TextCommands = null;
this.Connection = null;
base.Dispose();
}",Does nothing. Information about this object is handled via it's parent interface.,1
2381,"public ICommandResult TextCommandsPreview(ICommand command, Dictionary<String, ICommandParameter> parameters) {
ICommandResult result = null;
String text = parameters[""text""].First<String>();
if (this.Shared.Security.DispatchPermissionsCheck(command, command.Name).Success == true) {
AccountModel speakerAccount = this.Shared.Security.GetAccount(command);
// @todo pull the prefix from the text?
String prefix = this.Shared.Variables.Get<String>(CommonVariableNames.TextCommandPublicPrefix);
result = this.Parse(this.GetAccountNetworkPlayer(command, speakerAccount), speakerAccount, prefix, text);
if (result != null) {
result.Scope = new CommandData() {
Content = new List<String>() {
text
},
Connections = new List<ConnectionModel>() {
this.Connection.ConnectionModel
}
};
}
else {
result = command.Result;
}
}
else {
result = CommandResult.InsufficientPermissions;
}
return result;
}","Essentially does everything that parsing does, but fires a different event.",1
2382,"protected ICommandResult Parse(PlayerModel speakerNetworkPlayer, AccountModel speakerAccount, String prefix, String text) {
List<ITextCommandParser> parsers = new List<ITextCommandParser>() {
this.BuildFuzzyParser(speakerNetworkPlayer, speakerAccount),
this.BuildRouteParser(speakerNetworkPlayer, speakerAccount)
};
return parsers.Select(parser => parser.Parse(prefix, text)).FirstOrDefault(result => result != null);
}",This method may fire multiple events to execute multiple commands when more than one parser is included in the future. This is expected behaviour.,1
2383,"protected PlayerModel GetAccountNetworkPlayer(ICommand command, AccountModel speaker) {
PlayerModel player = this.Connection.ProtocolState.Players.Values.FirstOrDefault(p => p.Uid == command.Authentication.Uid);
if (speaker != null) {
AccountPlayerModel accountPlayer = speaker.Players.FirstOrDefault(p => p.ProtocolType == this.Connection.ConnectionModel.ProtocolType.Type);
if (accountPlayer != null) {
player = this.Connection.ProtocolState.Players.Values.FirstOrDefault(p => p.Uid == accountPlayer.Uid);
}
}
return player;
}","This is used so an account over a layer can issue a command like ""kick me"", but we only know ""me"" from the context of the account issuing the command. We use this to fetch the player in the game so we know who to kick.",1
2384,"public TextCommandIntervalModel() {
this.IntervalType = TextCommandIntervalType.Infinite;
}",Initializes with default values,1
2385,"public TextCommandModel() {
this.PluginGuid = Guid.Empty;
this.PluginCommand = String.Empty;
this.Description = String.Empty;
this.Parser = TextCommandParserType.Fuzzy;
this.Commands = new List<String>();
this.Priority = 0;
}","sets a default ""empty"" text command to match against.",1
2386,"public void Dispose() {
this.PluginGuid = Guid.Empty;
this.PluginCommand = null;
this.Description = null;
this.Parser = TextCommandParserType.Fuzzy;
this.Commands.Clear();
this.Commands = null;
}",This just makes the command inert,1
2387,"public ThrottledStream() {
this.Interval = new TimeSpan(0, 0, 0, 1);
this.Items = new List<T>();
}",Sets up the default values (1 second interval etc),1
2388,"public void Flush() {
lock (this.ItemsLock) {
if (this.Running == true && this.Items.Count > 0) {
if (this.FlushTo != null) {
this.FlushTo(new List<T>(this.Items));
}
}
this.Items.Clear();
}
}",Flushes any waitign items to the callback method,1
2389,"public IThrottledStream<T> Start() {
this.Running = true;
this.IntervalTick = new Timer(state => this.Flush(), null, this.Interval, this.Interval);
return this;
}","Start processing the stream, collecting items.",1
2390,"public IThrottledStream<T> Stop() {
this.Running = false;
this.FlushTo = null;
if (this.IntervalTick != null) {
this.IntervalTick.Dispose();
this.IntervalTick = null;
}
return this;
}",Stop processing the stream. Essentially disposes the object.,1
2391,"public Token() : base() {
this.MinimumWeightedSimilarity = Token.MinimumSimilarity;
}",Empty constructor to initialize default attributes,1
2392,"public static readonly Dictionary<TokenMethodMetadata, ReduceDelegateHandler> TokenCombineHandlers = new Dictionary<TokenMethodMetadata, ReduceDelegateHandler>() {","A list of reduction methods, but with anything that can be combined to represent a single token. This isn't the same as reduction, as the actual meaning of the token won't change just the number of tokens defining the meaning will be combined.",1
2393,"public static readonly Dictionary<TokenMethodMetadata, ReduceDelegateHandler> TokenReduceHandlers = new Dictionary<TokenMethodMetadata, ReduceDelegateHandler>() {",A list of handlers to reduce tokens to more specialized tokens.,1
2394,"public static readonly Dictionary<TokenMethodMetadata, ParseDelegateHandler> TokenParseHandlers = new Dictionary<TokenMethodMetadata, ParseDelegateHandler>() {",Dictionary of all parse handlers,1
2395,"public string ToStringWithCulture(object objectToConvert)
{
if ((objectToConvert == null))
{
throw new global::System.ArgumentNullException(""objectToConvert"");
}
System.Type t = objectToConvert.GetType();
System.Reflection.MethodInfo method = t.GetMethod(""ToString"", new System.Type[] {
typeof(System.IFormatProvider)});
if ((method == null))
{
return objectToConvert.ToString();
}
else
{
return ((string)(method.Invoke(objectToConvert, new object[] {
this.formatProviderField })));
}
}",This is called from the compile/run appdomain to convert objects within an expression block to a string,1
2396,"public override void Connect() {
if (this.MarkManager.RemoveExpiredMarks().IsValidMarkWindow() == true) {
this.MarkManager.Mark();
try {
this.ConnectionState = ConnectionState.ConnectionConnecting;
this.Client = new System.Net.Sockets.UdpClient(this.Options.Hostname, this.Options.Port) {
DontFragment = true
};
this.RemoteIpEndPoint = new IPEndPoint(IPAddress.IPv6Any, 0);
this.Client.BeginReceive(this.ReadCallback, null);
this.ConnectionState = ConnectionState.ConnectionReady;
}
catch (SocketException se) {
this.Shutdown(se);
}
catch (Exception e) {
this.Shutdown(e);
}
}
}",Attempts a connection to the server using the specified host name and port.,1
2397,"public void TestBasicPacketRecievedByListener() {
MockUdpListener listener;
MockUdpClient client;
AutoResetEvent packetWait = new AutoResetEvent(false);
this.CreateAndConnect(36000, out listener, out client);
listener.PacketReceived += (sender, request) => packetWait.Set();
client.Send(new MockPacket() {
Packet = {
RequestId = 1,
Origin = PacketOrigin.Client,
Type = PacketType.Request
},
Text = ""TestBasicPacketSend""
});
Assert.IsTrue(packetWait.WaitOne(1000));
}",Simple test to see if our listener ever recieves a packet.,1
2398,"public void TestBasicPacketDeserializedByListener() {
MockUdpListener listener;
MockUdpClient client;
MockPacket packet = null;
AutoResetEvent packetWait = new AutoResetEvent(false);
this.CreateAndConnect(36001, out listener, out client);
listener.PacketReceived += (sender, request) => {
packet = request;
packetWait.Set();
};
client.Send(new MockPacket() {
Packet = {
RequestId = 1,
Origin = PacketOrigin.Client,
Type = PacketType.Request
},
Text = ""TestBasicPacketSend""
});
Assert.IsTrue(packetWait.WaitOne(1000));
Assert.AreEqual(""Client Request 1 TestBasicPacketSend"", packet.Packet.DebugText);
}",Tests a packet is deserialized by the listener correctly.,1
2399,"public void TestBasicPacketListenerReply() {
MockUdpListener listener;
MockUdpClient client;
MockPacket packet = null;
AutoResetEvent packetWait = new AutoResetEvent(false);
this.CreateAndConnect(36002, out listener, out client);
listener.PacketReceived += (sender, request) => {
request.Packet.Type = PacketType.Response;
request.Text = ""OK"";
sender.Send(request);
};
client.PacketReceived += (sender, response) => {
packet = response as MockPacket;
packetWait.Set();
};
client.Send(new MockPacket() {
Packet = {
RequestId = 1,
Origin = PacketOrigin.Client,
Type = PacketType.Request
},
Text = ""TestBasicPacketSend""
});
Assert.IsTrue(packetWait.WaitOne(1000));
Assert.AreEqual(""Client Response 1 OK"", packet.Packet.DebugText);
}",Tests a packet can be manipulated by the mock Udp listener and returned & deserialized by the client.,1
2400,"public VariableController() : base() {
this.Shared = new SharedReferences();
this.VolatileVariables = new ConcurrentDictionary<String, VariableModel>();
this.ArchiveVariables = new ConcurrentDictionary<String, VariableModel>();
this.FlashVariables = new ConcurrentDictionary<String, VariableModel>();
this.CommandDispatchers.AddRange(new List<ICommandDispatch>() {
new CommandDispatch() {
CommandType = CommandType.VariablesSet,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""name"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""value"",
Type = typeof(String),
IsList = true
}
},
Handler = this.CommandSetCollection
},
new CommandDispatch() {
CommandType = CommandType.VariablesSet,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""name"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""value"",
Type = typeof(String)
}
},
Handler = this.CommandSetSingular
},
new CommandDispatch() {
CommandType = CommandType.VariablesSetA,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""name"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""value"",
Type = typeof(String),
IsList = true
}
},
Handler = this.CommandSetACollection
},
new CommandDispatch() {
CommandType = CommandType.VariablesSetA,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""name"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""value"",
Type = typeof(String)
}
},
Handler = this.CommandSetASingular
},
new CommandDispatch() {
CommandType = CommandType.VariablesSetF,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""name"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""value"",
Type = typeof(String),
IsList = true
}
},
Handler = this.CommandSetFCollection
},
new CommandDispatch() {
CommandType = CommandType.VariablesSetF,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""name"",
Type = typeof(String)
},
new CommandParameterType() {
Name = ""value"",
Type = typeof(String)
}
},
Handler = this.CommandSetFSingular
},
new CommandDispatch() {
CommandType = CommandType.VariablesGet,
ParameterTypes = new List<CommandParameterType>() {
new CommandParameterType() {
Name = ""name"",
Type = typeof(String)
}
},
Handler = this.CommandGet
}
});
}",Initializes the variable controller with default values and sets up command handlers.,1
2401,"public override ICoreController Execute() {
this.AssignEvents();
this.SetupDefaultVariables();
return base.Execute();
}",Begins the execution of this variable controller. Assigns events and loads the config for this file.,1
2402,"public override void Dispose() {
foreach (var variable in this.VolatileVariables) {
variable.Value.Dispose();
}
foreach (var archiveVariable in this.ArchiveVariables) {
archiveVariable.Value.Dispose();
}
this.VolatileVariables.Clear();
this.VolatileVariables = null;
this.ArchiveVariables.Clear();
this.ArchiveVariables = null;
}",Information about this object is handled via it's parent interface.,1
2403,"public override void WriteConfig(IConfig config, String password = null) {
// Use the .Value.Name to maintain the case
foreach (var archiveVariable in this.ArchiveVariables) {
// Don't save empty values, even empty values in a list.
var values = archiveVariable.Value.ToList<String>().Where(item => item.Length > 0).ToList();
if (values.Count > 0) {
config.Append(CommandBuilder.VariablesSetA(archiveVariable.Value.Name, values).ToConfigCommand());
}
}
foreach (var flashVariable in this.FlashVariables) {
// Don't save empty values, even empty values in a list.
var values = flashVariable.Value.ToList<String>().Where(item => item.Length > 0).ToList();
if (values.Count > 0) {
config.Append(CommandBuilder.VariablesSet(flashVariable.Value.Name, values).ToConfigCommand());
}
}
}",Does nothing. Information about this object is handled via it's parent interface.,1
2404,public Object Value {,The value of the variable,0
2405,public bool Readonly {,Tells VariableController this variable is readonly and should not be written to,0
2406,"public VariableModel() {
this.Name = String.Empty;
}",Initializes the variable with default values.,0
2407,"public WaitingAction() {
this.Expiration = DateTime.Now.AddSeconds(10);
this.Responses = new List<IPacket>();
}",Initializes the waiting action with the default values.,1
2408,"public WaitingActions() {
this.Waiting = new ConcurrentDictionary<Guid, IWaitingAction>();
}",Initializes the controller with the default values.,1
2409,"public void Flush() {
foreach (var expired in this.Waiting.Where(on => on.Value.Expiration < DateTime.Now)) {
IWaitingAction deferredAction;
if (this.Waiting.TryRemove(expired.Key, out deferredAction) == true) {
this.OnExpired(deferredAction.Action, deferredAction.Requests, deferredAction.Responses);
}
}
}",Find and removes all expired actions.,1
2410,"public void TestSuccessfulSinglePacketDoneAction() {
WaitingActions waitingActions = new WaitingActions();
bool doneFlag = false;
waitingActions.Done = (action, requests, responses) => { doneFlag = true; };
waitingActions.Wait(new NetworkAction(), new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
});
waitingActions.Mark(new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 1
});
Assert.IsTrue(doneFlag);
}",Tests a simple wait on a single action with a single packet will be successfully done,1
2411,"public void TestFailedDoneAction() {
WaitingActions waitingActions = new WaitingActions();
bool doneFlag = false;
waitingActions.Done = (action, requests, responses) => { doneFlag = true; };
waitingActions.Wait(new NetworkAction(), new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
});
waitingActions.Mark(new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 2
});
Assert.IsFalse(doneFlag);
}",Tests that done will not be fired if a packet with a different request id is passed in that does not match the waiting packet.,1
2412,"public void TestSuccessfulDoublePacketDoneAction() {
WaitingActions waitingActions = new WaitingActions();
bool doneFlag = false;
waitingActions.Done = (action, requests, responses) => { doneFlag = true; };
waitingActions.Wait(new NetworkAction(), new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
},
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 2
}
});
waitingActions.Mark(new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 1
});
waitingActions.Mark(new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 2
});
Assert.IsTrue(doneFlag);
}",Tests an action waiting for two packets will be successful,1
2413,"public void TestFailedDoublePacketActionWithTwoSameResponses() {
WaitingActions waitingActions = new WaitingActions();
bool doneFlag = false;
waitingActions.Done = (action, requests, responses) => { doneFlag = true; };
waitingActions.Wait(new NetworkAction(), new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
},
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 2
}
});
waitingActions.Mark(new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 1
});
// Now send in the same packet
waitingActions.Mark(new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Response,
RequestId = 1
});
Assert.IsFalse(doneFlag);
}","Tests an action waiting for two packets won't successful complete if two identical packets are passed in, but it's waiting for two different packets",1
2414,"public void TestExpiredAction() {
WaitingActions waitingActions = new WaitingActions();
bool expiredFlag = false;
waitingActions.Expired = (action, requests, responses) => { expiredFlag = true; };
waitingActions.Wait(new NetworkAction(), new List<IPacket>() {
new Packet() {
Origin = PacketOrigin.Client,
Type = PacketType.Request,
RequestId = 1
}
}, DateTime.Now.AddSeconds(-1));
waitingActions.Flush();
Assert.IsTrue(expiredFlag);
Assert.AreEqual(0, waitingActions.Waiting.Count);
}",Tests actions will be expired after their expiration time has elapsed,1
2415,"public void TestWordifySingleWord() {
List<string> words = ""single"".Wordify();
Assert.AreEqual(1, words.Count);
Assert.AreEqual(""single"", words.First());
}",Tests a single word will simply come through as a list with a single word in it.,1
2416,"public void TestWordifyDoubleWord() {
List<string> words = ""first second"".Wordify();
Assert.AreEqual(2, words.Count);
Assert.AreEqual(""first"", words.First());
Assert.AreEqual(""second"", words.Last());
}",Tests two simple words will be split into two simple words.,1
2417,"public void TestWordifyTripleWordFirstTwoQuoted() {
List<string> words = ""\""first second\"" third"".Wordify();
Assert.AreEqual(2, words.Count);
Assert.AreEqual(""first second"", words.First());
Assert.AreEqual(""third"", words.Last());
}","Tests three words, with the first two being quoted will yeild two words.",1
2418,"public void TestWordifyTripleWordLastTwoQuoted() {
List<string> words = ""first \""second third\"""".Wordify();
Assert.AreEqual(2, words.Count);
Assert.AreEqual(""first"", words.First());
Assert.AreEqual(""second third"", words.Last());
}","Tests three words, with the first two being quoted will yeild two words.",1
2419,"public void TestWordifyEscapedNewLine() {
List<string> words = ""first\\nsecond"".Wordify();
Assert.AreEqual(1, words.Count);
Assert.AreEqual(""first\nsecond"", words.First());
}",Tests newline will be counted as a character and escaped properly,1
2420,"public void TestWordifyEscapedCarriageReturn() {
List<string> words = ""first\\rsecond"".Wordify();
Assert.AreEqual(1, words.Count);
Assert.AreEqual(""first\rsecond"", words.First());
}",Tests newline will be counted as a character and escaped properly,1
2421,"public void TestWordifyEscapedTab() {
List<string> words = ""first\\tsecond"".Wordify();
Assert.AreEqual(1, words.Count);
Assert.AreEqual(""first\tsecond"", words.First());
}",Tests tab will be counted as a character and escaped properly,1
2422,"public void TestWordifyEscapedBackslash() {
List<string> words = ""first\\\\second"".Wordify();
Assert.AreEqual(1, words.Count);
Assert.AreEqual(""first\\second"", words.First());
}",Tests backslash will be counted as a character and escaped properly,1
2423,"public void TestWordifyQuoteWithinQuote() {
List<string> words = ""\""first \\\""second\"" third"".Wordify();
Assert.AreEqual(2, words.Count);
Assert.AreEqual(""first \""second"", words.First());
Assert.AreEqual(""third"", words.Last());
}",Tests backslash will be counted as a character and escaped properly,1
2424,"public enum CommandDirection {
/// <summary>
/// The command should go down the tree of children
/// </summary>
Tunnel,
/// <summary>
/// The command should go up through the ancestors
/// </summary>
Bubble
}",The direction a command should propogate in,1
2425,"public enum CommandResultType {
/// <summary>
/// Command never got run?
/// </summary>
None,
/// <summary>
/// Nothing was found or no errors, cancels, etc have occured. The command should continue to execute.
/// </summary>
Continue,
/// <summary>
/// The command should be canceled with no further previews/executions.
/// </summary>
Cancel,
/// <summary>
/// The command has failed
/// </summary>
Failed,
/// <summary>
/// The command is successful
/// </summary>
Success,
/// <summary>
/// An invalid parameter was passed into the command.
/// </summary>
InvalidParameter,
/// <summary>
/// A required parameter was invalid because a value already exists
/// </summary>
AlreadyExists,
/// <summary>
/// A required parameter was invalid because the object does not exists
/// </summary>
DoesNotExists,
/// <summary>
/// The command was executed but the user had insufficient permissions to follow through with the command.
/// </summary>
InsufficientPermissions,
/// <summary>
/// The user has a minimum amount to execute a command, but lacks the authority to execute it on the target.
/// </summary>
InsufficientAuthority,
/// <summary>
/// A limit has been exceeded when attempting to execute the command.
/// </summary>
LimitExceeded,
/// <summary>
/// The command is essentially canceled, but is continuing asynchronously.
/// </summary>
ContinuedAsynchronously,
/// <summary>
/// The command has times out while executing asynchronously
/// </summary>
TimeoutAsynchronously,
}",A status type as a result of the command.,1
2426,"public enum CommonVariableNames {
/// <summary>
/// (string) The password for encrypting/descrypting configs
/// </summary>
PotatoConfigPassword,
/// <summary>
/// (int) The maximum number of tokens allowed per account.
/// </summary>
/// <remarks>Default used is 5 if not set.</remarks>
SecurityMaximumAccessTokensPerAccount,
/// <summary>
/// (int) The maximum amount of time a token can go without being touched before it is considered expired.
/// </summary>
/// <remarks>Default used is 172800 (2 days) if not set.</remarks>
SecurityMaximumAccessTokenLastTouchedLengthSeconds,
/// <summary>
/// (string) The default language to use when a user does not have /// </summary>
LocalizationDefaultLanguageCode,
/// <summary>
/// (string) Prefix for in game commands. Default is ""!""
/// </summary>
TextCommandPublicPrefix,
/// <summary>
/// (string) Prefix for in game commands. Default is ""#""
/// </summary>
TextCommandProtectedPrefix,
/// <summary>
/// (string) Prefix for in game commands. Default is ""@""
/// </summary>
TextCommandPrivatePrefix,
/// <summary>
/// (int) Maximum number of connections to game servers allowed
/// </summary>
MaximumProtocolConnections,
/// <summary>
/// (int) The maximum amount of time an event should be held in memory before being flushed to a log.
/// </summary>
MaximumEventsTimeSeconds,
/// <summary>
/// (bool) True to log events to file, false to just discard the events.
/// </summary>
WriteLogEventsToFile,
/// <summary>
/// (bool) Flag turning te command sever on/off
/// </summary>
CommandServerEnabled,
/// <summary>
/// (uint) The port to listen for connections on.
/// </summary>
CommandServerPort,
/// <summary>
/// (string) The path to the certificate file. If unset then Potato's default /Certificates/CommandServer.pfx
/// will be used.
/// </summary>
CommandServerCertificatePath,
/// <summary>
/// (string) The password to the certificate store
/// </summary>
CommandServerCertificatePassword,
/// <summary>
/// List[String] list of strings to ignore if they match
/// </summary>
ProtocolEventsIgnoreList,
/// <summary>
/// List[String] list of configuration options for the database.
/// </summary>
DatabaseConfigGroups,
/// <summary>
/// (String) The name of the driver to use.
/// </summary>
DatabaseDriverName,
/// <summary>
/// (String) The hostname for the database driver to connect to.
/// </summary>
DatabaseHostname,
/// (String) <summary>
/// The port for the database driver to use.
/// </summary>
DatabasePort,
/// <summary>
/// (ushort) The database Uid to use by the database driver during authentication.
/// </summary>
DatabaseUid,
/// <summary>
/// (String) The database Password to use by the database driver during authentication.
/// </summary>
DatabasePassword,
/// <summary>
/// (String) The name of the database to use once connected.
/// </summary>
DatabaseName,
/// <summary>
/// (Bool) True if the database should exist in memory only
/// </summary>
DatabaseMemory,
/// <summary>
/// (String) The maximum number of rows to fetch from a query. This is 20 by default.
/// </summary>
DatabaseMaximumSelectedRows,
/// <summary>
/// List[String] list of configuration options for the push end points.
/// </summary>
EventsPushConfigGroups,
/// <summary>
/// (String) The Uri end point to push new events to
/// </summary>
EventsPushUri,
/// <summary>
/// (int) The interval in seconds to push events to the uri end point.
/// </summary>
EventPushIntervalSeconds,
/// <summary>
/// (string/PushEventsEndPointContentType) The content type to serialize the events list with. The default (if nothing set) is xml.
/// </summary>
EventPushContentType,
/// <summary>
/// (string) The key/password to be sent along with request to the push end point. Optional.
/// </summary>
EventPushStreamKey,
/// <summary>
/// List[String] A list of events the end point should send. If an event is not in this list, it won't be sent across the stream.
/// </summary>
EventPushInclusiveNames,
/// <summary>
/// List[String] A list of ignored event names that won't be logged to the file.
/// </summary>
EventsLogIgnoredNames,
/// <summary>
/// List[String] list of configuration options for the packages.
/// </summary>
PackagesConfigGroups,
/// <summary>
/// (String) The uri of the respository in the group
/// </summary>
PackagesRepositoryUri,
/// <summary>
/// (String) The full default uri of the source respository to download core Potato updates from.
/// </summary>
PackagesDefaultSourceRepositoryUri
}",All variable names are case-insensitive.,1
2427,"public enum PackageState {
/// <summary>
/// Package is not installed and is available on remote server
/// </summary>
NotInstalled,
/// <summary>
/// The package is installed and up to date
/// </summary>
Installed,
/// <summary>
/// Package installed, but version is out of date.
/// </summary>
UpdateAvailable
}","The current state of a package (installed, updatable or installed with no update)",1
2428,"public enum TextCommandParserType {
/// <summary>
/// Use any parser that eventually matches a command.
/// </summary>
Any,
/// <summary>
/// Fuzzy matching against text where commands don't need a set
/// structure.
/// </summary>
Fuzzy,
/// <summary>
/// Matches route-like format ""test :player :number"" against
/// specific text supplied by the player. Very precise matching required.
/// </summary>
Route
}","The different methods of parser available, converting text commands into matches",1
2429,"public enum ClientEventType {
/// <summary>
/// No event specified.
/// </summary>
None,
/// <summary>
/// The sate of the connection has changed (connection -> disconnected, etc.)
/// </summary>
ClientConnectionStateChange,
/// <summary>
/// A general connection failure, though not specifically socket related.
/// </summary>
ClientConnectionFailure,
/// <summary>
/// An exception has occured while communicating with the game server.
/// </summary>
ClientSocketException,
/// <summary>
/// A packet has been successfully sent to the game server.
/// </summary>
ClientPacketSent,
/// <summary>
/// Client packet has been recieved. It's already been dispatched and processed by
/// Potato's networking layer, so this is just for external usage.
/// </summary>
ClientPacketReceived,
/// <summary>
/// An action has been completed (all responses accounted for)
/// </summary>
ClientActionDone,
/// <summary>
/// An action has expired before being completed.
/// </summary>
ClientActionExpired
}","Event that has occured related to a connection, but not yet processed or already processed by the game.",1
2430,"public enum PacketOrigin {
/// <summary>
/// Unknown origin
/// </summary>
None,
/// <summary>
/// Packet was generated and sent by the server
/// </summary>
Server,
/// <summary>
/// Packet was generated and sent by the client
/// </summary>
Client
}",The original origin of the packet,1
2431,"public enum PacketType {
/// <summary>
/// Unknown direction
/// </summary>
None,
/// <summary>
/// Packet is a request for action to be taken by the client or server
/// </summary>
Request,
/// <summary>
/// Packet is a response to an action taken by the client or server
/// </summary>
Response
}","The type of packet, originally sent or recieved.",1
2432,"public enum ProtocolEventType {
/// <summary>
/// No event specified.
/// </summary>
None,
/// <summary>
/// The game has had its definitions for gamemodes, maps etc. loaded.
/// </summary>
ProtocolConfigExecuted,
/// <summary>
/// Any server info/server settings have been updated.
/// </summary>
ProtocolSettingsUpdated,
/// <summary>
/// Playerlist information has been updated (scores/pings etc might have changed)
/// </summary>
ProtocolPlayerlistUpdated,
/// <summary>
/// The maplist has been updated - synched with server or new maplist, added maps etc.
/// </summary>
ProtocolMaplistUpdated,
/// <summary>
/// The banlist has been updated - synched with server or new banlist, added/removed bans
/// </summary>
ProtocolBanlistUpdated,
/// <summary>
/// A player has joined the game
/// </summary>
ProtocolPlayerJoin,
/// <summary>
/// A player has left the game
/// </summary>
ProtocolPlayerLeave,
/// <summary>
/// A player has been killed
/// </summary>
ProtocolPlayerKill,
/// <summary>
/// Chat has occured on the server (by Potato, the server or a player)
/// </summary>
ProtocolChat,
/// <summary>
/// A player has spawned in
/// </summary>
ProtocolPlayerSpawn,
/// <summary>
/// A player has been kicked
/// </summary>
ProtocolPlayerKicked,
/// <summary>
/// A player has moved to another team or has been moved to another team
/// </summary>
ProtocolPlayerMoved,
/// <summary>
/// A player has been banned
/// </summary>
ProtocolPlayerBanned,
/// <summary>
/// A player has been unbanned
/// </summary>
ProtocolPlayerUnbanned,
/// <summary>
/// The map has changed
/// </summary>
ProtocolMapChanged,
/// <summary>
/// The round has changed
/// </summary>
ProtocolRoundChanged,
}",The type of event originating from the protocol,1
2433,"public enum NetworkActionType {
/// <summary>
/// No action
/// </summary>
None,
/// <summary>
/// Packet is to be sent
/// </summary>
[Description(""Send a raw packet to the server."")]
NetworkPacketSend,
/// <summary>
/// Outputs to the normal chat window that players use
/// </summary>
[Description(""Outputs to the normal chat window that players use"")]
NetworkTextSay,
/// <summary>
/// Outputs a bigger text if available in the game, otherwise it will fallback to a say.
/// </summary>
[Description(""Outputs a bigger text if available in the game, otherwise it will fallback to a say."")]
NetworkTextYell,
/// <summary>
/// Outputs a bigger text if available in the game. Will not fallback to 'say' if it is not available in the game.
/// </summary>
[Description(""Outputs a bigger text if available in the game. Will not fallback to 'say' if it is not available in the game."")]
NetworkTextYellOnly,
/// <summary>
/// Adds the map to the end of the maplist
/// </summary>
[Description(""Adds the map to the end of the maplist"")]
NetworkMapAppend,
/// <summary>
/// Changes to the specified game mode.
/// </summary>
[Description(""Changes to the specified game mode."")]
NetworkMapChangeMode,
/// <summary>
/// Removes all occurences of the map from the maplist
/// </summary>
[Description(""Removes all occurences of the map from the maplist"")]
NetworkMapRemove,
/// <summary>
/// Removes a specific index from the maplist
/// </summary>
[Description(""Removes a specific index from the maplist"")]
NetworkMapRemoveIndex,
/// <summary>
/// Inserts the map at a given index
/// </summary>
[Description(""Inserts the map at a given index"")]
NetworkMapInsert,
/// <summary>
/// Restarts the map
/// </summary>
[Description(""Restarts the map"")]
NetworkMapRestart,
/// <summary>
/// Restarts the current round
/// </summary>
[Description(""Restarts the current round"")]
NetworkMapRoundRestart,
/// <summary>
/// Forces map change to the next map
/// </summary>
[Description(""Forces map change to the next map"")]
NetworkMapNext,
/// <summary>
/// Forces a round change to the next round
/// </summary>
[Description(""Forces a round change to the next round"")]
NetworkMapRoundNext,
/// <summary>
/// Sets the next level index to play
/// </summary>
[Description(""Sets the next level index to play"")]
NetworkMapNextIndex,
/// <summary>
/// Removes all maps in the maplist
/// </summary>
[Description(""Removes all maps in the maplist"")]
NetworkMapClear,
/// <summary>
/// Moves the player to the specified location
/// </summary>
[Description(""Moves the player to the specified location"")]
NetworkPlayerMove,
/// <summary>
/// Kills (if available) and moves the player to the specified location
/// </summary>
[Description(""Kills (if available) and moves the player to the specified location"")]
NetworkPlayerMoveForce,
/// <summary>
/// Rotates a player to another team.
/// The destination team will not include any neutral/spectator teams.
/// </summary>
[Description(""Rotates a player to another team. The destination team will not include any neutral/spectator teams."")]
NetworkPlayerMoveRotate,
/// <summary>
/// Kills (if available) and rotates a player to another team
/// The destination team will not include any neutral/spectator teams.
/// </summary>
[Description(""Kills (if available) and rotates a player to another team. The destination team will not include any neutral/spectator teams."")]
NetworkPlayerMoveRotateForce,
/// <summary>
/// The player is banned or is going to be banned
/// </summary>
[Description(""The player is banned or is going to be banned"")]
NetworkPlayerBan,
/// <summary>
/// The player is unbanned or is going to be unbanned
/// </summary>
[Description(""The player is unbanned or is going to be unbanned"")]
NetworkPlayerUnban,
/// <summary>
/// Kicks a player out of the server
/// </summary>
[Description(""Kicks a player out of the server"")]
NetworkPlayerKick,
/// <summary>
/// Kills a player
/// </summary>
[Description(""Kills a player"")]
NetworkPlayerKill,
}",Common action types,1
2434,"public enum HumanHitLocation {
/// <summary>
/// No hit indicated
/// </summary>
None = 0x00,
/// <summary>
/// Head was hit
/// </summary>
Head = 0x1,
/// <summary>
/// Neck was hit
/// </summary>
Neck = 0x2,
/// <summary>
/// Upper torso was hit
/// </summary>
UpperTorso = 0x4,
/// <summary>
/// Lower torso was hit
/// </summary>
LowerTorso = 0x8,
/// <summary>
/// Upper left leg was hit
/// </summary>
UpperLeftLeg = 0x10,
/// <summary>
/// Upper right leg was hit
/// </summary>
UpperRightLeg = 0x20,
/// <summary>
/// Lower left left was hit
/// </summary>
LowerLeftLeg = 0x40,
/// <summary>
/// Lower right leg was hit
/// </summary>
LowerRightLeg = 0x80,
/// <summary>
/// Left foot was hit
/// </summary>
LeftFoot = 0x100,
/// <summary>
/// Right foot was hit
/// </summary>
RightFoot = 0x200,
/// <summary>
/// Upper left arm was hit
/// </summary>
UpperLeftArm = 0x400,
/// <summary>
/// Upper right arm was hit
/// </summary>
UpperRightArm = 0x800,
/// <summary>
/// Lower left arm was hit
/// </summary>
LowerLeftArm = 0x1000,
/// <summary>
/// Lower right arm was hit
/// </summary>
LowerRightArm = 0x2000,
/// <summary>
/// Left hand was hit
/// </summary>
LeftHand = 0x4000,
/// <summary>
/// Right hand was hit
/// </summary>
RightHand = 0x8000
}",A hit location for a humanoid,1
2435,"public enum NetworkOrigin {
/// <summary>
/// No origin specified
/// </summary>
None,
/// <summary>
/// Message was generated by the server (Potato and the players in the server didn't say it)
/// </summary>
Server,
/// <summary>
/// Message was sent from a player in game
/// </summary>
Player,
/// <summary>
/// Sent from Potato and reflected back after confirmation (when available) of it being sent /// </summary>
Reflected
}",The location of the event or data on the network,1
2436,"public enum TimeSubsetContext {
/// <summary>
/// No time subset specified
/// </summary>
None,
/// <summary>
/// The subset covers all times
/// </summary>
Permanent,
/// <summary>
/// Until the end of the current round
/// </summary>
Round,
/// <summary>
/// Until a set time limit has expired
/// </summary>
Time
}",A brief description of a unit of time,1
2437,"internal struct BandMatrix
{
/// <summary>
/// The band-diagonal matrix.
/// A double's array of size 11.
/// </summary>
public double[] a;
/// <summary>
/// Lower part of band-diagonal decomposition.
/// A double's array of size 5.
/// </summary>
public double[] al;
/// <summary>
/// Copy band matrix from source band matrix to current instance of band matrix.
/// </summary>
/// <param name=""from"">The source band matrix.</param>
private void CopyFrom(ref BandMatrix from)
{
Array.Copy(from.a, 0, a, 0, 11);
Array.Copy(from.al, 0, al, 0, 5);
}
/// <summary>
/// The source band matrix.
/// </summary>
/// <param name=""src"">The source band matrix.</param>
/// <param name=""srcIndex"">The source band matrix start element index.</param>
/// <param name=""dst"">The destination band matrix.</param>
/// <param name=""dstIndex"">The destination band matrix start element index.</param>
/// <param name=""length"">Number of elements to copy from source band matrix.</param>
public static void Copy(BandMatrix[] src, int srcIndex, BandMatrix[] dst, int dstIndex, int length)
{
for (int i = 0; i < length; ++i)
{
dst[i + dstIndex].CopyFrom(ref src[i + srcIndex]);
}
}
}",The band matrix.,1
2438,"public interface IBezierContext
{
/// <summary>
/// Called by spiro to start a contour.
/// </summary>
/// <param name=""x"">The X coordinate of the new start point.</param>
/// <param name=""y"">The Y coordinate of the new start point.</param>
/// <param name=""isOpen"">An boolean flag indicating wheter spline is open (True) or closed (False).</param>
void MoveTo(double x, double y, bool isOpen);
/// <summary>
/// Called by spiro to move from the last point to the next one on a straight line.
/// </summary>
/// <param name=""x"">The X coordinate of the new end point.</param>
/// <param name=""y"">The Y coordinate of the new end point.</param>
void LineTo(double x, double y);
/// <summary>
/// Called by spiro to move from the last point to the next along a quadratic bezier spline
/// (x1,y1) is the quadratic bezier control point and (x2,y2) will be the new end point.
/// </summary>
/// <param name=""x1"">The X coordinate of quadratic bezier bezier control point.</param>
/// <param name=""y1"">The Y coordinate of quadratic bezier bezier control point.</param>
/// <param name=""x2"">The X coordinate of the new end point.</param>
/// <param name=""y2"">The Y coordinate of the new end point.</param>
void QuadTo(double x1, double y1, double x2, double y2);
/// <summary>
/// Called by spiro to move from the last point to the next along a cubic bezier spline
/// (x1,y1) and (x2,y2) are the two off-curve control point and (x3,y3) will be the new end point.
/// </summary>
/// <param name=""x1"">The X coordinate of first cubic bezier spline off-curve control point.</param>
/// <param name=""y1"">The Y coordinate of first cubic bezier spline off-curve control point.</param>
/// <param name=""x2"">The X coordinate of second cubic bezier spline off-curve control point.</param>
/// <param name=""y2"">The Y coordinate of second cubic bezier spline off-curve control point.</param>
/// <param name=""x3"">The X coordinate of the new end point.</param>
/// <param name=""y3"">The Y coordinate of the new end point.</param>
void CurveTo(double x1, double y1, double x2, double y2, double x3, double y3);
/// <summary>
/// Called by spiro to mark current control point knot.
/// </summary>
/// <param name=""index"">The spiros control point knot index.</param>
/// <param name=""theta"">The spiros control point knot theta angle.</param>
/// <param name=""x"">The spiros control point X location.</param>
/// <param name=""y"">The spiros control point Y location.</param>
/// <param name=""type"">The spiros control point type.</param>
void MarkKnot(int index, double theta, double x, double y, SpiroPointType type);
}",As it does so it will call the appropriate routine in your bzier context with this information this should allow you to create your own internal representation of those curves.,1
2439,"public static void SpiroCPsToBezier(SpiroControlPoint[] spiros, int n, bool isClosed, IBezierContext bc)
{
SpiroCPsToBezier0(spiros, n, isClosed, bc);
}","As it does so it will call the appropriate routine in your bzier context with this information this should allow you to create your own internal representation of those curves. Open contours do not need to start with '{', nor to end with '}'. Close contours do not need to end with 'z'. This function is kept for backwards compatibility for older programs. Please use the function that return success/failure replies when done.",1
2440,"public static void TaggedSpiroCPsToBezier(SpiroControlPoint[] spiros, IBezierContext bc)
{
TaggedSpiroCPsToBezier0(spiros, bc);
}",As it does so it will call the appropriate routine in your bzier context with this information this should allow you to create your own internal representation of those curves. The spiros array should indicate it's own end. Open contours must have the ty field of the first cp set to '{' and have the ty field of the last cp set to '}'. Closed contours must have an extra cp at the end whose ty is 'z' the x and y values of this extra cp are ignored. This function is kept for backwards compatibility for older programs. Please use the functions that return success/failure replies when done.,1
2441,"public static bool SpiroCPsToBezier0(SpiroControlPoint[] spiros, int n, bool isClosed, IBezierContext bc)
{
SpiroSegment[] s;
if (n <= 0)
return false;
if (isClosed)
s = SpiroImpl.run_spiro(spiros, n);
else
{
SpiroPointType oldty_start = spiros[0].Type;
SpiroPointType oldty_end = spiros[n - 1].Type;
spiros[0].Type = SpiroPointType.OpenContour;
spiros[n - 1].Type = SpiroPointType.EndOpenContour;
s = SpiroImpl.run_spiro(spiros, n);
spiros[n - 1].Type = oldty_end;
spiros[0].Type = oldty_start;
}
if (s != null)
{
SpiroImpl.spiro_to_bpath(s, n, bc);
return true; // success
}
return false; // spiro did not converge or encountered non-finite values
}","As it does so it will call the appropriate routine in your bzier context with this information this should allow you to create your own internal representation of those curves. Open contours do not need to start with '{', nor to end with '}'. Close contours do not need to end with 'z'. This function is kept for backwards compatibility for older programs. Please use the function that return success/failure replies when done.",1
2442,"public static bool TaggedSpiroCPsToBezier0(SpiroControlPoint[] spiros, IBezierContext bc)
{
SpiroSegment[] s;
int n;
n = 0;
while (true)
{
if (spiros[n].Type == SpiroPointType.End || spiros[n].Type == SpiroPointType.EndOpenContour)
break;
// invalid input
if (n >= spiros.Length)
return false;
++n;
}
if (spiros[n].Type == SpiroPointType.EndOpenContour)
++n;
if (n <= 0)
return false; // invalid input
s = SpiroImpl.run_spiro(spiros, n);
if (s != null)
{
SpiroImpl.spiro_to_bpath(s, n, bc);
return true; // success
}
return false; // spiro did not converge or encountered non-finite values
}",As it does so it will call the appropriate routine in your bzier context with this information this should allow you to create your own internal representation of those curves. The spiros array should indicate it's own end. Open contours must have the ty field of the first cp set to '{' and have the ty field of the last cp set to '}'. Closed contours must have an extra cp at the end whose ty is 'z' the x and y values of this extra cp are ignored.,1
2443,"public static void SpiroCPsToBezier1(SpiroControlPoint[] spiros, int n, bool isClosed, IBezierContext bc, out bool done)
{
done = SpiroCPsToBezier0(spiros, n, isClosed, bc);
}","As it does so it will call the appropriate routine in your bzier context with this information this should allow you to create your own internal representation of those curves. Open contours do not need to start with '{', nor to end with '}'. Close contours do not need to end with 'z'.",1
2444,"public static void TaggedSpiroCPsToBezier1(SpiroControlPoint[] spiros, IBezierContext bc, out bool done)
{
done = TaggedSpiroCPsToBezier0(spiros, bc);
}",As it does so it will call the appropriate routine in your bzier context with this information this should allow you to create your own internal representation of those curves. The spiros array should indicate it's own end. Open contours must have the ty field of the first cp set to '{' and have the ty field of the last cp set to '}'. Closed contours must have an extra cp at the end whose ty is 'z' the x and y values of this extra cp are ignored.,1
2445,"public struct SpiroSegment
{
/// <summary>
/// Spiro code point segment_chord startX.
/// </summary>
public double X;
/// <summary>
/// Spiro code point segment_chord startY.
/// </summary>
public double Y;
/// <summary>
/// Spiro code point Type.
/// </summary>
public SpiroPointType Type;
/// <summary>
/// Bend theta between this vector and next vector.
/// </summary>
public double bend_th;
/// <summary>
/// A double's array of size 4.
/// </summary>
public double[] ks;
/// <summary>
/// The segment_chord distance from xy to next spiro code point.
/// </summary>
public double seg_ch;
/// <summary>
/// The segment_theta angle for this spiro code point.
/// </summary>
public double seg_th;
/// <summary>
/// Unused.
/// </summary>
public double l;
}",The run_spiro() uses array of information given in the spiro control point structure and creates an array in this structure format to use by spiro_to_bpath for building bezier curves.,1
2446,"public enum SpiroPointType
{
/// <summary>
/// A corner point.
/// Where the slopes and curvatures of the incoming and outgoing splines are unconstrained.
/// </summary>
Corner = 'v',
/// <summary>
/// A G4 curve point.
/// Continuous up to the fourth derivative.
/// </summary>
G4 = 'o',
/// <summary>
/// A G2 curve point.
/// Continuous up to the second derivative.
/// </summary>
G2 = 'c',
/// <summary>
/// A left constraint point.
/// Used to connect a curved line to a straight one.
/// </summary>
Left = '[',
/// <summary>
/// A right constraint point.
/// Used to connect a straight line to a curved one.
/// If you have a contour which is drawn clockwise, and you have a straight segment at the top, then the left point of that straight segment should be a left constraint, and the right point should be a right constraint.
/// </summary>
Right = ']',
/// <summary>
/// End point.
/// For a closed contour add an extra cp with a ty set to 'end'.
/// </summary>
End = 'z',
/// <summary>
/// Open contour.
/// For an open contour the first cp must have a ty set to 'open contour'.
/// </summary>
OpenContour = '{',
/// <summary>
/// End open contour.
/// For an open contour the last cp must have a ty set to 'end open contour'.
/// </summary>
EndOpenContour = '}'
}",Possible values of the spiro control point Type property.,1
2447,"static AllocatedBytesForCurrentThread()
{
var method = typeof(GC)
.GetTypeInfo()
.GetMethod(""GetAllocatedBytesForCurrentThread"", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
if (method == null)
{
_GetAllocatedBytesForCurrentThread = () => -0xBAAAAAAD;
IsAvailable = false;
NoAvailabilityReason = ""The running implementation of .NET does not expose 'GC.GetAllocatedBytesForCurrentThread'."";
}
else
{
_GetAllocatedBytesForCurrentThread = () => (long)method.Invoke(null, null);
if (IsBugFixed())
{
IsAvailable = true;
NoAvailabilityReason = """";
}
else
{
IsAvailable = false;
NoAvailabilityReason = ""Not capturing 'GC.GetAllocatedBytesForCurrentThread' because the targeted runtime does not contain the fix for 'https://github.com/dotnet/coreclr/issues/10207'"";
}
}
var allocatedBytesBefore = LastAllocatedBytes;
var allocatedBytesAfter = LastAllocatedBytes;
s_minAllocatedBytes = allocatedBytesAfter - allocatedBytesBefore;
}","gcGetAllocMethod.Invoke(null, null);",1
2448,"public struct BenchmarkIteration
{
private readonly BenchmarkIterator _iterator;
private readonly int _iterationNumber;
internal BenchmarkIteration(BenchmarkIterator iterator, int iterationNumber)
{
_iterator = iterator;
_iterationNumber = iterationNumber;
}
/// <summary>
/// Starts measuring performance metrics for this iteration.
/// </summary>
/// <returns></returns>
public BenchmarkIterationMeasurement StartMeasurement()
{
_iterator.StartMeasurement(_iterationNumber);
return new BenchmarkIterationMeasurement(this);
}
internal void StopMeasurement()
{
_iterator.StopMeasurement(_iterationNumber);
}
}",Represents a single iteration of a benchmark.,1
2449,"public struct BenchmarkIterationMeasurement : IDisposable
{
private readonly BenchmarkIteration _iteration;
internal BenchmarkIterationMeasurement(BenchmarkIteration iteration)
{
_iteration = iteration;
}
/// <summary>
/// Completes measurement of this iteration.
/// </summary>
public void Dispose()
{
_iteration.StopMeasurement();
}
}",Represents an ongoing measurement of a benchmark iteration.,1
2450,"public static IReadOnlyDictionary<string, ProfileSourceInfo> AvailablePreciseMachineCounters { get; }",Collection of available precise machine counters.,1
2451,"public interface IPerformanceMetricDiscoverer
{
/// <summary>
/// Gets the performance metrics from the metric attribute.
/// </summary>
/// <param name=""metricAttribute""></param>
/// <returns></returns>
IEnumerable<PerformanceMetricInfo> GetMetrics(IAttributeInfo metricAttribute);
}",Implemented by discoverers that provide metrics to performance tests.,1
2452,"public IDictionary<PerformanceMonitorCounter, long> PerformanceMonitorCounterData { get; set; }",TODO: Should PerformanceMonitorCounterData be exposed via a IReadOnlyDictionary?,1
2453,"public void WriteResults(ScenarioBenchmark scenario, string fileNameWithoutExtension)
{
WriteXmlResults(scenario, fileNameWithoutExtension);
WriteTableResults(new[] { scenario }, fileNameWithoutExtension, false);
}","This will save an XML, a Markdown, and a CSV file with the results.",1
2454,"public void Dispose()
{
Dispose(true);
GC.SuppressFinalize(this);
}","Performs tasks associated with freeing, releasing, or resetting unmanaged resources.",1
2455,"public App()
{
this.InitializeComponent();
this.Suspending += OnSuspending;
}","Initializes the singleton application object. This is the first line of authored code executed, and as such is the logical equivalent of main() or WinMain().",0
2456,"public App()
{
this.InitializeComponent();
this.Suspending += this.OnSuspending;
}","Initializes the singleton application object. This is the first line of authored code executed, and as such is the logical equivalent of main() or WinMain().",0
2457,"private void ProcessCommits()
{
// We are working only in a topological-reverse order (from parent commits to child)
var commitFilter = new CommitFilter()
{
FirstParentOnly = false,
SortBy = CommitSortStrategies.Topological | CommitSortStrategies.Reverse
};
// If a revision range is specified, try to use it
if (RevisionRange != null)
{
var revSpec = RevSpec.Parse(repo, RevisionRange);
if (revSpec.Type == RevSpecType.Single)
{
commitFilter.Since = revSpec.From.Id;
}
else if (revSpec.Type == RevSpecType.Range)
{
commitFilter.Range = RevisionRange;
}
}
// Gets all commits in topological reverse order
var commits = repo.Commits.QueryBy(commitFilter).ToList();
// Process commits
for (int i = 0; i < commits.Count; i++)
{
var commit = GetSimpleCommit(commits[i]);
OutputWriter.Write(""Rewrite {0} ({1}/{2}){3}"", commit.Id, i + 1, commits.Count, (i+1) == commits.Count ? string.Empty : ""\r"");
ProcessCommit(commit);
}
if (commits.Count == 0)
{
OutputWriter.WriteLine(""Nothing to rewrite."");
}
else
{
OutputWriter.WriteLine("" in {0:#.###}s"", clock.Elapsed.TotalSeconds);
}
}",Processes all commits.,1
2458,"private void WriteBranchRefs()
{
var originalRef = repo.Refs[branchRef];
if ((originalRef == null || BranchOverwrite) && lastCommit != null)
{
if (BranchOverwrite)
{
repo.Refs.Remove(branchRef);
}
repo.Refs.Add(branchRef, lastCommit.Id);
OutputWriter.WriteLine(""Ref '{0}' was {1}"", branchRef, originalRef != null && BranchOverwrite ? ""overwritten"" : ""created"");
}
}",Writes the final branch refs.,1
2459,"public void Run()
{
clock = Stopwatch.StartNew();
if (OutputWriter == null)
{
OutputWriter = Console.Out;
}
// Validate parameters
ValidateParameters();
// Prepare filtering
PrepareFiltering();
// Compile any scripts (from commit or tree filtering)
CompileScripts();
// Process all commits
ProcessCommits();
// Output the branch refs
WriteBranchRefs();
}",Runs the filtering.,1
2460,"public void Reset()
{
AuthorName = commit.Author.Name;
AuthorEmail = commit.Author.Email;
AuthorDate = commit.Author.When;
CommitterName = commit.Committer.Name;
CommitterEmail = commit.Committer.Email;
CommitterDate = commit.Committer.When;
Message = commit.Message;
Tree = commit.Tree;
}",Resets this values to the original commit.,1
2461,"public struct SimpleEntry
{
private readonly Repository repo;
private readonly TreeEntry entry;
private readonly GitObject target;
private readonly GitLink link;
private readonly Blob blob;
internal EntryValue NewEntryValue;
/// <summary>
/// Initializes a new instance of the <see cref=""SimpleEntry"" /> struct.
/// </summary>
/// <param name=""repo"">The repo.</param>
/// <param name=""entry"">The tree entry.</param>
/// <exception cref=""System.ArgumentNullException"">
/// repo
/// or
/// entry
/// </exception>
internal SimpleEntry(Repository repo, TreeEntry entry)
: this()
{
if (repo == null) throw new ArgumentNullException(""repo"");
if (entry == null) throw new ArgumentNullException(""entry"");
this.repo = repo;
this.entry = entry;
target = entry.Target;
this.blob = entry.Target as Blob;
this.link = entry.Target as GitLink;
}
/// <summary>
/// Gets the identifier object the blob or link object.
/// </summary>
/// <value>The identifier.</value>
public ObjectId Id
{
get { return target.Id; }
}
/// <summary>
/// Gets the text representation of <see cref=""Id""/>.
/// </summary>
/// <value>The sha.</value>
public string Sha
{
get { return target.Sha; }
}
/// <summary>
/// Gets the name of this entry.
/// </summary>
/// <value>The name.</value>
public string Name
{
get { return entry.Name; }
}
/// <summary>
/// Gets the path of this entry.
/// </summary>
/// <value>The path.</value>
public string Path
{
get { return entry.Path; }
}
/// <summary>
/// Gets a value indicating whether this instance is a blob.
/// </summary>
/// <value><c>true</c> if this instance is a blob; otherwise, <c>false</c>.</value>
public bool IsBlob
{
get { return blob != null; }
}
/// <summary>
/// Gets a value indicating whether this instance is binary blob.
/// </summary>
/// <value><c>true</c> if this instance is binary blob; otherwise, <c>false</c>.</value>
public bool IsBinary
{
get { return blob != null && blob.IsBinary; }
}
/// <summary>
/// Gets a value indicating whether this instance is a git link.
/// </summary>
/// <value><c>true</c> if this instance is a git link; otherwise, <c>false</c>.</value>
public bool IsLink
{
get { return link != null; }
}
/// <summary>
/// Gets the attributes of this entry.
/// </summary>
/// <value>The attributes.</value>
public Mode Attributes
{
get { return entry.Mode; }
}
/// <summary>
/// Gets the size of the blob or 0 if it is not a blob.
/// </summary>
/// <value>The size.</value>
public long Size
{
get { return blob != null ? blob.Size : 0; }
}
/// <summary>
/// Gets or sets a value indicating whether this <see cref=""SimpleEntry""/> should be discarded. Default is <c>false</c>.
/// </summary>
/// <value><c>true</c> if this commit should be discarded; otherwise, <c>false</c>.</value>
public bool Discard { get; set; }
/// <summary>
/// Gets or sets a tag object.
/// </summary>
/// <value>A tag object.</value>
public object Tag { get; set; }
/// <summary>
/// Gets the content of the blob as a byte array.
/// </summary>
/// <returns>The content of the blob as a byte array or null if no blob.</returns>
public byte[] GetBlobAsBytes()
{
if (blob == null)
{
return null;
}
var stream = blob.GetContentStream();
var memoryStream = new MemoryStream();
stream.CopyTo(memoryStream);
memoryStream.Position = 0;
return memoryStream.ToArray();
}
/// <summary>
/// Gets the content of the blob as a stream.
/// </summary>
/// <returns>The content of the blob as a stream or null if no blob.</returns>
public Stream GetBlobAsStream()
{
if (blob != null)
{
return blob.GetContentStream();
}
return null;
}
/// <summary>
/// Gets the content of the blob as a text.
/// </summary>
/// <returns>The content of the blob as a text or null if no blob.</returns>
public string GetBlobAsText()
{
if (blob != null)
{
return blob.GetContentText();
}
return null;
}
/// <summary>
/// Replace the content of this entry by a stream.
/// </summary>
/// <param name=""content"">The content stream.</param>
/// <param name=""mode"">The mode.</param>
/// <exception cref=""System.ArgumentNullException"">content</exception>
public void SetBlob(Stream content, Mode mode = Mode.NonExecutableFile)
{
if (content == null) throw new ArgumentNullException(""content"");
var newBlob = repo.ObjectDatabase.CreateBlob(content);
SetBlob(newBlob, mode);
}
/// <summary>
/// Replace the content of this entry by a byte array.
/// </summary>
/// <param name=""content"">The content byte array.</param>
/// <param name=""mode"">The mode.</param>
/// <exception cref=""System.ArgumentNullException"">content</exception>
public void SetBlob(byte[] content, Mode mode = Mode.NonExecutableFile)
{
if (content == null) throw new ArgumentNullException(""content"");
var newBlob = repo.ObjectDatabase.CreateBlob(new MemoryStream(content));
SetBlob(newBlob, mode);
}
/// <summary>
/// Replace the content of this entry by a string.
/// </summary>
/// <param name=""content"">The content string.</param>
/// <param name=""mode"">The mode.</param>
/// <exception cref=""System.ArgumentNullException"">content</exception>
public void SetBlob(string content, Mode mode = Mode.NonExecutableFile)
{
SetBlob(content, Encoding.UTF8, mode);
}
/// <summary>
/// Replace the content of this entry by a string with a particular encoding.
/// </summary>
/// <param name=""content"">The content string.</param>
/// <param name=""encoding"">The encoding mode for the string.</param>
/// <param name=""mode"">The mode.</param>
/// <exception cref=""System.ArgumentNullException"">content</exception>
public void SetBlob(string content, Encoding encoding, Mode mode = Mode.NonExecutableFile)
{
if (content == null) throw new ArgumentNullException(""content"");
var newBlob = repo.ObjectDatabase.CreateBlob(new MemoryStream(encoding.GetBytes(content)));
SetBlob(newBlob, mode);
}
/// <summary>
/// Replace the content of this entry by a blob.
/// </summary>
/// <param name=""newBlob"">The content blob.</param>
/// <param name=""mode"">The mode.</param>
/// <exception cref=""System.ArgumentNullException"">content</exception>
public void SetBlob(Blob newBlob, Mode mode = Mode.NonExecutableFile)
{
if (newBlob == null) throw new ArgumentNullException(""newBlob"");
NewEntryValue = new EntryValue(newBlob, mode);
}
/// <summary>
/// Performs an implicit conversion from <see cref=""SimpleEntry""/> to <see cref=""TreeEntry""/>.
/// </summary>
/// <param name=""entry"">The entry.</param>
/// <returns>The result of the conversion.</returns>
public static implicit operator TreeEntry(SimpleEntry entry)
{
return entry.entry;
}
public override string ToString()
{
return string.Format(""Entry: {0} => {1}"", Path, Id);
}
internal struct EntryValue
{
public EntryValue(Blob blob, Mode mode)
{
Blob = blob;
Mode = mode;
}
public readonly Blob Blob;
public readonly Mode Mode;
}
}",Represents a git blob or link in a tree.,1
2462,"public void ModifyCommitMessageAll()
{
var test = InitializeTest();
// Test directly the main program as we want to test also command line parameters
Assert.Equal(0, Program.Main(""--commit-filter"",
@""commit.Message += """"This is a test"""";"",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD""));
var repo = test.Repo;
var headNewMaster = AssertBranchRef(repo);
var originalCommits = GetCommits(repo);
var newCommits = GetCommits(repo, headNewMaster);
// Make sure that we have the same number of commits
Assert.Equal(originalCommits.Count, newCommits.Count);
for (int i = 0; i < newCommits.Count; i++)
{
var originalCommit = originalCommits[i];
var commit = newCommits[i];
// All commits should have same tree id
Assert.Equal(originalCommit.Tree.Id, commit.Tree.Id);
// Check the new message
Assert.EndsWith(""This is a test"", commit.Message);
Assert.StartsWith(originalCommit.Message, commit.Message);
}
// Cleanup the test only if we succeed
test.Dispose();
}","Appends the message ""This is a test"" to all commits.",1
2463,"public void ModifyCommitMessageLast4()
{
var test = InitializeTest();
// Test directly the main program as we want to test also command line parameters
Assert.Equal(0, Program.Main(""--commit-filter"",
@""commit.Message += """"This is a test"""";"",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD~4..HEAD""));
var repo = test.Repo;
var headNewMaster = AssertBranchRef(repo);
var originalCommits = GetCommits(repo);
var originalCommitsRange = GetCommitsFromRange(repo, @""HEAD~4..HEAD"").Select(commit => commit.Id).ToList();
var newCommits = GetCommits(repo, headNewMaster);
// Make sure that we have the same number of commits
Assert.Equal(originalCommits.Count, newCommits.Count);
for (int i = 0; i < newCommits.Count; i++)
{
var originalCommit = originalCommits[i];
var commit = newCommits[i];
if (originalCommitsRange.Contains(originalCommit.Id))
{
// All commits should have same tree id
Assert.Equal(originalCommit.Tree.Id, commit.Tree.Id);
// Check the new message
Assert.EndsWith(""This is a test"", commit.Message);
Assert.StartsWith(originalCommit.Message, commit.Message);
}
else
{
// All commits should have same tree id
Assert.Equal(originalCommit.Id, commit.Id);
}
}
// Cleanup the test only if we succeed
test.Dispose();
}","Appends the message ""This is a test"" to the previous 4 commits.",1
2464,"public void ModifyCommitMessageLast2WithDetach()
{
var test = InitializeTest();
// Test directly the main program as we want to test also command line parameters
Assert.Equal(0, Program.Main(""--commit-filter"",
@""commit.Message += """"This is a test"""";"",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
""--detach"",
@""HEAD~2..HEAD""));
var repo = test.Repo;
var headNewMaster = AssertBranchRef(repo);
var originalCommits = GetCommitsFromRange(repo, @""HEAD~2..HEAD"");
var newCommits = GetCommits(repo, headNewMaster);
// Make sure that we have the same number of commits
Assert.Equal(originalCommits.Count, newCommits.Count);
for (int i = 0; i < newCommits.Count; i++)
{
var originalCommit = originalCommits[i];
var commit = newCommits[i];
// All commits should have same tree id
Assert.Equal(originalCommit.Tree.Id, commit.Tree.Id);
// Check the new message
Assert.EndsWith(""This is a test"", commit.Message);
Assert.StartsWith(originalCommit.Message, commit.Message);
// The second commit is detached
if (i == 1)
{
Assert.Equal(0, commit.Parents.Count());
}
}
// Cleanup the test only if we succeed
test.Dispose();
}","Appends the message ""This is a test"" to the previous commit and detach it from its parent.",1
2465,"public void DiscardAllCommitMessageExceptOne()
{
var test = InitializeTest();
// Test directly the main program as we want to test also command line parameters
Assert.Equal(0, Program.Main(""--commit-filter"",
@""commit.Discard = !commit.Message.Contains(""""test.bin""""); if (!commit.Discard) { commit.AuthorName=""""NewAuthor""""; commit.AuthorEmail = """"test@gmail.com""""; commit.CommitterName =""""NewCommitter""""; commit.CommitterEmail = """"test2@gmail.com""""; }"",
""--repo-dir"", test.Path,
""--branch"", NewBranch
));
var repo = test.Repo;
var headNewMaster = AssertBranchRef(repo);
var newCommits = GetCommits(repo, headNewMaster);
// We should have only 1 commit
Assert.Equal(1, newCommits.Count);
var commitLeft = newCommits[0];
Assert.Contains(""test.bin"", commitLeft.Message);
// Check new field
Assert.Equal(""NewAuthor"", commitLeft.Author.Name);
Assert.Equal(""test@gmail.com"", commitLeft.Author.Email);
Assert.Equal(""NewCommitter"", commitLeft.Committer.Name);
Assert.Equal(""test2@gmail.com"", commitLeft.Committer.Email);
// Cleanup the test only if we succeed
test.Dispose();
}",Discard all commits that don't contain the 'test.bin' text in their message. Rewrite author and committer of the commit left.,1
2466,"public void KeepOnlyOneDirectory()
{
var test = InitializeTest();
Program.Main(""--keep"",
@""/Test1"",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD"");
var repo = test.Repo;
var headNewMaster = AssertBranchRef(repo);
var newCommits = GetCommits(repo, headNewMaster);
Assert.True(newCommits.Count > 0);
for (int i = 0; i < newCommits.Count; i++)
{
var commit = newCommits[i];
Assert.Equal(1, commit.Tree.Count);
var entry = commit.Tree[""Test1""];
Assert.NotNull(entry);
Assert.Equal(TreeEntryTargetType.Tree, entry.TargetType);
var tree = (Tree) entry.Target;
Assert.Equal(3, tree.Count);
}
// Cleanup the test only if we succeed
test.Dispose();
}",Keeps only /Test1 directory,1
2467,"public void KeepOnlyOneDirectoryAndFile()
{
var test = InitializeTest();
Program.Main(""--keep"", ""/Test1"",
""--keep"", ""a.txt"",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD"");
CheckKeepOnlyOneDirectoryAndFile(test);
// Cleanup the test only if we succeed
test.Dispose();
}",Keeps /Test1 directory and a.txt file,1
2468,"public void RemoveFilesWithTxtExtension()
{
var test = InitializeTest();
Program.Main(""--remove"", ""*.txt"",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD"");
var repo = test.Repo;
var headNewMaster = AssertBranchRef(repo);
var newCommits = GetCommits(repo, headNewMaster);
Assert.Equal(1, newCommits.Count);
Assert.Equal(1, newCommits[0].Tree.Count);
Assert.NotNull(newCommits[0].Tree[""Binary/test.bin""]);
// Cleanup the test only if we succeed
test.Dispose();
}",Removes all *.txt files,1
2469,"public void KeepTwoDirectoriesAndRemoveExcept()
{
var test = InitializeTest();
Program.Main(""--keep"", ""/Test[12]"",
""--remove"", ""*"", // removes all files
""--remove"", ""!a[12].txt"", // except a[12].txt
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD"");
CheckKeepTwoDirectoriesAndRemoveExcept(test);
// Cleanup the test only if we succeed
test.Dispose();
}","Keeps directory /Test[12], remove all files except a[12].txt",1
2470,"public void KeepOnlyNonBinaryFilesLessThan10Bytes()
{
var test = InitializeTest();
Assert.Equal(0, Program.Main(""--keep"", ""* => entry.Discard = entry.IsBinary || entry.Size > 10; "",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD""));
CheckKeepOnlyNonBinaryFilesLessThan10Bytes(test);
// Cleanup the test only if we succeed
test.Dispose();
}",Keeps only non binary files less than 10 bytes,1
2471,"public void KeepOnlyNonBinaryFilesLessThan10BytesWithMultiLine()
{
var test = InitializeTest();
Assert.Equal(0, Program.Main(""--keep"", @""* {% entry.Discard = entry.IsBinary || entry.Size > 10; %}"",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD""));
CheckKeepOnlyNonBinaryFilesLessThan10Bytes(test);
// Cleanup the test only if we succeed
test.Dispose();
}",Keeps only non binary files less than 10 bytes (using multiline script,1
2472,"public void PatternsScriptsOrder()
{
var test = InitializeTest();
Assert.Equal(0, Program.Main(""--keep"", ""a.txt => entry.Discard = false;"",
""--keep"", ""* => entry.Discard = true;"",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD""));
var repo = test.Repo;
var headNewMaster = AssertBranchRef(repo);
var newCommits = GetCommits(repo, headNewMaster);
Assert.Equal(1, newCommits.Count);
var commit = newCommits[0];
{
Assert.Equal(1, commit.Tree.Count);
Assert.NotNull(commit.Tree[""a.txt""]);
}
// Cleanup the test only if we succeed
test.Dispose();
}",Make sure that order is satisfied when using scripts (so first pattern is matched and stops).,1
2473,"public void InvalidMultiLineScript()
{
var test = InitializeTest();
var result = Program.Main(""--keep"", @""* {% entry.Discard = entry.IsBinary || entry.Size > 10; "",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD"");
Assert.NotEqual(0, result);
Assert.Contains(""Expecting the end %} of multiline script"", test.Output);
// Cleanup the test only if we succeed
test.Dispose();
}",Forget the closing multiline script %},1
2474,"public void RemoveBinaryFilesBiggerThan10Bytes()
{
var test = InitializeTest();
Assert.Equal(0, Program.Main(""--remove"", ""* => entry.Discard = entry.IsBinary && entry.Size > 10; "",
""--repo-dir"", test.Path,
""--branch"", NewBranch,
@""HEAD""));
var repo = test.Repo;
var headNewMaster = AssertBranchRef(repo);
var originalCommits = GetCommits(repo);
var newCommits = GetCommits(repo, headNewMaster);
// We have only a binary file in one commit, so we should have one commit less
Assert.Equal(originalCommits.Count -1, newCommits.Count);
foreach (var commit in newCommits)
{
var entries = GetEntries(commit.Tree).ToList();
foreach (var entry in entries)
{
var blob = (Blob)entry.Target;
Assert.False(blob.IsBinary);
}
}
// Cleanup the test only if we succeed
test.Dispose();
}",Deletes all binary files bigger than 10 bytes,1
2475,"public void RestartScene() {
Application.LoadLevel( 0 );
}",Simple restart method triggered by UI.Button.,1
2476,"public static SpriteCutterOutput Cut( SpriteCutterInput input ) {
if ( input.gameObject == null ) {
Debug.LogWarning( ""SpriteCutter.Cut exceuted with null gameObject!"" );
return null;
}
/* Cutting mesh and collider */
Vector3 localLineStart = input.gameObject.transform.InverseTransformPoint( input.lineStart );
Vector3 localLineEnd = input.gameObject.transform.InverseTransformPoint( input.lineEnd );
SpriteRenderer spriteRenderer = input.gameObject.GetComponent<SpriteRenderer>();
MeshRenderer meshRenderer = input.gameObject.GetComponent<MeshRenderer>();
FlatConvexPolygonMeshCutter.CutResult meshCutResult =
CutSpriteOrMeshRenderer( localLineStart, localLineEnd, spriteRenderer, meshRenderer );
if ( meshCutResult.DidNotCut() ) {
return null;
}
FlatConvexCollidersCutter.CutResult collidersCutResults;
if ( input.dontCutColliders ) {
collidersCutResults = new FlatConvexCollidersCutter.CutResult();
} else {
collidersCutResults =
CutColliders( localLineStart, localLineEnd, input.gameObject.GetComponents<Collider2D>() );
if ( collidersCutResults.DidNotCut() ) {
return null;
}
}
SideCutData firstCutData = new SideCutData() {
cuttedMesh = meshCutResult.firstSideMesh,
cuttedCollidersRepresentations = collidersCutResults.firstSideColliderRepresentations
};
SideCutData secondCutData = new SideCutData() {
cuttedMesh = meshCutResult.secondSideMesh,
cuttedCollidersRepresentations = collidersCutResults.secondSideColliderRepresentations
};
/* Second side result - created as new GameObject or instantiated copy of the original GameObject. */
SpriteCutterGameObject secondSideResult = null;
switch ( input.gameObjectCreationMode ) {
case GameObjectCreationMode.CUT_OFF_NEW:
case GameObjectCreationMode.CUT_INTO_TWO:
secondSideResult = SpriteCutterGameObject.CreateNew( input.gameObject, true );
PrepareResultGameObject( secondSideResult, spriteRenderer, meshRenderer, secondCutData );
break;
case GameObjectCreationMode.CUT_OFF_COPY:
secondSideResult = SpriteCutterGameObject.CreateAsInstantiatedCopyOf( input.gameObject, true );
SpriteRenderer copiedSpriteRenderer = secondSideResult.gameObject.GetComponent<SpriteRenderer>();
MeshRenderer copiedMeshRenderer = secondSideResult.gameObject.GetComponent<MeshRenderer>();
if ( copiedSpriteRenderer != null ) {
RendererParametersRepresentation tempParameters = new RendererParametersRepresentation();
tempParameters.CopyFrom( copiedSpriteRenderer );
SafeSpriteRendererRemoverBehaviour.get.RemoveAndWaitOneFrame( copiedSpriteRenderer, onFinish: () => {
PrepareResultGameObject( secondSideResult, tempParameters, secondCutData );
} );
} else {
PrepareResultGameObject( secondSideResult, copiedSpriteRenderer, copiedMeshRenderer, secondCutData );
}
break;
}
/* First side result */
SpriteCutterGameObject firstSideResult = null;
switch ( input.gameObjectCreationMode ) {
case GameObjectCreationMode.CUT_OFF_NEW:
case GameObjectCreationMode.CUT_OFF_COPY:
firstSideResult = SpriteCutterGameObject.CreateAs( input.gameObject );
if ( spriteRenderer != null ) {
RendererParametersRepresentation tempParameters = new RendererParametersRepresentation();
tempParameters.CopyFrom( spriteRenderer );
SafeSpriteRendererRemoverBehaviour.get.RemoveAndWaitOneFrame( spriteRenderer, onFinish: () => {
PrepareResultGameObject( firstSideResult, tempParameters, firstCutData );
} );
} else {
PrepareResultGameObject( firstSideResult, spriteRenderer, meshRenderer, firstCutData );
}
break;
case GameObjectCreationMode.CUT_INTO_TWO:
firstSideResult = SpriteCutterGameObject.CreateNew( input.gameObject, true );
PrepareResultGameObject( firstSideResult, spriteRenderer, meshRenderer, firstCutData );
break;
}
return new SpriteCutterOutput() {
firstSideGameObject = firstSideResult.gameObject,
secondSideGameObject = secondSideResult.gameObject,
};
}","Returns null, if cutting didn't took place.",1
2477,"public void TestTypeArray()
{
var arr = new Type[100];
for (var i = 0; i < arr.Length; i++)
{
arr[i] = typeof (int);
}
Test(arr);
}","fails big time, we are writing the entire qualified type name for each entry, fs pickler does not.",1
2478,"public enum AssertionConditionType
{
/// <summary>Marked parameter should be evaluated to true.</summary>
IS_TRUE = 0,
/// <summary>Marked parameter should be evaluated to false.</summary>
IS_FALSE = 1,
/// <summary>Marked parameter should be evaluated to null value.</summary>
IS_NULL = 2,
/// <summary>Marked parameter should be evaluated to not null value.</summary>
IS_NOT_NULL = 3
}","Specifies assertion type. If the assertion method argument satisfies the condition, then the execution continues. Otherwise, execution is assumed to be halted.",1
2479,"static void Main()
{
if (!System.Diagnostics.Debugger.IsAttached)
{
ServiceBase[] ServicesToRun;
ServicesToRun = new ServiceBase[] { new Service1() };
ServiceBase.Run(ServicesToRun);
}
else
{
Service1.StartThread();
}
}",The main entry point for the application.,1
2480,"private void InitializeComponent()
{
this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
this.serviceInstaller1 = new System.ServiceProcess.ServiceInstaller();
// // serviceProcessInstaller1
// this.serviceProcessInstaller1.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
this.serviceProcessInstaller1.Password = null;
this.serviceProcessInstaller1.Username = null;
// // serviceInstaller1
// this.serviceInstaller1.Description = ""Creates a temporary overlay of a folder for each user. Folders are configured in "" +
""settings.xml in the program directory."";
this.serviceInstaller1.DisplayName = ""OverlayFS"";
this.serviceInstaller1.ServiceName = ""OverlayFS"";
this.serviceInstaller1.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
// // ProjectInstaller
// this.Installers.AddRange(new System.Configuration.Install.Installer[] {
this.serviceProcessInstaller1,
this.serviceInstaller1});
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2481,"private void InitializeComponent()
{
// // Service1
// this.ServiceName = ""OverlayFS"";
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2482,"private void InitializeComponent()
{
this.sourceTextBox = new System.Windows.Forms.RichTextBox();
this.splitContainer1 = new System.Windows.Forms.SplitContainer();
this.splitContainer2 = new System.Windows.Forms.SplitContainer();
this.listView1 = new System.Windows.Forms.ListView();
this.columnHeader1 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeader2 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeader3 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.tabControl1 = new System.Windows.Forms.TabControl();
this.tabPage1 = new System.Windows.Forms.TabPage();
this.astTreeView = new System.Windows.Forms.TreeView();
this.tabPage2 = new System.Windows.Forms.TabPage();
this.rawParserTreeView = new System.Windows.Forms.TreeView();
this.parseButton = new System.Windows.Forms.Button();
this.label1 = new System.Windows.Forms.Label();
this.checkBox1 = new System.Windows.Forms.CheckBox();
this.generateSourceButton = new System.Windows.Forms.Button();
this.button2 = new System.Windows.Forms.Button();
this.button3 = new System.Windows.Forms.Button();
this.findInTreeButton = new System.Windows.Forms.Button();
this.label2 = new System.Windows.Forms.Label();
this.checkBox2 = new System.Windows.Forms.CheckBox();
this.comboBox1 = new System.Windows.Forms.ComboBox();
this.label3 = new System.Windows.Forms.Label();
this.resolveButton = new System.Windows.Forms.Button();
((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();
this.splitContainer1.Panel1.SuspendLayout();
this.splitContainer1.Panel2.SuspendLayout();
this.splitContainer1.SuspendLayout();
((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();
this.splitContainer2.Panel1.SuspendLayout();
this.splitContainer2.Panel2.SuspendLayout();
this.splitContainer2.SuspendLayout();
this.tabControl1.SuspendLayout();
this.tabPage1.SuspendLayout();
this.tabPage2.SuspendLayout();
this.SuspendLayout();
// // sourceTextBox
// this.sourceTextBox.Cursor = System.Windows.Forms.Cursors.IBeam;
this.sourceTextBox.Dock = System.Windows.Forms.DockStyle.Fill;
this.sourceTextBox.Font = new System.Drawing.Font(""Consolas"", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
this.sourceTextBox.HideSelection = false;
this.sourceTextBox.Location = new System.Drawing.Point(0, 0);
this.sourceTextBox.Name = ""sourceTextBox"";
this.sourceTextBox.Size = new System.Drawing.Size(411, 502);
this.sourceTextBox.TabIndex = 0;
this.sourceTextBox.TabStop = false;
this.sourceTextBox.Text = """";
this.sourceTextBox.WordWrap = false;
this.sourceTextBox.SelectionChanged += new System.EventHandler(this.SourceTextBoxOnSelectionChanged);
this.sourceTextBox.TextChanged += new System.EventHandler(this.SourceTextBoxOnTextChanged);
// // splitContainer1
// this.splitContainer1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.splitContainer1.Location = new System.Drawing.Point(12, 12);
this.splitContainer1.Name = ""splitContainer1"";
// // splitContainer1.Panel1
// this.splitContainer1.Panel1.Controls.Add(this.splitContainer2);
// // splitContainer1.Panel2
// this.splitContainer1.Panel2.Controls.Add(this.tabControl1);
this.splitContainer1.Size = new System.Drawing.Size(860, 595);
this.splitContainer1.SplitterDistance = 411;
this.splitContainer1.TabIndex = 1;
// // splitContainer2
// this.splitContainer2.Dock = System.Windows.Forms.DockStyle.Fill;
this.splitContainer2.FixedPanel = System.Windows.Forms.FixedPanel.Panel2;
this.splitContainer2.Location = new System.Drawing.Point(0, 0);
this.splitContainer2.Name = ""splitContainer2"";
this.splitContainer2.Orientation = System.Windows.Forms.Orientation.Horizontal;
// // splitContainer2.Panel1
// this.splitContainer2.Panel1.Controls.Add(this.sourceTextBox);
// // splitContainer2.Panel2
// this.splitContainer2.Panel2.Controls.Add(this.listView1);
this.splitContainer2.Size = new System.Drawing.Size(411, 595);
this.splitContainer2.SplitterDistance = 502;
this.splitContainer2.TabIndex = 0;
// // listView1
// this.listView1.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
this.columnHeader1,
this.columnHeader2,
this.columnHeader3});
this.listView1.Dock = System.Windows.Forms.DockStyle.Fill;
this.listView1.Location = new System.Drawing.Point(0, 0);
this.listView1.Name = ""listView1"";
this.listView1.Size = new System.Drawing.Size(411, 89);
this.listView1.TabIndex = 10;
this.listView1.UseCompatibleStateImageBehavior = false;
this.listView1.View = System.Windows.Forms.View.Details;
// // columnHeader1
// this.columnHeader1.Text = ""Severity"";
// // columnHeader2
// this.columnHeader2.Text = ""Message"";
this.columnHeader2.Width = 156;
// // columnHeader3
// this.columnHeader3.Text = ""Location"";
this.columnHeader3.Width = 84;
// // tabControl1
// this.tabControl1.Controls.Add(this.tabPage1);
this.tabControl1.Controls.Add(this.tabPage2);
this.tabControl1.Dock = System.Windows.Forms.DockStyle.Fill;
this.tabControl1.Location = new System.Drawing.Point(0, 0);
this.tabControl1.Name = ""tabControl1"";
this.tabControl1.SelectedIndex = 0;
this.tabControl1.Size = new System.Drawing.Size(445, 595);
this.tabControl1.TabIndex = 2;
// // tabPage1
// this.tabPage1.Controls.Add(this.astTreeView);
this.tabPage1.Location = new System.Drawing.Point(4, 22);
this.tabPage1.Name = ""tabPage1"";
this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
this.tabPage1.Size = new System.Drawing.Size(437, 569);
this.tabPage1.TabIndex = 0;
this.tabPage1.Text = ""AST"";
this.tabPage1.UseVisualStyleBackColor = true;
// // astTreeView
// this.astTreeView.Dock = System.Windows.Forms.DockStyle.Fill;
this.astTreeView.HideSelection = false;
this.astTreeView.Location = new System.Drawing.Point(3, 3);
this.astTreeView.Name = ""astTreeView"";
this.astTreeView.Size = new System.Drawing.Size(431, 563);
this.astTreeView.TabIndex = 0;
this.astTreeView.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.AstTreeViewOnAfterSelect);
// // tabPage2
// this.tabPage2.Controls.Add(this.rawParserTreeView);
this.tabPage2.Location = new System.Drawing.Point(4, 22);
this.tabPage2.Name = ""tabPage2"";
this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
this.tabPage2.Size = new System.Drawing.Size(437, 569);
this.tabPage2.TabIndex = 1;
this.tabPage2.Text = ""Parser tree"";
this.tabPage2.UseVisualStyleBackColor = true;
// // rawParserTreeView
// this.rawParserTreeView.Dock = System.Windows.Forms.DockStyle.Fill;
this.rawParserTreeView.HideSelection = false;
this.rawParserTreeView.Location = new System.Drawing.Point(3, 3);
this.rawParserTreeView.Name = ""rawParserTreeView"";
this.rawParserTreeView.Size = new System.Drawing.Size(431, 563);
this.rawParserTreeView.TabIndex = 1;
// // parseButton
// this.parseButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this.parseButton.Location = new System.Drawing.Point(12, 626);
this.parseButton.Name = ""parseButton"";
this.parseButton.Size = new System.Drawing.Size(105, 23);
this.parseButton.TabIndex = 2;
this.parseButton.Text = ""Parse source"";
this.parseButton.UseVisualStyleBackColor = true;
this.parseButton.Click += new System.EventHandler(this.ParseButtonOnClick);
// // label1
// this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.label1.Location = new System.Drawing.Point(451, 626);
this.label1.Name = ""label1"";
this.label1.Size = new System.Drawing.Size(258, 23);
this.label1.TabIndex = 3;
this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
// // checkBox1
// this.checkBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this.checkBox1.AutoSize = true;
this.checkBox1.Location = new System.Drawing.Point(123, 659);
this.checkBox1.Name = ""checkBox1"";
this.checkBox1.Size = new System.Drawing.Size(78, 17);
this.checkBox1.TabIndex = 4;
this.checkBox1.Text = ""Word wrap"";
this.checkBox1.UseVisualStyleBackColor = true;
this.checkBox1.CheckedChanged += new System.EventHandler(this.CheckBoxOnCheckedChanged);
// // generateSourceButton
// this.generateSourceButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.generateSourceButton.Location = new System.Drawing.Point(716, 626);
this.generateSourceButton.Name = ""generateSourceButton"";
this.generateSourceButton.Size = new System.Drawing.Size(156, 23);
this.generateSourceButton.TabIndex = 5;
this.generateSourceButton.Text = ""Generate source"";
this.generateSourceButton.UseVisualStyleBackColor = true;
this.generateSourceButton.Click += new System.EventHandler(this.GenerateSourceButtonOnClick);
// // button2
// this.button2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.button2.Location = new System.Drawing.Point(797, 655);
this.button2.Name = ""button2"";
this.button2.Size = new System.Drawing.Size(75, 23);
this.button2.TabIndex = 6;
this.button2.Text = ""Add type"";
this.button2.UseVisualStyleBackColor = true;
this.button2.Click += new System.EventHandler(this.AddTypeButtonOnClick);
// // button3
// this.button3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.button3.Location = new System.Drawing.Point(716, 655);
this.button3.Name = ""button3"";
this.button3.Size = new System.Drawing.Size(75, 23);
this.button3.TabIndex = 7;
this.button3.Text = ""Add field"";
this.button3.UseVisualStyleBackColor = true;
this.button3.Click += new System.EventHandler(this.AddFieldButtonOnClick);
// // findInTreeButton
// this.findInTreeButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this.findInTreeButton.Location = new System.Drawing.Point(12, 655);
this.findInTreeButton.Name = ""findInTreeButton"";
this.findInTreeButton.Size = new System.Drawing.Size(105, 23);
this.findInTreeButton.TabIndex = 8;
this.findInTreeButton.Text = ""Find in tree"";
this.findInTreeButton.UseVisualStyleBackColor = true;
this.findInTreeButton.Click += new System.EventHandler(this.FindInTreeButtonOnClick);
// // label2
// this.label2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this.label2.AutoSize = true;
this.label2.Location = new System.Drawing.Point(123, 631);
this.label2.Name = ""label2"";
this.label2.Size = new System.Drawing.Size(0, 13);
this.label2.TabIndex = 9;
this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
// // checkBox2
// this.checkBox2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this.checkBox2.AutoSize = true;
this.checkBox2.Location = new System.Drawing.Point(207, 659);
this.checkBox2.Name = ""checkBox2"";
this.checkBox2.Size = new System.Drawing.Size(105, 17);
this.checkBox2.TabIndex = 10;
this.checkBox2.Text = ""Auto update tree"";
this.checkBox2.UseVisualStyleBackColor = true;
// // comboBox1
// this.comboBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this.comboBox1.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this.comboBox1.FormattingEnabled = true;
this.comboBox1.Location = new System.Drawing.Point(318, 657);
this.comboBox1.Name = ""comboBox1"";
this.comboBox1.Size = new System.Drawing.Size(121, 21);
this.comboBox1.TabIndex = 11;
// // label3
// this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this.label3.AutoSize = true;
this.label3.Location = new System.Drawing.Point(12, 610);
this.label3.Name = ""label3"";
this.label3.Size = new System.Drawing.Size(35, 13);
this.label3.TabIndex = 12;
this.label3.Text = ""label3"";
// // resolveButton
// this.resolveButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.resolveButton.Location = new System.Drawing.Point(635, 655);
this.resolveButton.Name = ""resolveButton"";
this.resolveButton.Size = new System.Drawing.Size(75, 23);
this.resolveButton.TabIndex = 13;
this.resolveButton.Text = ""Resolve"";
this.resolveButton.UseVisualStyleBackColor = true;
this.resolveButton.Click += new System.EventHandler(this.ResolveButtonOnClick);
// // Form1
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(884, 686);
this.Controls.Add(this.resolveButton);
this.Controls.Add(this.label3);
this.Controls.Add(this.comboBox1);
this.Controls.Add(this.checkBox2);
this.Controls.Add(this.label2);
this.Controls.Add(this.findInTreeButton);
this.Controls.Add(this.button3);
this.Controls.Add(this.button2);
this.Controls.Add(this.generateSourceButton);
this.Controls.Add(this.checkBox1);
this.Controls.Add(this.label1);
this.Controls.Add(this.parseButton);
this.Controls.Add(this.splitContainer1);
this.Name = ""Form1"";
this.Text = ""Form1"";
this.splitContainer1.Panel1.ResumeLayout(false);
this.splitContainer1.Panel2.ResumeLayout(false);
((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();
this.splitContainer1.ResumeLayout(false);
this.splitContainer2.Panel1.ResumeLayout(false);
this.splitContainer2.Panel2.ResumeLayout(false);
((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).EndInit();
this.splitContainer2.ResumeLayout(false);
this.tabControl1.ResumeLayout(false);
this.tabPage1.ResumeLayout(false);
this.tabPage2.ResumeLayout(false);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2483,"public interface IDocument : ITextSource
{
/// <summary>
/// Occurs when (a part of) the text of the document is about to change.
/// </summary>
event TextChangeEventHandler TextChanging;
/// <summary>
/// Occurs when (a part of) the text of the document has changed.
/// </summary>
event TextChangeEventHandler TextChanged;
/// <summary>
/// Creates a read-only snapshot of the text document.
/// </summary>
/// <returns>A read-only document representing the snapshot.</returns>
IDocument CreateDocumentSnapshot();
/// <summary>
/// Converts the specified text location's line and column number in the document to a character offset of the total document string.
/// </summary>
/// <param name=""location"">The text location to convert.</param>
/// <returns>The character offset of the text location.</returns>
int LocationToOffset(TextLocation location);
/// <summary>
/// Converts the specified character offset to the corresponding text location in the text document.
/// </summary>
/// <param name=""offset"">The character offset to convert.</param>
/// <returns>The text location of the character offset.</returns>
TextLocation OffsetToLocation(int offset);
/// <summary>
/// Converts the specified line number to a character offset of the total document string.
/// </summary>
/// <param name=""line"">The line number to convert.</param>
/// <returns>The character offset of the line number.</returns>
int LineToOffset(int line);
/// <summary>
/// Converts the specified character offset to the line number of the text document.
/// </summary>
/// <param name=""offset"">The offset to convert.</param>
/// <returns>The line number.</returns>
int OffsetToLine(int offset);
/// <summary>
/// Gets the text located at the specified range in the text document.
/// </summary>
/// <param name=""range"">The range of the text to get.</param>
/// <returns>The text at the given range.</returns>
string GetRangeText(TextRange range);
/// <summary>
/// Gets the length of the text located at the specified range in the text document.
/// </summary>
/// <param name=""range"">The range of the text to get.</param>
/// <returns>The length of the text at the given range.</returns>
int GetRangeTextLength(TextRange range);
/// <summary>
/// Prepares the document for editing.
/// </summary>
void BeginUpdate();
/// <summary>
/// Finalises the editing process.
/// </summary>
void EndUpdate();
/// <summary>
/// Removes a given amount of characters from the document at the given offset.
/// </summary>
/// <param name=""offset"">The offset of the text to remove.</param>
/// <param name=""length"">The length of the text to remove.</param>
void Remove(int offset, int length);
/// <summary>
/// Inserts a string into the document at the given offset.
/// </summary>
/// <param name=""offset"">The offset of the string to insert.</param>
/// <param name=""text"">The string to insert.</param>
void Insert(int offset, string text);
/// <summary>
/// Replaces a given amount of characters from the document at the given offset with a new string.
/// </summary>
/// <param name=""offset"">The offset of the text to replace.</param>
/// <param name=""length"">The length of the text to replace.</param>
/// <param name=""text"">The text to use as a replacement.</param>
void Replace(int offset, int length, string text);
}",Provides methods for representing a text document.,1
2484,"public interface INamedDefinition : IScopeMember
{
/// <summary>
/// Gets the name of this member.
/// </summary>
string Name
{
get;
}
/// <summary>
/// Gets the full name of this member.
/// </summary>
string FullName
{
get;
}
}",Provides properties for giving a definition in the type system a name.,1
2485,"public interface INamespaceDefinitionProvider
{
/// <summary>
/// Yields a collection of namespaces that are defined by this object.
/// </summary>
/// <returns>A collection of namespaces.</returns>
IEnumerable<NamespaceDefinition> GetNamespaceDefinitions();
}",Provides methods for representing an object that holds namespace definitions.,1
2486,"public interface IScope
{
/// <summary>
/// Gets the resolution scope provider that declares this resolution scope.
/// </summary>
/// <returns>The declaring resolution scope provider.</returns>
IScopeProvider GetDeclaringProvider();
/// <summary>
/// Resolves an identifier to an actual definition.
/// </summary>
/// <param name=""identifier"">The identifier to resolve.</param>
/// <returns>The result of the resolution process.</returns>
ResolveResult ResolveIdentifier(string identifier);
/// <summary>
/// Gets a collection of named definitions defined in this scope. This does not include the names from the parent scope.
/// </summary>
/// <returns>A collection of named definitions.</returns>
IEnumerable<INamedDefinition> GetDefinitions();
}",Provides methods for defining a resolution scope.,1
2487,"public interface ITextOutput
{
/// <summary>
/// Gets the current location of the text output.
/// </summary>
TextLocation Location
{
get;
}
/// <summary>
/// Increments the current indentation length.
/// </summary>
void Indent();
/// <summary>
/// Decrements the current indentation length.
/// </summary>
void Unindent();
/// <summary>
/// Writes a character to the text output.
/// </summary>
/// <param name=""char"">The character to write.</param>
void Write(char @char);
/// <summary>
/// Writes a string to the text output.
/// </summary>
/// <param name=""text"">The string to write.</param>
void Write(string text);
/// <summary>
/// Terminates the current line of text and starts a new one.
/// </summary>
void WriteLine();
}",Provides methods for representing a text output.,1
2488,"public interface ITextSource
{
/// <summary>
/// Gets the length of the text in the text source.
/// </summary>
int TextLength
{
get;
}
/// <summary>
/// Gets the text of the text source.
/// </summary>
string Text
{
get;
}
/// <summary>
/// Creates a snapshot of the text source.
/// </summary>
/// <returns>The snapshot of the text source.</returns>
ITextSource CreateSnapshot();
/// <summary>
/// Creates a trimmed snapshot of the text source.
/// </summary>
/// <param name=""offset"">The starting offset of the text to create a snapshot from.</param>
/// <param name=""length"">The length of the text to create a snapshot from.</param>
/// <returns></returns>
ITextSource CreateSnapshot(int offset, int length);
/// <summary>
/// Gets the character at a given offset.
/// </summary>
/// <param name=""offset"">The offset of the character to get.</param>
/// <returns>The character at the given offset.</returns>
char GetChar(int offset);
/// <summary>
/// Gets the text at a given offset and length.
/// </summary>
/// <param name=""offset"">The offset of the text to get.</param>
/// <param name=""length"">The length of the text to get.</param>
/// <returns>The text at the given offset and length.</returns>
string GetText(int offset, int length);
/// <summary>
/// Gets the offset of a specific character.
/// </summary>
/// <param name=""character"">The character to search.</param>
/// <param name=""offset"">The starting offset of the text to search in.</param>
/// <param name=""length"">The length of the text to search in.</param>
/// <returns></returns>
int IndexOf(char character, int offset, int length);
/// <summary>
/// Gets the offset of the character that appears first in the text source.
/// </summary>
/// <param name=""characters"">The characters to search.</param>
/// <param name=""offset"">The starting offset of the text to search in.</param>
/// <param name=""length"">The length of the text to search in.</param>
/// <returns></returns>
int IndexOfAny(char[] characters, int offset, int length);
/// <summary>
/// Creates a text reader for this text source.
/// </summary>
/// <returns></returns>
TextReader CreateReader();
/// <summary>
/// Writes the text of this text source to the given text writer.
/// </summary>
/// <param name=""writer"">The text writer to write to.</param>
void WriteTo(TextWriter writer);
}",Provides methods for representing a text source.,1
2489,"public interface ITypeDefinitionProvider
{
/// <summary>
/// Yields a collection of types that are defined by this object.
/// </summary>
/// <returns>A collection of types.</returns>
IEnumerable<TypeDefinition> GetTypeDefinitions();
}",Provides methods for representing an object that holds type definitions.,1
2490,"static void Main()
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new Form1());
}",The main entry point for the application.,1
2491,"void IDocument.BeginUpdate()
{
}",Prepares the document for editing.,0
2492,"void IDocument.EndUpdate()
{
}",Finalises the editing process.,0
2493,"private void InitializeComponent()
{
this.treeView1 = new System.Windows.Forms.TreeView();
this.SuspendLayout();
// // treeView1
// this.treeView1.Dock = System.Windows.Forms.DockStyle.Fill;
this.treeView1.Location = new System.Drawing.Point(0, 0);
this.treeView1.Name = ""treeView1"";
this.treeView1.Size = new System.Drawing.Size(284, 262);
this.treeView1.TabIndex = 0;
// // ResolveResultDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(284, 262);
this.Controls.Add(this.treeView1);
this.Name = ""ResolveResultDialog"";
this.Text = ""ResolveResultDialog"";
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2494,internal static byte[] Automaton {,Looks up a localized resource of type System.Byte[].,1
2495,internal static string SymbolElements {,"Looks up a localized string similar to <?xml version=""1.0"" encoding=""utf-8""?> <Tokens> <Token Value=""+"" Type=""Operator"" /> <Token Value=""-"" Type=""Operator"" /> <Token Value=""/"" Type=""Operator"" /> <Token Value="""" Type=""Operator"" /> <Token Value=""*"" Type=""Operator"" /> <Token Value=""Mod"" Type=""Operator"" /> <Token Value=""="" Type=""Operator"" /> <Token Value=""Or"" Type=""Operator"" /> <Token Value=""And"" Type=""Operator"" /> <Token Value=""Xor"" Type=""Operator"" /> <Token Value=""OrElse"" Type=""Operator"" /> <Token Value=""AndAl [rest of string was truncated]"";.",0
2496,"public void BeginUpdate()
{
}",Prepares the document for editing.,0
2497,"public void EndUpdate()
{
}",Finalises the editing process.,0
2498,"public void Indent()
{
Indentation++;
}",Increments the current indentation length.,1
2499,"public void Unindent()
{
Indentation--;
}",Decrements the current indentation length.,1
2500,"public void WriteLine()
{
Writer.WriteLine();
_indentationRequired = true;
Location = new TextLocation(Location.Line + 1, 0);
}",Terminates the current line of text and starts a new one.,1
2501,"public struct TextLocation
{
public static readonly TextLocation Empty = new TextLocation(0, 0);
public TextLocation(int line, int column)
{
Line = line;
Column = column;
}
/// <summary>
/// Gets the line number of the location.
/// </summary>
public int Line
{
get;
}
/// <summary>
/// Gets the column number of the location.
/// </summary>
public int Column
{
get;
}
/// <summary>
/// Translates the text location by a given amount of lines and columns.
/// </summary>
/// <param name=""deltaLine"">The line translation to use.</param>
/// <param name=""deltaColumn"">The column translation to use.</param>
/// <returns>The translated text location.</returns>
public TextLocation Offset(int deltaLine, int deltaColumn)
{
return new TextLocation(Line + deltaLine, Column + deltaColumn);
}
public override int GetHashCode()
{
return Line ^ Column;
}
public override bool Equals(object obj)
{
if (obj is TextLocation)
return (TextLocation)obj == this;
return false;
}
public static bool operator ==(TextLocation a, TextLocation b)
{
return a.Line == b.Line && a.Column == b.Column;
}
public static bool operator !=(TextLocation a, TextLocation b)
{
return !(a == b);
}
public static bool operator >(TextLocation a, TextLocation b)
{
return a.Line > b.Line || (a.Line == b.Line && a.Column > b.Column);
}
public static bool operator >=(TextLocation a, TextLocation b)
{
return !(a < b);
}
public static bool operator <(TextLocation a, TextLocation b)
{
return a.Line < b.Line || (a.Line == b.Line && a.Column < b.Column);
}
public static bool operator <=(TextLocation a, TextLocation b)
{
return !(a > b);
}
public override string ToString()
{
return string.Format(""{{{0}, {1}}}"", Line, Column);
}
}",Represents a location in a text document.,1
2502,"public struct TextRange
{
public static readonly TextRange Empty = new TextRange(TextLocation.Empty, TextLocation.Empty);
public TextRange(int startLine, int startColumn, int endLine, int endColumn)
: this(new TextLocation(startLine, startColumn), new TextLocation(endLine, endColumn))
{
}
public TextRange(TextLocation start, TextLocation end)
{
Start = start;
End = end;
}
/// <summary>
/// Gets the start location of the text range.
/// </summary>
public TextLocation Start
{
get;
}
/// <summary>
/// Gets the end location of the text range.
/// </summary>
public TextLocation End
{
get;
}
/// <summary>
/// Determines whether the given text location is inbetween the boundaries of this text range.
/// </summary>
/// <param name=""location"">The location to check.</param>
/// <returns><c>True</c> if the location is inbetween the boundaries, otherwise <c>False</c>.</returns>
public bool Contains(TextLocation location)
{
return location >= Start && location <= End;
}
/// <summary>
/// Determines whether the given text range boundaries is inbetween the boundaries of this text range.
/// </summary>
/// <param name=""range"">The range to check.</param>
/// <returns><c>True</c> if the range is inbetween the boundaries, otherwise <c>False</c>.</returns>
public bool Contains(TextRange range)
{
return Contains(range.Start) && Contains(range.End);
}
/// <summary>
/// Determines whether the given text range intersects with this text range.
/// </summary>
/// <param name=""range"">The range to check.</param>
/// <returns><c>True</c> if the two ranges intersect, otherwise <c>False</c>.</returns>
public bool IntersectsWith(TextRange range)
{
return Contains(range.Start) || Contains(range.End);
}
/// <summary>
/// Translates this text range by a given amount of lines and columns.
/// </summary>
/// <param name=""deltaLine"">The line translation to use.</param>
/// <param name=""deltaColumn"">The column translation to use.</param>
/// <returns>The translated text range.</returns>
public TextRange Offset(int deltaLine, int deltaColumn)
{
return new TextRange(Start.Offset(deltaLine, deltaColumn), End.Offset(deltaLine, deltaColumn));
}
public override int GetHashCode()
{
return Start.GetHashCode() ^ End.GetHashCode();
}
public override bool Equals(object obj)
{
if (obj is TextRange)
return (TextRange)obj == this;
return false;
}
public static bool operator ==(TextRange a, TextRange b)
{
return a.Start == b.Start && a.End == b.End;
}
public static bool operator !=(TextRange a, TextRange b)
{
return !(a == b);
}
public override string ToString()
{
return string.Format(""{{{0}, {1}}}"", Start, End);
}
}",Represents a range of text in a text document.,1
2503,"public enum BraceStyle
{
/// <summary>
/// Specifies that braces are placed at the same line of the statement.
/// </summary>
EndOfLine,
/// <summary>
/// Specifies that braces are placed at the same line of the statement, but no extra space is used.
/// </summary>
EndOfLineNoSpacing,
/// <summary>
/// Specifies that braces are placed at the next line of the statement.
/// </summary>
NextLine,
/// <summary>
/// Specifies that braces are placed at the next line of the statement, but the amount of indentation is increased.
/// </summary>
NextLineIndented
}",Provides styles of brace placements in a source code file.,1
2504,"public void LoadNativeLibraries()
{
LoadNativeLibrariesFromJava();
}",Loads native plugin libraries on platforms where this is explicitly required.,1
2505,"public void InitializePlatform()
{
InitAndroidPlatform();
}",Initialized platform specific settings,1
2506,"public QCARUnity.InitError Start(string licenseKey)
{
int errorCode = InitQCAR(licenseKey);
if (errorCode >= 0)
InitializeSurface();
return (QCARUnity.InitError)errorCode;
}",Initializes QCAR; called from Start,1
2507,"public void Update()
{
if (SurfaceUtilities.HasSurfaceBeenRecreated())
{
InitializeSurface();
}
else
{
// if Unity reports that the orientation has changed, reset the member variable
// - this will trigger a check in Java for a few frames...
if (Screen.orientation != mScreenOrientation)
ResetUnityScreenOrientation();
CheckOrientation();
}
mFramesSinceLastOrientationReset++;
}","Called from Update, checks for various life cycle events that need to be forwarded to QCAR, e.g. orientation changes",1
2508,"public void OnPause()
{
QCARUnity.OnPause();
}",Pauses QCAR,1
2509,"public void OnResume()
{
QCARUnity.OnResume();
}",Resumes QCAR,1
2510,"public void OnDestroy()
{
QCARUnity.Deinit();
}",Deinitializes QCAR,1
2511,"void Awake()
{
List<MethodInfo> methods = this.GetType().GetMethods(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly).ToList();
methods.AddRange(this.GetType().GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly));
foreach (MethodInfo methodInfo in methods)
{
foreach (Attribute attribute in methodInfo.GetCustomAttributes(true))
{
if (attribute is FactorySetter)
{
Action factorySetMethod = Delegate.CreateDelegate(typeof(Action), this, methodInfo) as Action;
if (factorySetMethod != null)
{
factorySetMethod();
}
}
}
}
}",call all member methods that have the FactoryStart attribute,1
2512,"void OnDestroy()
{
QCARAbstractBehaviour qcarBehaviour = (QCARAbstractBehaviour)FindObjectOfType(typeof(QCARAbstractBehaviour));
if (qcarBehaviour)
{
qcarBehaviour.UnregisterQCARInitErrorCallback(OnQCARInitializationError);
}
}","When this game object is destroyed, it unregisters itself as event handler",1
2513,"public void OnPropCreated(Prop prop)
{
if (mReconstructionBehaviour)
mReconstructionBehaviour.AssociateProp(PropTemplate, prop);
}",Called when a prop has been created,1
2514,"public void OnSurfaceCreated(Surface surface)
{
if (mReconstructionBehaviour)
mReconstructionBehaviour.AssociateSurface(SurfaceTemplate, surface);
}",Called when a surface has been created,1
2515,"public void OnTrackableStateChanged(
TrackableBehaviour.Status previousStatus,
TrackableBehaviour.Status newStatus)
{
if (newStatus == TrackableBehaviour.Status.DETECTED ||
newStatus == TrackableBehaviour.Status.TRACKED ||
newStatus == TrackableBehaviour.Status.EXTENDED_TRACKED)
{
OnTrackingFound();
}
else
{
OnTrackingLost();
}
}",Implementation of the ITrackableEventHandler function called when the tracking state changes.,1
2516,"public static void SetError(string errorText)
{
mErrorText = errorText;
mErrorOccurred = true;
}",Sets an error text that is rendered every frame,1
2517,"public void LoadNativeLibraries()
{
}",Loads native plugin libraries on platforms where this is explicitly required.,0
2518,"public void InitializePlatform()
{
setPlatFormNative();
}",Initialized platform specific settings,0
2519,"public QCARUnity.InitError Start(string licenseKey)
{
int errorCode = initQCARiOS((int)Screen.orientation, licenseKey);
if (errorCode >= 0)
InitializeSurface();
return (QCARUnity.InitError)errorCode;
}",Initializes QCAR; called from Start,1
2520,"public void Update()
{
if (SurfaceUtilities.HasSurfaceBeenRecreated())
{
InitializeSurface();
}
else
{
// if Unity reports that the orientation has changed, set it correctly in native
if (Screen.orientation != mScreenOrientation)
SetUnityScreenOrientation();
}
}","Called from Update, checks for various life cycle events that need to be forwarded to QCAR, e.g. orientation changes",1
2521,"static SharpZipLibUnzipper()
{
Unzipper.Instance = new SharpZipLibUnzipper();
}",register an instance of this class at the singleton immediately,1
2522,"public void OnTrackableStateChanged(
TrackableBehaviour.Status previousStatus,
TrackableBehaviour.Status newStatus)
{
if (newStatus == TrackableBehaviour.Status.DETECTED ||
newStatus == TrackableBehaviour.Status.TRACKED)
{
OnTrackingFound();
}
else
{
OnTrackingLost();
}
}",Implementation of the ITrackableEventHandler function called when the tracking state changes.,1
2523,"public enum ToolRunnerType
{
/// <summary>
/// A tool runner that uses the Windows API to create a virtual desktop and process jobs
/// to start a tool and keep it hidden. The associated implementation of
/// <see cref=""IToolRunner""/> is <see cref=""VirtualDesktopToolRunner""/>.
/// </summary>
VirtualDesktop,
/// <summary>
/// A tool runner that uses basic processes to start and stop jobs. The associated
/// implementation of <see cref=""IToolRunner""/> is <see cref=""SimpleToolRunner""/>.
/// </summary>
Simple
}",The types of tools runner.,1
2524,"private void InitializeComponent()
{
this.btnGetPrivacy = new System.Windows.Forms.Button();
this.rchtxtLogMessages = new System.Windows.Forms.RichTextBox();
this.grpPrivacyOptions = new System.Windows.Forms.GroupBox();
this.chkEtcHosts = new System.Windows.Forms.CheckBox();
this.chkOneDrive = new System.Windows.Forms.CheckBox();
this.menuStrip1 = new System.Windows.Forms.MenuStrip();
this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
this.mnuAbout = new System.Windows.Forms.ToolStripMenuItem();
this.groupBox2 = new System.Windows.Forms.GroupBox();
this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
this.chkWindowsServices = new System.Windows.Forms.CheckBox();
this.grpPrivacyOptions.SuspendLayout();
this.menuStrip1.SuspendLayout();
this.groupBox2.SuspendLayout();
this.tableLayoutPanel1.SuspendLayout();
this.SuspendLayout();
// // btnGetPrivacy
// this.btnGetPrivacy.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.btnGetPrivacy.BackColor = System.Drawing.SystemColors.Control;
this.btnGetPrivacy.Font = new System.Drawing.Font(""Microsoft Sans Serif"", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
this.btnGetPrivacy.Location = new System.Drawing.Point(3, 204);
this.btnGetPrivacy.Name = ""btnGetPrivacy"";
this.btnGetPrivacy.Size = new System.Drawing.Size(495, 108);
this.btnGetPrivacy.TabIndex = 0;
this.btnGetPrivacy.Text = ""Get your privacy back"";
this.btnGetPrivacy.UseVisualStyleBackColor = false;
this.btnGetPrivacy.Click += new System.EventHandler(this.btnGetPrivacy_Click);
// // rchtxtLogMessages
// this.rchtxtLogMessages.Dock = System.Windows.Forms.DockStyle.Fill;
this.rchtxtLogMessages.Location = new System.Drawing.Point(3, 16);
this.rchtxtLogMessages.Name = ""rchtxtLogMessages"";
this.rchtxtLogMessages.Size = new System.Drawing.Size(489, 103);
this.rchtxtLogMessages.TabIndex = 2;
this.rchtxtLogMessages.Text = """";
this.rchtxtLogMessages.WordWrap = false;
// // grpPrivacyOptions
// this.grpPrivacyOptions.Controls.Add(this.chkWindowsServices);
this.grpPrivacyOptions.Controls.Add(this.chkEtcHosts);
this.grpPrivacyOptions.Controls.Add(this.chkOneDrive);
this.grpPrivacyOptions.Dock = System.Windows.Forms.DockStyle.Fill;
this.grpPrivacyOptions.Location = new System.Drawing.Point(3, 3);
this.grpPrivacyOptions.Name = ""grpPrivacyOptions"";
this.grpPrivacyOptions.Size = new System.Drawing.Size(495, 195);
this.grpPrivacyOptions.TabIndex = 3;
this.grpPrivacyOptions.TabStop = false;
this.grpPrivacyOptions.Text = ""Privacy restoring options"";
// // chkEtcHosts
// this.chkEtcHosts.AutoSize = true;
this.chkEtcHosts.Checked = true;
this.chkEtcHosts.CheckState = System.Windows.Forms.CheckState.Checked;
this.chkEtcHosts.Location = new System.Drawing.Point(6, 42);
this.chkEtcHosts.Name = ""chkEtcHosts"";
this.chkEtcHosts.Size = new System.Drawing.Size(200, 17);
this.chkEtcHosts.TabIndex = 1;
this.chkEtcHosts.Tag = ""EtcHosts"";
this.chkEtcHosts.Text = ""Block tracking domains in /etc/hosts"";
this.chkEtcHosts.UseVisualStyleBackColor = true;
// // chkOneDrive
// this.chkOneDrive.AutoSize = true;
this.chkOneDrive.Checked = true;
this.chkOneDrive.CheckState = System.Windows.Forms.CheckState.Checked;
this.chkOneDrive.Location = new System.Drawing.Point(6, 19);
this.chkOneDrive.Name = ""chkOneDrive"";
this.chkOneDrive.Size = new System.Drawing.Size(114, 17);
this.chkOneDrive.TabIndex = 0;
this.chkOneDrive.Tag = ""OneDrive"";
this.chkOneDrive.Text = ""Remove OneDrive"";
this.chkOneDrive.UseVisualStyleBackColor = true;
// // menuStrip1
// this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
this.aboutToolStripMenuItem});
this.menuStrip1.Location = new System.Drawing.Point(0, 0);
this.menuStrip1.Name = ""menuStrip1"";
this.menuStrip1.Size = new System.Drawing.Size(501, 24);
this.menuStrip1.TabIndex = 4;
this.menuStrip1.Text = ""menuStrip1"";
// // aboutToolStripMenuItem
// this.aboutToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
this.mnuAbout});
this.aboutToolStripMenuItem.Name = ""aboutToolStripMenuItem"";
this.aboutToolStripMenuItem.Size = new System.Drawing.Size(44, 20);
this.aboutToolStripMenuItem.Text = ""Help"";
// // mnuAbout
// this.mnuAbout.Name = ""mnuAbout"";
this.mnuAbout.Size = new System.Drawing.Size(152, 22);
this.mnuAbout.Text = ""About"";
this.mnuAbout.Click += new System.EventHandler(this.mnuAbout_Click);
// // groupBox2
// this.groupBox2.Controls.Add(this.rchtxtLogMessages);
this.groupBox2.Dock = System.Windows.Forms.DockStyle.Fill;
this.groupBox2.Location = new System.Drawing.Point(3, 318);
this.groupBox2.Name = ""groupBox2"";
this.groupBox2.Size = new System.Drawing.Size(495, 122);
this.groupBox2.TabIndex = 6;
this.groupBox2.TabStop = false;
this.groupBox2.Text = ""Technical Information"";
// // tableLayoutPanel1
// this.tableLayoutPanel1.ColumnCount = 1;
this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
this.tableLayoutPanel1.Controls.Add(this.groupBox2, 0, 2);
this.tableLayoutPanel1.Controls.Add(this.grpPrivacyOptions, 0, 0);
this.tableLayoutPanel1.Controls.Add(this.btnGetPrivacy, 0, 1);
this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;
this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 24);
this.tableLayoutPanel1.Name = ""tableLayoutPanel1"";
this.tableLayoutPanel1.RowCount = 3;
this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 45.56883F));
this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 25.76996F));
this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 28.66122F));
this.tableLayoutPanel1.Size = new System.Drawing.Size(501, 443);
this.tableLayoutPanel1.TabIndex = 7;
// // chkWindowsServices
// this.chkWindowsServices.AutoSize = true;
this.chkWindowsServices.Checked = true;
this.chkWindowsServices.CheckState = System.Windows.Forms.CheckState.Checked;
this.chkWindowsServices.Location = new System.Drawing.Point(6, 65);
this.chkWindowsServices.Name = ""chkWindowsServices"";
this.chkWindowsServices.Size = new System.Drawing.Size(191, 17);
this.chkWindowsServices.TabIndex = 2;
this.chkWindowsServices.Tag = ""WindowsServices"";
this.chkWindowsServices.Text = ""Disable relevant Windows services"";
this.chkWindowsServices.UseVisualStyleBackColor = true;
// // frmMain
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(501, 467);
this.Controls.Add(this.tableLayoutPanel1);
this.Controls.Add(this.menuStrip1);
this.MainMenuStrip = this.menuStrip1;
this.MaximizeBox = false;
this.Name = ""frmMain"";
this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
this.Text = ""Windows 10 Privacy"";
this.Load += new System.EventHandler(this.frmMain_Load);
this.grpPrivacyOptions.ResumeLayout(false);
this.grpPrivacyOptions.PerformLayout();
this.menuStrip1.ResumeLayout(false);
this.menuStrip1.PerformLayout();
this.groupBox2.ResumeLayout(false);
this.tableLayoutPanel1.ResumeLayout(false);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2525,"static void Main()
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new frmMain());
}",The main entry point for the application.,1
2526,"private void InitializeComponent()
{
this.label1 = new System.Windows.Forms.Label();
this.label2 = new System.Windows.Forms.Label();
this.databaseUsernameTextBox = new System.Windows.Forms.TextBox();
this.databasePasswordTextBox = new System.Windows.Forms.TextBox();
this.confirmButton = new System.Windows.Forms.Button();
this.label3 = new System.Windows.Forms.Label();
this.numericUpDown1 = new System.Windows.Forms.NumericUpDown();
((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).BeginInit();
this.SuspendLayout();
// // label1
// this.label1.AutoSize = true;
this.label1.Location = new System.Drawing.Point(12, 9);
this.label1.Name = ""label1"";
this.label1.Size = new System.Drawing.Size(107, 13);
this.label1.TabIndex = 0;
this.label1.Text = ""Database Username:"";
// // label2
// this.label2.AutoSize = true;
this.label2.Location = new System.Drawing.Point(12, 40);
this.label2.Name = ""label2"";
this.label2.Size = new System.Drawing.Size(105, 13);
this.label2.TabIndex = 1;
this.label2.Text = ""Database Password:"";
// // databaseUsernameTextBox
// this.databaseUsernameTextBox.Location = new System.Drawing.Point(125, 6);
this.databaseUsernameTextBox.Name = ""databaseUsernameTextBox"";
this.databaseUsernameTextBox.Size = new System.Drawing.Size(193, 20);
this.databaseUsernameTextBox.TabIndex = 2;
// // databasePasswordTextBox
// this.databasePasswordTextBox.Location = new System.Drawing.Point(125, 37);
this.databasePasswordTextBox.Name = ""databasePasswordTextBox"";
this.databasePasswordTextBox.PasswordChar = '*';
this.databasePasswordTextBox.Size = new System.Drawing.Size(193, 20);
this.databasePasswordTextBox.TabIndex = 3;
// // confirmButton
// this.confirmButton.Location = new System.Drawing.Point(243, 91);
this.confirmButton.Name = ""confirmButton"";
this.confirmButton.Size = new System.Drawing.Size(75, 23);
this.confirmButton.TabIndex = 4;
this.confirmButton.Text = ""Confirm"";
this.confirmButton.UseVisualStyleBackColor = true;
this.confirmButton.Click += new System.EventHandler(this.confirmButton_Click);
// // label3
// this.label3.AutoSize = true;
this.label3.Location = new System.Drawing.Point(39, 67);
this.label3.Name = ""label3"";
this.label3.Size = new System.Drawing.Size(78, 13);
this.label3.TabIndex = 5;
this.label3.Text = ""Database Port:"";
// // numericUpDown1
// this.numericUpDown1.Location = new System.Drawing.Point(125, 65);
this.numericUpDown1.Maximum = new decimal(new int[] {
99999,
0,
0,
0});
this.numericUpDown1.Minimum = new decimal(new int[] {
1,
0,
0,
0});
this.numericUpDown1.Name = ""numericUpDown1"";
this.numericUpDown1.Size = new System.Drawing.Size(193, 20);
this.numericUpDown1.TabIndex = 6;
this.numericUpDown1.Value = new decimal(new int[] {
3306,
0,
0,
0});
// // DatabaseConfigurationForm
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(330, 126);
this.ControlBox = false;
this.Controls.Add(this.numericUpDown1);
this.Controls.Add(this.label3);
this.Controls.Add(this.confirmButton);
this.Controls.Add(this.databasePasswordTextBox);
this.Controls.Add(this.databaseUsernameTextBox);
this.Controls.Add(this.label2);
this.Controls.Add(this.label1);
this.Name = ""DatabaseConfigurationForm"";
this.Text = ""DatabaseConfigurationForm"";
((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).EndInit();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2527,"static void Main()
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new RaileyBuilder());
}",The main entry point for the application.,1
2528,"private void InitializeComponent()
{
this.installServerButton = new System.Windows.Forms.Button();
this.targetFolderTextBox = new System.Windows.Forms.TextBox();
this.label1 = new System.Windows.Forms.Label();
this.browseServerFolderButton = new System.Windows.Forms.Button();
this.updateServerButton = new System.Windows.Forms.Button();
this.progressLabel = new System.Windows.Forms.Label();
this.progressBar = new System.Windows.Forms.ProgressBar();
this.installClientButton = new System.Windows.Forms.Button();
this.updateClientButton = new System.Windows.Forms.Button();
this.SuspendLayout();
// // installServerButton
// this.installServerButton.Location = new System.Drawing.Point(12, 63);
this.installServerButton.Name = ""installServerButton"";
this.installServerButton.Size = new System.Drawing.Size(92, 45);
this.installServerButton.TabIndex = 0;
this.installServerButton.Text = ""Install Server"";
this.installServerButton.UseVisualStyleBackColor = true;
this.installServerButton.Click += new System.EventHandler(this.installServerButton_Click);
// // targetFolderTextBox
// this.targetFolderTextBox.Location = new System.Drawing.Point(12, 25);
this.targetFolderTextBox.Name = ""targetFolderTextBox"";
this.targetFolderTextBox.Size = new System.Drawing.Size(425, 20);
this.targetFolderTextBox.TabIndex = 1;
// // label1
// this.label1.AutoSize = true;
this.label1.Location = new System.Drawing.Point(12, 9);
this.label1.Name = ""label1"";
this.label1.Size = new System.Drawing.Size(92, 13);
this.label1.TabIndex = 2;
this.label1.Text = ""Installation Folder:"";
// // browseServerFolderButton
// this.browseServerFolderButton.Location = new System.Drawing.Point(443, 22);
this.browseServerFolderButton.Name = ""browseServerFolderButton"";
this.browseServerFolderButton.Size = new System.Drawing.Size(25, 23);
this.browseServerFolderButton.TabIndex = 3;
this.browseServerFolderButton.Text = ""..."";
this.browseServerFolderButton.UseVisualStyleBackColor = true;
this.browseServerFolderButton.Click += new System.EventHandler(this.browseServerFolderButton_Click);
// // updateServerButton
// this.updateServerButton.Location = new System.Drawing.Point(110, 63);
this.updateServerButton.Name = ""updateServerButton"";
this.updateServerButton.Size = new System.Drawing.Size(92, 45);
this.updateServerButton.TabIndex = 4;
this.updateServerButton.Text = ""Update Server"";
this.updateServerButton.UseVisualStyleBackColor = true;
this.updateServerButton.Click += new System.EventHandler(this.updateServerButton_Click);
// // progressLabel
// this.progressLabel.AutoSize = true;
this.progressLabel.Location = new System.Drawing.Point(12, 114);
this.progressLabel.Name = ""progressLabel"";
this.progressLabel.Size = new System.Drawing.Size(0, 13);
this.progressLabel.TabIndex = 6;
// // progressBar
// this.progressBar.Location = new System.Drawing.Point(12, 130);
this.progressBar.Name = ""progressBar"";
this.progressBar.Size = new System.Drawing.Size(456, 23);
this.progressBar.TabIndex = 7;
// // installClientButton
// this.installClientButton.Location = new System.Drawing.Point(278, 63);
this.installClientButton.Name = ""installClientButton"";
this.installClientButton.Size = new System.Drawing.Size(92, 45);
this.installClientButton.TabIndex = 8;
this.installClientButton.Text = ""Install Client"";
this.installClientButton.UseVisualStyleBackColor = true;
this.installClientButton.Click += new System.EventHandler(this.installClientButton_Click);
// // updateClientButton
// this.updateClientButton.Location = new System.Drawing.Point(376, 63);
this.updateClientButton.Name = ""updateClientButton"";
this.updateClientButton.Size = new System.Drawing.Size(92, 45);
this.updateClientButton.TabIndex = 9;
this.updateClientButton.Text = ""Update Client"";
this.updateClientButton.UseVisualStyleBackColor = true;
this.updateClientButton.Click += new System.EventHandler(this.updateClientButton_Click);
// // RaileyBuilder
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(480, 160);
this.Controls.Add(this.updateClientButton);
this.Controls.Add(this.installClientButton);
this.Controls.Add(this.progressBar);
this.Controls.Add(this.progressLabel);
this.Controls.Add(this.updateServerButton);
this.Controls.Add(this.browseServerFolderButton);
this.Controls.Add(this.label1);
this.Controls.Add(this.targetFolderTextBox);
this.Controls.Add(this.installServerButton);
this.Name = ""RaileyBuilder"";
this.Text = ""Railey Builder"";
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2529,"private void InitializeComponent()
{
System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
this.mainSplitContainer = new System.Windows.Forms.SplitContainer();
this.pbGameView = new System.Windows.Forms.PictureBox();
this.rightSplitContainer = new System.Windows.Forms.SplitContainer();
this.tbInfo = new System.Windows.Forms.TextBox();
this.tbStatus = new System.Windows.Forms.TextBox();
((System.ComponentModel.ISupportInitialize)(this.mainSplitContainer)).BeginInit();
this.mainSplitContainer.Panel1.SuspendLayout();
this.mainSplitContainer.Panel2.SuspendLayout();
this.mainSplitContainer.SuspendLayout();
((System.ComponentModel.ISupportInitialize)(this.pbGameView)).BeginInit();
((System.ComponentModel.ISupportInitialize)(this.rightSplitContainer)).BeginInit();
this.rightSplitContainer.Panel1.SuspendLayout();
this.rightSplitContainer.Panel2.SuspendLayout();
this.rightSplitContainer.SuspendLayout();
this.SuspendLayout();
// // mainSplitContainer
// this.mainSplitContainer.Dock = System.Windows.Forms.DockStyle.Fill;
this.mainSplitContainer.Location = new System.Drawing.Point(0, 0);
this.mainSplitContainer.Name = ""mainSplitContainer"";
// // mainSplitContainer.Panel1
// this.mainSplitContainer.Panel1.Controls.Add(this.pbGameView);
this.mainSplitContainer.Panel1.Padding = new System.Windows.Forms.Padding(12, 12, 0, 12);
// // mainSplitContainer.Panel2
// this.mainSplitContainer.Panel2.Controls.Add(this.rightSplitContainer);
this.mainSplitContainer.Panel2.Padding = new System.Windows.Forms.Padding(0, 12, 12, 12);
this.mainSplitContainer.Size = new System.Drawing.Size(999, 622);
this.mainSplitContainer.SplitterDistance = 744;
this.mainSplitContainer.SplitterWidth = 12;
this.mainSplitContainer.TabIndex = 0;
// // pbGameView
// this.pbGameView.Dock = System.Windows.Forms.DockStyle.Fill;
this.pbGameView.Location = new System.Drawing.Point(12, 12);
this.pbGameView.Name = ""pbGameView"";
this.pbGameView.Size = new System.Drawing.Size(732, 598);
this.pbGameView.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
this.pbGameView.TabIndex = 0;
this.pbGameView.TabStop = false;
// // rightSplitContainer
// this.rightSplitContainer.Dock = System.Windows.Forms.DockStyle.Fill;
this.rightSplitContainer.Location = new System.Drawing.Point(0, 12);
this.rightSplitContainer.Name = ""rightSplitContainer"";
this.rightSplitContainer.Orientation = System.Windows.Forms.Orientation.Horizontal;
// // rightSplitContainer.Panel1
// this.rightSplitContainer.Panel1.Controls.Add(this.tbInfo);
// // rightSplitContainer.Panel2
// this.rightSplitContainer.Panel2.Controls.Add(this.tbStatus);
this.rightSplitContainer.Size = new System.Drawing.Size(231, 598);
this.rightSplitContainer.SplitterDistance = 427;
this.rightSplitContainer.SplitterWidth = 12;
this.rightSplitContainer.TabIndex = 1;
// // tbInfo
// this.tbInfo.Dock = System.Windows.Forms.DockStyle.Fill;
this.tbInfo.Location = new System.Drawing.Point(0, 0);
this.tbInfo.Multiline = true;
this.tbInfo.Name = ""tbInfo"";
this.tbInfo.ReadOnly = true;
this.tbInfo.Size = new System.Drawing.Size(231, 427);
this.tbInfo.TabIndex = 0;
// // tbStatus
// this.tbStatus.Dock = System.Windows.Forms.DockStyle.Fill;
this.tbStatus.Location = new System.Drawing.Point(0, 0);
this.tbStatus.Margin = new System.Windows.Forms.Padding(10);
this.tbStatus.Multiline = true;
this.tbStatus.Name = ""tbStatus"";
this.tbStatus.ReadOnly = true;
this.tbStatus.Size = new System.Drawing.Size(231, 159);
this.tbStatus.TabIndex = 0;
// // MainForm
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(999, 622);
this.Controls.Add(this.mainSplitContainer);
this.Icon = ((System.Drawing.Icon)(resources.GetObject(""$this.Icon"")));
this.KeyPreview = true;
this.Name = ""MainForm"";
this.Text = ""Snake Wars Viewer"";
this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.MainForm_KeyDown);
this.mainSplitContainer.Panel1.ResumeLayout(false);
this.mainSplitContainer.Panel2.ResumeLayout(false);
((System.ComponentModel.ISupportInitialize)(this.mainSplitContainer)).EndInit();
this.mainSplitContainer.ResumeLayout(false);
((System.ComponentModel.ISupportInitialize)(this.pbGameView)).EndInit();
this.rightSplitContainer.Panel1.ResumeLayout(false);
this.rightSplitContainer.Panel1.PerformLayout();
this.rightSplitContainer.Panel2.ResumeLayout(false);
this.rightSplitContainer.Panel2.PerformLayout();
((System.ComponentModel.ISupportInitialize)(this.rightSplitContainer)).EndInit();
this.rightSplitContainer.ResumeLayout(false);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2530,"private static void Main()
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
var mainForm = new MainForm();
var contestConnector = new ContestConnector(Settings.Default.ContestServerHost,
Settings.Default.ContestServerPort, mainForm);
Application.Run(mainForm);
}",The main entry point for the application.,1
2531,"public void DrawTitle( Graphics g, GraphPane pane, float shiftPos, float scaleFactor )
{
string str = MakeTitle();
// If the Axis is visible, draw the title
//if ( _isVisible && _title._isVisible && str.Length > 0 )
if ( _isVisible && _title._isVisible && !string.IsNullOrEmpty( str ) )
{
bool hasTic = ( _scale._isLabelsInside ?
( this.MajorTic.IsInside || this.MajorTic._isCrossInside ||
this.MinorTic.IsInside || this.MinorTic._isCrossInside ) :
( this.MajorTic.IsOutside || this.MajorTic._isCrossOutside || this.MinorTic.IsOutside || this.MinorTic._isCrossOutside ) );
// Calculate the title position in screen coordinates
float x = ( _scale._maxPix - _scale._minPix ) / 2;
float scaledTic = MajorTic.ScaledTic( scaleFactor );
float scaledLabelGap = _scale._fontSpec.GetHeight( scaleFactor ) * _scale._labelGap;
float scaledTitleGap = _title.GetScaledGap( scaleFactor );
// The space for the scale labels is only reserved if the axis is not shifted due to the
// cross value. Note that this could be a problem if the axis is only shifted slightly,
// since the scale value labels may overlap the axis title. However, it's not possible to
// calculate that actual shift amount at this point, because the ChartRect rect has not yet been
// calculated, and the cross value is determined using a transform of scale values (which
// rely on ChartRect).
float gap = scaledTic * ( hasTic ? 1.0f : 0.0f ) +
this.Title.FontSpec.BoundingBox( g, str, scaleFactor ).Height / 2.0F;
float y = ( _scale._isVisible ? _scale.GetScaleMaxSpace( g, pane, scaleFactor, true ).Height
+ scaledLabelGap : 0 );
if ( _scale._isLabelsInside )
y = shiftPos - y - gap;
else
y = shiftPos + y + gap;
if ( !_crossAuto && !_title._isTitleAtCross )
y = Math.Max( y, gap );
AlignV alignV = AlignV.Center;
// Add in the TitleGap space
y += scaledTitleGap;
// Draw the title
this.Title.FontSpec.Draw( g, pane, str, x, y,
AlignH.Center, alignV, scaleFactor );
}
}","On entry, it is assumed that the graphics transform has been configured so that the origin is at the left side of this axis, and the axis is aligned along the X coordinate direction.",1
2532,"override internal bool IsXIndependent( GraphPane pane )
{
return pane._barSettings.Base == BarBase.X || pane._barSettings.Base == BarBase.X2;
}","true if the X axis is independent, false otherwise",1
2533,"public int Move( int index, int relativePos )
{
if ( index < 0 || index >= List.Count )
return -1;
object obj = List[index];
List.RemoveAt( index );
index += relativePos;
if ( index < 0 )
index = 0;
if ( index > List.Count )
index = List.Count;
List.Insert( index, obj );
return index;
}","For Graphic type objects, this method controls the Z-Order of the items. Objects at the beginning of the list appear in front of objects at the end of the list.",1
2534,"public void Sort( SortType type, int index )
{
this.Sort( new CurveItem.Comparer( type, index ) );
}",Sorts the list according to the point values at the specified index and for the specified axis.,1
2535,"public int Move( int index, int relativePos )
{
if ( index < 0 || index >= Count )
return -1;
CurveItem curve = this[index];
this.RemoveAt( index );
index += relativePos;
if ( index < 0 )
index = 0;
if ( index > Count )
index = Count;
Insert( index, curve );
return index;
}","For Graphic type objects, this method controls the Z-Order of the items. Objects at the beginning of the list appear in front of objects at the end of the list.",1
2536,"private void GetStackRange( GraphPane pane, CurveItem curve, out double tXMinVal,
out double tYMinVal, out double tXMaxVal, out double tYMaxVal )
{
// initialize the values to outrageous ones to start
tXMinVal = tYMinVal = Double.MaxValue;
tXMaxVal = tYMaxVal = Double.MinValue;
ValueHandler valueHandler = new ValueHandler( pane, false );
Axis baseAxis = curve.BaseAxis( pane );
bool isXBase = baseAxis is XAxis || baseAxis is X2Axis;
double lowVal, baseVal, hiVal;
for ( int i=0; i<curve.Points.Count; i++ )
{
valueHandler.GetValues( curve, i, out baseVal, out lowVal, out hiVal );
double x = isXBase ? baseVal : hiVal;
double y = isXBase ? hiVal : baseVal;
if ( x != PointPair.Missing && y != PointPair.Missing && lowVal != PointPair.Missing )
{
if ( x < tXMinVal )
tXMinVal = x;
if ( x > tXMaxVal )
tXMaxVal = x;
if ( y < tYMinVal )
tYMinVal = y;
if ( y > tYMaxVal )
tYMaxVal = y;
if ( !isXBase )
{
if ( lowVal < tXMinVal )
tXMinVal = lowVal;
if ( lowVal > tXMaxVal )
tXMaxVal = lowVal;
}
else
{
if ( lowVal < tYMinVal )
tYMinVal = lowVal;
if ( lowVal > tYMaxVal )
tYMaxVal = lowVal;
}
}
}
}","This method is required for the stacked types because (for bars), the negative values are a separate stack than the positive values. If you just sum up the bars, you will get the sum of the positive plus negative, which is less than the maximum positive value and greater than the maximum negative value.",1
2537,"public struct DataPoint
{
/// <summary>
/// The X value for the point, stored as a double type.
/// </summary>
public double X;
/// <summary>
/// The Y value for the point, stored as a double type.
/// </summary>
public double Y;
}","A simple storage struct to maintain an individual sampling of data. This only contains two data values in order to reduce to memory load for large datasets. (e.g., no Tag or Z property)",1
2538,"public DataSourcePointList()
{
_bindingSource = new BindingSource();
_xDataMember = string.Empty;
_yDataMember = string.Empty;
_zDataMember = string.Empty;
_tagDataMember = string.Empty;
}",Default Constructor,1
2539,"override internal bool IsXIndependent( GraphPane pane )
{
return pane._barSettings.Base == BarBase.X;
}","true if the X axis is independent, false otherwise",1
2540,"private void Init()
{
_color = Color.White;
_secondaryValueGradientColor = Color.White;
_brush = null;
_type = FillType.None;
_isScaled = Default.IsScaled;
_alignH = Default.AlignH;
_alignV = Default.AlignV;
_rangeMin = 0.0;
_rangeMax = 1.0;
_rangeDefault = double.MaxValue;
_gradientBM = null;
_colorList = null;
_positionList = null;
_angle = 0;
_image = null;
_wrapMode = WrapMode.Tile;
}",Generic initializer to default values,1
2541,"public SizeF MeasureString( Graphics g, string text, float scaleFactor, SizeF layoutArea )
{
Remake( scaleFactor, this.Size, ref _scaledSize, ref _font );
SizeF size = g.MeasureString( text, _font, layoutArea );
if ( _isDropShadow )
{
size.Width += (float)( Math.Cos( _dropShadowAngle ) *
_dropShadowOffset * _font.Height );
size.Height += (float)( Math.Sin( _dropShadowAngle ) *
_dropShadowOffset * _font.Height );
}
return size;
}",This method will allow the text to wrap as necessary to fit the .,1
2542,"private void InitializeComponent()
{
this.components = new System.ComponentModel.Container();
this.statusStrip = new System.Windows.Forms.StatusStrip();
this.toolStripStatus = new System.Windows.Forms.ToolStripStatusLabel();
this.GraphControl = new ZedGraph.ZedGraphControl();
this.statusStrip.SuspendLayout();
this.SuspendLayout();
// // statusStrip
// this.statusStrip.AutoSize = false;
this.statusStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
this.toolStripStatus});
this.statusStrip.LayoutStyle = System.Windows.Forms.ToolStripLayoutStyle.Flow;
this.statusStrip.Location = new System.Drawing.Point(0, 385);
this.statusStrip.Name = ""statusStrip"";
this.statusStrip.Size = new System.Drawing.Size(809, 22);
this.statusStrip.TabIndex = 1;
// // toolStripStatus
// this.toolStripStatus.Name = ""toolStripStatus"";
this.toolStripStatus.Size = new System.Drawing.Size(50, 15);
this.toolStripStatus.Text = ""Position"";
// // GraphControl
// this.GraphControl.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this.GraphControl.Location = new System.Drawing.Point(12, 12);
this.GraphControl.Name = ""GraphControl"";
this.GraphControl.ScrollGrace = 0;
this.GraphControl.ScrollMaxX = 0;
this.GraphControl.ScrollMaxY = 0;
this.GraphControl.ScrollMaxY2 = 0;
this.GraphControl.ScrollMinX = 0;
this.GraphControl.ScrollMinY = 0;
this.GraphControl.ScrollMinY2 = 0;
this.GraphControl.Size = new System.Drawing.Size(785, 370);
this.GraphControl.TabIndex = 0;
// // FormChart
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(809, 407);
this.Controls.Add(this.statusStrip);
this.Controls.Add(this.GraphControl);
this.Name = ""FormChart"";
this.Text = ""FormChart"";
this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.FormChart_FormClosed);
this.statusStrip.ResumeLayout(false);
this.statusStrip.PerformLayout();
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2543,"private void InitializeComponent()
{
this.buttonBrowse = new System.Windows.Forms.Button();
this.textBoxSource = new System.Windows.Forms.TextBox();
this.labelSource = new System.Windows.Forms.Label();
this.buttonSettings = new System.Windows.Forms.Button();
this.labelTimeRemainingElapsed = new System.Windows.Forms.Label();
this.labelTimeDivider = new System.Windows.Forms.Label();
this.labelTimeElapsed = new System.Windows.Forms.Label();
this.labelTimeRemaining = new System.Windows.Forms.Label();
this.progressBarScan = new System.Windows.Forms.ProgressBar();
this.labelPlaylistFiles = new System.Windows.Forms.Label();
this.buttonViewReport = new System.Windows.Forms.Button();
this.buttonScan = new System.Windows.Forms.Button();
this.textBoxDetails = new System.Windows.Forms.TextBox();
this.labelProgress = new System.Windows.Forms.Label();
this.buttonSelectAll = new System.Windows.Forms.Button();
this.buttonUnselectAll = new System.Windows.Forms.Button();
this.buttonCustomPlaylist = new System.Windows.Forms.Button();
this.splitContainerOuter = new System.Windows.Forms.SplitContainer();
this.splitContainerInner = new System.Windows.Forms.SplitContainer();
this.listViewPlaylistFiles = new System.Windows.Forms.ListView();
this.columnHeaderPlaylistName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderPlaylistGroup = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderPlaylistLength = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderPlaylistEstimatedBytes = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderPlaylistMeasuredBytes = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.listViewStreamFiles = new System.Windows.Forms.ListView();
this.columnHeaderFileName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderIndex = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderFileLength = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderFileEstimatedBytes = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderFileMeasuredBytes = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.listViewStreams = new System.Windows.Forms.ListView();
this.columnHeaderStreamCodec = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderStreamLanguage = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderBitrate = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderDescription = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.buttonRescan = new System.Windows.Forms.Button();
this.splitContainerOuter.Panel1.SuspendLayout();
this.splitContainerOuter.Panel2.SuspendLayout();
this.splitContainerOuter.SuspendLayout();
this.splitContainerInner.Panel1.SuspendLayout();
this.splitContainerInner.Panel2.SuspendLayout();
this.splitContainerInner.SuspendLayout();
this.SuspendLayout();
// // buttonBrowse
// this.buttonBrowse.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.buttonBrowse.Location = new System.Drawing.Point(416, 23);
this.buttonBrowse.Name = ""buttonBrowse"";
this.buttonBrowse.Size = new System.Drawing.Size(75, 23);
this.buttonBrowse.TabIndex = 1;
this.buttonBrowse.Text = ""Browse..."";
this.buttonBrowse.UseVisualStyleBackColor = true;
this.buttonBrowse.Click += new System.EventHandler(this.buttonBrowse_Click);
// // textBoxSource
// this.textBoxSource.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.textBoxSource.Location = new System.Drawing.Point(17, 24);
this.textBoxSource.Name = ""textBoxSource"";
this.textBoxSource.Size = new System.Drawing.Size(393, 20);
this.textBoxSource.TabIndex = 0;
this.textBoxSource.TextChanged += new System.EventHandler(this.textBoxSource_TextChanged);
// // labelSource
// this.labelSource.AutoSize = true;
this.labelSource.Location = new System.Drawing.Point(14, 8);
this.labelSource.Name = ""labelSource"";
this.labelSource.Size = new System.Drawing.Size(141, 13);
this.labelSource.TabIndex = 3;
this.labelSource.Text = ""Select the Source BD-ROM:"";
// // buttonSettings
// this.buttonSettings.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.buttonSettings.Location = new System.Drawing.Point(463, 548);
this.buttonSettings.Name = ""buttonSettings"";
this.buttonSettings.Size = new System.Drawing.Size(108, 23);
this.buttonSettings.TabIndex = 10;
this.buttonSettings.Text = ""Settings..."";
this.buttonSettings.UseVisualStyleBackColor = true;
this.buttonSettings.Click += new System.EventHandler(this.buttonSettings_Click);
// // labelTimeRemainingElapsed
// this.labelTimeRemainingElapsed.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.labelTimeRemainingElapsed.AutoSize = true;
this.labelTimeRemainingElapsed.Font = new System.Drawing.Font(""Microsoft Sans Serif"", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
this.labelTimeRemainingElapsed.Location = new System.Drawing.Point(310, 503);
this.labelTimeRemainingElapsed.Name = ""labelTimeRemainingElapsed"";
this.labelTimeRemainingElapsed.Size = new System.Drawing.Size(135, 13);
this.labelTimeRemainingElapsed.TabIndex = 35;
this.labelTimeRemainingElapsed.Text = ""Time Remaining / Elapsed:"";
// // labelTimeDivider
// this.labelTimeDivider.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.labelTimeDivider.AutoSize = true;
this.labelTimeDivider.Location = new System.Drawing.Point(503, 503);
this.labelTimeDivider.Name = ""labelTimeDivider"";
this.labelTimeDivider.Size = new System.Drawing.Size(12, 13);
this.labelTimeDivider.TabIndex = 34;
this.labelTimeDivider.Text = ""/"";
// // labelTimeElapsed
// this.labelTimeElapsed.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.labelTimeElapsed.AutoSize = true;
this.labelTimeElapsed.Font = new System.Drawing.Font(""Microsoft Sans Serif"", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
this.labelTimeElapsed.Location = new System.Drawing.Point(521, 503);
this.labelTimeElapsed.Name = ""labelTimeElapsed"";
this.labelTimeElapsed.Size = new System.Drawing.Size(49, 13);
this.labelTimeElapsed.TabIndex = 33;
this.labelTimeElapsed.Text = ""00:00:00"";
// // labelTimeRemaining
// this.labelTimeRemaining.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.labelTimeRemaining.AutoSize = true;
this.labelTimeRemaining.Font = new System.Drawing.Font(""Microsoft Sans Serif"", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
this.labelTimeRemaining.Location = new System.Drawing.Point(451, 503);
this.labelTimeRemaining.Name = ""labelTimeRemaining"";
this.labelTimeRemaining.Size = new System.Drawing.Size(49, 13);
this.labelTimeRemaining.TabIndex = 32;
this.labelTimeRemaining.Text = ""00:00:00"";
// // progressBarScan
// this.progressBarScan.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.progressBarScan.Location = new System.Drawing.Point(17, 519);
this.progressBarScan.Name = ""progressBarScan"";
this.progressBarScan.Size = new System.Drawing.Size(554, 23);
this.progressBarScan.TabIndex = 31;
// // labelPlaylistFiles
// this.labelPlaylistFiles.AutoSize = true;
this.labelPlaylistFiles.Location = new System.Drawing.Point(14, 55);
this.labelPlaylistFiles.Name = ""labelPlaylistFiles"";
this.labelPlaylistFiles.Size = new System.Drawing.Size(86, 13);
this.labelPlaylistFiles.TabIndex = 28;
this.labelPlaylistFiles.Text = ""Select Playlist(s):"";
// // buttonViewReport
// this.buttonViewReport.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.buttonViewReport.Enabled = false;
this.buttonViewReport.Location = new System.Drawing.Point(285, 548);
this.buttonViewReport.Name = ""buttonViewReport"";
this.buttonViewReport.Size = new System.Drawing.Size(108, 23);
this.buttonViewReport.TabIndex = 9;
this.buttonViewReport.Text = ""View Report..."";
this.buttonViewReport.UseVisualStyleBackColor = true;
this.buttonViewReport.Click += new System.EventHandler(this.buttonViewReport_Click);
// // buttonScan
// this.buttonScan.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.buttonScan.Enabled = false;
this.buttonScan.Location = new System.Drawing.Point(168, 548);
this.buttonScan.Name = ""buttonScan"";
this.buttonScan.Size = new System.Drawing.Size(108, 23);
this.buttonScan.TabIndex = 8;
this.buttonScan.Text = ""Scan Bitrates"";
this.buttonScan.UseVisualStyleBackColor = true;
this.buttonScan.Click += new System.EventHandler(this.buttonScan_Click);
// // textBoxDetails
// this.textBoxDetails.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.textBoxDetails.Enabled = false;
this.textBoxDetails.Location = new System.Drawing.Point(16, 438);
this.textBoxDetails.Multiline = true;
this.textBoxDetails.Name = ""textBoxDetails"";
this.textBoxDetails.ReadOnly = true;
this.textBoxDetails.ScrollBars = System.Windows.Forms.ScrollBars.Both;
this.textBoxDetails.Size = new System.Drawing.Size(554, 59);
this.textBoxDetails.TabIndex = 8;
// // labelProgress
// this.labelProgress.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this.labelProgress.AutoSize = true;
this.labelProgress.Location = new System.Drawing.Point(14, 503);
this.labelProgress.Name = ""labelProgress"";
this.labelProgress.Size = new System.Drawing.Size(0, 13);
this.labelProgress.TabIndex = 37;
// // buttonSelectAll
// this.buttonSelectAll.Enabled = false;
this.buttonSelectAll.Location = new System.Drawing.Point(106, 50);
this.buttonSelectAll.Name = ""buttonSelectAll"";
this.buttonSelectAll.Size = new System.Drawing.Size(75, 23);
this.buttonSelectAll.TabIndex = 2;
this.buttonSelectAll.Text = ""Select All"";
this.buttonSelectAll.UseVisualStyleBackColor = true;
this.buttonSelectAll.Click += new System.EventHandler(this.buttonSelectAll_Click);
// // buttonUnselectAll
// this.buttonUnselectAll.Enabled = false;
this.buttonUnselectAll.Location = new System.Drawing.Point(187, 50);
this.buttonUnselectAll.Name = ""buttonUnselectAll"";
this.buttonUnselectAll.Size = new System.Drawing.Size(75, 23);
this.buttonUnselectAll.TabIndex = 3;
this.buttonUnselectAll.Text = ""Unselect All"";
this.buttonUnselectAll.UseVisualStyleBackColor = true;
this.buttonUnselectAll.Click += new System.EventHandler(this.buttonUnselectAll_Click);
// // buttonCustomPlaylist
// this.buttonCustomPlaylist.Enabled = false;
this.buttonCustomPlaylist.Location = new System.Drawing.Point(268, 50);
this.buttonCustomPlaylist.Name = ""buttonCustomPlaylist"";
this.buttonCustomPlaylist.Size = new System.Drawing.Size(75, 23);
this.buttonCustomPlaylist.TabIndex = 4;
this.buttonCustomPlaylist.Text = ""Custom..."";
this.buttonCustomPlaylist.UseVisualStyleBackColor = true;
this.buttonCustomPlaylist.Click += new System.EventHandler(this.buttonCustomPlaylist_Click);
// // splitContainerOuter
// this.splitContainerOuter.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.splitContainerOuter.Location = new System.Drawing.Point(17, 79);
this.splitContainerOuter.Name = ""splitContainerOuter"";
this.splitContainerOuter.Orientation = System.Windows.Forms.Orientation.Horizontal;
// // splitContainerOuter.Panel1
// this.splitContainerOuter.Panel1.Controls.Add(this.splitContainerInner);
// // splitContainerOuter.Panel2
// this.splitContainerOuter.Panel2.Controls.Add(this.listViewStreams);
this.splitContainerOuter.Size = new System.Drawing.Size(553, 353);
this.splitContainerOuter.SplitterDistance = 199;
this.splitContainerOuter.TabIndex = 38;
// // splitContainerInner
// this.splitContainerInner.Dock = System.Windows.Forms.DockStyle.Fill;
this.splitContainerInner.Location = new System.Drawing.Point(0, 0);
this.splitContainerInner.Name = ""splitContainerInner"";
this.splitContainerInner.Orientation = System.Windows.Forms.Orientation.Horizontal;
// // splitContainerInner.Panel1
// this.splitContainerInner.Panel1.Controls.Add(this.listViewPlaylistFiles);
// // splitContainerInner.Panel2
// this.splitContainerInner.Panel2.Controls.Add(this.listViewStreamFiles);
this.splitContainerInner.Size = new System.Drawing.Size(553, 199);
this.splitContainerInner.SplitterDistance = 97;
this.splitContainerInner.TabIndex = 0;
// // listViewPlaylistFiles
// this.listViewPlaylistFiles.CheckBoxes = true;
this.listViewPlaylistFiles.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
this.columnHeaderPlaylistName,
this.columnHeaderPlaylistGroup,
this.columnHeaderPlaylistLength,
this.columnHeaderPlaylistEstimatedBytes,
this.columnHeaderPlaylistMeasuredBytes});
this.listViewPlaylistFiles.Dock = System.Windows.Forms.DockStyle.Fill;
this.listViewPlaylistFiles.Enabled = false;
this.listViewPlaylistFiles.FullRowSelect = true;
this.listViewPlaylistFiles.HideSelection = false;
this.listViewPlaylistFiles.Location = new System.Drawing.Point(0, 0);
this.listViewPlaylistFiles.MultiSelect = false;
this.listViewPlaylistFiles.Name = ""listViewPlaylistFiles"";
this.listViewPlaylistFiles.Size = new System.Drawing.Size(553, 97);
this.listViewPlaylistFiles.TabIndex = 5;
this.listViewPlaylistFiles.UseCompatibleStateImageBehavior = false;
this.listViewPlaylistFiles.View = System.Windows.Forms.View.Details;
this.listViewPlaylistFiles.ColumnClick += new System.Windows.Forms.ColumnClickEventHandler(this.listViewPlaylistFiles_ColumnClick);
this.listViewPlaylistFiles.SelectedIndexChanged += new System.EventHandler(this.listViewPlaylistFiles_SelectedIndexChanged);
// // columnHeaderPlaylistName
// this.columnHeaderPlaylistName.Text = ""Playlist File"";
this.columnHeaderPlaylistName.Width = 103;
// // columnHeaderPlaylistGroup
// this.columnHeaderPlaylistGroup.Text = ""Group"";
// // columnHeaderPlaylistLength
// this.columnHeaderPlaylistLength.Text = ""Length"";
this.columnHeaderPlaylistLength.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderPlaylistLength.Width = 73;
// // columnHeaderPlaylistEstimatedBytes
// this.columnHeaderPlaylistEstimatedBytes.Text = ""Estimated Bytes"";
this.columnHeaderPlaylistEstimatedBytes.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderPlaylistEstimatedBytes.Width = 98;
// // columnHeaderPlaylistMeasuredBytes
// this.columnHeaderPlaylistMeasuredBytes.Text = ""Measured Bytes"";
this.columnHeaderPlaylistMeasuredBytes.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderPlaylistMeasuredBytes.Width = 125;
// // listViewStreamFiles
// this.listViewStreamFiles.Activation = System.Windows.Forms.ItemActivation.OneClick;
this.listViewStreamFiles.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
this.columnHeaderFileName,
this.columnHeaderIndex,
this.columnHeaderFileLength,
this.columnHeaderFileEstimatedBytes,
this.columnHeaderFileMeasuredBytes});
this.listViewStreamFiles.Dock = System.Windows.Forms.DockStyle.Fill;
this.listViewStreamFiles.Enabled = false;
this.listViewStreamFiles.FullRowSelect = true;
this.listViewStreamFiles.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
this.listViewStreamFiles.HideSelection = false;
this.listViewStreamFiles.Location = new System.Drawing.Point(0, 0);
this.listViewStreamFiles.MultiSelect = false;
this.listViewStreamFiles.Name = ""listViewStreamFiles"";
this.listViewStreamFiles.Size = new System.Drawing.Size(553, 98);
this.listViewStreamFiles.TabIndex = 6;
this.listViewStreamFiles.UseCompatibleStateImageBehavior = false;
this.listViewStreamFiles.View = System.Windows.Forms.View.Details;
// // columnHeaderFileName
// this.columnHeaderFileName.Text = ""Stream File"";
this.columnHeaderFileName.Width = 82;
// // columnHeaderIndex
// this.columnHeaderIndex.Text = ""Index"";
// // columnHeaderFileLength
// this.columnHeaderFileLength.Text = ""Length"";
this.columnHeaderFileLength.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderFileLength.Width = 77;
// // columnHeaderFileEstimatedBytes
// this.columnHeaderFileEstimatedBytes.Text = ""Estimated Bytes"";
this.columnHeaderFileEstimatedBytes.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderFileEstimatedBytes.Width = 119;
// // columnHeaderFileMeasuredBytes
// this.columnHeaderFileMeasuredBytes.Text = ""Measured Bytes"";
this.columnHeaderFileMeasuredBytes.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderFileMeasuredBytes.Width = 125;
// // listViewStreams
// this.listViewStreams.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
this.columnHeaderStreamCodec,
this.columnHeaderStreamLanguage,
this.columnHeaderBitrate,
this.columnHeaderDescription});
this.listViewStreams.Dock = System.Windows.Forms.DockStyle.Fill;
this.listViewStreams.Enabled = false;
this.listViewStreams.FullRowSelect = true;
this.listViewStreams.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
this.listViewStreams.HideSelection = false;
this.listViewStreams.Location = new System.Drawing.Point(0, 0);
this.listViewStreams.MultiSelect = false;
this.listViewStreams.Name = ""listViewStreams"";
this.listViewStreams.Size = new System.Drawing.Size(553, 150);
this.listViewStreams.TabIndex = 7;
this.listViewStreams.UseCompatibleStateImageBehavior = false;
this.listViewStreams.View = System.Windows.Forms.View.Details;
// // columnHeaderStreamCodec
// this.columnHeaderStreamCodec.Text = ""Codec"";
this.columnHeaderStreamCodec.Width = 103;
// // columnHeaderStreamLanguage
// this.columnHeaderStreamLanguage.Text = ""Language"";
this.columnHeaderStreamLanguage.Width = 151;
// // columnHeaderBitrate
// this.columnHeaderBitrate.Text = ""Bit Rate"";
// // columnHeaderDescription
// this.columnHeaderDescription.Text = ""Description"";
this.columnHeaderDescription.Width = 306;
// // buttonRescan
// this.buttonRescan.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.buttonRescan.Enabled = false;
this.buttonRescan.Location = new System.Drawing.Point(497, 23);
this.buttonRescan.Name = ""buttonRescan"";
this.buttonRescan.Size = new System.Drawing.Size(75, 23);
this.buttonRescan.TabIndex = 2;
this.buttonRescan.Text = ""Rescan"";
this.buttonRescan.UseVisualStyleBackColor = true;
this.buttonRescan.Click += new System.EventHandler(this.buttonRescan_Click);
// // FormMain
// this.AllowDrop = true;
this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(584, 575);
this.Controls.Add(this.buttonRescan);
this.Controls.Add(this.splitContainerOuter);
this.Controls.Add(this.buttonCustomPlaylist);
this.Controls.Add(this.buttonUnselectAll);
this.Controls.Add(this.buttonSelectAll);
this.Controls.Add(this.labelProgress);
this.Controls.Add(this.buttonSettings);
this.Controls.Add(this.labelTimeRemainingElapsed);
this.Controls.Add(this.labelTimeDivider);
this.Controls.Add(this.labelTimeElapsed);
this.Controls.Add(this.labelTimeRemaining);
this.Controls.Add(this.progressBarScan);
this.Controls.Add(this.labelPlaylistFiles);
this.Controls.Add(this.buttonViewReport);
this.Controls.Add(this.buttonScan);
this.Controls.Add(this.textBoxDetails);
this.Controls.Add(this.buttonBrowse);
this.Controls.Add(this.textBoxSource);
this.Controls.Add(this.labelSource);
this.Name = ""FormMain"";
this.Text = ""BDInfo v.0.5.9"";
this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.FormMain_FormClosing);
this.Load += new System.EventHandler(this.FormMain_Load);
this.LocationChanged += new System.EventHandler(this.FormMain_LocationChanged);
this.DragDrop += new System.Windows.Forms.DragEventHandler(this.FormMain_DragDrop);
this.DragEnter += new System.Windows.Forms.DragEventHandler(this.FormMain_DragEnter);
this.Resize += new System.EventHandler(this.FormMain_Resize);
this.splitContainerOuter.Panel1.ResumeLayout(false);
this.splitContainerOuter.Panel2.ResumeLayout(false);
this.splitContainerOuter.ResumeLayout(false);
this.splitContainerInner.Panel1.ResumeLayout(false);
this.splitContainerInner.Panel2.ResumeLayout(false);
this.splitContainerInner.ResumeLayout(false);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2544,"private void InitializeComponent()
{
this.textBoxName = new System.Windows.Forms.TextBox();
this.buttonOK = new System.Windows.Forms.Button();
this.buttonCancel = new System.Windows.Forms.Button();
this.splitContainerOuter = new System.Windows.Forms.SplitContainer();
this.groupBoxSourcePlaylist = new System.Windows.Forms.GroupBox();
this.buttonAddAll = new System.Windows.Forms.Button();
this.splitContainerInner = new System.Windows.Forms.SplitContainer();
this.listViewPlaylistFiles = new System.Windows.Forms.ListView();
this.columnHeaderPlaylistName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderPlaylistLength = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderPlaylistEstimatedBytes = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderPlaylistMeasuredBytes = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.listViewStreamFiles = new System.Windows.Forms.ListView();
this.columnHeaderFileName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderFileLength = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderFileEstimatedBytes = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeaderFileMeasuredBytes = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.buttonAdd = new System.Windows.Forms.Button();
this.groupBoxCustomPlaylist = new System.Windows.Forms.GroupBox();
this.buttonDown = new System.Windows.Forms.Button();
this.buttonUp = new System.Windows.Forms.Button();
this.buttonRemove = new System.Windows.Forms.Button();
this.listViewTargetFiles = new System.Windows.Forms.ListView();
this.columnHeader1 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeader2 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeader3 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.columnHeader4 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
this.checkBoxFilterIncompatible = new System.Windows.Forms.CheckBox();
this.splitContainerOuter.Panel1.SuspendLayout();
this.splitContainerOuter.Panel2.SuspendLayout();
this.splitContainerOuter.SuspendLayout();
this.groupBoxSourcePlaylist.SuspendLayout();
this.splitContainerInner.Panel1.SuspendLayout();
this.splitContainerInner.Panel2.SuspendLayout();
this.splitContainerInner.SuspendLayout();
this.groupBoxCustomPlaylist.SuspendLayout();
this.SuspendLayout();
// // textBoxName
// this.textBoxName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.textBoxName.Location = new System.Drawing.Point(12, 13);
this.textBoxName.Name = ""textBoxName"";
this.textBoxName.Size = new System.Drawing.Size(399, 20);
this.textBoxName.TabIndex = 0;
// // buttonOK
// this.buttonOK.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
this.buttonOK.Enabled = false;
this.buttonOK.Location = new System.Drawing.Point(214, 459);
this.buttonOK.Name = ""buttonOK"";
this.buttonOK.Size = new System.Drawing.Size(75, 23);
this.buttonOK.TabIndex = 9;
this.buttonOK.Text = ""OK"";
this.buttonOK.UseVisualStyleBackColor = true;
this.buttonOK.Click += new System.EventHandler(this.buttonOK_Click);
// // buttonCancel
// this.buttonCancel.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
this.buttonCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
this.buttonCancel.Location = new System.Drawing.Point(295, 459);
this.buttonCancel.Name = ""buttonCancel"";
this.buttonCancel.Size = new System.Drawing.Size(75, 23);
this.buttonCancel.TabIndex = 10;
this.buttonCancel.Text = ""Cancel"";
this.buttonCancel.UseVisualStyleBackColor = true;
this.buttonCancel.Click += new System.EventHandler(this.buttonCancel_Click);
// // splitContainerOuter
// this.splitContainerOuter.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.splitContainerOuter.Location = new System.Drawing.Point(12, 39);
this.splitContainerOuter.Name = ""splitContainerOuter"";
this.splitContainerOuter.Orientation = System.Windows.Forms.Orientation.Horizontal;
// // splitContainerOuter.Panel1
// this.splitContainerOuter.Panel1.Controls.Add(this.groupBoxSourcePlaylist);
// // splitContainerOuter.Panel2
// this.splitContainerOuter.Panel2.Controls.Add(this.groupBoxCustomPlaylist);
this.splitContainerOuter.Size = new System.Drawing.Size(560, 414);
this.splitContainerOuter.SplitterDistance = 257;
this.splitContainerOuter.TabIndex = 21;
// // groupBoxSourcePlaylist
// this.groupBoxSourcePlaylist.Controls.Add(this.buttonAddAll);
this.groupBoxSourcePlaylist.Controls.Add(this.splitContainerInner);
this.groupBoxSourcePlaylist.Controls.Add(this.buttonAdd);
this.groupBoxSourcePlaylist.Dock = System.Windows.Forms.DockStyle.Fill;
this.groupBoxSourcePlaylist.Location = new System.Drawing.Point(0, 0);
this.groupBoxSourcePlaylist.Name = ""groupBoxSourcePlaylist"";
this.groupBoxSourcePlaylist.Size = new System.Drawing.Size(560, 257);
this.groupBoxSourcePlaylist.TabIndex = 21;
this.groupBoxSourcePlaylist.TabStop = false;
this.groupBoxSourcePlaylist.Text = ""Source Playlist:"";
// // buttonAddAll
// this.buttonAddAll.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.buttonAddAll.Enabled = false;
this.buttonAddAll.Location = new System.Drawing.Point(283, 228);
this.buttonAddAll.Name = ""buttonAddAll"";
this.buttonAddAll.Size = new System.Drawing.Size(75, 23);
this.buttonAddAll.TabIndex = 23;
this.buttonAddAll.Text = ""Add All"";
this.buttonAddAll.UseVisualStyleBackColor = true;
this.buttonAddAll.Click += new System.EventHandler(this.buttonAddAll_Click);
// // splitContainerInner
// this.splitContainerInner.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.splitContainerInner.Location = new System.Drawing.Point(6, 19);
this.splitContainerInner.Name = ""splitContainerInner"";
this.splitContainerInner.Orientation = System.Windows.Forms.Orientation.Horizontal;
// // splitContainerInner.Panel1
// this.splitContainerInner.Panel1.Controls.Add(this.listViewPlaylistFiles);
// // splitContainerInner.Panel2
// this.splitContainerInner.Panel2.Controls.Add(this.listViewStreamFiles);
this.splitContainerInner.Size = new System.Drawing.Size(548, 203);
this.splitContainerInner.SplitterDistance = 100;
this.splitContainerInner.TabIndex = 22;
// // listViewPlaylistFiles
// this.listViewPlaylistFiles.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
this.columnHeaderPlaylistName,
this.columnHeaderPlaylistLength,
this.columnHeaderPlaylistEstimatedBytes,
this.columnHeaderPlaylistMeasuredBytes});
this.listViewPlaylistFiles.Dock = System.Windows.Forms.DockStyle.Fill;
this.listViewPlaylistFiles.FullRowSelect = true;
this.listViewPlaylistFiles.HideSelection = false;
this.listViewPlaylistFiles.Location = new System.Drawing.Point(0, 0);
this.listViewPlaylistFiles.MultiSelect = false;
this.listViewPlaylistFiles.Name = ""listViewPlaylistFiles"";
this.listViewPlaylistFiles.Size = new System.Drawing.Size(548, 100);
this.listViewPlaylistFiles.TabIndex = 2;
this.listViewPlaylistFiles.UseCompatibleStateImageBehavior = false;
this.listViewPlaylistFiles.View = System.Windows.Forms.View.Details;
this.listViewPlaylistFiles.ColumnClick += new System.Windows.Forms.ColumnClickEventHandler(this.listViewPlaylistFiles_ColumnClick);
this.listViewPlaylistFiles.SelectedIndexChanged += new System.EventHandler(this.listViewPlaylistFiles_SelectedIndexChanged);
// // columnHeaderPlaylistName
// this.columnHeaderPlaylistName.Text = ""Playlist File"";
this.columnHeaderPlaylistName.Width = 103;
// // columnHeaderPlaylistLength
// this.columnHeaderPlaylistLength.Text = ""Length"";
this.columnHeaderPlaylistLength.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderPlaylistLength.Width = 73;
// // columnHeaderPlaylistEstimatedBytes
// this.columnHeaderPlaylistEstimatedBytes.Text = ""Estimated Bytes"";
this.columnHeaderPlaylistEstimatedBytes.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderPlaylistEstimatedBytes.Width = 98;
// // columnHeaderPlaylistMeasuredBytes
// this.columnHeaderPlaylistMeasuredBytes.Text = ""Measured Bytes"";
this.columnHeaderPlaylistMeasuredBytes.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderPlaylistMeasuredBytes.Width = 125;
// // listViewStreamFiles
// this.listViewStreamFiles.Activation = System.Windows.Forms.ItemActivation.OneClick;
this.listViewStreamFiles.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
this.columnHeaderFileName,
this.columnHeaderFileLength,
this.columnHeaderFileEstimatedBytes,
this.columnHeaderFileMeasuredBytes});
this.listViewStreamFiles.Dock = System.Windows.Forms.DockStyle.Fill;
this.listViewStreamFiles.FullRowSelect = true;
this.listViewStreamFiles.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
this.listViewStreamFiles.HideSelection = false;
this.listViewStreamFiles.Location = new System.Drawing.Point(0, 0);
this.listViewStreamFiles.MultiSelect = false;
this.listViewStreamFiles.Name = ""listViewStreamFiles"";
this.listViewStreamFiles.Size = new System.Drawing.Size(548, 99);
this.listViewStreamFiles.TabIndex = 3;
this.listViewStreamFiles.UseCompatibleStateImageBehavior = false;
this.listViewStreamFiles.View = System.Windows.Forms.View.Details;
this.listViewStreamFiles.SelectedIndexChanged += new System.EventHandler(this.listViewStreamFiles_SelectedIndexChanged);
// // columnHeaderFileName
// this.columnHeaderFileName.Text = ""Stream File"";
this.columnHeaderFileName.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderFileName.Width = 82;
// // columnHeaderFileLength
// this.columnHeaderFileLength.Text = ""Length"";
this.columnHeaderFileLength.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderFileLength.Width = 77;
// // columnHeaderFileEstimatedBytes
// this.columnHeaderFileEstimatedBytes.Text = ""Estimated Bytes"";
this.columnHeaderFileEstimatedBytes.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderFileEstimatedBytes.Width = 119;
// // columnHeaderFileMeasuredBytes
// this.columnHeaderFileMeasuredBytes.Text = ""Measured Bytes"";
this.columnHeaderFileMeasuredBytes.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeaderFileMeasuredBytes.Width = 125;
// // buttonAdd
// this.buttonAdd.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.buttonAdd.Enabled = false;
this.buttonAdd.Location = new System.Drawing.Point(202, 228);
this.buttonAdd.Name = ""buttonAdd"";
this.buttonAdd.Size = new System.Drawing.Size(75, 23);
this.buttonAdd.TabIndex = 4;
this.buttonAdd.Text = ""Add"";
this.buttonAdd.UseVisualStyleBackColor = true;
this.buttonAdd.Click += new System.EventHandler(this.buttonAdd_Click);
// // groupBoxCustomPlaylist
// this.groupBoxCustomPlaylist.Controls.Add(this.buttonDown);
this.groupBoxCustomPlaylist.Controls.Add(this.buttonUp);
this.groupBoxCustomPlaylist.Controls.Add(this.buttonRemove);
this.groupBoxCustomPlaylist.Controls.Add(this.listViewTargetFiles);
this.groupBoxCustomPlaylist.Dock = System.Windows.Forms.DockStyle.Fill;
this.groupBoxCustomPlaylist.Location = new System.Drawing.Point(0, 0);
this.groupBoxCustomPlaylist.Name = ""groupBoxCustomPlaylist"";
this.groupBoxCustomPlaylist.Size = new System.Drawing.Size(560, 153);
this.groupBoxCustomPlaylist.TabIndex = 20;
this.groupBoxCustomPlaylist.TabStop = false;
this.groupBoxCustomPlaylist.Text = ""Custom Playlist:"";
// // buttonDown
// this.buttonDown.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this.buttonDown.Enabled = false;
this.buttonDown.Location = new System.Drawing.Point(87, 122);
this.buttonDown.Name = ""buttonDown"";
this.buttonDown.Size = new System.Drawing.Size(75, 23);
this.buttonDown.TabIndex = 7;
this.buttonDown.Text = ""Move Down"";
this.buttonDown.UseVisualStyleBackColor = true;
this.buttonDown.Click += new System.EventHandler(this.buttonDown_Click);
// // buttonUp
// this.buttonUp.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this.buttonUp.Enabled = false;
this.buttonUp.Location = new System.Drawing.Point(6, 122);
this.buttonUp.Name = ""buttonUp"";
this.buttonUp.Size = new System.Drawing.Size(75, 23);
this.buttonUp.TabIndex = 6;
this.buttonUp.Text = ""Move Up"";
this.buttonUp.UseVisualStyleBackColor = true;
this.buttonUp.Click += new System.EventHandler(this.buttonUp_Click);
// // buttonRemove
// this.buttonRemove.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this.buttonRemove.Enabled = false;
this.buttonRemove.Location = new System.Drawing.Point(243, 122);
this.buttonRemove.Name = ""buttonRemove"";
this.buttonRemove.Size = new System.Drawing.Size(75, 23);
this.buttonRemove.TabIndex = 8;
this.buttonRemove.Text = ""Remove"";
this.buttonRemove.UseVisualStyleBackColor = true;
this.buttonRemove.Click += new System.EventHandler(this.buttonRemove_Click);
// // listViewTargetFiles
// this.listViewTargetFiles.Activation = System.Windows.Forms.ItemActivation.OneClick;
this.listViewTargetFiles.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.listViewTargetFiles.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
this.columnHeader1,
this.columnHeader2,
this.columnHeader3,
this.columnHeader4});
this.listViewTargetFiles.FullRowSelect = true;
this.listViewTargetFiles.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
this.listViewTargetFiles.HideSelection = false;
this.listViewTargetFiles.Location = new System.Drawing.Point(6, 19);
this.listViewTargetFiles.MultiSelect = false;
this.listViewTargetFiles.Name = ""listViewTargetFiles"";
this.listViewTargetFiles.Size = new System.Drawing.Size(548, 97);
this.listViewTargetFiles.TabIndex = 5;
this.listViewTargetFiles.UseCompatibleStateImageBehavior = false;
this.listViewTargetFiles.View = System.Windows.Forms.View.Details;
this.listViewTargetFiles.SelectedIndexChanged += new System.EventHandler(this.listViewTargetFiles_SelectedIndexChanged);
// // columnHeader1
// this.columnHeader1.Text = ""Stream File"";
this.columnHeader1.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeader1.Width = 82;
// // columnHeader2
// this.columnHeader2.Text = ""Length"";
this.columnHeader2.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeader2.Width = 77;
// // columnHeader3
// this.columnHeader3.Text = ""Estimated Bytes"";
this.columnHeader3.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeader3.Width = 119;
// // columnHeader4
// this.columnHeader4.Text = ""Measured Bytes"";
this.columnHeader4.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this.columnHeader4.Width = 125;
// // checkBoxFilterIncompatible
// this.checkBoxFilterIncompatible.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.checkBoxFilterIncompatible.AutoSize = true;
this.checkBoxFilterIncompatible.Checked = true;
this.checkBoxFilterIncompatible.CheckState = System.Windows.Forms.CheckState.Checked;
this.checkBoxFilterIncompatible.Location = new System.Drawing.Point(417, 16);
this.checkBoxFilterIncompatible.Name = ""checkBoxFilterIncompatible"";
this.checkBoxFilterIncompatible.Size = new System.Drawing.Size(149, 17);
this.checkBoxFilterIncompatible.TabIndex = 22;
this.checkBoxFilterIncompatible.Text = ""Filter incombatible playlists"";
this.checkBoxFilterIncompatible.UseVisualStyleBackColor = true;
this.checkBoxFilterIncompatible.CheckedChanged += new System.EventHandler(this.checkBoxFilterIncompatible_CheckedChanged);
// // FormPlaylist
// this.AcceptButton = this.buttonOK;
this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.CancelButton = this.buttonCancel;
this.ClientSize = new System.Drawing.Size(584, 492);
this.Controls.Add(this.checkBoxFilterIncompatible);
this.Controls.Add(this.splitContainerOuter);
this.Controls.Add(this.buttonOK);
this.Controls.Add(this.buttonCancel);
this.Controls.Add(this.textBoxName);
this.Name = ""FormPlaylist"";
this.Text = ""BDInfo Custom Playlist"";
this.Load += new System.EventHandler(this.FormPlaylist_Load);
this.Resize += new System.EventHandler(this.FormPlaylist_Resize);
this.splitContainerOuter.Panel1.ResumeLayout(false);
this.splitContainerOuter.Panel2.ResumeLayout(false);
this.splitContainerOuter.ResumeLayout(false);
this.groupBoxSourcePlaylist.ResumeLayout(false);
this.splitContainerInner.Panel1.ResumeLayout(false);
this.splitContainerInner.Panel2.ResumeLayout(false);
this.splitContainerInner.ResumeLayout(false);
this.groupBoxCustomPlaylist.ResumeLayout(false);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2545,"private void InitializeComponent()
{
this.buttonCopy = new System.Windows.Forms.Button();
this.textBoxReport = new System.Windows.Forms.TextBox();
this.buttonChart = new System.Windows.Forms.Button();
this.labelChartType = new System.Windows.Forms.Label();
this.comboBoxChartType = new System.Windows.Forms.ComboBox();
this.labelStream = new System.Windows.Forms.Label();
this.comboBoxStream = new System.Windows.Forms.ComboBox();
this.labelAngle = new System.Windows.Forms.Label();
this.comboBoxAngle = new System.Windows.Forms.ComboBox();
this.labelPlaylist = new System.Windows.Forms.Label();
this.comboBoxPlaylist = new System.Windows.Forms.ComboBox();
this.SuspendLayout();
// // buttonCopy
// this.buttonCopy.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
this.buttonCopy.Location = new System.Drawing.Point(285, 457);
this.buttonCopy.Name = ""buttonCopy"";
this.buttonCopy.Size = new System.Drawing.Size(122, 23);
this.buttonCopy.TabIndex = 6;
this.buttonCopy.Text = ""Copy to Clipboard"";
this.buttonCopy.UseVisualStyleBackColor = true;
this.buttonCopy.Click += new System.EventHandler(this.buttonCopy_Click);
// // textBoxReport
// this.textBoxReport.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this.textBoxReport.Font = new System.Drawing.Font(""Courier New"", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
this.textBoxReport.Location = new System.Drawing.Point(12, 51);
this.textBoxReport.MaxLength = 0;
this.textBoxReport.Multiline = true;
this.textBoxReport.Name = ""textBoxReport"";
this.textBoxReport.ScrollBars = System.Windows.Forms.ScrollBars.Both;
this.textBoxReport.Size = new System.Drawing.Size(668, 400);
this.textBoxReport.TabIndex = 5;
this.textBoxReport.WordWrap = false;
this.textBoxReport.KeyDown += new System.Windows.Forms.KeyEventHandler(this.textBoxReport_KeyDown);
// // buttonChart
// this.buttonChart.Location = new System.Drawing.Point(452, 22);
this.buttonChart.Name = ""buttonChart"";
this.buttonChart.Size = new System.Drawing.Size(122, 23);
this.buttonChart.TabIndex = 4;
this.buttonChart.Text = ""Generate Chart..."";
this.buttonChart.UseVisualStyleBackColor = true;
this.buttonChart.Click += new System.EventHandler(this.buttonChart_Click);
// // labelChartType
// this.labelChartType.AutoSize = true;
this.labelChartType.Location = new System.Drawing.Point(266, 8);
this.labelChartType.Name = ""labelChartType"";
this.labelChartType.Size = new System.Drawing.Size(62, 13);
this.labelChartType.TabIndex = 47;
this.labelChartType.Text = ""Chart Type:"";
// // comboBoxChartType
// this.comboBoxChartType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this.comboBoxChartType.FormattingEnabled = true;
this.comboBoxChartType.Items.AddRange(new object[] {
""Video Bitrate: 1-Second Window"",
""Video Bitrate: 5-Second Window"",
""Video Bitrate: 10-Second Window"",
""Video Frame Size (Min / Max)"",
""Video Frame Type Counts"",
""Video Frame Type Sizes""});
this.comboBoxChartType.Location = new System.Drawing.Point(266, 24);
this.comboBoxChartType.Name = ""comboBoxChartType"";
this.comboBoxChartType.Size = new System.Drawing.Size(180, 21);
this.comboBoxChartType.TabIndex = 3;
// // labelStream
// this.labelStream.AutoSize = true;
this.labelStream.Location = new System.Drawing.Point(117, 8);
this.labelStream.Name = ""labelStream"";
this.labelStream.Size = new System.Drawing.Size(43, 13);
this.labelStream.TabIndex = 45;
this.labelStream.Text = ""Stream:"";
// // comboBoxStream
// this.comboBoxStream.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this.comboBoxStream.FormattingEnabled = true;
this.comboBoxStream.Location = new System.Drawing.Point(117, 24);
this.comboBoxStream.Name = ""comboBoxStream"";
this.comboBoxStream.Size = new System.Drawing.Size(99, 21);
this.comboBoxStream.TabIndex = 1;
// // labelAngle
// this.labelAngle.AutoSize = true;
this.labelAngle.Location = new System.Drawing.Point(222, 8);
this.labelAngle.Name = ""labelAngle"";
this.labelAngle.Size = new System.Drawing.Size(37, 13);
this.labelAngle.TabIndex = 43;
this.labelAngle.Text = ""Angle:"";
// // comboBoxAngle
// this.comboBoxAngle.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this.comboBoxAngle.FormattingEnabled = true;
this.comboBoxAngle.Location = new System.Drawing.Point(222, 24);
this.comboBoxAngle.Name = ""comboBoxAngle"";
this.comboBoxAngle.Size = new System.Drawing.Size(38, 21);
this.comboBoxAngle.TabIndex = 2;
// // labelPlaylist
// this.labelPlaylist.AutoSize = true;
this.labelPlaylist.Location = new System.Drawing.Point(12, 8);
this.labelPlaylist.Name = ""labelPlaylist"";
this.labelPlaylist.Size = new System.Drawing.Size(42, 13);
this.labelPlaylist.TabIndex = 41;
this.labelPlaylist.Text = ""Playlist:"";
// // comboBoxPlaylist
// this.comboBoxPlaylist.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this.comboBoxPlaylist.FormattingEnabled = true;
this.comboBoxPlaylist.Location = new System.Drawing.Point(12, 24);
this.comboBoxPlaylist.Name = ""comboBoxPlaylist"";
this.comboBoxPlaylist.Size = new System.Drawing.Size(99, 21);
this.comboBoxPlaylist.TabIndex = 0;
this.comboBoxPlaylist.SelectedIndexChanged += new System.EventHandler(this.comboBoxPlaylist_SelectedIndexChanged);
// // FormReport
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ClientSize = new System.Drawing.Size(692, 492);
this.Controls.Add(this.buttonChart);
this.Controls.Add(this.labelChartType);
this.Controls.Add(this.comboBoxChartType);
this.Controls.Add(this.labelStream);
this.Controls.Add(this.comboBoxStream);
this.Controls.Add(this.labelAngle);
this.Controls.Add(this.comboBoxAngle);
this.Controls.Add(this.labelPlaylist);
this.Controls.Add(this.comboBoxPlaylist);
this.Controls.Add(this.buttonCopy);
this.Controls.Add(this.textBoxReport);
this.Name = ""FormReport"";
this.Text = ""BDInfo Report"";
this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.FormReport_FormClosed);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2546,"private void InitializeComponent()
{
this.checkBoxFilterLoopingPlaylists = new System.Windows.Forms.CheckBox();
this.checkBoxAutosaveReport = new System.Windows.Forms.CheckBox();
this.buttonCancel = new System.Windows.Forms.Button();
this.buttonOK = new System.Windows.Forms.Button();
this.checkBoxGenerateStreamDiagnostics = new System.Windows.Forms.CheckBox();
this.checkBoxKeepStreamOrder = new System.Windows.Forms.CheckBox();
this.checkBoxGenerateTextSummary = new System.Windows.Forms.CheckBox();
this.checkBoxFilterShortPlaylists = new System.Windows.Forms.CheckBox();
this.textBoxFilterShortPlaylistsValue = new System.Windows.Forms.TextBox();
this.labelPlaylistLength = new System.Windows.Forms.Label();
this.checkBoxUseImagePrefix = new System.Windows.Forms.CheckBox();
this.textBoxUseImagePrefixValue = new System.Windows.Forms.TextBox();
this.checkBoxEnableSSIF = new System.Windows.Forms.CheckBox();
this.SuspendLayout();
// // checkBoxFilterLoopingPlaylists
// this.checkBoxFilterLoopingPlaylists.AutoSize = true;
this.checkBoxFilterLoopingPlaylists.Checked = true;
this.checkBoxFilterLoopingPlaylists.CheckState = System.Windows.Forms.CheckState.Checked;
this.checkBoxFilterLoopingPlaylists.Location = new System.Drawing.Point(11, 99);
this.checkBoxFilterLoopingPlaylists.Name = ""checkBoxFilterLoopingPlaylists"";
this.checkBoxFilterLoopingPlaylists.Size = new System.Drawing.Size(177, 17);
this.checkBoxFilterLoopingPlaylists.TabIndex = 3;
this.checkBoxFilterLoopingPlaylists.Text = ""Filter playlists that contain loops."";
this.checkBoxFilterLoopingPlaylists.UseVisualStyleBackColor = true;
// // checkBoxAutosaveReport
// this.checkBoxAutosaveReport.AutoSize = true;
this.checkBoxAutosaveReport.Location = new System.Drawing.Point(11, 53);
this.checkBoxAutosaveReport.Name = ""checkBoxAutosaveReport"";
this.checkBoxAutosaveReport.Size = new System.Drawing.Size(202, 17);
this.checkBoxAutosaveReport.TabIndex = 2;
this.checkBoxAutosaveReport.Text = ""Auto-save report on scan completion."";
this.checkBoxAutosaveReport.UseVisualStyleBackColor = true;
// // buttonCancel
// this.buttonCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
this.buttonCancel.Location = new System.Drawing.Point(126, 196);
this.buttonCancel.Name = ""buttonCancel"";
this.buttonCancel.Size = new System.Drawing.Size(75, 23);
this.buttonCancel.TabIndex = 6;
this.buttonCancel.Text = ""Cancel"";
this.buttonCancel.UseVisualStyleBackColor = true;
this.buttonCancel.Click += new System.EventHandler(this.buttonCancel_Click);
// // buttonOK
// this.buttonOK.Location = new System.Drawing.Point(45, 196);
this.buttonOK.Name = ""buttonOK"";
this.buttonOK.Size = new System.Drawing.Size(75, 23);
this.buttonOK.TabIndex = 5;
this.buttonOK.Text = ""OK"";
this.buttonOK.UseVisualStyleBackColor = true;
this.buttonOK.Click += new System.EventHandler(this.buttonOK_Click);
// // checkBoxGenerateStreamDiagnostics
// this.checkBoxGenerateStreamDiagnostics.AutoSize = true;
this.checkBoxGenerateStreamDiagnostics.Checked = true;
this.checkBoxGenerateStreamDiagnostics.CheckState = System.Windows.Forms.CheckState.Checked;
this.checkBoxGenerateStreamDiagnostics.Location = new System.Drawing.Point(11, 7);
this.checkBoxGenerateStreamDiagnostics.Name = ""checkBoxGenerateStreamDiagnostics"";
this.checkBoxGenerateStreamDiagnostics.Size = new System.Drawing.Size(195, 17);
this.checkBoxGenerateStreamDiagnostics.TabIndex = 0;
this.checkBoxGenerateStreamDiagnostics.Text = ""Include stream diagnostics in report."";
this.checkBoxGenerateStreamDiagnostics.UseVisualStyleBackColor = true;
// // checkBoxKeepStreamOrder
// this.checkBoxKeepStreamOrder.AutoSize = true;
this.checkBoxKeepStreamOrder.Location = new System.Drawing.Point(11, 76);
this.checkBoxKeepStreamOrder.Name = ""checkBoxKeepStreamOrder"";
this.checkBoxKeepStreamOrder.Size = new System.Drawing.Size(165, 17);
this.checkBoxKeepStreamOrder.TabIndex = 4;
this.checkBoxKeepStreamOrder.Text = ""Keep original stream ordering."";
this.checkBoxKeepStreamOrder.UseVisualStyleBackColor = true;
// // checkBoxGenerateTextSummary
// this.checkBoxGenerateTextSummary.AutoSize = true;
this.checkBoxGenerateTextSummary.Checked = true;
this.checkBoxGenerateTextSummary.CheckState = System.Windows.Forms.CheckState.Checked;
this.checkBoxGenerateTextSummary.Location = new System.Drawing.Point(11, 30);
this.checkBoxGenerateTextSummary.Name = ""checkBoxGenerateTextSummary"";
this.checkBoxGenerateTextSummary.Size = new System.Drawing.Size(198, 17);
this.checkBoxGenerateTextSummary.TabIndex = 1;
this.checkBoxGenerateTextSummary.Text = ""Include quick text summary in report."";
this.checkBoxGenerateTextSummary.UseVisualStyleBackColor = true;
// // checkBoxFilterShortPlaylists
// this.checkBoxFilterShortPlaylists.AutoSize = true;
this.checkBoxFilterShortPlaylists.Checked = true;
this.checkBoxFilterShortPlaylists.CheckState = System.Windows.Forms.CheckState.Checked;
this.checkBoxFilterShortPlaylists.Location = new System.Drawing.Point(11, 122);
this.checkBoxFilterShortPlaylists.Name = ""checkBoxFilterShortPlaylists"";
this.checkBoxFilterShortPlaylists.Size = new System.Drawing.Size(153, 17);
this.checkBoxFilterShortPlaylists.TabIndex = 7;
this.checkBoxFilterShortPlaylists.Text = ""Filter playlists with length < "";
this.checkBoxFilterShortPlaylists.UseVisualStyleBackColor = true;
// // textBoxFilterShortPlaylistsValue
// this.textBoxFilterShortPlaylistsValue.Location = new System.Drawing.Point(160, 120);
this.textBoxFilterShortPlaylistsValue.MaxLength = 4;
this.textBoxFilterShortPlaylistsValue.Name = ""textBoxFilterShortPlaylistsValue"";
this.textBoxFilterShortPlaylistsValue.Size = new System.Drawing.Size(41, 20);
this.textBoxFilterShortPlaylistsValue.TabIndex = 8;
this.textBoxFilterShortPlaylistsValue.Text = ""20"";
// // labelPlaylistLength
// this.labelPlaylistLength.AutoSize = true;
this.labelPlaylistLength.Location = new System.Drawing.Point(202, 124);
this.labelPlaylistLength.Name = ""labelPlaylistLength"";
this.labelPlaylistLength.Size = new System.Drawing.Size(24, 13);
this.labelPlaylistLength.TabIndex = 9;
this.labelPlaylistLength.Text = ""sec"";
// // checkBoxUseImagePrefix
// this.checkBoxUseImagePrefix.AutoSize = true;
this.checkBoxUseImagePrefix.Location = new System.Drawing.Point(11, 145);
this.checkBoxUseImagePrefix.Name = ""checkBoxUseImagePrefix"";
this.checkBoxUseImagePrefix.Size = new System.Drawing.Size(104, 17);
this.checkBoxUseImagePrefix.TabIndex = 10;
this.checkBoxUseImagePrefix.Text = ""Use image prefix"";
this.checkBoxUseImagePrefix.UseVisualStyleBackColor = true;
// // textBoxUseImagePrefixValue
// this.textBoxUseImagePrefixValue.Location = new System.Drawing.Point(113, 143);
this.textBoxUseImagePrefixValue.MaxLength = 4;
this.textBoxUseImagePrefixValue.Name = ""textBoxUseImagePrefixValue"";
this.textBoxUseImagePrefixValue.Size = new System.Drawing.Size(113, 20);
this.textBoxUseImagePrefixValue.TabIndex = 11;
this.textBoxUseImagePrefixValue.Text = ""video-"";
// // checkBoxEnableSSIF
// this.checkBoxEnableSSIF.AutoSize = true;
this.checkBoxEnableSSIF.Location = new System.Drawing.Point(11, 168);
this.checkBoxEnableSSIF.Name = ""checkBoxEnableSSIF"";
this.checkBoxEnableSSIF.Size = new System.Drawing.Size(134, 17);
this.checkBoxEnableSSIF.TabIndex = 12;
this.checkBoxEnableSSIF.Text = ""Enable SSIF scanning."";
this.checkBoxEnableSSIF.UseVisualStyleBackColor = true;
// // FormSettings
// this.AcceptButton = this.buttonOK;
this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.CancelButton = this.buttonCancel;
this.ClientSize = new System.Drawing.Size(243, 231);
this.Controls.Add(this.checkBoxEnableSSIF);
this.Controls.Add(this.textBoxUseImagePrefixValue);
this.Controls.Add(this.checkBoxUseImagePrefix);
this.Controls.Add(this.labelPlaylistLength);
this.Controls.Add(this.textBoxFilterShortPlaylistsValue);
this.Controls.Add(this.checkBoxFilterShortPlaylists);
this.Controls.Add(this.checkBoxGenerateTextSummary);
this.Controls.Add(this.checkBoxKeepStreamOrder);
this.Controls.Add(this.checkBoxFilterLoopingPlaylists);
this.Controls.Add(this.checkBoxAutosaveReport);
this.Controls.Add(this.buttonCancel);
this.Controls.Add(this.buttonOK);
this.Controls.Add(this.checkBoxGenerateStreamDiagnostics);
this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
this.MaximizeBox = false;
this.Name = ""FormSettings"";
this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
this.Text = ""BDInfo Settings"";
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2547,"public int Move( int index, int relativePos )
{
if ( index < 0 || index >= Count )
return -1;
GraphObj graphObj = this[index];
this.RemoveAt( index );
index += relativePos;
if ( index < 0 )
index = 0;
if ( index > Count )
index = Count;
Insert( index, graphObj );
return index;
}","For Graphic type objects, this method controls the Z-Order of the items. Objects at the beginning of the list appear in front of objects at the end of the list.",1
2548,"public RectangleF CalcChartRect( Graphics g )
{
// Calculate the chart rect, deducting the area for the scales, titles, legend, etc.
//int	hStack;
//float	legendWidth, legendHeight;
return CalcChartRect( g, CalcScaleFactor() );
}","The ChartRect is the plot area bounded by the axes, and the rect is the total area as specified by the client application.",1
2549,"public RectangleF CalcChartRect( Graphics g, float scaleFactor )
{
// chart rect starts out at the full pane rect less the margins
// and less space for the Pane title
RectangleF clientRect = this.CalcClientRect( g, scaleFactor );
//float minSpaceX = 0;
//float minSpaceY = 0;
//float minSpaceY2 = 0;
float totSpaceY = 0;
//float spaceY2 = 0;
// actual minimum axis space for the left side of the chart rect
float minSpaceL = 0;
// actual minimum axis space for the right side of the chart rect
float minSpaceR = 0;
// actual minimum axis space for the bottom side of the chart rect
float minSpaceB = 0;
// actual minimum axis space for the top side of the chart rect
float minSpaceT = 0;
_xAxis.CalcSpace( g, this, scaleFactor, out minSpaceB );
_x2Axis.CalcSpace( g, this, scaleFactor, out minSpaceT );
//minSpaceB = _xAxis.tmpMinSpace;
foreach ( Axis axis in _yAxisList )
{
float fixedSpace;
float tmp = axis.CalcSpace( g, this, scaleFactor, out fixedSpace );
//if ( !axis.CrossAuto || axis.Cross < _xAxis.Min )
if ( axis.IsCrossShifted( this ) )
totSpaceY += tmp;
minSpaceL += fixedSpace;
}
foreach ( Axis axis in _y2AxisList )
{
float fixedSpace;
float tmp = axis.CalcSpace( g, this, scaleFactor, out fixedSpace );
//if ( !axis.CrossAuto || axis.Cross < _xAxis.Min )
if ( axis.IsCrossShifted( this ) )
totSpaceY += tmp;
minSpaceR += fixedSpace;
}
float spaceB = 0, spaceT = 0, spaceL = 0, spaceR = 0;
SetSpace( _xAxis, clientRect.Height - _xAxis._tmpSpace, ref spaceB, ref spaceT );
//	minSpaceT = Math.Max( minSpaceT, spaceT );
SetSpace( _x2Axis, clientRect.Height - _x2Axis._tmpSpace, ref spaceT, ref spaceB );
_xAxis._tmpSpace = spaceB;
_x2Axis._tmpSpace = spaceT;
float totSpaceL = 0;
float totSpaceR = 0;
foreach ( Axis axis in _yAxisList )
{
SetSpace( axis, clientRect.Width - totSpaceY, ref spaceL, ref spaceR );
minSpaceR = Math.Max( minSpaceR, spaceR );
totSpaceL += spaceL;
axis._tmpSpace = spaceL;
}
foreach ( Axis axis in _y2AxisList )
{
SetSpace( axis, clientRect.Width - totSpaceY, ref spaceR, ref spaceL );
minSpaceL = Math.Max( minSpaceL, spaceL );
totSpaceR += spaceR;
axis._tmpSpace = spaceR;
}
RectangleF tmpRect = clientRect;
totSpaceL = Math.Max( totSpaceL, minSpaceL );
totSpaceR = Math.Max( totSpaceR, minSpaceR );
spaceB = Math.Max( spaceB, minSpaceB );
spaceT = Math.Max( spaceT, minSpaceT );
tmpRect.X += totSpaceL;
tmpRect.Width -= totSpaceL + totSpaceR;
tmpRect.Height -= spaceT + spaceB;
tmpRect.Y += spaceT;
_legend.CalcRect( g, this, scaleFactor, ref tmpRect );
return tmpRect;
}","The ChartRect is the plot area bounded by the axes, and the rect is the total area as specified by the client application.",1
2550,"public Link()
{
_title = string.Empty;
_url = string.Empty;
_target = string.Empty;
this.Tag = null;
_isEnabled = false;
}","Default constructor. Set all properties to string.Empty, or null.",1
2551,"public Location( double x, double y, CoordType coordType ) :
this( x, y, coordType, AlignH.Left, AlignV.Top )
{
}","The (x,y) position corresponds to the top-left corner;",1
2552,"public Location( double x, double y, CoordType coordType, AlignH alignH, AlignV alignV )
{
_x = x;
_y = y;
_width = 0;
_height = 0;
_coordinateFrame = coordType;
_alignH = alignH;
_alignV = alignV;
}","The (x,y) position corresponds to the top-left corner;",1
2553,"public PointF TransformBottomRight( PaneBase pane )
{
return Transform( pane, this.X2, this.Y2, _coordinateFrame );
}",A PointF in pixel units.,1
2554,"public RectangleF TransformRect( PaneBase pane )
{
PointF pix1 = TransformTopLeft( pane );
PointF pix2 = TransformBottomRight( pane );
//PointF pix3 = TransformTopLeft( pane, pix2.X - pix1.X, pix2.Y - pix1.Y );
return new RectangleF( pix1.X, pix1.Y, Math.Abs(pix2.X - pix1.X), Math.Abs(pix2.Y - pix1.Y) );
}",A RectangleF in pixel units.,1
2555,"public void SetLayout( Graphics g, bool isColumnSpecified, int[] countList )
{
SetLayout( g, isColumnSpecified, countList, null );
}","This method specifies the number of rows in each column, or the number of columns in each row, allowing for irregular layouts. Overloads are available that provide other layout options.",1
2556,"public void SetLayout( Graphics g, bool isColumnSpecified, int[] countList, float[] proportion )
{
InitLayout();
// use defaults if the parameters are invalid
if ( countList != null && countList.Length > 0 )
{
_prop = new float[countList.Length];
// Sum up the total proportional factors
float sumProp = 0.0f;
for ( int i = 0; i < countList.Length; i++ )
{
_prop[i] = ( proportion == null || proportion.Length <= i || proportion[i] < 1e-10 ) ?
1.0f : proportion[i];
sumProp += _prop[i];
}
// Make prop sum to 1.0
for ( int i = 0; i < countList.Length; i++ )
_prop[i] /= sumProp;
_isColumnSpecified = isColumnSpecified;
_countList = countList;
DoLayout( g );
}
}","This method specifies the number of panes in each row or column, allowing for irregular layouts.",1
2557,"public NoDupePointList()
{
_isFiltered = false;
_filteredCount = 0;
_visibleIndicies = null;
_filterMode = 0;
}",default constructor,1
2558,"public PaneBase ShallowClone()
{
// return a shallow copy
return this.MemberwiseClone() as PaneBase;
}","Note that this method uses MemberWiseClone, which will copy all members (shallow) including those of classes derived from this class.",1
2559,"public Bitmap GetImage( bool isAntiAlias )
{
Bitmap bitmap = new Bitmap( (int) _rect.Width, (int) _rect.Height );
using ( Graphics bitmapGraphics = Graphics.FromImage( bitmap ) )
{
bitmapGraphics.TranslateTransform( -_rect.Left, -_rect.Top );
this.Draw( bitmapGraphics );
}
return bitmap;
}",A Bitmap object rendered with the current graph.,1
2560,"public void SetLayout( bool isColumnSpecified, int[] countList )
{
SetLayout( isColumnSpecified, countList, null );
}","This method specifies the number of rows in each column, or the number of columns in each row, allowing for irregular layouts. Overloads are available that provide other layout options.",1
2561,"public void SetLayout( bool isColumnSpecified, int[] countList, float[] proportion )
{
Init();
// use defaults if the parameters are invalid
if ( countList != null && countList.Length > 0 )
{
this._prop = new float[countList.Length];
// Sum up the total proportional factors
float sumProp = 0.0f;
for ( int i = 0; i < countList.Length; i++ )
{
this._prop[i] = ( proportion == null || proportion.Length <= i || proportion[i] < 1e-10 ) ?
1.0f : proportion[i];
sumProp += this._prop[i];
}
// Make prop sum to 1.0
for ( int i=0; i<countList.Length; i++ )
this._prop[i] /= sumProp;
_isColumnSpecified = isColumnSpecified;
_countList = countList;
}
}","This method specifies the number of panes in each row or column, allowing for irregular layouts.",1
2562,"public int IndexOf( string title )
{
int index = 0;
foreach ( GraphPane pane in this )
{
if ( String.Compare( pane.Title.Text, title, true ) == 0 )
return index;
index++;
}
return -1;
}","The comparison of titles is not case sensitive, but it must include all characters including punctuation, spaces, etc.",1
2563,"static void Main(string[] args)
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new FormMain(args));
}",The main entry point for the application.,1
2564,"public RadarPointList( RadarPointList rhs )
{
for ( int i = 0; i < rhs.Count; i++ )
this.Add( rhs.GetAt(i) );
}",Copy Constructor,1
2565,"public SampleMultiPointList()
{
XData = PerfDataType.Time;
YData = PerfDataType.Distance;
DataCollection = new ArrayList();
}",Default constructor,1
2566,"public SamplePointList()
{
XType = SampleType.Time;
YType = SampleType.Position;
list = new ArrayList();
}",default constructor,1
2567,"virtual public void PickScale( GraphPane pane, Graphics g, float scaleFactor )
{
double minVal = _rangeMin;
double maxVal = _rangeMax;
// Make sure that minVal and maxVal are legitimate values
if ( Double.IsInfinity( minVal ) || Double.IsNaN( minVal ) || minVal == Double.MaxValue )
minVal = 0.0;
if ( Double.IsInfinity( maxVal ) || Double.IsNaN( maxVal ) || maxVal == Double.MaxValue )
maxVal = 0.0;
// if the scales are autoranged, use the actual data values for the range
double range = maxVal - minVal;
// ""Grace"" is applied to the numeric axis types only
bool numType = !this.IsAnyOrdinal;
// For autoranged values, assign the value. If appropriate, adjust the value by the
// ""Grace"" value.
if ( _minAuto )
{
_min = minVal;
// Do not let the grace value extend the axis below zero when all the values were positive
if ( numType && ( _min < 0 || minVal - _minGrace * range >= 0.0 ) )
_min = minVal - _minGrace * range;
}
if ( _maxAuto )
{
_max = maxVal;
// Do not let the grace value extend the axis above zero when all the values were negative
if ( numType && ( _max > 0 || maxVal + _maxGrace * range <= 0.0 ) )
_max = maxVal + _maxGrace * range;
}
if ( _max == _min && _maxAuto && _minAuto )
{
if ( Math.Abs( _max ) > 1e-100 )
{
_max *= ( _min < 0 ? 0.95 : 1.05 );
_min *= ( _min < 0 ? 1.05 : 0.95 );
}
else
{
_max = 1.0;
_min = -1.0;
}
}
if ( _max <= _min )
{
if ( _maxAuto )
_max = _min + 1.0;
else if ( _minAuto )
_min = _max - 1.0;
}
}",On Exit:,0
2568,"public int CalcMaxLabels( Graphics g, GraphPane pane, float scaleFactor )
{
SizeF size = this.GetScaleMaxSpace( g, pane, scaleFactor, false );
// The font angles are already set such that the Width is parallel to the appropriate (X or Y)
// axis. Therefore, we always use size.Width.
// use the minimum of 1/4 the max Width or 1 character space
//	double allowance = this.Scale.FontSpec.GetWidth( g, scaleFactor );
//	if ( allowance > size.Width / 4 )
//	allowance = size.Width / 4;
float maxWidth = 1000;
float temp = 1000;
float costh = (float) Math.Abs( Math.Cos( _fontSpec.Angle * Math.PI / 180.0 ) );
float sinth = (float) Math.Abs( Math.Sin( _fontSpec.Angle * Math.PI / 180.0 ) );
if ( costh > 0.001 )
maxWidth = size.Width / costh;
if ( sinth > 0.001 )
temp = size.Height / sinth;
if ( temp < maxWidth )
maxWidth = temp;
//maxWidth = size.Width;
/*
if ( this is XAxis )
// Add an extra character width to leave a minimum of 1 character space between labels
maxWidth = size.Width + this.Scale.FontSpec.GetWidth( g, scaleFactor );
else
// For vertical spacing, we only need 1/2 character
maxWidth = size.Width + this.Scale.FontSpec.GetWidth( g, scaleFactor ) / 2.0;
*/
if ( maxWidth <= 0 )
maxWidth = 1;
// Calculate the maximum number of labels
double width;
RectangleF chartRect = pane.Chart._rect;
if ( _ownerAxis is XAxis || _ownerAxis is X2Axis )
width = ( chartRect.Width == 0 ) ? pane.Rect.Width * 0.75 : chartRect.Width;
else
width = ( chartRect.Height == 0 ) ? pane.Rect.Height * 0.75 : chartRect.Height;
int maxLabels = (int) ( width / maxWidth );
if ( maxLabels <= 0 )
maxLabels = 1;
return maxLabels;
}","This method works for both X and Y direction axes, and it works for angled text (assuming that a bounding box is an appropriate measure). Technically, labels at 45 degree angles could fit better than the return value of this method since the bounding boxes can overlap without the labels actually overlapping.",1
2569,"public struct ScrollRange
{
private bool _isScrollable;
private double _min;
private double _max;
/// <summary>
/// Construct a <see cref=""ScrollRange"" /> object given the specified data values.
/// </summary>
/// <param name=""min"">The minimum axis value limit for the scroll bar</param>
/// <param name=""max"">The maximum axis value limit for the scroll bar</param>
/// <param name=""isScrollable"">true to make this item scrollable, false otherwise</param>
public ScrollRange( double min, double max, bool isScrollable )
{
_min = min;
_max = max;
_isScrollable = isScrollable;
}
/// <summary>
/// Sets the scroll range to default values of zero, and sets the <see cref=""IsScrollable"" />
/// property as specified.
/// </summary>
/// <param name=""isScrollable"">true to make this item scrollable, false otherwise</param>
public ScrollRange( bool isScrollable )
{
_min = 0.0;
_max = 0.0;
_isScrollable = isScrollable;
}
/// <summary>
/// The Copy Constructor
/// </summary>
/// <param name=""rhs"">The <see cref=""ScrollRange""/> object from which to copy</param>
public ScrollRange( ScrollRange rhs )
{
_min = rhs._min;
_max = rhs._max;
_isScrollable = rhs._isScrollable;
}
/// <summary>
/// Gets or sets a property that determines if the <see cref=""Axis"" /> corresponding to
/// this <see cref=""ScrollRange"" /> object can be scrolled.
/// </summary>
public bool IsScrollable
{
get { return _isScrollable; }
set { _isScrollable = value; }
}
/// <summary>
/// The minimum axis value limit for the scroll bar.
/// </summary>
public double Min
{
get { return _min; }
set { _min = value; }
}
/// <summary>
/// The maximum axis value limit for the scroll bar.
/// </summary>
public double Max
{
get { return _max; }
set { _max = value; }
}
}",A simple struct to store minimum and maximum double type values for the scroll range,1
2570,"public ScrollRangeList()
{
}",Default constructor for the collection class.,0
2571,"public StockPointList()
{
}",Default constructor for the collection class,0
2572,"public bool GetValues( CurveItem curve, int iPt, out double baseVal,
out double lowVal, out double hiVal )
{
return GetValues( _pane, curve, iPt, out baseVal,
out lowVal, out hiVal );
}","The main purpose of this method is to handle stacked bars, in which case the stacked values are returned rather than the individual data values.",1
2573,"public static bool GetValues( GraphPane pane, CurveItem curve, int iPt,
out double baseVal, out double lowVal, out double hiVal )
{
hiVal = PointPair.Missing;
lowVal = PointPair.Missing;
baseVal = PointPair.Missing;
if ( curve == null || curve.Points.Count <= iPt || !curve.IsVisible )
return false;
Axis baseAxis = curve.BaseAxis( pane );
Axis valueAxis = curve.ValueAxis( pane );
if ( baseAxis is XAxis || baseAxis is X2Axis )
baseVal = curve.Points[iPt].X;
else
baseVal = curve.Points[iPt].Y;
// is it a stacked bar type?
if ( curve is BarItem && ( pane._barSettings.Type == BarType.Stack ||
pane._barSettings.Type == BarType.PercentStack ) )
{
double positiveStack = 0;
double negativeStack = 0;
double curVal;
// loop through all the curves, summing up the values to get a total (only
// for the current ordinal position iPt)
foreach ( CurveItem tmpCurve in pane.CurveList )
{
// Sum the value for the current curve only if it is a bar
if ( tmpCurve.IsBar && tmpCurve.IsVisible )
{
curVal = PointPair.Missing;
// For non-ordinal curves, find a matching base value (must match exactly)
if ( curve.IsOverrideOrdinal || !baseAxis._scale.IsAnyOrdinal )
{
IPointList points = tmpCurve.Points;
for ( int i=0; i<points.Count; i++ )
{
if ( ( baseAxis is XAxis || baseAxis is X2Axis ) && points[i].X == baseVal )
{
curVal = points[i].Y;
break;
}
else if ( !(baseAxis is XAxis || baseAxis is X2Axis) && points[i].Y == baseVal )
{
curVal = points[i].X;
break;
}
}
}
// otherwise, it's an ordinal type so use the value at the same ordinal position
else if ( iPt < tmpCurve.Points.Count )
{
// Get the value for the appropriate value axis
if ( baseAxis is XAxis || baseAxis is X2Axis )
curVal = tmpCurve.Points[iPt].Y;
else
curVal = tmpCurve.Points[iPt].X;
}
// If it's a missing value, skip it
if ( curVal == PointPair.Missing )
{
positiveStack = PointPair.Missing;
negativeStack = PointPair.Missing;
}
// the current curve is the target curve, save the summed values for later
if ( tmpCurve == curve )
{
// if the value is positive, use the positive stack
if ( curVal >= 0 )
{
lowVal = positiveStack;
hiVal = ( curVal == PointPair.Missing || positiveStack == PointPair.Missing ) ?
PointPair.Missing : positiveStack + curVal;
}
// otherwise, use the negative stack
else
{
hiVal = negativeStack;
lowVal = ( curVal == PointPair.Missing || negativeStack == PointPair.Missing ) ?
PointPair.Missing : negativeStack + curVal;
}
}
// Add all positive values to the positive stack, and negative values to the
// negative stack
if ( curVal >= 0 )
positiveStack = ( curVal == PointPair.Missing || positiveStack == PointPair.Missing ) ?
PointPair.Missing : positiveStack + curVal;
else
negativeStack = ( curVal == PointPair.Missing || negativeStack == PointPair.Missing ) ?
PointPair.Missing : negativeStack + curVal;
}
}
// if the curve is a PercentStack type, then calculate the percent for this bar
// based on the total height of the stack
if ( pane._barSettings.Type == BarType.PercentStack &&
hiVal != PointPair.Missing && lowVal != PointPair.Missing )
{
// Use the total magnitude of the positive plus negative bar stacks to determine
// the percentage value
positiveStack += Math.Abs( negativeStack );
// just to avoid dividing by zero...
if ( positiveStack != 0 )
{
// calculate the percentage values
lowVal = lowVal / positiveStack * 100.0;
hiVal = hiVal / positiveStack * 100.0;
}
else
{
lowVal = 0;
hiVal = 0;
}
}
if ( baseVal == PointPair.Missing || lowVal == PointPair.Missing ||
hiVal == PointPair.Missing )
return false;
else
return true;
}
// If the curve is a stacked line type, then sum up the values similar to the stacked bar type
else if ( curve is LineItem && pane.LineType == LineType.Stack )
{
double stack = 0;
double curVal;
// loop through all the curves, summing up the values to get a total (only
// for the current ordinal position iPt)
foreach ( CurveItem tmpCurve in pane.CurveList )
{
// make sure the curve is a Line type
if ( tmpCurve is LineItem && tmpCurve.IsVisible )
{
curVal = PointPair.Missing;
// For non-ordinal curves, find a matching base value (must match exactly)
if ( curve.IsOverrideOrdinal || !baseAxis._scale.IsAnyOrdinal )
{
IPointList points = tmpCurve.Points;
for ( int i = 0; i < points.Count; i++ )
{
if ( points[i].X == baseVal )
{
curVal = points[i].Y;
break;
}
}
}
// otherwise, it's an ordinal type so use the value at the same ordinal position
else if ( iPt < tmpCurve.Points.Count )
{
// For line types, the Y axis is always the value axis
curVal = tmpCurve.Points[iPt].Y;
}
// if the current value is missing, then the rest of the stack is missing
if ( curVal == PointPair.Missing )
stack = PointPair.Missing;
// if the current curve is the target curve, save the values
if ( tmpCurve == curve )
{
lowVal = stack;
//	if ( curVal < 0 && stack == 0 )
//	{
//	stack = curVal;
//	lowVal = curVal;
//	hiVal = curVal;
//	}
//	else
hiVal = ( curVal == PointPair.Missing || stack == PointPair.Missing ) ?
PointPair.Missing : stack + curVal;
}
// sum all the curves to a single total. This includes both positive and
// negative values (unlike the bar stack type).
stack = ( curVal == PointPair.Missing || stack == PointPair.Missing ) ?
PointPair.Missing : stack + curVal;
}
}
if ( baseVal == PointPair.Missing || lowVal == PointPair.Missing ||
hiVal == PointPair.Missing )
return false;
else
return true;
}
// otherwise, the curve is not a stacked type (not a stacked bar or stacked line)
else
{
if ((!(curve is HiLowBarItem)) && (!(curve is ErrorBarItem)))
lowVal = 0;
else
lowVal = curve.Points[iPt].LowValue;
if ( baseAxis is XAxis || baseAxis is X2Axis )
hiVal = curve.Points[iPt].Y;
else
hiVal = curve.Points[iPt].X;
}
// Special Exception: Bars on log scales should always plot from the Min value upwards,
// since they can never be zero
if ( curve is BarItem && valueAxis._scale.IsLog && lowVal == 0 )
lowVal = valueAxis._scale._min;
if ( baseVal == PointPair.Missing || hiVal == PointPair.Missing ||
( lowVal == PointPair.Missing && ( curve is ErrorBarItem ||
curve is HiLowBarItem ) ) )
return false;
else
return true;
}","The main purpose of this method is to handle stacked bars and lines, in which case the stacked values are returned rather than the individual data values. However, this method works generically for any curve type.",1
2574,"public override bool Equals( object obj )
{
if ( obj is XDate )
{
return ((XDate) obj)._xlDate == _xlDate;
}
else if ( obj is double )
{
return ((double) obj) == _xlDate;
}
else
return false;
}",FALSE,0
2575,"public Y2AxisList()
{
}",Default constructor for the collection class.,0
2576,"public int IndexOf( string title )
{
int index = 0;
foreach ( Y2Axis axis in this )
{
if ( String.Compare( axis.Title._text, title, true ) == 0 )
return index;
index++;
}
return -1;
}","The comparison of titles is not case sensitive, but it must include all characters including punctuation, spaces, etc.",1
2577,"public YAxisList()
{
}",Default constructor for the collection class.,0
2578,"public int IndexOf( string title )
{
int index = 0;
foreach ( YAxis axis in this )
{
if ( String.Compare( axis.Title._text, title, true ) == 0 )
return index;
index++;
}
return -1;
}","The comparison of titles is not case sensitive, but it must include all characters including punctuation, spaces, etc.",1
2579,"public enum ContextMenuObjectState
{
/// <summary>
/// The object is an Inactive Curve Item at the Context Menu's mouse position
/// </summary>
InactiveSelection,
/// <summary>
/// The object is an active Curve Item at the Context Menu's mouse position
/// </summary>
ActiveSelection,
/// <summary>
/// There is no selectable object present at the Context Menu's mouse position
/// </summary>
Background
}",Public enumeration that specifies the type of object present at the Context Menu's mouse location,1
2580,"private ContextMenuObjectState GetObjectState()
{
ContextMenuObjectState objState = ContextMenuObjectState.Background;
// Determine object state
Point mousePt = this.PointToClient( Control.MousePosition );
int iPt;
GraphPane pane;
object nearestObj;
using ( Graphics g = this.CreateGraphics() )
{
if ( this.MasterPane.FindNearestPaneObject( mousePt, g, out pane,
out nearestObj, out iPt ) )
{
CurveItem item = nearestObj as CurveItem;
if ( item != null && iPt >= 0 )
{
if ( item.IsSelected )
objState = ContextMenuObjectState.ActiveSelection;
else
objState = ContextMenuObjectState.InactiveSelection;
}
}
}
return objState;
}","Find the object currently under the mouse cursor, and return its state.",1
2581,"private void ClipboardCopyThread()
{
Clipboard.SetDataObject( ImageRender(), true );
}",A threaded version of the copy method to avoid crash with MTA,1
2582,"private void ClipboardCopyThreadEmf()
{
using (Graphics g = this.CreateGraphics())
{
IntPtr hdc = g.GetHdc();
Metafile metaFile = new Metafile(hdc, EmfType.EmfPlusOnly);
g.ReleaseHdc(hdc);
using (Graphics gMeta = Graphics.FromImage(metaFile))
{
this._masterPane.Draw( gMeta );
}
//IntPtr hMeta = metaFile.GetHenhmetafile();
ClipboardMetafileHelper.PutEnhMetafileOnClipboard( this.Handle, metaFile );
//System.Windows.Forms.Clipboard.SetDataObject(hMeta, true);
//g.Dispose();
}
}",A threaded version of the copy method to avoid crash with MTA,1
2583,"private void InitializeComponent()
{
this.components = new System.ComponentModel.Container();
this.vScrollBar1 = new System.Windows.Forms.VScrollBar();
this.hScrollBar1 = new System.Windows.Forms.HScrollBar();
this.pointToolTip = new System.Windows.Forms.ToolTip( this.components );
this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip( this.components );
this.SuspendLayout();
// // vScrollBar1
// this.vScrollBar1.Location = new System.Drawing.Point( 128, 0 );
this.vScrollBar1.Name = ""vScrollBar1"";
this.vScrollBar1.Size = new System.Drawing.Size( 17, 128 );
this.vScrollBar1.TabIndex = 0;
//this.vScrollBar1.MouseCaptureChanged += new System.EventHandler( this.ScrollBarMouseCaptureChanged );
this.vScrollBar1.Scroll += new System.Windows.Forms.ScrollEventHandler( this.vScrollBar1_Scroll );
// // hScrollBar1
// this.hScrollBar1.Location = new System.Drawing.Point( 0, 128 );
this.hScrollBar1.Name = ""hScrollBar1"";
this.hScrollBar1.Size = new System.Drawing.Size( 128, 17 );
this.hScrollBar1.TabIndex = 1;
//this.hScrollBar1.MouseCaptureChanged += new System.EventHandler( this.ScrollBarMouseCaptureChanged );
this.hScrollBar1.Scroll += new System.Windows.Forms.ScrollEventHandler( this.hScrollBar1_Scroll );
// // pointToolTip
// this.pointToolTip.AutoPopDelay = 5000;
this.pointToolTip.InitialDelay = 100;
this.pointToolTip.ReshowDelay = 0;
// // contextMenuStrip1
// this.contextMenuStrip1.Name = ""contextMenuStrip1"";
this.contextMenuStrip1.Size = new System.Drawing.Size( 61, 4 );
this.contextMenuStrip1.Opening += new System.ComponentModel.CancelEventHandler( this.contextMenuStrip1_Opening );
// // ZedGraphControl
// this.AutoScaleDimensions = new System.Drawing.SizeF( 6F, 13F );
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.ContextMenuStrip = this.contextMenuStrip1;
this.Controls.Add( this.hScrollBar1 );
this.Controls.Add( this.vScrollBar1 );
this.Name = ""ZedGraphControl"";
this.Resize += new System.EventHandler( this.ZedGraphControl_ReSize );
this.KeyUp += new System.Windows.Forms.KeyEventHandler( this.ZedGraphControl_KeyUp );
this.KeyDown += new System.Windows.Forms.KeyEventHandler( this.ZedGraphControl_KeyDown );
this.MouseWheel += new System.Windows.Forms.MouseEventHandler( this.ZedGraphControl_MouseWheel );
this.ResumeLayout( false );
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2584,"protected void SetCursor()
{
SetCursor( this.PointToClient( Control.MousePosition ) );
}",Set the cursor according to the current mouse location.,1
2585,"protected void SetCursor( Point mousePt )
{
if ( _masterPane != null )
{
GraphPane pane = _masterPane.FindChartRect( mousePt );
if ( ( _isEnableHPan || _isEnableVPan ) && ( Control.ModifierKeys == Keys.Shift || _isPanning ) &&
( pane != null || _isPanning ) )
this.Cursor = Cursors.Hand;
else if ( ( _isEnableVZoom || _isEnableHZoom ) && ( pane != null || _isZooming ) )
this.Cursor = Cursors.Cross;
else if ( _isEnableSelection && ( pane != null || _isSelecting ) )
this.Cursor = Cursors.Cross;
else
this.Cursor = Cursors.Default;
//	else if ( isZoomMode || isPanMode )
//	this.Cursor = Cursors.No;
}
}",Set the cursor according to the current mouse location.,1
2586,"protected void ZoomScale( Axis axis, double zoomFraction, double centerVal, bool isZoomOnCenter )
{
if ( axis != null && zoomFraction > 0.0001 && zoomFraction < 1000.0 )
{
Scale scale = axis._scale;
/*
if ( axis.Scale.IsLog )
{
double ratio = Math.Sqrt( axis._scale._max / axis._scale._min * zoomFraction );
if ( !isZoomOnCenter )
centerVal = Math.Sqrt( axis._scale._max * axis._scale._min );
axis._scale._min = centerVal / ratio;
axis._scale._max = centerVal * ratio;
}
else
{
*/
double minLin = axis._scale._minLinearized;
double maxLin = axis._scale._maxLinearized;
double range = ( maxLin - minLin ) * zoomFraction / 2.0;
if ( !isZoomOnCenter )
centerVal = ( maxLin + minLin ) / 2.0;
axis._scale._minLinearized = centerVal - range;
axis._scale._maxLinearized = centerVal + range;
//	}
axis._scale._minAuto = false;
axis._scale._maxAuto = false;
}
}",This method is used for MouseWheel zoom operations,1
2587,"public virtual void AxisChange()
{
lock ( this )
{
if ( BeenDisposed || _masterPane == null )
return;
using ( Graphics g = this.CreateGraphics() )
{
_masterPane.AxisChange( g );
//g.Dispose();
}
if ( _isAutoScrollRange )
SetScrollRangeFromData();
}
}",ZedGraphControl.GraphPane.AxisChange( ZedGraphControl.CreateGraphics() ),0
2588,"public enum StateType
{
/// <summary>
/// Indicates the <see cref=""ZoomState""/> object is from a Zoom operation
/// </summary>
Zoom,
/// <summary>
/// Indicates the <see cref=""ZoomState""/> object is from a Wheel Zoom operation
/// </summary>
WheelZoom,
/// <summary>
/// Indicates the <see cref=""ZoomState""/> object is from a Pan operation
/// </summary>
Pan,
/// <summary>
/// Indicates the <see cref=""ZoomState""/> object is from a Scroll operation
/// </summary>
Scroll
}",An enumeration that describes whether a given state is the result of a Pan or Zoom operation.,1
2589,"public ZoomStateStack()
{
}",Default Constructor,0
2590,"public enum SampleType
{
/// <summary>
/// Designates the ""Time"" property will be used
/// </summary>
Time,
/// <summary>
/// Designates the ""Position"" property will be used
/// </summary>
Position,
/// <summary>
/// Designates the Instantaneous Velocity property will be used
/// </summary>
VelocityInst,
/// <summary>
/// Designates the ""Time since start"" property will be used
/// </summary>
TimeDiff,
/// <summary>
/// Designates the Average Velocity property will be used
/// </summary>
VelocityAvg
};",enumeration used to indicate which type of data will be plotted.,1
2591,"public enum DateUnit
{
/// <summary> Yearly units <see cref=""Scale.MajorUnit""/> and <see cref=""Scale.MinorUnit""/>
/// </summary>
Year,
/// <summary> Monthly units <see cref=""Scale.MajorUnit""/> and <see cref=""Scale.MinorUnit""/>
/// </summary>
Month,
/// <summary> Daily units <see cref=""Scale.MajorUnit""/> and <see cref=""Scale.MinorUnit""/>
/// </summary>
Day,
/// <summary> Hourly units <see cref=""Scale.MajorUnit""/> and <see cref=""Scale.MinorUnit""/>
/// </summary>
Hour,
/// <summary> Minute units <see cref=""Scale.MajorUnit""/> and <see cref=""Scale.MinorUnit""/>
/// </summary>
Minute,
/// <summary> Second units <see cref=""Scale.MajorUnit""/> and <see cref=""Scale.MinorUnit""/>
/// </summary>
Second,
/// <summary> Millisecond units <see cref=""Scale.MajorUnit""/> and <see cref=""Scale.MinorUnit""/>
/// </summary>
Millisecond
}",Enumeration type for the various axis date and time unit types that are available,1
2592,"public enum RenderModeType
{
/// <summary>
/// Renders as an IMG tag referencing a local generated image. ContentType stays text.
/// </summary>
ImageTag,
/// <summary>
/// Renders the binary image. ContentType is changed accordingly.
/// </summary>
RawImage
}",Enum for specifying the type of data to be returned by the ZedGraphWeb Render() method.,1
2593,"static void Main()
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
if (new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator))
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new win10privacyfix2());
}
else
{
MessageBox.Show(""This application needs administrator privileges to run properly."");
}
}",The main entry point for the application.,1
2594,internal static System.Drawing.Bitmap _63b5c5cd8aa765371b3dfa0e71ba707d {,Looks up a localized resource of type System.Drawing.Bitmap.,0
2595,internal static System.Drawing.Bitmap de {,Looks up a localized resource of type System.Drawing.Bitmap.,0
2596,internal static System.Drawing.Bitmap us {,Looks up a localized resource of type System.Drawing.Bitmap.,0
2597,"private void InitializeComponent()
{
System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(win10privacyfix2));
this.c_service_diag1 = new System.Windows.Forms.CheckBox();
this.pb = new System.Windows.Forms.ProgressBar();
this.b_check = new System.Windows.Forms.Button();
this.toolStrip1 = new System.Windows.Forms.ToolStrip();
this.b_blog = new System.Windows.Forms.ToolStripButton();
this.toolStripButton1 = new System.Windows.Forms.ToolStripButton();
this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
this.b_de = new System.Windows.Forms.ToolStripButton();
this.b_us = new System.Windows.Forms.ToolStripButton();
this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
this.toolStripButton4 = new System.Windows.Forms.ToolStripButton();
this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
this.toolStripLabel1 = new System.Windows.Forms.ToolStripLabel();
this.groupBox1 = new System.Windows.Forms.GroupBox();
this.b_diag = new System.Windows.Forms.Button();
this.b_geo = new System.Windows.Forms.Button();
this.b_dmw = new System.Windows.Forms.Button();
this.b_winup_start = new System.Windows.Forms.Button();
this.b_defender_sam = new System.Windows.Forms.Button();
this.b_defender_net = new System.Windows.Forms.Button();
this.b_def_c = new System.Windows.Forms.Button();
this.b_p2p = new System.Windows.Forms.Button();
this.b_winup_stop = new System.Windows.Forms.Button();
this.c_defender_sam = new System.Windows.Forms.CheckBox();
this.c_defender_net = new System.Windows.Forms.CheckBox();
this.checkBox9 = new System.Windows.Forms.CheckBox();
this.c_p2p = new System.Windows.Forms.CheckBox();
this.checkBox7 = new System.Windows.Forms.CheckBox();
this.checkBox6 = new System.Windows.Forms.CheckBox();
this.c_service_dmw1 = new System.Windows.Forms.CheckBox();
this.checkBox4 = new System.Windows.Forms.CheckBox();
this.c_service_geo1 = new System.Windows.Forms.CheckBox();
this.c_service_diag2 = new System.Windows.Forms.CheckBox();
this.groupBox2 = new System.Windows.Forms.GroupBox();
this.b_pri_ads = new System.Windows.Forms.Button();
this.b_pri_local = new System.Windows.Forms.Button();
this.b_pri_write = new System.Windows.Forms.Button();
this.b_pri_smart = new System.Windows.Forms.Button();
this.c_pri_ads = new System.Windows.Forms.CheckBox();
this.c_pri_local = new System.Windows.Forms.CheckBox();
this.c_pri_write = new System.Windows.Forms.CheckBox();
this.c_pri_smart = new System.Windows.Forms.CheckBox();
this.b_pri_tele = new System.Windows.Forms.Button();
this.b_pri_freq = new System.Windows.Forms.Button();
this.c_pri_tele = new System.Windows.Forms.CheckBox();
this.c_pri_freq = new System.Windows.Forms.CheckBox();
this.groupBox3 = new System.Windows.Forms.GroupBox();
this.checkBox24 = new System.Windows.Forms.CheckBox();
this.button25 = new System.Windows.Forms.Button();
this.button24 = new System.Windows.Forms.Button();
this.button23 = new System.Windows.Forms.Button();
this.button17 = new System.Windows.Forms.Button();
this.button18 = new System.Windows.Forms.Button();
this.button19 = new System.Windows.Forms.Button();
this.button20 = new System.Windows.Forms.Button();
this.checkBox16 = new System.Windows.Forms.CheckBox();
this.checkBox17 = new System.Windows.Forms.CheckBox();
this.checkBox18 = new System.Windows.Forms.CheckBox();
this.checkBox19 = new System.Windows.Forms.CheckBox();
this.button21 = new System.Windows.Forms.Button();
this.button22 = new System.Windows.Forms.Button();
this.checkBox20 = new System.Windows.Forms.CheckBox();
this.checkBox23 = new System.Windows.Forms.CheckBox();
this.groupBox4 = new System.Windows.Forms.GroupBox();
this.button34 = new System.Windows.Forms.Button();
this.checkBox31 = new System.Windows.Forms.CheckBox();
this.groupBox5 = new System.Windows.Forms.GroupBox();
this.infotext = new System.Windows.Forms.Label();
this.c_misc_onedrive = new System.Windows.Forms.CheckBox();
this.b_misc_onedrive = new System.Windows.Forms.Button();
this.c_misc_god = new System.Windows.Forms.CheckBox();
this.b_misc_god = new System.Windows.Forms.Button();
this.toolStrip1.SuspendLayout();
this.groupBox1.SuspendLayout();
this.groupBox2.SuspendLayout();
this.groupBox3.SuspendLayout();
this.groupBox4.SuspendLayout();
this.groupBox5.SuspendLayout();
this.SuspendLayout();
// // c_service_diag1
// this.c_service_diag1.AutoSize = true;
this.c_service_diag1.Enabled = false;
this.c_service_diag1.Location = new System.Drawing.Point(6, 19);
this.c_service_diag1.Name = ""c_service_diag1"";
this.c_service_diag1.Size = new System.Drawing.Size(152, 17);
this.c_service_diag1.TabIndex = 0;
this.c_service_diag1.Text = ""DiagTrack Service State..."";
this.c_service_diag1.UseVisualStyleBackColor = true;
// // pb
// this.pb.Location = new System.Drawing.Point(12, 312);
this.pb.Name = ""pb"";
this.pb.Size = new System.Drawing.Size(940, 23);
this.pb.TabIndex = 1;
// // b_check
// this.b_check.Location = new System.Drawing.Point(958, 312);
this.b_check.Name = ""b_check"";
this.b_check.Size = new System.Drawing.Size(109, 23);
this.b_check.TabIndex = 2;
this.b_check.Text = ""check"";
this.b_check.UseVisualStyleBackColor = true;
this.b_check.Click += new System.EventHandler(this.b_check_Click);
// // toolStrip1
// this.toolStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
this.b_blog,
this.toolStripButton1,
this.toolStripSeparator2,
this.b_de,
this.b_us,
this.toolStripSeparator1,
this.toolStripButton4,
this.toolStripSeparator3,
this.toolStripLabel1});
this.toolStrip1.Location = new System.Drawing.Point(0, 0);
this.toolStrip1.Name = ""toolStrip1"";
this.toolStrip1.Size = new System.Drawing.Size(1071, 25);
this.toolStrip1.TabIndex = 3;
this.toolStrip1.Text = ""toolStrip1"";
// // b_blog
// this.b_blog.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
this.b_blog.Image = global::win10privacyfix2.Properties.Resources._63b5c5cd8aa765371b3dfa0e71ba707d;
this.b_blog.ImageTransparentColor = System.Drawing.Color.Magenta;
this.b_blog.Name = ""b_blog"";
this.b_blog.Size = new System.Drawing.Size(23, 22);
this.b_blog.Text = ""toolStripButton3"";
this.b_blog.ToolTipText = ""https://wiiare.in/win10fix"";
this.b_blog.Click += new System.EventHandler(this.b_blog_Click);
// // toolStripButton1
// this.toolStripButton1.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
this.toolStripButton1.Image = ((System.Drawing.Image)(resources.GetObject(""toolStripButton1.Image"")));
this.toolStripButton1.ImageTransparentColor = System.Drawing.Color.Magenta;
this.toolStripButton1.Name = ""toolStripButton1"";
this.toolStripButton1.Size = new System.Drawing.Size(23, 22);
this.toolStripButton1.Text = ""reddit thread"";
this.toolStripButton1.Click += new System.EventHandler(this.toolStripButton1_Click_1);
// // toolStripSeparator2
// this.toolStripSeparator2.Name = ""toolStripSeparator2"";
this.toolStripSeparator2.Size = new System.Drawing.Size(6, 25);
// // b_de
// this.b_de.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
this.b_de.Image = global::win10privacyfix2.Properties.Resources.de;
this.b_de.ImageTransparentColor = System.Drawing.Color.Magenta;
this.b_de.Name = ""b_de"";
this.b_de.Size = new System.Drawing.Size(23, 22);
this.b_de.Text = ""switch to german"";
this.b_de.Click += new System.EventHandler(this.toolStripButton1_Click);
// // b_us
// this.b_us.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
this.b_us.Image = global::win10privacyfix2.Properties.Resources.us;
this.b_us.ImageTransparentColor = System.Drawing.Color.Magenta;
this.b_us.Name = ""b_us"";
this.b_us.Size = new System.Drawing.Size(23, 22);
this.b_us.Text = ""b_us"";
this.b_us.ToolTipText = ""switch to english"";
this.b_us.Click += new System.EventHandler(this.b_us_Click);
// // toolStripSeparator1
// this.toolStripSeparator1.Name = ""toolStripSeparator1"";
this.toolStripSeparator1.Size = new System.Drawing.Size(6, 25);
// // toolStripButton4
// this.toolStripButton4.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
this.toolStripButton4.Enabled = false;
this.toolStripButton4.Image = ((System.Drawing.Image)(resources.GetObject(""toolStripButton4.Image"")));
this.toolStripButton4.ImageTransparentColor = System.Drawing.Color.Magenta;
this.toolStripButton4.Name = ""toolStripButton4"";
this.toolStripButton4.Size = new System.Drawing.Size(23, 22);
this.toolStripButton4.Text = ""switch to fr"";
// // toolStripSeparator3
// this.toolStripSeparator3.Name = ""toolStripSeparator3"";
this.toolStripSeparator3.Size = new System.Drawing.Size(6, 25);
// // toolStripLabel1
// this.toolStripLabel1.Name = ""toolStripLabel1"";
this.toolStripLabel1.Size = new System.Drawing.Size(51, 22);
this.toolStripLabel1.Text = ""Licenses"";
this.toolStripLabel1.Click += new System.EventHandler(this.toolStripLabel1_Click);
// // groupBox1
// this.groupBox1.Controls.Add(this.b_diag);
this.groupBox1.Controls.Add(this.b_geo);
this.groupBox1.Controls.Add(this.b_dmw);
this.groupBox1.Controls.Add(this.b_winup_start);
this.groupBox1.Controls.Add(this.b_defender_sam);
this.groupBox1.Controls.Add(this.b_defender_net);
this.groupBox1.Controls.Add(this.b_def_c);
this.groupBox1.Controls.Add(this.b_p2p);
this.groupBox1.Controls.Add(this.b_winup_stop);
this.groupBox1.Controls.Add(this.c_defender_sam);
this.groupBox1.Controls.Add(this.c_defender_net);
this.groupBox1.Controls.Add(this.checkBox9);
this.groupBox1.Controls.Add(this.c_p2p);
this.groupBox1.Controls.Add(this.checkBox7);
this.groupBox1.Controls.Add(this.checkBox6);
this.groupBox1.Controls.Add(this.c_service_dmw1);
this.groupBox1.Controls.Add(this.checkBox4);
this.groupBox1.Controls.Add(this.c_service_geo1);
this.groupBox1.Controls.Add(this.c_service_diag2);
this.groupBox1.Controls.Add(this.c_service_diag1);
this.groupBox1.Location = new System.Drawing.Point(12, 28);
this.groupBox1.Name = ""groupBox1"";
this.groupBox1.Size = new System.Drawing.Size(320, 276);
this.groupBox1.TabIndex = 5;
this.groupBox1.TabStop = false;
this.groupBox1.Text = ""Services"";
// // b_diag
// this.b_diag.Enabled = false;
this.b_diag.Location = new System.Drawing.Point(233, 36);
this.b_diag.Name = ""b_diag"";
this.b_diag.Size = new System.Drawing.Size(30, 23);
this.b_diag.TabIndex = 14;
this.b_diag.Text = ""fix"";
this.b_diag.UseVisualStyleBackColor = true;
// // b_geo
// this.b_geo.Enabled = false;
this.b_geo.Location = new System.Drawing.Point(233, 82);
this.b_geo.Name = ""b_geo"";
this.b_geo.Size = new System.Drawing.Size(30, 23);
this.b_geo.TabIndex = 14;
this.b_geo.Text = ""fix"";
this.b_geo.UseVisualStyleBackColor = true;
// // b_dmw
// this.b_dmw.Enabled = false;
this.b_dmw.Location = new System.Drawing.Point(233, 128);
this.b_dmw.Name = ""b_dmw"";
this.b_dmw.Size = new System.Drawing.Size(30, 23);
this.b_dmw.TabIndex = 18;
this.b_dmw.Text = ""fix"";
this.b_dmw.UseVisualStyleBackColor = true;
// // b_winup_start
// this.b_winup_start.Enabled = false;
this.b_winup_start.Location = new System.Drawing.Point(201, 153);
this.b_winup_start.Name = ""b_winup_start"";
this.b_winup_start.Size = new System.Drawing.Size(35, 23);
this.b_winup_start.TabIndex = 17;
this.b_winup_start.Text = ""start"";
this.b_winup_start.UseVisualStyleBackColor = true;
// // b_defender_sam
// this.b_defender_sam.Enabled = false;
this.b_defender_sam.Location = new System.Drawing.Point(233, 250);
this.b_defender_sam.Name = ""b_defender_sam"";
this.b_defender_sam.Size = new System.Drawing.Size(30, 23);
this.b_defender_sam.TabIndex = 16;
this.b_defender_sam.Text = ""fix"";
this.b_defender_sam.UseVisualStyleBackColor = true;
// // b_defender_net
// this.b_defender_net.Enabled = false;
this.b_defender_net.Location = new System.Drawing.Point(233, 227);
this.b_defender_net.Name = ""b_defender_net"";
this.b_defender_net.Size = new System.Drawing.Size(30, 23);
this.b_defender_net.TabIndex = 15;
this.b_defender_net.Text = ""fix"";
this.b_defender_net.UseVisualStyleBackColor = true;
// // b_def_c
// this.b_def_c.Enabled = false;
this.b_def_c.Location = new System.Drawing.Point(233, 204);
this.b_def_c.Name = ""b_def_c"";
this.b_def_c.Size = new System.Drawing.Size(30, 23);
this.b_def_c.TabIndex = 14;
this.b_def_c.Text = ""fix"";
this.b_def_c.UseVisualStyleBackColor = true;
// // b_p2p
// this.b_p2p.Enabled = false;
this.b_p2p.Location = new System.Drawing.Point(233, 180);
this.b_p2p.Name = ""b_p2p"";
this.b_p2p.Size = new System.Drawing.Size(30, 23);
this.b_p2p.TabIndex = 13;
this.b_p2p.Text = ""fix"";
this.b_p2p.UseVisualStyleBackColor = true;
// // b_winup_stop
// this.b_winup_stop.Enabled = false;
this.b_winup_stop.Location = new System.Drawing.Point(233, 153);
this.b_winup_stop.Name = ""b_winup_stop"";
this.b_winup_stop.Size = new System.Drawing.Size(42, 23);
this.b_winup_stop.TabIndex = 6;
this.b_winup_stop.Text = ""stop"";
this.b_winup_stop.UseVisualStyleBackColor = true;
// // c_defender_sam
// this.c_defender_sam.AutoSize = true;
this.c_defender_sam.Enabled = false;
this.c_defender_sam.Location = new System.Drawing.Point(6, 249);
this.c_defender_sam.Name = ""c_defender_sam"";
this.c_defender_sam.Size = new System.Drawing.Size(209, 17);
this.c_defender_sam.TabIndex = 10;
this.c_defender_sam.Text = ""Windows Defender Sample submission"";
this.c_defender_sam.UseVisualStyleBackColor = true;
this.c_defender_sam.CheckedChanged += new System.EventHandler(this.checkBox11_CheckedChanged);
// // c_defender_net
// this.c_defender_net.AutoSize = true;
this.c_defender_net.Enabled = false;
this.c_defender_net.Location = new System.Drawing.Point(6, 226);
this.c_defender_net.Name = ""c_defender_net"";
this.c_defender_net.Size = new System.Drawing.Size(217, 17);
this.c_defender_net.TabIndex = 9;
this.c_defender_net.Text = ""Windows Defender Netzwork Inspection"";
this.c_defender_net.UseVisualStyleBackColor = true;
// // checkBox9
// this.checkBox9.AutoSize = true;
this.checkBox9.Enabled = false;
this.checkBox9.Location = new System.Drawing.Point(6, 203);
this.checkBox9.Name = ""checkBox9"";
this.checkBox9.Size = new System.Drawing.Size(198, 17);
this.checkBox9.TabIndex = 8;
this.checkBox9.Text = ""Windows Defender Cloud Protection"";
this.checkBox9.UseVisualStyleBackColor = true;
// // c_p2p
// this.c_p2p.AutoSize = true;
this.c_p2p.Enabled = false;
this.c_p2p.Location = new System.Drawing.Point(6, 180);
this.c_p2p.Name = ""c_p2p"";
this.c_p2p.Size = new System.Drawing.Size(202, 17);
this.c_p2p.TabIndex = 7;
this.c_p2p.Text = ""Windows Update P2P Service active"";
this.c_p2p.UseVisualStyleBackColor = true;
// // checkBox7
// this.checkBox7.AutoSize = true;
this.checkBox7.Enabled = false;
this.checkBox7.Location = new System.Drawing.Point(6, 157);
this.checkBox7.Name = ""checkBox7"";
this.checkBox7.Size = new System.Drawing.Size(189, 17);
this.checkBox7.TabIndex = 6;
this.checkBox7.Text = ""Windows Update Serivce is active"";
this.checkBox7.UseVisualStyleBackColor = true;
// // checkBox6
// this.checkBox6.AutoSize = true;
this.checkBox6.Enabled = false;
this.checkBox6.Location = new System.Drawing.Point(6, 134);
this.checkBox6.Name = ""checkBox6"";
this.checkBox6.Size = new System.Drawing.Size(193, 17);
this.checkBox6.TabIndex = 5;
this.checkBox6.Text = ""dmwappushservice Service State..."";
this.checkBox6.UseVisualStyleBackColor = true;
// // c_service_dmw1
// this.c_service_dmw1.AutoSize = true;
this.c_service_dmw1.Enabled = false;
this.c_service_dmw1.Location = new System.Drawing.Point(6, 111);
this.c_service_dmw1.Name = ""c_service_dmw1"";
this.c_service_dmw1.Size = new System.Drawing.Size(193, 17);
this.c_service_dmw1.TabIndex = 4;
this.c_service_dmw1.Text = ""dmwappushservice Service State..."";
this.c_service_dmw1.UseVisualStyleBackColor = true;
// // checkBox4
// this.checkBox4.AutoSize = true;
this.checkBox4.Enabled = false;
this.checkBox4.Location = new System.Drawing.Point(6, 88);
this.checkBox4.Name = ""checkBox4"";
this.checkBox4.Size = new System.Drawing.Size(171, 17);
this.checkBox4.TabIndex = 3;
this.checkBox4.Text = ""Geolocation Service Startup...."";
this.checkBox4.UseVisualStyleBackColor = true;
// // c_service_geo1
// this.c_service_geo1.AutoSize = true;
this.c_service_geo1.Enabled = false;
this.c_service_geo1.Location = new System.Drawing.Point(6, 65);
this.c_service_geo1.Name = ""c_service_geo1"";
this.c_service_geo1.Size = new System.Drawing.Size(171, 17);
this.c_service_geo1.TabIndex = 2;
this.c_service_geo1.Text = ""Geolocation Service Startup...."";
this.c_service_geo1.UseVisualStyleBackColor = true;
// // c_service_diag2
// this.c_service_diag2.AutoSize = true;
this.c_service_diag2.Enabled = false;
this.c_service_diag2.Location = new System.Drawing.Point(6, 42);
this.c_service_diag2.Name = ""c_service_diag2"";
this.c_service_diag2.Size = new System.Drawing.Size(152, 17);
this.c_service_diag2.TabIndex = 1;
this.c_service_diag2.Text = ""DiagTrack Service State..."";
this.c_service_diag2.UseVisualStyleBackColor = true;
// // groupBox2
// this.groupBox2.Controls.Add(this.b_pri_ads);
this.groupBox2.Controls.Add(this.b_pri_local);
this.groupBox2.Controls.Add(this.b_pri_write);
this.groupBox2.Controls.Add(this.b_pri_smart);
this.groupBox2.Controls.Add(this.c_pri_ads);
this.groupBox2.Controls.Add(this.c_pri_local);
this.groupBox2.Controls.Add(this.c_pri_write);
this.groupBox2.Controls.Add(this.c_pri_smart);
this.groupBox2.Controls.Add(this.b_pri_tele);
this.groupBox2.Controls.Add(this.b_pri_freq);
this.groupBox2.Controls.Add(this.c_pri_tele);
this.groupBox2.Controls.Add(this.c_pri_freq);
this.groupBox2.Location = new System.Drawing.Point(338, 28);
this.groupBox2.Name = ""groupBox2"";
this.groupBox2.Size = new System.Drawing.Size(277, 278);
this.groupBox2.TabIndex = 19;
this.groupBox2.TabStop = false;
this.groupBox2.Text = ""General Privacy Settings"";
// // b_pri_ads
// this.b_pri_ads.Enabled = false;
this.b_pri_ads.Location = new System.Drawing.Point(235, 62);
this.b_pri_ads.Name = ""b_pri_ads"";
this.b_pri_ads.Size = new System.Drawing.Size(30, 20);
this.b_pri_ads.TabIndex = 23;
this.b_pri_ads.Text = ""fix"";
this.b_pri_ads.UseVisualStyleBackColor = true;
// // b_pri_local
// this.b_pri_local.Enabled = false;
this.b_pri_local.Location = new System.Drawing.Point(235, 134);
this.b_pri_local.Name = ""b_pri_local"";
this.b_pri_local.Size = new System.Drawing.Size(30, 20);
this.b_pri_local.TabIndex = 22;
this.b_pri_local.Text = ""fix"";
this.b_pri_local.UseVisualStyleBackColor = true;
// // b_pri_write
// this.b_pri_write.Enabled = false;
this.b_pri_write.Location = new System.Drawing.Point(235, 108);
this.b_pri_write.Name = ""b_pri_write"";
this.b_pri_write.Size = new System.Drawing.Size(30, 20);
this.b_pri_write.TabIndex = 21;
this.b_pri_write.Text = ""fix"";
this.b_pri_write.UseVisualStyleBackColor = true;
// // b_pri_smart
// this.b_pri_smart.Enabled = false;
this.b_pri_smart.Location = new System.Drawing.Point(235, 85);
this.b_pri_smart.Name = ""b_pri_smart"";
this.b_pri_smart.Size = new System.Drawing.Size(30, 20);
this.b_pri_smart.TabIndex = 20;
this.b_pri_smart.Text = ""fix"";
this.b_pri_smart.UseVisualStyleBackColor = true;
this.b_pri_smart.Click += new System.EventHandler(this.b_pri_smart_Click);
// // c_pri_ads
// this.c_pri_ads.AutoSize = true;
this.c_pri_ads.Enabled = false;
this.c_pri_ads.Location = new System.Drawing.Point(6, 65);
this.c_pri_ads.Name = ""c_pri_ads"";
this.c_pri_ads.Size = new System.Drawing.Size(138, 17);
this.c_pri_ads.TabIndex = 19;
this.c_pri_ads.Text = ""Checking Advert Info...."";
this.c_pri_ads.UseVisualStyleBackColor = true;
this.c_pri_ads.MouseLeave += new System.EventHandler(this.c_pri_ads_MouseLeave);
this.c_pri_ads.MouseHover += new System.EventHandler(this.c_pri_ads_MouseHover);
// // c_pri_local
// this.c_pri_local.AutoSize = true;
this.c_pri_local.Enabled = false;
this.c_pri_local.Location = new System.Drawing.Point(6, 137);
this.c_pri_local.Name = ""c_pri_local"";
this.c_pri_local.Size = new System.Drawing.Size(235, 17);
this.c_pri_local.TabIndex = 18;
this.c_pri_local.Text = ""Let websites provide locally relevant content"";
this.c_pri_local.UseVisualStyleBackColor = true;
// // c_pri_write
// this.c_pri_write.AutoSize = true;
this.c_pri_write.Enabled = false;
this.c_pri_write.Location = new System.Drawing.Point(6, 114);
this.c_pri_write.Name = ""c_pri_write"";
this.c_pri_write.Size = new System.Drawing.Size(201, 17);
this.c_pri_write.TabIndex = 17;
this.c_pri_write.Text = ""Send Microsoft info about how I write"";
this.c_pri_write.UseVisualStyleBackColor = true;
// // c_pri_smart
// this.c_pri_smart.AutoSize = true;
this.c_pri_smart.Enabled = false;
this.c_pri_smart.Location = new System.Drawing.Point(6, 91);
this.c_pri_smart.Name = ""c_pri_smart"";
this.c_pri_smart.Size = new System.Drawing.Size(118, 17);
this.c_pri_smart.TabIndex = 16;
this.c_pri_smart.Text = ""SmartScreen Filter.."";
this.c_pri_smart.UseVisualStyleBackColor = true;
// // b_pri_tele
// this.b_pri_tele.Enabled = false;
this.b_pri_tele.Location = new System.Drawing.Point(235, 42);
this.b_pri_tele.Name = ""b_pri_tele"";
this.b_pri_tele.Size = new System.Drawing.Size(30, 20);
this.b_pri_tele.TabIndex = 15;
this.b_pri_tele.Text = ""fix"";
this.b_pri_tele.UseVisualStyleBackColor = true;
this.b_pri_tele.Click += new System.EventHandler(this.b_pri_tele_Click);
// // b_pri_freq
// this.b_pri_freq.Enabled = false;
this.b_pri_freq.Location = new System.Drawing.Point(235, 19);
this.b_pri_freq.Name = ""b_pri_freq"";
this.b_pri_freq.Size = new System.Drawing.Size(30, 20);
this.b_pri_freq.TabIndex = 14;
this.b_pri_freq.Text = ""fix"";
this.b_pri_freq.UseVisualStyleBackColor = true;
// // c_pri_tele
// this.c_pri_tele.AutoSize = true;
this.c_pri_tele.Enabled = false;
this.c_pri_tele.Location = new System.Drawing.Point(6, 42);
this.c_pri_tele.Name = ""c_pri_tele"";
this.c_pri_tele.Size = new System.Drawing.Size(205, 17);
this.c_pri_tele.TabIndex = 1;
this.c_pri_tele.Text = ""Checking Mircosoft Telemetry Hosts..."";
this.c_pri_tele.UseVisualStyleBackColor = true;
// // c_pri_freq
// this.c_pri_freq.AutoSize = true;
this.c_pri_freq.Enabled = false;
this.c_pri_freq.Location = new System.Drawing.Point(6, 19);
this.c_pri_freq.Name = ""c_pri_freq"";
this.c_pri_freq.Size = new System.Drawing.Size(172, 17);
this.c_pri_freq.TabIndex = 0;
this.c_pri_freq.Text = ""Checking Feedback frequency"";
this.c_pri_freq.UseVisualStyleBackColor = true;
// // groupBox3
// this.groupBox3.Controls.Add(this.checkBox24);
this.groupBox3.Controls.Add(this.button25);
this.groupBox3.Controls.Add(this.button24);
this.groupBox3.Controls.Add(this.button23);
this.groupBox3.Controls.Add(this.button17);
this.groupBox3.Controls.Add(this.button18);
this.groupBox3.Controls.Add(this.button19);
this.groupBox3.Controls.Add(this.button20);
this.groupBox3.Controls.Add(this.checkBox16);
this.groupBox3.Controls.Add(this.checkBox17);
this.groupBox3.Controls.Add(this.checkBox18);
this.groupBox3.Controls.Add(this.checkBox19);
this.groupBox3.Controls.Add(this.button21);
this.groupBox3.Controls.Add(this.button22);
this.groupBox3.Controls.Add(this.checkBox20);
this.groupBox3.Controls.Add(this.checkBox23);
this.groupBox3.Location = new System.Drawing.Point(621, 28);
this.groupBox3.Name = ""groupBox3"";
this.groupBox3.Size = new System.Drawing.Size(277, 278);
this.groupBox3.TabIndex = 24;
this.groupBox3.TabStop = false;
this.groupBox3.Text = ""Windows 10 Apps"";
// // checkBox24
// this.checkBox24.AutoSize = true;
this.checkBox24.Enabled = false;
this.checkBox24.Location = new System.Drawing.Point(6, 186);
this.checkBox24.Name = ""checkBox24"";
this.checkBox24.Size = new System.Drawing.Size(71, 17);
this.checkBox24.TabIndex = 27;
this.checkBox24.Text = ""OneDrive"";
this.checkBox24.UseVisualStyleBackColor = true;
// // button25
// this.button25.Enabled = false;
this.button25.Location = new System.Drawing.Point(210, 186);
this.button25.Name = ""button25"";
this.button25.Size = new System.Drawing.Size(55, 20);
this.button25.TabIndex = 26;
this.button25.Text = ""uninstall"";
this.button25.UseVisualStyleBackColor = true;
// // button24
// this.button24.Enabled = false;
this.button24.Location = new System.Drawing.Point(59, 160);
this.button24.Name = ""button24"";
this.button24.Size = new System.Drawing.Size(153, 20);
this.button24.TabIndex = 25;
this.button24.Text = ""uninstall all windows 10 apps"";
this.button24.UseVisualStyleBackColor = true;
// // button23
// this.button23.Enabled = false;
this.button23.Location = new System.Drawing.Point(218, 160);
this.button23.Name = ""button23"";
this.button23.Size = new System.Drawing.Size(47, 20);
this.button23.TabIndex = 24;
this.button23.Text = ""fix all"";
this.button23.UseVisualStyleBackColor = true;
// // button17
// this.button17.Enabled = false;
this.button17.Location = new System.Drawing.Point(235, 134);
this.button17.Name = ""button17"";
this.button17.Size = new System.Drawing.Size(30, 20);
this.button17.TabIndex = 23;
this.button17.Text = ""fix"";
this.button17.UseVisualStyleBackColor = true;
// // button18
// this.button18.Enabled = false;
this.button18.Location = new System.Drawing.Point(235, 111);
this.button18.Name = ""button18"";
this.button18.Size = new System.Drawing.Size(30, 20);
this.button18.TabIndex = 22;
this.button18.Text = ""fix"";
this.button18.UseVisualStyleBackColor = true;
// // button19
// this.button19.Enabled = false;
this.button19.Location = new System.Drawing.Point(235, 88);
this.button19.Name = ""button19"";
this.button19.Size = new System.Drawing.Size(30, 20);
this.button19.TabIndex = 21;
this.button19.Text = ""fix"";
this.button19.UseVisualStyleBackColor = true;
// // button20
// this.button20.Enabled = false;
this.button20.Location = new System.Drawing.Point(235, 65);
this.button20.Name = ""button20"";
this.button20.Size = new System.Drawing.Size(30, 20);
this.button20.TabIndex = 20;
this.button20.Text = ""fix"";
this.button20.UseVisualStyleBackColor = true;
// // checkBox16
// this.checkBox16.AutoSize = true;
this.checkBox16.Enabled = false;
this.checkBox16.Location = new System.Drawing.Point(6, 134);
this.checkBox16.Name = ""checkBox16"";
this.checkBox16.Size = new System.Drawing.Size(140, 17);
this.checkBox16.TabIndex = 19;
this.checkBox16.Text = ""... to bluetooth and wlan"";
this.checkBox16.UseVisualStyleBackColor = true;
// // checkBox17
// this.checkBox17.AutoSize = true;
this.checkBox17.Enabled = false;
this.checkBox17.Location = new System.Drawing.Point(6, 111);
this.checkBox17.Name = ""checkBox17"";
this.checkBox17.Size = new System.Drawing.Size(122, 17);
this.checkBox17.TabIndex = 18;
this.checkBox17.Text = ""... to SMS and MMS"";
this.checkBox17.UseVisualStyleBackColor = true;
// // checkBox18
// this.checkBox18.AutoSize = true;
this.checkBox18.Enabled = false;
this.checkBox18.Location = new System.Drawing.Point(6, 88);
this.checkBox18.Name = ""checkBox18"";
this.checkBox18.Size = new System.Drawing.Size(92, 17);
this.checkBox18.TabIndex = 17;
this.checkBox18.Text = ""... to Calendar"";
this.checkBox18.UseVisualStyleBackColor = true;
// // checkBox19
// this.checkBox19.AutoSize = true;
this.checkBox19.Enabled = false;
this.checkBox19.Location = new System.Drawing.Point(6, 65);
this.checkBox19.Name = ""checkBox19"";
this.checkBox19.Size = new System.Drawing.Size(163, 17);
this.checkBox19.TabIndex = 16;
this.checkBox19.Text = ""... to Name, picture and more"";
this.checkBox19.UseVisualStyleBackColor = true;
// // button21
// this.button21.Enabled = false;
this.button21.Location = new System.Drawing.Point(235, 42);
this.button21.Name = ""button21"";
this.button21.Size = new System.Drawing.Size(30, 20);
this.button21.TabIndex = 15;
this.button21.Text = ""fix"";
this.button21.UseVisualStyleBackColor = true;
// // button22
// this.button22.Enabled = false;
this.button22.Location = new System.Drawing.Point(235, 19);
this.button22.Name = ""button22"";
this.button22.Size = new System.Drawing.Size(30, 20);
this.button22.TabIndex = 14;
this.button22.Text = ""fix"";
this.button22.UseVisualStyleBackColor = true;
// // checkBox20
// this.checkBox20.AutoSize = true;
this.checkBox20.Enabled = false;
this.checkBox20.Location = new System.Drawing.Point(6, 42);
this.checkBox20.Name = ""checkBox20"";
this.checkBox20.Size = new System.Drawing.Size(86, 17);
this.checkBox20.TabIndex = 1;
this.checkBox20.Text = ""... to Camera"";
this.checkBox20.UseVisualStyleBackColor = true;
// // checkBox23
// this.checkBox23.AutoSize = true;
this.checkBox23.Enabled = false;
this.checkBox23.Location = new System.Drawing.Point(6, 19);
this.checkBox23.Name = ""checkBox23"";
this.checkBox23.Size = new System.Drawing.Size(91, 17);
this.checkBox23.TabIndex = 0;
this.checkBox23.Text = ""... to Location"";
this.checkBox23.UseVisualStyleBackColor = true;
// // groupBox4
// this.groupBox4.Controls.Add(this.b_misc_god);
this.groupBox4.Controls.Add(this.c_misc_god);
this.groupBox4.Controls.Add(this.b_misc_onedrive);
this.groupBox4.Controls.Add(this.c_misc_onedrive);
this.groupBox4.Controls.Add(this.button34);
this.groupBox4.Controls.Add(this.checkBox31);
this.groupBox4.Location = new System.Drawing.Point(904, 28);
this.groupBox4.Name = ""groupBox4"";
this.groupBox4.Size = new System.Drawing.Size(163, 278);
this.groupBox4.TabIndex = 28;
this.groupBox4.TabStop = false;
this.groupBox4.Text = ""Misc"";
// // button34
// this.button34.Enabled = false;
this.button34.Location = new System.Drawing.Point(124, 19);
this.button34.Name = ""button34"";
this.button34.Size = new System.Drawing.Size(30, 20);
this.button34.TabIndex = 14;
this.button34.Text = ""fix"";
this.button34.UseVisualStyleBackColor = true;
// // checkBox31
// this.checkBox31.AutoSize = true;
this.checkBox31.Enabled = false;
this.checkBox31.Location = new System.Drawing.Point(6, 19);
this.checkBox31.Name = ""checkBox31"";
this.checkBox31.Size = new System.Drawing.Size(102, 17);
this.checkBox31.TabIndex = 0;
this.checkBox31.Text = ""... Windows.old "";
this.checkBox31.UseVisualStyleBackColor = true;
// // groupBox5
// this.groupBox5.Controls.Add(this.infotext);
this.groupBox5.Location = new System.Drawing.Point(18, 349);
this.groupBox5.Name = ""groupBox5"";
this.groupBox5.Size = new System.Drawing.Size(1049, 120);
this.groupBox5.TabIndex = 29;
this.groupBox5.TabStop = false;
this.groupBox5.Text = ""Infobox"";
// // infotext
// this.infotext.AutoSize = true;
this.infotext.Location = new System.Drawing.Point(13, 21);
this.infotext.Name = ""infotext"";
this.infotext.Size = new System.Drawing.Size(0, 13);
this.infotext.TabIndex = 0;
// // c_misc_onedrive
// this.c_misc_onedrive.AutoSize = true;
this.c_misc_onedrive.Enabled = false;
this.c_misc_onedrive.Location = new System.Drawing.Point(6, 42);
this.c_misc_onedrive.Name = ""c_misc_onedrive"";
this.c_misc_onedrive.Size = new System.Drawing.Size(107, 17);
this.c_misc_onedrive.TabIndex = 15;
this.c_misc_onedrive.Text = ""One Drive Status"";
this.c_misc_onedrive.UseVisualStyleBackColor = true;
// // b_misc_onedrive
// this.b_misc_onedrive.Enabled = false;
this.b_misc_onedrive.Location = new System.Drawing.Point(124, 39);
this.b_misc_onedrive.Name = ""b_misc_onedrive"";
this.b_misc_onedrive.Size = new System.Drawing.Size(30, 20);
this.b_misc_onedrive.TabIndex = 16;
this.b_misc_onedrive.Text = ""fix"";
this.b_misc_onedrive.UseVisualStyleBackColor = true;
// // c_misc_god
// this.c_misc_god.AutoSize = true;
this.c_misc_god.Enabled = false;
this.c_misc_god.Location = new System.Drawing.Point(6, 68);
this.c_misc_god.Name = ""c_misc_god"";
this.c_misc_god.Size = new System.Drawing.Size(72, 17);
this.c_misc_god.TabIndex = 17;
this.c_misc_god.Text = ""Godmode"";
this.c_misc_god.UseVisualStyleBackColor = true;
// // b_misc_god
// this.b_misc_god.Enabled = false;
this.b_misc_god.Location = new System.Drawing.Point(124, 62);
this.b_misc_god.Name = ""b_misc_god"";
this.b_misc_god.Size = new System.Drawing.Size(30, 20);
this.b_misc_god.TabIndex = 18;
this.b_misc_god.Text = ""fix"";
this.b_misc_god.UseVisualStyleBackColor = true;
this.b_misc_god.Click += new System.EventHandler(this.b_misc_god_Click);
// // win10privacyfix2
// this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
this.BackColor = System.Drawing.SystemColors.Control;
this.ClientSize = new System.Drawing.Size(1071, 481);
this.Controls.Add(this.groupBox5);
this.Controls.Add(this.groupBox4);
this.Controls.Add(this.groupBox3);
this.Controls.Add(this.groupBox2);
this.Controls.Add(this.groupBox1);
this.Controls.Add(this.toolStrip1);
this.Controls.Add(this.b_check);
this.Controls.Add(this.pb);
this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
this.HelpButton = true;
this.Icon = ((System.Drawing.Icon)(resources.GetObject(""$this.Icon"")));
this.MaximizeBox = false;
this.Name = ""win10privacyfix2"";
this.Text = ""win10privacyfix2"";
this.toolStrip1.ResumeLayout(false);
this.toolStrip1.PerformLayout();
this.groupBox1.ResumeLayout(false);
this.groupBox1.PerformLayout();
this.groupBox2.ResumeLayout(false);
this.groupBox2.PerformLayout();
this.groupBox3.ResumeLayout(false);
this.groupBox3.PerformLayout();
this.groupBox4.ResumeLayout(false);
this.groupBox4.PerformLayout();
this.groupBox5.ResumeLayout(false);
this.groupBox5.PerformLayout();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2598,"public void RootTest()
{
Assert.AreEqual(FileSystemPath.Parse(""/""), root);
}",A test for Root /summary>,1
2599,"public void ParentPathTest()
{
Assert.IsTrue(
Directories
.Where(d => d.GetDirectorySegments().Length == 1)
.All(d => d.ParentPath == root)
);
Assert.IsFalse(!Files.All(f => f.RemoveChild(root.AppendFile(f.EntityName)) == f.ParentPath));
EAssert.Throws<InvalidOperationException>(() => Assert.AreEqual(root.ParentPath, root.ParentPath));
}",A test for ParentPath /summary>,1
2600,"public void IsRootTest()
{
Assert.IsTrue(root.IsRoot);
Assert.IsFalse(directoryA.IsRoot);
Assert.IsFalse(fileA.IsRoot);
}",A test for IsRoot /summary>,1
2601,"public void IsFileTest()
{
Assert.IsTrue(fileA.IsFile);
Assert.IsFalse(directoryA.IsFile);
Assert.IsFalse(root.IsFile);
}",A test for IsFile /summary>,1
2602,"public void IsDirectoryTest()
{
Assert.IsTrue(directoryA.IsDirectory);
Assert.IsTrue(root.IsDirectory);
Assert.IsFalse(fileA.IsDirectory);
}",A test for IsDirectory /summary>,1
2603,"public void EntityNameTest()
{
Assert.AreEqual(fileA.EntityName, ""filea"");
Assert.AreEqual(fileB.EntityName, ""fileb.txt"");
Assert.AreEqual(root.EntityName, null);
}",A test for EntityName /summary>,1
2604,"public void ToStringTest()
{
string s = ""/directorya/"";
Assert.AreEqual(s, FileSystemPath.Parse(s).ToString());
}",A test for ToString /summary>,1
2605,"public void RemoveParentTest()
{
Assert.AreEqual(directoryB.RemoveParent(directoryB), root);
Assert.AreEqual(fileB.RemoveParent(directoryA), FileSystemPath.Parse(""/fileb.txt""));
Assert.AreEqual(root.RemoveParent(root), root);
Assert.AreEqual(directoryB.RemoveParent(root), directoryB);
EAssert.Throws<ArgumentException>(() => fileB.RemoveParent(FileSystemPath.Parse(""/nonexistantparent/"")));
EAssert.Throws<ArgumentException>(() => fileB.RemoveParent(FileSystemPath.Parse(""/nonexistantparent"")));
EAssert.Throws<ArgumentException>(() => fileB.RemoveParent(FileSystemPath.Parse(""/fileb.txt"")));
EAssert.Throws<ArgumentException>(() => fileB.RemoveParent(FileSystemPath.Parse(""/directorya"")));
}",A test for RemoveParent /summary>,1
2606,"public void RemoveChildTest()
{
Assert.AreEqual(fileB.RemoveChild(FileSystemPath.Parse(""/fileb.txt"")), directoryA);
Assert.AreEqual(directoryB.RemoveChild(FileSystemPath.Parse(""/directoryb/"")), directoryA);
Assert.AreEqual(directoryB.RemoveChild(directoryB), root);
Assert.AreEqual(fileB.RemoveChild(fileB), root);
EAssert.Throws<ArgumentException>(() => directoryA.RemoveChild(FileSystemPath.Parse(""/nonexistantchild"")));
EAssert.Throws<ArgumentException>(() => directoryA.RemoveChild(FileSystemPath.Parse(""/directorya"")));
}",A test for RemoveChild /summary>,1
2607,"public void ParseTest()
{
Assert.IsTrue(_paths.All(p => p == FileSystemPath.Parse(p.ToString())));
EAssert.Throws<ArgumentNullException>(() => FileSystemPath.Parse(null));
EAssert.Throws<ParseException>(() => FileSystemPath.Parse(""thisisnotapath""));
EAssert.Throws<ParseException>(() => FileSystemPath.Parse(""/thisisainvalid//path""));
}",A test for Parse /summary>,1
2608,"public void IsRootedTest()
{
Assert.IsTrue(FileSystemPath.IsRooted(""/filea""));
Assert.IsTrue(FileSystemPath.IsRooted(""/directorya/""));
Assert.IsFalse(FileSystemPath.IsRooted(""filea""));
Assert.IsFalse(FileSystemPath.IsRooted(""directorya/""));
Assert.IsTrue(_paths.All(p => FileSystemPath.IsRooted(p.ToString())));
}",A test for IsRooted /summary>,1
2609,"public void IsParentOfTest()
{
Assert.IsTrue(directoryA.IsParentOf(fileB));
Assert.IsTrue(directoryA.IsParentOf(directoryB));
Assert.IsTrue(root.IsParentOf(fileA));
Assert.IsTrue(root.IsParentOf(directoryA));
Assert.IsTrue(root.IsParentOf(fileB));
Assert.IsTrue(root.IsParentOf(directoryB));
Assert.IsFalse(fileB.IsParentOf(directoryA));
Assert.IsFalse(directoryB.IsParentOf(directoryA));
Assert.IsFalse(fileA.IsParentOf(root));
Assert.IsFalse(directoryA.IsParentOf(root));
Assert.IsFalse(fileB.IsParentOf(root));
Assert.IsFalse(directoryB.IsParentOf(root));
}",A test for IsParentOf /summary>,1
2610,"public void IsChildOfTest()
{
Assert.IsTrue(fileB.IsChildOf(directoryA));
Assert.IsTrue(directoryB.IsChildOf(directoryA));
Assert.IsTrue(fileA.IsChildOf(root));
Assert.IsTrue(directoryA.IsChildOf(root));
Assert.IsTrue(fileB.IsChildOf(root));
Assert.IsTrue(directoryB.IsChildOf(root));
Assert.IsFalse(directoryA.IsChildOf(fileB));
Assert.IsFalse(directoryA.IsChildOf(directoryB));
Assert.IsFalse(root.IsChildOf(fileA));
Assert.IsFalse(root.IsChildOf(directoryA));
Assert.IsFalse(root.IsChildOf(fileB));
Assert.IsFalse(root.IsChildOf(directoryB));
}",A test for IsChildOf /summary>,1
2611,"public void GetExtensionTest()
{
Assert.AreEqual(fileA.GetExtension(), """");
Assert.AreEqual(fileB.GetExtension(), "".txt"");
fileC = FileSystemPath.Parse(""/directory.txt/filec"");
Assert.AreEqual(fileC.GetExtension(), """");
EAssert.Throws<ArgumentException>(() => directoryA.GetExtension());
}",A test for GetExtension /summary>,1
2612,"public void GetDirectorySegmentsTest()
{
Assert.AreEqual(0, root.GetDirectorySegments().Length);
Directories
.Where(d => !d.IsRoot)
.All(d => d.GetDirectorySegments().Length == d.ParentPath.GetDirectorySegments().Length - 1);
Files.All(f => f.GetDirectorySegments().Length == f.ParentPath.GetDirectorySegments().Length); }",A test for GetDirectorySegments /summary>,1
2613,"public void CompareToTest()
{
foreach(var pa in _paths)
foreach(var pb in _paths)
Assert.AreEqual(pa.CompareTo(pb), pa.ToString().CompareTo(pb.ToString()));
}",A test for CompareTo /summary>,1
2614,"public void ChangeExtensionTest()
{
_paths
.Where(p => p.IsFile)
.All(p => p.ChangeExtension("".exe"").GetExtension() == "".exe"");
EAssert.Throws<ArgumentException>(() => directoryA.ChangeExtension("".exe""));
}",A test for ChangeExtension /summary>,1
2615,"public void AppendPathTest()
{
Directories.All(p => p.AppendPath(root) == p);
Directories.All(p => p.AppendPath("""") == p);
var subpath = FileSystemPath.Parse(""/dir/file"");
var subpathstr = ""dir/file"";
Directories.All(p => p.AppendPath(subpath).ParentPath.ParentPath == p);
Directories.All(p => p.AppendPath(subpathstr).ParentPath.ParentPath == p);
Directories.All(pa => _paths.All(pb => pa.AppendPath(pb).IsChildOf(pa)));
EAssert.Throws<InvalidOperationException>(() => fileA.AppendPath(subpath));
EAssert.Throws<InvalidOperationException>(() => fileA.AppendPath(subpathstr));
EAssert.Throws<ArgumentException>(() => directoryA.AppendPath(""/rootedpath/""));
}",A test for AppendPath /summary>,1
2616,"public void AppendFileTest()
{
Directories.All(d => d.AppendFile(""file"").IsFile);
Directories.All(d => d.AppendFile(""file"").EntityName == ""file"");
Directories.All(d => d.AppendFile(""file"").ParentPath == d);
EAssert.Throws<InvalidOperationException>(() => fileA.AppendFile(""file""));
EAssert.Throws<ArgumentException>(() => directoryA.AppendFile(""dir/file""));
}",A test for AppendFile /summary>,1
2617,"public void AppendDirectoryTest()
{
Directories.All(d => d.AppendDirectory(""dir"").IsDirectory);
Directories.All(d => d.AppendDirectory(""dir"").EntityName == ""dir"");
Directories.All(d => d.AppendDirectory(""dir"").ParentPath == d);
EAssert.Throws<InvalidOperationException>(() => fileA.AppendDirectory(""dir""));
EAssert.Throws<ArgumentException>(() => root.AppendDirectory(""dir/dir""));
}",A test for AppendDirectory /summary>,1
2618,"private void InitializeComponent()
{
this.label1 = new System.Windows.Forms.Label();
this._logoPictureBox = new System.Windows.Forms.PictureBox();
this.textBoxDescription = new System.Windows.Forms.Label();
this.labelCopyright = new System.Windows.Forms.Label();
this.labelCompanyName = new System.Windows.Forms.Label();
this.labelVersion = new System.Windows.Forms.Label();
this.linkLabel1 = new System.Windows.Forms.LinkLabel();
this.label2 = new System.Windows.Forms.Label();
this._btnCheckForUpdates = new System.Windows.Forms.Button();
this._pnlUpdates = new System.Windows.Forms.Panel();
this._lblUpdateStatus = new System.Windows.Forms.Label();
this._btnUpdate = new System.Windows.Forms.Button();
((System.ComponentModel.ISupportInitialize)(this._logoPictureBox)).BeginInit();
this._pnlUpdates.SuspendLayout();
this.SuspendLayout();
// // label1
// this.label1.FlatStyle = System.Windows.Forms.FlatStyle.System;
this.label1.Location = new System.Drawing.Point(8, 214);
this.label1.Name = ""label1"";
this.label1.Size = new System.Drawing.Size(397, 35);
this.label1.TabIndex = 24;
this.label1.Text = ""Some Icons are Copyright Yusuke Kamiyamane. All rights reserved. Licensed under"" +
"" a Creative Commons Attribution 3.0 license."";
// // _logoPictureBox
// this._logoPictureBox.Dock = System.Windows.Forms.DockStyle.Top;
this._logoPictureBox.Image = global::gitter.Properties.Resources.ImgStartPageLogo;
this._logoPictureBox.Location = new System.Drawing.Point(0, 0);
this._logoPictureBox.Name = ""_logoPictureBox"";
this._logoPictureBox.Size = new System.Drawing.Size(500, 90);
this._logoPictureBox.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
this._logoPictureBox.TabIndex = 13;
this._logoPictureBox.TabStop = false;
// // textBoxDescription
// this.textBoxDescription.FlatStyle = System.Windows.Forms.FlatStyle.System;
this.textBoxDescription.Location = new System.Drawing.Point(8, 93);
this.textBoxDescription.Name = ""textBoxDescription"";
this.textBoxDescription.Size = new System.Drawing.Size(362, 17);
this.textBoxDescription.TabIndex = 25;
this.textBoxDescription.Text = ""Graphical interface for git content tracker."";
this.textBoxDescription.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
// // labelCopyright
// this.labelCopyright.FlatStyle = System.Windows.Forms.FlatStyle.System;
this.labelCopyright.Location = new System.Drawing.Point(8, 145);
this.labelCopyright.Name = ""labelCopyright"";
this.labelCopyright.Size = new System.Drawing.Size(158, 17);
this.labelCopyright.TabIndex = 25;
this.labelCopyright.Text = ""Written by: Popovskiy Maxim"";
this.labelCopyright.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
// // labelCompanyName
// this.labelCompanyName.FlatStyle = System.Windows.Forms.FlatStyle.System;
this.labelCompanyName.Location = new System.Drawing.Point(8, 171);
this.labelCompanyName.Name = ""labelCompanyName"";
this.labelCompanyName.Size = new System.Drawing.Size(427, 33);
this.labelCompanyName.TabIndex = 25;
this.labelCompanyName.Text = ""gitter is free software; you can redistribute it and/or modify it under the terms"" +
"" of the GNU General Public License."";
this.labelCompanyName.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
// // labelVersion
// this.labelVersion.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this.labelVersion.FlatStyle = System.Windows.Forms.FlatStyle.System;
this.labelVersion.Location = new System.Drawing.Point(69, 119);
this.labelVersion.Name = ""labelVersion"";
this.labelVersion.Size = new System.Drawing.Size(70, 17);
this.labelVersion.TabIndex = 26;
this.labelVersion.Text = ""[Version]"";
this.labelVersion.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
// // linkLabel1
// this.linkLabel1.Location = new System.Drawing.Point(172, 145);
this.linkLabel1.Name = ""linkLabel1"";
this.linkLabel1.Size = new System.Drawing.Size(149, 17);
this.linkLabel1.TabIndex = 27;
this.linkLabel1.TabStop = true;
this.linkLabel1.Text = ""amgine.gitter@gmail.com"";
this.linkLabel1.LinkClicked += OnEmailLinkClicked;
// // label2
// this.label2.FlatStyle = System.Windows.Forms.FlatStyle.System;
this.label2.Location = new System.Drawing.Point(8, 119);
this.label2.Name = ""label2"";
this.label2.Size = new System.Drawing.Size(52, 17);
this.label2.TabIndex = 25;
this.label2.Text = ""Version:"";
this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
// // _btnCheckForUpdates
// this._btnCheckForUpdates.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnCheckForUpdates.Location = new System.Drawing.Point(0, 0);
this._btnCheckForUpdates.Name = ""_btnCheckForUpdates"";
this._btnCheckForUpdates.Size = new System.Drawing.Size(123, 23);
this._btnCheckForUpdates.TabIndex = 28;
this._btnCheckForUpdates.Text = ""Check For Updates"";
this._btnCheckForUpdates.UseVisualStyleBackColor = true;
this._btnCheckForUpdates.Click += new System.EventHandler(this.OnCheckForUpdatesClick);
// // _pnlUpdates
// this._pnlUpdates.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlUpdates.Controls.Add(this._lblUpdateStatus);
this._pnlUpdates.Controls.Add(this._btnUpdate);
this._pnlUpdates.Controls.Add(this._btnCheckForUpdates);
this._pnlUpdates.Location = new System.Drawing.Point(175, 116);
this._pnlUpdates.Name = ""_pnlUpdates"";
this._pnlUpdates.Size = new System.Drawing.Size(322, 23);
this._pnlUpdates.TabIndex = 29;
// // _lblUpdateStatus
// this._lblUpdateStatus.AutoSize = true;
this._lblUpdateStatus.Location = new System.Drawing.Point(-3, 4);
this._lblUpdateStatus.Name = ""_lblUpdateStatus"";
this._lblUpdateStatus.Size = new System.Drawing.Size(57, 15);
this._lblUpdateStatus.TabIndex = 29;
this._lblUpdateStatus.Text = ""[STATUS]"";
this._lblUpdateStatus.Visible = false;
// // _btnUpdate
// this._btnUpdate.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnUpdate.Location = new System.Drawing.Point(190, 0);
this._btnUpdate.Name = ""_btnUpdate"";
this._btnUpdate.Size = new System.Drawing.Size(88, 23);
this._btnUpdate.TabIndex = 28;
this._btnUpdate.Text = ""Update"";
this._btnUpdate.UseVisualStyleBackColor = true;
this._btnUpdate.Visible = false;
this._btnUpdate.Click += new System.EventHandler(this.OnUpdateClick);
// // AboutDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._pnlUpdates);
this.Controls.Add(this.linkLabel1);
this.Controls.Add(this.labelVersion);
this.Controls.Add(this.labelCompanyName);
this.Controls.Add(this.labelCopyright);
this.Controls.Add(this.label2);
this.Controls.Add(this.textBoxDescription);
this.Controls.Add(this._logoPictureBox);
this.Controls.Add(this.label1);
this.Name = ""AboutDialog"";
this.Size = new System.Drawing.Size(500, 252);
((System.ComponentModel.ISupportInitialize)(this._logoPictureBox)).EndInit();
this._pnlUpdates.ResumeLayout(false);
this._pnlUpdates.PerformLayout();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2619,"public static ICommandArgument Verbose()
{
return CommandFlag.Verbose();
}",Be verbose.,1
2620,"public static ICommandArgument Interactive()
{
return CommandFlag.Interactive();
}",Add modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See Interactive mode for details.,1
2621,"public static ICommandArgument Update()
{
return new CommandFlag(""--update"");
}","Update only files that git already knows about, staging modified content for commit and marking deleted files for removal. This is similar to what ""git commit -a"" does in preparation for making a commit, except that the update is limited to paths specified on the command line. If no paths are specified, all tracked files in the current directory and its subdirectories are updated.",1
2622,"public static ICommandArgument IntentToAdd()
{
return new CommandFlag(""--intent-to-add"");
}","Record only the fact that the path will be added later. An entry for the path is placed in the index with no content. This is useful for, among other things, showing the unstaged content of such files with git diff and committing them with git commit -a.",1
2623,"public static ICommandArgument IgnoreErrors()
{
return new CommandFlag(""--ignore-errors"");
}","If some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status.",1
2624,"public static ICommandArgument NoMoreOptions()
{
return CommandFlag.NoMoreOptions();
}","This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).",1
2625,"private void InitializeComponent()
{
this._txtMessage = new System.Windows.Forms.TextBox();
this._lblMessage = new System.Windows.Forms.Label();
this._txtRevision = new gitter.Git.Gui.Controls.RevisionPicker();
this._lblRevision = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _txtMessage
// this._txtMessage.AcceptsReturn = true;
this._txtMessage.AcceptsTab = true;
this._txtMessage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtMessage.Location = new System.Drawing.Point(3, 49);
this._txtMessage.Multiline = true;
this._txtMessage.Name = ""_txtMessage"";
this._txtMessage.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
this._txtMessage.Size = new System.Drawing.Size(394, 189);
this._txtMessage.TabIndex = 1;
// // _lblMessage
// this._lblMessage.AutoSize = true;
this._lblMessage.Location = new System.Drawing.Point(0, 31);
this._lblMessage.Name = ""_lblMessage"";
this._lblMessage.Size = new System.Drawing.Size(76, 15);
this._lblMessage.TabIndex = 2;
this._lblMessage.Text = ""%Message%:"";
// // _txtRevision
// this._txtRevision.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtRevision.FormattingEnabled = true;
this._txtRevision.Location = new System.Drawing.Point(94, 3);
this._txtRevision.Name = ""_txtRevision"";
this._txtRevision.Size = new System.Drawing.Size(303, 23);
this._txtRevision.TabIndex = 0;
// // _lblRevision
// this._lblRevision.AutoSize = true;
this._lblRevision.Location = new System.Drawing.Point(0, 6);
this._lblRevision.Name = ""_lblRevision"";
this._lblRevision.Size = new System.Drawing.Size(74, 15);
this._lblRevision.TabIndex = 3;
this._lblRevision.Text = ""%Revision%:"";
// // AddNoteDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblRevision);
this.Controls.Add(this._txtRevision);
this.Controls.Add(this._txtMessage);
this.Controls.Add(this._lblMessage);
this.Name = ""AddNoteDialog"";
this.Size = new System.Drawing.Size(400, 241);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2626,"private void InitializeComponent()
{
this._lblName = new System.Windows.Forms.Label();
this._lblValue = new System.Windows.Forms.Label();
this._txtName = new System.Windows.Forms.TextBox();
this._txtValue = new System.Windows.Forms.TextBox();
this.SuspendLayout();
// // _lblName
// this._lblName.AutoSize = true;
this._lblName.Location = new System.Drawing.Point(0, 6);
this._lblName.Name = ""_lblName"";
this._lblName.Size = new System.Drawing.Size(62, 15);
this._lblName.TabIndex = 0;
this._lblName.Text = ""%Name%:"";
// // _lblValue
// this._lblValue.AutoSize = true;
this._lblValue.Location = new System.Drawing.Point(0, 32);
this._lblValue.Name = ""_lblValue"";
this._lblValue.Size = new System.Drawing.Size(59, 15);
this._lblValue.TabIndex = 1;
this._lblValue.Text = ""%Value%:"";
// // _txtName
// this._txtName.Location = new System.Drawing.Point(94, 3);
this._txtName.Name = ""_txtName"";
this._txtName.Size = new System.Drawing.Size(288, 23);
this._txtName.TabIndex = 2;
// // _txtValue
// this._txtValue.Location = new System.Drawing.Point(94, 29);
this._txtValue.Name = ""_txtValue"";
this._txtValue.Size = new System.Drawing.Size(288, 23);
this._txtValue.TabIndex = 3;
// // AddParameterDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._txtValue);
this.Controls.Add(this._txtName);
this.Controls.Add(this._lblValue);
this.Controls.Add(this._lblName);
this.Name = ""AddParameterDialog"";
this.Size = new System.Drawing.Size(385, 55);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2627,"private void InitializeComponent()
{
this._lblUrl = new System.Windows.Forms.Label();
this._lblName = new System.Windows.Forms.Label();
this._txtUrl = new System.Windows.Forms.TextBox();
this._txtName = new System.Windows.Forms.TextBox();
this._chkFetch = new System.Windows.Forms.CheckBox();
this._pnlOptions = new System.Windows.Forms.Panel();
this._chkMirror = new System.Windows.Forms.CheckBox();
this._grpOptions = new gitter.Framework.Controls.GroupSeparator();
this.panel1 = new System.Windows.Forms.Panel();
this._tagFetchAll = new System.Windows.Forms.RadioButton();
this._tagFetchNone = new System.Windows.Forms.RadioButton();
this._tagFetchDefault = new System.Windows.Forms.RadioButton();
this._grpTagImport = new gitter.Framework.Controls.GroupSeparator();
this.panel2 = new System.Windows.Forms.Panel();
this._trackSpecified = new System.Windows.Forms.RadioButton();
this._trackAllBranches = new System.Windows.Forms.RadioButton();
this._grpBranches = new gitter.Framework.Controls.GroupSeparator();
this._pnlOptions.SuspendLayout();
this.panel1.SuspendLayout();
this.panel2.SuspendLayout();
this.SuspendLayout();
// // _lblUrl
// this._lblUrl.AutoSize = true;
this._lblUrl.Location = new System.Drawing.Point(0, 32);
this._lblUrl.Name = ""_lblUrl"";
this._lblUrl.Size = new System.Drawing.Size(51, 15);
this._lblUrl.TabIndex = 7;
this._lblUrl.Text = ""%URL%:"";
// // _lblName
// this._lblName.AutoSize = true;
this._lblName.Location = new System.Drawing.Point(0, 6);
this._lblName.Name = ""_lblName"";
this._lblName.Size = new System.Drawing.Size(62, 15);
this._lblName.TabIndex = 6;
this._lblName.Text = ""%Name%:"";
// // _txtUrl
// this._txtUrl.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtUrl.Location = new System.Drawing.Point(94, 29);
this._txtUrl.Name = ""_txtUrl"";
this._txtUrl.Size = new System.Drawing.Size(288, 23);
this._txtUrl.TabIndex = 1;
// // _txtName
// this._txtName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtName.Location = new System.Drawing.Point(94, 3);
this._txtName.Name = ""_txtName"";
this._txtName.Size = new System.Drawing.Size(288, 23);
this._txtName.TabIndex = 0;
// // _chkFetch
// this._chkFetch.AutoSize = true;
this._chkFetch.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkFetch.Location = new System.Drawing.Point(12, 25);
this._chkFetch.Name = ""_chkFetch"";
this._chkFetch.Size = new System.Drawing.Size(125, 20);
this._chkFetch.TabIndex = 2;
this._chkFetch.Text = ""%Fetch Remote%"";
this._chkFetch.UseVisualStyleBackColor = true;
// // _pnlOptions
// this._pnlOptions.Controls.Add(this._chkMirror);
this._pnlOptions.Controls.Add(this._grpOptions);
this._pnlOptions.Controls.Add(this._chkFetch);
this._pnlOptions.Location = new System.Drawing.Point(0, 58);
this._pnlOptions.Margin = new System.Windows.Forms.Padding(0);
this._pnlOptions.Name = ""_pnlOptions"";
this._pnlOptions.Size = new System.Drawing.Size(382, 49);
this._pnlOptions.TabIndex = 10;
// // _chkMirror
// this._chkMirror.AutoSize = true;
this._chkMirror.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkMirror.Location = new System.Drawing.Point(177, 25);
this._chkMirror.Name = ""_chkMirror"";
this._chkMirror.Size = new System.Drawing.Size(85, 20);
this._chkMirror.TabIndex = 3;
this._chkMirror.Text = ""%Mirror%"";
this._chkMirror.UseVisualStyleBackColor = true;
// // _grpOptions
// this._grpOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._grpOptions.Location = new System.Drawing.Point(0, 0);
this._grpOptions.Name = ""_grpOptions"";
this._grpOptions.Size = new System.Drawing.Size(382, 19);
this._grpOptions.TabIndex = 0;
this._grpOptions.Text = ""%Options%"";
// // panel1
// this.panel1.Controls.Add(this._tagFetchAll);
this.panel1.Controls.Add(this._tagFetchNone);
this.panel1.Controls.Add(this._tagFetchDefault);
this.panel1.Controls.Add(this._grpTagImport);
this.panel1.Location = new System.Drawing.Point(0, 107);
this.panel1.Margin = new System.Windows.Forms.Padding(0);
this.panel1.Name = ""panel1"";
this.panel1.Size = new System.Drawing.Size(382, 48);
this.panel1.TabIndex = 11;
// // _tagFetchAll
// this._tagFetchAll.AutoSize = true;
this._tagFetchAll.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._tagFetchAll.Location = new System.Drawing.Point(248, 25);
this._tagFetchAll.Name = ""_tagFetchAll"";
this._tagFetchAll.Size = new System.Drawing.Size(93, 20);
this._tagFetchAll.TabIndex = 9;
this._tagFetchAll.Text = ""%All Tags%"";
this._tagFetchAll.UseVisualStyleBackColor = true;
// // _tagFetchNone
// this._tagFetchNone.AutoSize = true;
this._tagFetchNone.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._tagFetchNone.Location = new System.Drawing.Point(127, 25);
this._tagFetchNone.Name = ""_tagFetchNone"";
this._tagFetchNone.Size = new System.Drawing.Size(95, 20);
this._tagFetchNone.TabIndex = 8;
this._tagFetchNone.Text = ""%No Tags%"";
this._tagFetchNone.UseVisualStyleBackColor = true;
// // _tagFetchDefault
// this._tagFetchDefault.AutoSize = true;
this._tagFetchDefault.Checked = true;
this._tagFetchDefault.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._tagFetchDefault.Location = new System.Drawing.Point(11, 25);
this._tagFetchDefault.Name = ""_tagFetchDefault"";
this._tagFetchDefault.Size = new System.Drawing.Size(89, 20);
this._tagFetchDefault.TabIndex = 7;
this._tagFetchDefault.TabStop = true;
this._tagFetchDefault.Text = ""%Default%"";
this._tagFetchDefault.UseVisualStyleBackColor = true;
// // _grpTagImport
// this._grpTagImport.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._grpTagImport.Location = new System.Drawing.Point(0, 0);
this._grpTagImport.Name = ""_grpTagImport"";
this._grpTagImport.Size = new System.Drawing.Size(382, 19);
this._grpTagImport.TabIndex = 0;
this._grpTagImport.Text = ""%Tag Import Mode%"";
// // panel2
// this.panel2.Controls.Add(this._trackSpecified);
this.panel2.Controls.Add(this._trackAllBranches);
this.panel2.Controls.Add(this._grpBranches);
this.panel2.Location = new System.Drawing.Point(294, 196);
this.panel2.Margin = new System.Windows.Forms.Padding(0);
this.panel2.Name = ""panel2"";
this.panel2.Size = new System.Drawing.Size(382, 207);
this.panel2.TabIndex = 12;
this.panel2.Visible = false;
// // _trackSpecified
// this._trackSpecified.AutoSize = true;
this._trackSpecified.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._trackSpecified.Location = new System.Drawing.Point(11, 45);
this._trackSpecified.Name = ""_trackSpecified"";
this._trackSpecified.Size = new System.Drawing.Size(134, 20);
this._trackSpecified.TabIndex = 5;
this._trackSpecified.Text = ""%Track Specified%:"";
this._trackSpecified.UseVisualStyleBackColor = true;
// // _trackAllBranches
// this._trackAllBranches.AutoSize = true;
this._trackAllBranches.Checked = true;
this._trackAllBranches.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._trackAllBranches.Location = new System.Drawing.Point(11, 25);
this._trackAllBranches.Name = ""_trackAllBranches"";
this._trackAllBranches.Size = new System.Drawing.Size(97, 20);
this._trackAllBranches.TabIndex = 4;
this._trackAllBranches.TabStop = true;
this._trackAllBranches.Text = ""%Track All%"";
this._trackAllBranches.UseVisualStyleBackColor = true;
// // _grpBranches
// this._grpBranches.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._grpBranches.Location = new System.Drawing.Point(0, 0);
this._grpBranches.Name = ""_grpBranches"";
this._grpBranches.Size = new System.Drawing.Size(382, 19);
this._grpBranches.TabIndex = 0;
this._grpBranches.Text = ""%Tracking Branches%"";
// // AddRemoteDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this.panel2);
this.Controls.Add(this.panel1);
this.Controls.Add(this._pnlOptions);
this.Controls.Add(this._lblUrl);
this.Controls.Add(this._lblName);
this.Controls.Add(this._txtUrl);
this.Controls.Add(this._txtName);
this.Name = ""AddRemoteDialog"";
this.Size = new System.Drawing.Size(385, 156);
this._pnlOptions.ResumeLayout(false);
this._pnlOptions.PerformLayout();
this.panel1.ResumeLayout(false);
this.panel1.PerformLayout();
this.panel2.ResumeLayout(false);
this.panel2.PerformLayout();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2628,"private void InitializeComponent()
{
this._btnSelectDirectory = new System.Windows.Forms.Button();
this._lblPath = new System.Windows.Forms.Label();
this._txtPath = new System.Windows.Forms.TextBox();
this._txtDescription = new System.Windows.Forms.TextBox();
this._lblDescription = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _btnSelectDirectory
// this._btnSelectDirectory.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnSelectDirectory.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnSelectDirectory.Location = new System.Drawing.Point(353, 3);
this._btnSelectDirectory.Name = ""_btnSelectDirectory"";
this._btnSelectDirectory.Size = new System.Drawing.Size(29, 23);
this._btnSelectDirectory.TabIndex = 1;
this._btnSelectDirectory.Text = ""..."";
this._btnSelectDirectory.UseVisualStyleBackColor = true;
this._btnSelectDirectory.Click += new System.EventHandler(this._btnSelectDirectory_Click);
// // _lblPath
// this._lblPath.AutoSize = true;
this._lblPath.Location = new System.Drawing.Point(0, 6);
this._lblPath.Name = ""_lblPath"";
this._lblPath.Size = new System.Drawing.Size(54, 15);
this._lblPath.TabIndex = 15;
this._lblPath.Text = ""%Path%:"";
// // _txtPath
// this._txtPath.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtPath.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
this._txtPath.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.FileSystemDirectories;
this._txtPath.Location = new System.Drawing.Point(94, 3);
this._txtPath.Name = ""_txtPath"";
this._txtPath.Size = new System.Drawing.Size(259, 23);
this._txtPath.TabIndex = 0;
// // _txtDescription
// this._txtDescription.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtDescription.Location = new System.Drawing.Point(94, 32);
this._txtDescription.Name = ""_txtDescription"";
this._txtDescription.Size = new System.Drawing.Size(288, 23);
this._txtDescription.TabIndex = 2;
// // _lblDescription
// this._lblDescription.AutoSize = true;
this._lblDescription.Location = new System.Drawing.Point(0, 35);
this._lblDescription.Name = ""_lblDescription"";
this._lblDescription.Size = new System.Drawing.Size(90, 15);
this._lblDescription.TabIndex = 15;
this._lblDescription.Text = ""%Description%:"";
// // AddRepositoryDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._btnSelectDirectory);
this.Controls.Add(this._lblDescription);
this.Controls.Add(this._lblPath);
this.Controls.Add(this._txtDescription);
this.Controls.Add(this._txtPath);
this.Name = ""AddRepositoryDialog"";
this.Size = new System.Drawing.Size(385, 58);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2629,"private void InitializeComponent()
{
this._txtRepository = new System.Windows.Forms.TextBox();
this._txtPath = new System.Windows.Forms.TextBox();
this._txtBranch = new System.Windows.Forms.TextBox();
this._lblPath = new System.Windows.Forms.Label();
this._lblUrl = new System.Windows.Forms.Label();
this._chkBranch = new System.Windows.Forms.CheckBox();
this.SuspendLayout();
// // _txtRepository
// this._txtRepository.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtRepository.Location = new System.Drawing.Point(100, 29);
this._txtRepository.Name = ""_txtRepository"";
this._txtRepository.Size = new System.Drawing.Size(311, 23);
this._txtRepository.TabIndex = 7;
// // _txtPath
// this._txtPath.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtPath.Location = new System.Drawing.Point(100, 3);
this._txtPath.Name = ""_txtPath"";
this._txtPath.Size = new System.Drawing.Size(311, 23);
this._txtPath.TabIndex = 7;
// // _txtBranch
// this._txtBranch.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtBranch.Enabled = false;
this._txtBranch.Location = new System.Drawing.Point(100, 55);
this._txtBranch.Name = ""_txtBranch"";
this._txtBranch.Size = new System.Drawing.Size(311, 23);
this._txtBranch.TabIndex = 7;
// // _lblPath
// this._lblPath.AutoSize = true;
this._lblPath.Location = new System.Drawing.Point(0, 6);
this._lblPath.Name = ""_lblPath"";
this._lblPath.Size = new System.Drawing.Size(54, 15);
this._lblPath.TabIndex = 8;
this._lblPath.Text = ""%Path%:"";
// // _lblUrl
// this._lblUrl.AutoSize = true;
this._lblUrl.Location = new System.Drawing.Point(0, 32);
this._lblUrl.Name = ""_lblUrl"";
this._lblUrl.Size = new System.Drawing.Size(51, 15);
this._lblUrl.TabIndex = 9;
this._lblUrl.Text = ""%URL%:"";
// // _chkBranch
// this._chkBranch.AutoSize = true;
this._chkBranch.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkBranch.Location = new System.Drawing.Point(3, 57);
this._chkBranch.Name = ""_chkBranch"";
this._chkBranch.Size = new System.Drawing.Size(92, 20);
this._chkBranch.TabIndex = 10;
this._chkBranch.Text = ""%Branch%:"";
this._chkBranch.UseVisualStyleBackColor = true;
this._chkBranch.CheckedChanged += new System.EventHandler(this._chkBranch_CheckedChanged);
// // AddSubmoduleDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._chkBranch);
this.Controls.Add(this._lblUrl);
this.Controls.Add(this._lblPath);
this.Controls.Add(this._txtPath);
this.Controls.Add(this._txtBranch);
this.Controls.Add(this._txtRepository);
this.Name = ""AddSubmoduleDialog"";
this.Size = new System.Drawing.Size(414, 82);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2630,"public static ICommandArgument Keep()
{
return new CommandFlag(""--keep"");
}",Pass -k flag to git-mailinfo (see git-mailinfo(1)).,1
2631,"public static ICommandArgument Quiet()
{
return CommandFlag.Quiet();
}",Be quiet. Only print error messages.,1
2632,"public static ICommandArgument Utf8()
{
return new CommandFlag(""--utf8"");
}",Pass -u flag to git-mailinfo (see git-mailinfo(1)). The proposed commit log message taken from the e-mail is re-coded into UTF-8 encoding (configuration variable i18n.commitencoding can be used to specify project's preferred encoding if it is not UTF-8).,1
2633,"public static ICommandArgument NoUtf8()
{
return new CommandFlag(""--no-utf8"");
}",Pass -n flag to git-mailinfo (see git-mailinfo(1)).,1
2634,"public static ICommandArgument FallbackOn3WayMerge()
{
return new CommandFlag(""--3way"");
}","When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally.",1
2635,"public static ICommandArgument Interactive()
{
return new CommandFlag(""--interactive"");
}",Run interactively.,0
2636,"private void InitializeComponent()
{
this.panel1 = new System.Windows.Forms.Panel();
this._radGdiPlus = new System.Windows.Forms.RadioButton();
this._radGdi = new System.Windows.Forms.RadioButton();
this.groupSeparator1 = new gitter.Framework.Controls.GroupSeparator();
this.groupSeparator2 = new gitter.Framework.Controls.GroupSeparator();
this._pnlThemesContainer = new System.Windows.Forms.Panel();
this._pnlRestartRequiredWarning = new System.Windows.Forms.Panel();
this.pictureBox1 = new System.Windows.Forms.PictureBox();
this.label1 = new System.Windows.Forms.Label();
this.panel1.SuspendLayout();
this._pnlRestartRequiredWarning.SuspendLayout();
((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
this.SuspendLayout();
// // panel1
// this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.panel1.Controls.Add(this._radGdiPlus);
this.panel1.Controls.Add(this._radGdi);
this.panel1.Location = new System.Drawing.Point(3, 20);
this.panel1.Name = ""panel1"";
this.panel1.Size = new System.Drawing.Size(388, 48);
this.panel1.TabIndex = 0;
// // _radGdiPlus
// this._radGdiPlus.AutoSize = true;
this._radGdiPlus.Checked = true;
this._radGdiPlus.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radGdiPlus.Location = new System.Drawing.Point(3, 25);
this._radGdiPlus.Name = ""_radGdiPlus"";
this._radGdiPlus.Size = new System.Drawing.Size(58, 20);
this._radGdiPlus.TabIndex = 1;
this._radGdiPlus.TabStop = true;
this._radGdiPlus.Text = ""GDI+"";
this._radGdiPlus.UseVisualStyleBackColor = true;
// // _radGdi
// this._radGdi.AutoSize = true;
this._radGdi.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radGdi.Location = new System.Drawing.Point(3, 3);
this._radGdi.Name = ""_radGdi"";
this._radGdi.Size = new System.Drawing.Size(50, 20);
this._radGdi.TabIndex = 0;
this._radGdi.Text = ""GDI"";
this._radGdi.UseVisualStyleBackColor = true;
// // groupSeparator1
// this.groupSeparator1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.groupSeparator1.Location = new System.Drawing.Point(0, 0);
this.groupSeparator1.Name = ""groupSeparator1"";
this.groupSeparator1.Size = new System.Drawing.Size(388, 19);
this.groupSeparator1.TabIndex = 1;
this.groupSeparator1.Text = ""Preferred text renderer"";
// // groupSeparator2
// this.groupSeparator2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.groupSeparator2.Location = new System.Drawing.Point(0, 74);
this.groupSeparator2.Name = ""groupSeparator2"";
this.groupSeparator2.Size = new System.Drawing.Size(388, 19);
this.groupSeparator2.TabIndex = 2;
this.groupSeparator2.Text = ""Application theme"";
// // _pnlThemesContainer
// this._pnlThemesContainer.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlThemesContainer.Location = new System.Drawing.Point(3, 94);
this._pnlThemesContainer.Name = ""_pnlThemesContainer"";
this._pnlThemesContainer.Size = new System.Drawing.Size(385, 182);
this._pnlThemesContainer.TabIndex = 3;
// // _pnlRestartRequiredWarning
// this._pnlRestartRequiredWarning.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlRestartRequiredWarning.Controls.Add(this.pictureBox1);
this._pnlRestartRequiredWarning.Controls.Add(this.label1);
this._pnlRestartRequiredWarning.Location = new System.Drawing.Point(3, 282);
this._pnlRestartRequiredWarning.Name = ""_pnlRestartRequiredWarning"";
this._pnlRestartRequiredWarning.Size = new System.Drawing.Size(385, 20);
this._pnlRestartRequiredWarning.TabIndex = 4;
this._pnlRestartRequiredWarning.Visible = false;
// // pictureBox1
// this.pictureBox1.Image = global::gitter.Framework.Properties.Resources.ImgLogWarning;
this.pictureBox1.Location = new System.Drawing.Point(0, 3);
this.pictureBox1.Name = ""pictureBox1"";
this.pictureBox1.Size = new System.Drawing.Size(16, 16);
this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
this.pictureBox1.TabIndex = 0;
this.pictureBox1.TabStop = false;
// // label1
// this.label1.AutoSize = true;
this.label1.Location = new System.Drawing.Point(18, 4);
this.label1.Name = ""label1"";
this.label1.Size = new System.Drawing.Size(256, 15);
this.label1.TabIndex = 1;
this.label1.Text = ""Application must be restarted to apply changes"";
// // AppearancePage
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._pnlRestartRequiredWarning);
this.Controls.Add(this._pnlThemesContainer);
this.Controls.Add(this.groupSeparator2);
this.Controls.Add(this.groupSeparator1);
this.Controls.Add(this.panel1);
this.Name = ""AppearancePage"";
this.Size = new System.Drawing.Size(391, 305);
this.panel1.ResumeLayout(false);
this.panel1.PerformLayout();
this._pnlRestartRequiredWarning.ResumeLayout(false);
this._pnlRestartRequiredWarning.PerformLayout();
((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2637,"private void InitializeComponent()
{
this._grpApplyTo = new gitter.Framework.Controls.GroupSeparator();
this._grpOptions = new gitter.Framework.Controls.GroupSeparator();
this._radWorkingDirectory = new System.Windows.Forms.RadioButton();
this._radIndexAndWorkingDirectory = new System.Windows.Forms.RadioButton();
this._radIndexOnly = new System.Windows.Forms.RadioButton();
this._chkReverse = new System.Windows.Forms.CheckBox();
this._lblPatches = new System.Windows.Forms.Label();
this._btnAddFiles = new System.Windows.Forms.Button();
this._btnAddFromClipboard = new System.Windows.Forms.Button();
this._lstPatches = new gitter.Framework.Controls.CustomListBox();
this.SuspendLayout();
// // _grpApplyTo
// this._grpApplyTo.Location = new System.Drawing.Point(0, 189);
this._grpApplyTo.Name = ""_grpApplyTo"";
this._grpApplyTo.Size = new System.Drawing.Size(397, 19);
this._grpApplyTo.TabIndex = 1;
this._grpApplyTo.Text = ""%Apply to%"";
// // _grpOptions
// this._grpOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpOptions.Location = new System.Drawing.Point(0, 277);
this._grpOptions.Name = ""_grpOptions"";
this._grpOptions.Size = new System.Drawing.Size(397, 19);
this._grpOptions.TabIndex = 2;
this._grpOptions.Text = ""%Options%"";
// // _radWorkingDirectory
// this._radWorkingDirectory.AutoSize = true;
this._radWorkingDirectory.Checked = true;
this._radWorkingDirectory.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radWorkingDirectory.Location = new System.Drawing.Point(14, 214);
this._radWorkingDirectory.Name = ""_radWorkingDirectory"";
this._radWorkingDirectory.Size = new System.Drawing.Size(146, 20);
this._radWorkingDirectory.TabIndex = 3;
this._radWorkingDirectory.TabStop = true;
this._radWorkingDirectory.Text = ""%Working directory%"";
this._radWorkingDirectory.UseVisualStyleBackColor = true;
// // _radIndexAndWorkingDirectory
// this._radIndexAndWorkingDirectory.AutoSize = true;
this._radIndexAndWorkingDirectory.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radIndexAndWorkingDirectory.Location = new System.Drawing.Point(14, 254);
this._radIndexAndWorkingDirectory.Name = ""_radIndexAndWorkingDirectory"";
this._radIndexAndWorkingDirectory.Size = new System.Drawing.Size(198, 20);
this._radIndexAndWorkingDirectory.TabIndex = 4;
this._radIndexAndWorkingDirectory.Text = ""%Index and working directory%"";
this._radIndexAndWorkingDirectory.UseVisualStyleBackColor = true;
// // _radIndexOnly
// this._radIndexOnly.AutoSize = true;
this._radIndexOnly.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radIndexOnly.Location = new System.Drawing.Point(14, 234);
this._radIndexOnly.Name = ""_radIndexOnly"";
this._radIndexOnly.Size = new System.Drawing.Size(79, 20);
this._radIndexOnly.TabIndex = 5;
this._radIndexOnly.Text = ""%Index%"";
this._radIndexOnly.UseVisualStyleBackColor = true;
// // _chkReverse
// this._chkReverse.AutoSize = true;
this._chkReverse.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkReverse.Location = new System.Drawing.Point(14, 302);
this._chkReverse.Name = ""_chkReverse"";
this._chkReverse.Size = new System.Drawing.Size(92, 20);
this._chkReverse.TabIndex = 6;
this._chkReverse.Text = ""%Reverse%"";
this._chkReverse.UseVisualStyleBackColor = true;
// // _lblPatches
// this._lblPatches.AutoSize = true;
this._lblPatches.Location = new System.Drawing.Point(0, 0);
this._lblPatches.Name = ""_lblPatches"";
this._lblPatches.Size = new System.Drawing.Size(71, 15);
this._lblPatches.TabIndex = 7;
this._lblPatches.Text = ""%Patches%:"";
// // _btnAddFiles
// this._btnAddFiles.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnAddFiles.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnAddFiles.Location = new System.Drawing.Point(144, 160);
this._btnAddFiles.Name = ""_btnAddFiles"";
this._btnAddFiles.Size = new System.Drawing.Size(93, 23);
this._btnAddFiles.TabIndex = 8;
this._btnAddFiles.Text = ""%Add Files%..."";
this._btnAddFiles.UseVisualStyleBackColor = true;
this._btnAddFiles.Click += new System.EventHandler(this.OnAddFilesClick);
// // _btnAddFromClipboard
// this._btnAddFromClipboard.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnAddFromClipboard.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnAddFromClipboard.Location = new System.Drawing.Point(243, 160);
this._btnAddFromClipboard.Name = ""_btnAddFromClipboard"";
this._btnAddFromClipboard.Size = new System.Drawing.Size(154, 23);
this._btnAddFromClipboard.TabIndex = 8;
this._btnAddFromClipboard.Text = ""%Add From Clipboard%"";
this._btnAddFromClipboard.UseVisualStyleBackColor = true;
this._btnAddFromClipboard.Click += new System.EventHandler(this.OnAddFromClipboardClick);
// // _lstPatches
// this._lstPatches.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstPatches.ForeColor = System.Drawing.SystemColors.WindowText;
this._lstPatches.Location = new System.Drawing.Point(3, 18);
this._lstPatches.Name = ""_lstPatches"";
this._lstPatches.Size = new System.Drawing.Size(394, 136);
this._lstPatches.TabIndex = 9;
this._lstPatches.Text = ""%No patches to apply%"";
// // ApplyPatchesDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lstPatches);
this.Controls.Add(this._btnAddFromClipboard);
this.Controls.Add(this._btnAddFiles);
this.Controls.Add(this._lblPatches);
this.Controls.Add(this._chkReverse);
this.Controls.Add(this._radIndexOnly);
this.Controls.Add(this._radIndexAndWorkingDirectory);
this.Controls.Add(this._radWorkingDirectory);
this.Controls.Add(this._grpOptions);
this.Controls.Add(this._grpApplyTo);
this.Name = ""ApplyPatchesDialog"";
this.Size = new System.Drawing.Size(400, 325);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2638,"public static ICommandArgument Format(string format)
{
return new CommandParameterValue(""--format"", format);
}",Format of the resulting archive.,1
2639,"public static ICommandArgument List()
{
return new CommandFlag(""--list"");
}",Show all available formats.,1
2640,"public static ICommandArgument Verbose()
{
return CommandFlag.Verbose();
}",Report progress to stderr.,1
2641,"public static ICommandArgument Prefix(string prefix)
{
return new CommandParameterValue(""--prefix"", prefix);
}",Prepend prefix to each filename in the archive.,1
2642,"public static ICommandArgument Output(string file)
{
return new CommandParameterValue(""--output"", file.AssureDoubleQuotes());
}",Write the archive to file instead of stdout.,1
2643,"public static ICommandArgument WorktreeAttributes()
{
return new CommandFlag(""--worktree-attributes"");
}",Look for attributes in .gitattributes in working directory too.,1
2644,"public static ICommandArgument Remote(string repo)
{
return new CommandParameterValue(""--remote"", repo);
}","Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository.",1
2645,"public static void AreEqual<T>(T expected, T actual)
{
if(null == expected)
{
// Two nulls are considered equal, regardless of type semantics.
if(null != actual && !actual.Equals(expected))
{
_Break();
}
}
else if(!expected.Equals(actual))
{
_Break();
}
}",This breaks into the debugger in the case of a failed assertion.,1
2646,"public static void AreNotEqual<T>(T notExpected, T actual)
{
if(null == notExpected)
{
// Two nulls are considered equal, regardless of type semantics.
if(null == actual || actual.Equals(notExpected))
{
_Break();
}
}
else if(notExpected.Equals(actual))
{
_Break();
}
}",This breaks into the debugger in the case of a failed assertion.,1
2647,"public static void Implies(bool condition, bool result)
{
if(condition && !result)
{
_Break();
}
}",This breaks into the debugger in the case of a failed assertion.,1
2648,"public static void Implies(bool condition, ImplicationFunction result)
{
if(condition && !result())
{
_Break();
}
}",This overload only evaluates the result if the first condition is true.,1
2649,"public static void IsFalse(bool condition)
{
if(condition)
{
_Break();
}
}",This breaks into the debugger in the case of a failed assertion.,1
2650,"public static void IsFalse(bool condition, string message)
{
if(condition)
{
_Break();
}
}",This breaks into the debugger in the case of a failed assertion.,1
2651,"public static void IsTrue(bool condition)
{
if(!condition)
{
_Break();
}
}",This breaks into the debugger in the case of a failed assertion.,1
2652,"public static void IsTrue(bool condition, string message)
{
if(!condition)
{
_Break();
}
}",This breaks into the debugger in the case of a failed assertion.,1
2653,"public static void IsApartmentState(ApartmentState expectedState)
{
if(Thread.CurrentThread.GetApartmentState() != expectedState)
{
_Break();
}
}",This breaks into the debugger in the case of a failed assertion.,1
2654,"public void NotifyCanceled()
{
Verify.State.IsTrue(IsInitialized);
_isCanceled = true;
var eof = _eof;
if(eof != null)
{
_eof = null;
eof.Dispose();
}
}","Reader should still receive bytes, but disable any stream processing.",1
2655,"public void WaitForEndOfStream()
{
Verify.State.IsTrue(IsInitialized);
_eof.WaitOne();
_eof.Dispose();
_stream = null;
_eof = null;
}",Closes the reader.,1
2656,"public void Clear()
{
Verify.State.IsFalse(IsInitialized);
_bufferChain.Clear();
_length = 0;
}",Removes all collected byte buffers.,1
2657,"public void WaitForEndOfStream()
{
Verify.State.IsTrue(IsInitialized);
var eof = _eof;
if(eof != null)
{
try
{
eof.WaitOne();
eof.Dispose();
}
catch(ObjectDisposedException)
{
}
}
_stream = null;
_byteBuffer = null;
_charBuffer = null;
_decoder = null;
_eof = null;
}",Closes the reader.,1
2658,"public void Clear()
{
Verify.State.IsFalse(IsInitialized);
_stringBuilder.Clear();
}",Clears internal buffer.,1
2659,"private void InitializeComponent()
{
this._blamePanel = new gitter.Git.Gui.Controls.BlameViewer();
this.SuspendLayout();
// // _blamePanel
// this._blamePanel.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._blamePanel.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._blamePanel.Location = new System.Drawing.Point(0, 0);
this._blamePanel.Name = ""_blamePanel"";
this._blamePanel.Size = new System.Drawing.Size(555, 362);
this._blamePanel.TabIndex = 0;
// // BlameView
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._blamePanel);
this.Name = ""BlameView"";
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2660,"private void InitializeComponent()
{
this.components = new System.ComponentModel.Container();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2661,"private void InitializeComponent()
{
this._txtRevision = new System.Windows.Forms.TextBox();
this._lblRevision = new System.Windows.Forms.Label();
this._lstReferences = new gitter.Git.Gui.Controls.ReferencesListBox();
this.SuspendLayout();
// // _txtRevision
// this._txtRevision.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtRevision.Location = new System.Drawing.Point(94, 3);
this._txtRevision.Name = ""_txtRevision"";
this._txtRevision.Size = new System.Drawing.Size(288, 23);
this._txtRevision.TabIndex = 0;
// // _lblRevision
// this._lblRevision.AutoSize = true;
this._lblRevision.Location = new System.Drawing.Point(0, 6);
this._lblRevision.Name = ""_lblRevision"";
this._lblRevision.Size = new System.Drawing.Size(74, 15);
this._lblRevision.TabIndex = 5;
this._lblRevision.Text = ""%Revision%:"";
// // _lstReferences
// this._lstReferences.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._lstReferences.DisableContextMenus = true;
this._lstReferences.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstReferences.Location = new System.Drawing.Point(3, 28);
this._lstReferences.Name = ""_lstReferences"";
this._lstReferences.ShowTreeLines = true;
this._lstReferences.Size = new System.Drawing.Size(379, 294);
this._lstReferences.TabIndex = 1;
this._lstReferences.SelectionChanged += new System.EventHandler(this.OnSelectionChanged);
// // CheckoutDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._txtRevision);
this.Controls.Add(this._lstReferences);
this.Controls.Add(this._lblRevision);
this.Name = ""CheckoutDialog"";
this.Size = new System.Drawing.Size(385, 325);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2662,"private void InitializeComponent()
{
this._lstCommits = new gitter.Framework.Controls.FlowLayoutControl();
this._grpOptions = new gitter.Framework.Controls.GroupSeparator();
this._pnlOptions = new System.Windows.Forms.Panel();
this._chkNoCommit = new System.Windows.Forms.CheckBox();
this._grpMainlineParentCommit = new gitter.Framework.Controls.GroupSeparator();
this._pnlMainlineParentCommit = new System.Windows.Forms.Panel();
this._txtRevision = new System.Windows.Forms.TextBox();
this._lblRevision = new System.Windows.Forms.Label();
this._pnlOptions.SuspendLayout();
this._pnlMainlineParentCommit.SuspendLayout();
this.SuspendLayout();
// // _lstCommits
// this._lstCommits.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstCommits.ForeColor = System.Drawing.SystemColors.WindowText;
this._lstCommits.Location = new System.Drawing.Point(13, 25);
this._lstCommits.Name = ""_lstCommits"";
this._lstCommits.Size = new System.Drawing.Size(464, 218);
this._lstCommits.TabIndex = 1;
// // _grpOptions
// this._grpOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpOptions.Location = new System.Drawing.Point(0, 0);
this._grpOptions.Name = ""_grpOptions"";
this._grpOptions.Size = new System.Drawing.Size(477, 19);
this._grpOptions.TabIndex = 1;
this._grpOptions.Text = ""%Options%"";
// // _pnlOptions
// this._pnlOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlOptions.Controls.Add(this._chkNoCommit);
this._pnlOptions.Controls.Add(this._grpOptions);
this._pnlOptions.Location = new System.Drawing.Point(0, 278);
this._pnlOptions.Name = ""_pnlOptions"";
this._pnlOptions.Size = new System.Drawing.Size(480, 49);
this._pnlOptions.TabIndex = 2;
// // _chkNoCommit
// this._chkNoCommit.AutoSize = true;
this._chkNoCommit.Location = new System.Drawing.Point(13, 25);
this._chkNoCommit.Name = ""_chkNoCommit"";
this._chkNoCommit.Size = new System.Drawing.Size(107, 19);
this._chkNoCommit.TabIndex = 2;
this._chkNoCommit.Text = ""%No commit%"";
this._chkNoCommit.UseVisualStyleBackColor = true;
// // _grpMainlineParentCommit
// this._grpMainlineParentCommit.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpMainlineParentCommit.Location = new System.Drawing.Point(0, 0);
this._grpMainlineParentCommit.Name = ""_grpMainlineParentCommit"";
this._grpMainlineParentCommit.Size = new System.Drawing.Size(477, 19);
this._grpMainlineParentCommit.TabIndex = 1;
this._grpMainlineParentCommit.Text = ""%Mainline Parent Commit%"";
// // _pnlMainlineParentCommit
// this._pnlMainlineParentCommit.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlMainlineParentCommit.Controls.Add(this._grpMainlineParentCommit);
this._pnlMainlineParentCommit.Controls.Add(this._lstCommits);
this._pnlMainlineParentCommit.Location = new System.Drawing.Point(0, 29);
this._pnlMainlineParentCommit.Name = ""_pnlMainlineParentCommit"";
this._pnlMainlineParentCommit.Size = new System.Drawing.Size(480, 243);
this._pnlMainlineParentCommit.TabIndex = 3;
// // _txtRevision
// this._txtRevision.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtRevision.Font = new System.Drawing.Font(""Courier New"", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(204)));
this._txtRevision.Location = new System.Drawing.Point(94, 3);
this._txtRevision.Name = ""_txtRevision"";
this._txtRevision.ReadOnly = true;
this._txtRevision.Size = new System.Drawing.Size(383, 20);
this._txtRevision.TabIndex = 0;
// // _lblRevision
// this._lblRevision.AutoSize = true;
this._lblRevision.Location = new System.Drawing.Point(0, 6);
this._lblRevision.Name = ""_lblRevision"";
this._lblRevision.Size = new System.Drawing.Size(74, 15);
this._lblRevision.TabIndex = 4;
this._lblRevision.Text = ""%Revision%:"";
// // CherryPickDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._txtRevision);
this.Controls.Add(this._lblRevision);
this.Controls.Add(this._pnlMainlineParentCommit);
this.Controls.Add(this._pnlOptions);
this.Name = ""CherryPickDialog"";
this.Size = new System.Drawing.Size(480, 327);
this._pnlOptions.ResumeLayout(false);
this._pnlOptions.PerformLayout();
this._pnlMainlineParentCommit.ResumeLayout(false);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2663,"public static ICommandArgument Directories()
{
return new CommandFlag(""-d"");
}","Remove untracked directories in addition to untracked files. If an untracked directory is managed by a different git repository, it is not removed by default. Use -f option twice if you really want to remove such a directory.",1
2664,"public static ICommandArgument Quiet()
{
return new CommandFlag(""--quiet"");
}","Be quiet, only report errors, but not the files that are successfully removed.",1
2665,"public static ICommandArgument DryRun()
{
return new CommandFlag(""--dry-run"");
}","Don't actually remove anything, just show what would be done.",1
2666,"public static ICommandArgument Exclude(string pattern)
{
return new CommandParameterValue(""--exclude"", pattern, '=');
}",Specify special exceptions to not be cleaned. Each <pattern> is the same form as in $GIT_DIR/info/excludes and this option can be given multiple times.,1
2667,"public static ICommandArgument IncludeIgnored()
{
return new CommandFlag(""-x"");
}","Don't use the ignore rules. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with git reset) to create a pristine working directory to test a clean build.",1
2668,"private void InitializeComponent()
{
this._txtPattern = new System.Windows.Forms.TextBox();
this._lblIncludePattern = new System.Windows.Forms.Label();
this._radIncludeUntracked = new System.Windows.Forms.RadioButton();
this._radIncludeIgnored = new System.Windows.Forms.RadioButton();
this._radIncludeBoth = new System.Windows.Forms.RadioButton();
this._lblExcludePattern = new System.Windows.Forms.Label();
this._txtExclude = new System.Windows.Forms.TextBox();
this._lblType = new System.Windows.Forms.Label();
this._chkRemoveDirectories = new System.Windows.Forms.CheckBox();
this._lstFilesToClear = new gitter.Git.Gui.Controls.TreeListBox();
this._lblObjectList = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _txtPattern
// this._txtPattern.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtPattern.Location = new System.Drawing.Point(127, 3);
this._txtPattern.Name = ""_txtPattern"";
this._txtPattern.Size = new System.Drawing.Size(307, 23);
this._txtPattern.TabIndex = 0;
this._txtPattern.TextChanged += new System.EventHandler(this.OnPatternTextChanged);
// // _lblIncludePattern
// this._lblIncludePattern.AutoSize = true;
this._lblIncludePattern.Location = new System.Drawing.Point(3, 6);
this._lblIncludePattern.Name = ""_lblIncludePattern"";
this._lblIncludePattern.Size = new System.Drawing.Size(110, 15);
this._lblIncludePattern.TabIndex = 1;
this._lblIncludePattern.Text = ""%Include Pattern%:"";
// // _radIncludeUntracked
// this._radIncludeUntracked.AutoSize = true;
this._radIncludeUntracked.Checked = true;
this._radIncludeUntracked.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radIncludeUntracked.Location = new System.Drawing.Point(127, 61);
this._radIncludeUntracked.Name = ""_radIncludeUntracked"";
this._radIncludeUntracked.Size = new System.Drawing.Size(85, 20);
this._radIncludeUntracked.TabIndex = 2;
this._radIncludeUntracked.TabStop = true;
this._radIncludeUntracked.Text = ""Untracked"";
this._radIncludeUntracked.UseVisualStyleBackColor = true;
this._radIncludeUntracked.CheckedChanged += new System.EventHandler(this.OnRadioButtonCheckedChanged);
// // _radIncludeIgnored
// this._radIncludeIgnored.AutoSize = true;
this._radIncludeIgnored.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radIncludeIgnored.Location = new System.Drawing.Point(239, 61);
this._radIncludeIgnored.Name = ""_radIncludeIgnored"";
this._radIncludeIgnored.Size = new System.Drawing.Size(72, 20);
this._radIncludeIgnored.TabIndex = 3;
this._radIncludeIgnored.Text = ""Ignored"";
this._radIncludeIgnored.UseVisualStyleBackColor = true;
this._radIncludeIgnored.CheckedChanged += new System.EventHandler(this.OnRadioButtonCheckedChanged);
// // _radIncludeBoth
// this._radIncludeBoth.AutoSize = true;
this._radIncludeBoth.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radIncludeBoth.Location = new System.Drawing.Point(349, 61);
this._radIncludeBoth.Name = ""_radIncludeBoth"";
this._radIncludeBoth.Size = new System.Drawing.Size(56, 20);
this._radIncludeBoth.TabIndex = 4;
this._radIncludeBoth.Text = ""Both"";
this._radIncludeBoth.UseVisualStyleBackColor = true;
this._radIncludeBoth.CheckedChanged += new System.EventHandler(this.OnRadioButtonCheckedChanged);
// // _lblExcludePattern
// this._lblExcludePattern.AutoSize = true;
this._lblExcludePattern.Location = new System.Drawing.Point(3, 35);
this._lblExcludePattern.Name = ""_lblExcludePattern"";
this._lblExcludePattern.Size = new System.Drawing.Size(111, 15);
this._lblExcludePattern.TabIndex = 1;
this._lblExcludePattern.Text = ""%Exclude Pattern%:"";
// // _txtExclude
// this._txtExclude.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtExclude.Location = new System.Drawing.Point(127, 32);
this._txtExclude.Name = ""_txtExclude"";
this._txtExclude.Size = new System.Drawing.Size(307, 23);
this._txtExclude.TabIndex = 1;
this._txtExclude.TextChanged += new System.EventHandler(this.OnPatternTextChanged);
// // _lblType
// this._lblType.AutoSize = true;
this._lblType.Location = new System.Drawing.Point(3, 63);
this._lblType.Name = ""_lblType"";
this._lblType.Size = new System.Drawing.Size(56, 15);
this._lblType.TabIndex = 1;
this._lblType.Text = ""%Type%:"";
// // _chkRemoveDirectories
// this._chkRemoveDirectories.AutoSize = true;
this._chkRemoveDirectories.Checked = true;
this._chkRemoveDirectories.CheckState = System.Windows.Forms.CheckState.Checked;
this._chkRemoveDirectories.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkRemoveDirectories.Location = new System.Drawing.Point(127, 81);
this._chkRemoveDirectories.Name = ""_chkRemoveDirectories"";
this._chkRemoveDirectories.Size = new System.Drawing.Size(156, 20);
this._chkRemoveDirectories.TabIndex = 5;
this._chkRemoveDirectories.Text = ""Also remove directories"";
this._chkRemoveDirectories.UseVisualStyleBackColor = true;
this._chkRemoveDirectories.CheckedChanged += new System.EventHandler(this.OnRemoveDirectoriesCheckedChanged);
// // _lstFilesToClear
// this._lstFilesToClear.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstFilesToClear.DisableContextMenus = true;
this._lstFilesToClear.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstFilesToClear.Location = new System.Drawing.Point(3, 122);
this._lstFilesToClear.Name = ""_lstFilesToClear"";
this._lstFilesToClear.ShowTreeLines = true;
this._lstFilesToClear.Size = new System.Drawing.Size(431, 270);
this._lstFilesToClear.TabIndex = 6;
this._lstFilesToClear.ItemActivated += new System.EventHandler<gitter.Framework.Controls.ItemEventArgs>(this.OnFilesToClearItemActivated);
// // _lblObjectList
// this._lblObjectList.AutoSize = true;
this._lblObjectList.Location = new System.Drawing.Point(0, 104);
this._lblObjectList.Name = ""_lblObjectList"";
this._lblObjectList.Size = new System.Drawing.Size(181, 15);
this._lblObjectList.TabIndex = 7;
this._lblObjectList.Text = ""%Objects that will be removed%:"";
// // CleanDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblObjectList);
this.Controls.Add(this._chkRemoveDirectories);
this.Controls.Add(this._radIncludeBoth);
this.Controls.Add(this._radIncludeIgnored);
this.Controls.Add(this._radIncludeUntracked);
this.Controls.Add(this._lstFilesToClear);
this.Controls.Add(this._txtExclude);
this.Controls.Add(this._lblExcludePattern);
this.Controls.Add(this._txtPattern);
this.Controls.Add(this._lblType);
this.Controls.Add(this._lblIncludePattern);
this.Name = ""CleanDialog"";
this.Size = new System.Drawing.Size(437, 395);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2669,"private void InitializeComponent()
{
this._lblPathToGitExe = new System.Windows.Forms.Label();
this._txtmSysGitPath = new System.Windows.Forms.TextBox();
this._cmdAutoDetect = new System.Windows.Forms.Button();
this._lblFoundVersion = new System.Windows.Forms.Label();
this._cmdBrowse = new System.Windows.Forms.Button();
this._lblVersion = new System.Windows.Forms.Label();
this._radAlwaysAutodetect = new System.Windows.Forms.RadioButton();
this._radSpecifyManually = new System.Windows.Forms.RadioButton();
this._lblLatestVersionValue = new System.Windows.Forms.Label();
this._lblLatestVersion = new System.Windows.Forms.Label();
this._btnDownload = new System.Windows.Forms.Button();
this._btnRefreshLatestVersion = new System.Windows.Forms.Button();
this._chkFallbackToAnsi = new System.Windows.Forms.CheckBox();
this._chkLogCLICalls = new System.Windows.Forms.CheckBox();
this._openFileDialog = new System.Windows.Forms.OpenFileDialog();
this.SuspendLayout();
// // _lblPathToGitExe
// this._lblPathToGitExe.AutoSize = true;
this._lblPathToGitExe.Location = new System.Drawing.Point(0, 0);
this._lblPathToGitExe.Name = ""_lblPathToGitExe"";
this._lblPathToGitExe.Size = new System.Drawing.Size(105, 15);
this._lblPathToGitExe.TabIndex = 1;
this._lblPathToGitExe.Text = ""%Path to git.exe%:"";
// // _txtmSysGitPath
// this._txtmSysGitPath.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtmSysGitPath.Location = new System.Drawing.Point(3, 24);
this._txtmSysGitPath.Name = ""_txtmSysGitPath"";
this._txtmSysGitPath.Size = new System.Drawing.Size(473, 23);
this._txtmSysGitPath.TabIndex = 2;
this._txtmSysGitPath.TextChanged += new System.EventHandler(this._txtmSysGitPath_TextChanged);
// // _cmdAutoDetect
// this._cmdAutoDetect.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._cmdAutoDetect.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._cmdAutoDetect.Location = new System.Drawing.Point(270, 53);
this._cmdAutoDetect.Name = ""_cmdAutoDetect"";
this._cmdAutoDetect.Size = new System.Drawing.Size(100, 23);
this._cmdAutoDetect.TabIndex = 3;
this._cmdAutoDetect.Text = ""%Autodetect%"";
this._cmdAutoDetect.UseVisualStyleBackColor = true;
this._cmdAutoDetect.Click += new System.EventHandler(this._cmdAutoDetect_Click);
// // _lblFoundVersion
// this._lblFoundVersion.AutoSize = true;
this._lblFoundVersion.Location = new System.Drawing.Point(0, 57);
this._lblFoundVersion.Name = ""_lblFoundVersion"";
this._lblFoundVersion.Size = new System.Drawing.Size(106, 15);
this._lblFoundVersion.TabIndex = 7;
this._lblFoundVersion.Text = ""%Found Version%:"";
// // _cmdBrowse
// this._cmdBrowse.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._cmdBrowse.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._cmdBrowse.Location = new System.Drawing.Point(376, 53);
this._cmdBrowse.Name = ""_cmdBrowse"";
this._cmdBrowse.Size = new System.Drawing.Size(100, 23);
this._cmdBrowse.TabIndex = 9;
this._cmdBrowse.Text = ""%Browse%..."";
this._cmdBrowse.UseVisualStyleBackColor = true;
this._cmdBrowse.Click += new System.EventHandler(this._cmdBrowse_Click);
// // _lblVersion
// this._lblVersion.AutoSize = true;
this._lblVersion.Location = new System.Drawing.Point(114, 57);
this._lblVersion.Name = ""_lblVersion"";
this._lblVersion.Size = new System.Drawing.Size(83, 15);
this._lblVersion.TabIndex = 11;
this._lblVersion.Text = ""<unavailable>"";
// // _radAlwaysAutodetect
// this._radAlwaysAutodetect.AutoSize = true;
this._radAlwaysAutodetect.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radAlwaysAutodetect.Location = new System.Drawing.Point(117, -2);
this._radAlwaysAutodetect.Name = ""_radAlwaysAutodetect"";
this._radAlwaysAutodetect.Size = new System.Drawing.Size(148, 20);
this._radAlwaysAutodetect.TabIndex = 12;
this._radAlwaysAutodetect.TabStop = true;
this._radAlwaysAutodetect.Text = ""%Always autodetect%"";
this._radAlwaysAutodetect.UseVisualStyleBackColor = true;
this._radAlwaysAutodetect.CheckedChanged += new System.EventHandler(this._radAlwaysAutodetect_CheckedChanged);
// // _radSpecifyManually
// this._radSpecifyManually.AutoSize = true;
this._radSpecifyManually.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radSpecifyManually.Location = new System.Drawing.Point(270, -2);
this._radSpecifyManually.Name = ""_radSpecifyManually"";
this._radSpecifyManually.Size = new System.Drawing.Size(141, 20);
this._radSpecifyManually.TabIndex = 13;
this._radSpecifyManually.TabStop = true;
this._radSpecifyManually.Text = ""%Specify manually%"";
this._radSpecifyManually.UseVisualStyleBackColor = true;
// // _lblLatestVersionValue
// this._lblLatestVersionValue.AutoSize = true;
this._lblLatestVersionValue.Location = new System.Drawing.Point(114, 86);
this._lblLatestVersionValue.Name = ""_lblLatestVersionValue"";
this._lblLatestVersionValue.Size = new System.Drawing.Size(81, 15);
this._lblLatestVersionValue.TabIndex = 21;
this._lblLatestVersionValue.Text = ""%serching%..."";
// // _lblLatestVersion
// this._lblLatestVersion.AutoSize = true;
this._lblLatestVersion.Location = new System.Drawing.Point(0, 86);
this._lblLatestVersion.Name = ""_lblLatestVersion"";
this._lblLatestVersion.Size = new System.Drawing.Size(103, 15);
this._lblLatestVersion.TabIndex = 20;
this._lblLatestVersion.Text = ""%Latest Version%:"";
// // _btnDownload
// this._btnDownload.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnDownload.Enabled = false;
this._btnDownload.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnDownload.Location = new System.Drawing.Point(376, 82);
this._btnDownload.Name = ""_btnDownload"";
this._btnDownload.Size = new System.Drawing.Size(100, 23);
this._btnDownload.TabIndex = 19;
this._btnDownload.Text = ""%Download%"";
this._btnDownload.UseVisualStyleBackColor = true;
this._btnDownload.Click += new System.EventHandler(this._btnDownload_Click);
// // _btnRefreshLatestVersion
// this._btnRefreshLatestVersion.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnRefreshLatestVersion.Enabled = false;
this._btnRefreshLatestVersion.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnRefreshLatestVersion.Location = new System.Drawing.Point(270, 82);
this._btnRefreshLatestVersion.Name = ""_btnRefreshLatestVersion"";
this._btnRefreshLatestVersion.Size = new System.Drawing.Size(100, 23);
this._btnRefreshLatestVersion.TabIndex = 18;
this._btnRefreshLatestVersion.Text = ""%Refresh%"";
this._btnRefreshLatestVersion.UseVisualStyleBackColor = true;
this._btnRefreshLatestVersion.Click += new System.EventHandler(this._btnRefreshLatestVersion_Click);
// // _chkFallbackToAnsi
// this._chkFallbackToAnsi.AutoSize = true;
this._chkFallbackToAnsi.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkFallbackToAnsi.Location = new System.Drawing.Point(3, 133);
this._chkFallbackToAnsi.Name = ""_chkFallbackToAnsi"";
this._chkFallbackToAnsi.Size = new System.Drawing.Size(372, 20);
this._chkFallbackToAnsi.TabIndex = 17;
this._chkFallbackToAnsi.Text = ""%Fallback to Ansi codepage if UTF-8 fails to decode characters%"";
this._chkFallbackToAnsi.UseVisualStyleBackColor = true;
// // _chkLogCLICalls
// this._chkLogCLICalls.AutoSize = true;
this._chkLogCLICalls.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkLogCLICalls.Location = new System.Drawing.Point(3, 111);
this._chkLogCLICalls.Name = ""_chkLogCLICalls"";
this._chkLogCLICalls.Size = new System.Drawing.Size(227, 20);
this._chkLogCLICalls.TabIndex = 17;
this._chkLogCLICalls.Text = ""%Log command line interface calls%"";
this._chkLogCLICalls.UseVisualStyleBackColor = true;
// // CliOptionsPage
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblLatestVersionValue);
this.Controls.Add(this._lblLatestVersion);
this.Controls.Add(this._lblPathToGitExe);
this.Controls.Add(this._btnDownload);
this.Controls.Add(this._cmdBrowse);
this.Controls.Add(this._btnRefreshLatestVersion);
this.Controls.Add(this._lblFoundVersion);
this.Controls.Add(this._chkFallbackToAnsi);
this.Controls.Add(this._lblVersion);
this.Controls.Add(this._chkLogCLICalls);
this.Controls.Add(this._cmdAutoDetect);
this.Controls.Add(this._radAlwaysAutodetect);
this.Controls.Add(this._radSpecifyManually);
this.Controls.Add(this._txtmSysGitPath);
this.Name = ""CliOptionsPage"";
this.Size = new System.Drawing.Size(479, 158);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2670,"public static ICommandArgument Bare()
{
return new CommandFlag(""--bare"");
}","Make a bare GIT repository. That is, instead of creating directory and placing the administrative files in directory/.git, make the directory itself the $GIT_DIR. This obviously implies the -n because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to refs/remotes/origin/. When this option is used, neither remote-tracking branches nor the related configuration variables are created.",1
2671,"public static ICommandArgument Depth(int depth)
{
return new CommandParameterValue(""--depth"", depth.ToString(), ' ');
}","Create a shallow clone with a history truncated to the specified number of revisions. A shallow repository has a number of limitations (you cannot clone or fetch from it, nor push from nor into it), but is adequate if you are only interested in the recent history of a large project with a long history, and would want to send in fixes as patches.",1
2672,"public static ICommandArgument Verbose()
{
return CommandFlag.Verbose();
}","Display the progressbar, even in case the standard output is not a terminal.",1
2673,"private void InitializeComponent()
{
this._lblRealPath = new System.Windows.Forms.Label();
this._lblWillBeClonedInto = new System.Windows.Forms.Label();
this._chkAppendRepositoryNameFromUrl = new System.Windows.Forms.CheckBox();
this._pnlOptions = new System.Windows.Forms.Panel();
this._lblDepth = new System.Windows.Forms.Label();
this._chkNoCheckout = new System.Windows.Forms.CheckBox();
this._chkRecursive = new System.Windows.Forms.CheckBox();
this._numDepth = new System.Windows.Forms.NumericUpDown();
this._chkShallowClone = new System.Windows.Forms.CheckBox();
this._txtRemoteName = new System.Windows.Forms.TextBox();
this._lblRemoteName = new System.Windows.Forms.Label();
this._chkMirror = new System.Windows.Forms.CheckBox();
this._btnSelectTemplate = new System.Windows.Forms.Button();
this._grpOptions = new gitter.Framework.Controls.GroupSeparator();
this._chkBare = new System.Windows.Forms.CheckBox();
this._chkUseTemplate = new System.Windows.Forms.CheckBox();
this._txtTemplate = new System.Windows.Forms.TextBox();
this._lblUrl = new System.Windows.Forms.Label();
this._txtUrl = new System.Windows.Forms.TextBox();
this._btnSelectDirectory = new System.Windows.Forms.Button();
this._lblPath = new System.Windows.Forms.Label();
this._txtPath = new System.Windows.Forms.TextBox();
this._pnlOptions.SuspendLayout();
((System.ComponentModel.ISupportInitialize)(this._numDepth)).BeginInit();
this.SuspendLayout();
// // _lblRealPath
// this._lblRealPath.AutoSize = true;
this._lblRealPath.Location = new System.Drawing.Point(0, 98);
this._lblRealPath.Name = ""_lblRealPath"";
this._lblRealPath.Size = new System.Drawing.Size(0, 15);
this._lblRealPath.TabIndex = 22;
// // _lblWillBeClonedInto
// this._lblWillBeClonedInto.AutoSize = true;
this._lblWillBeClonedInto.Location = new System.Drawing.Point(0, 83);
this._lblWillBeClonedInto.Name = ""_lblWillBeClonedInto"";
this._lblWillBeClonedInto.Size = new System.Drawing.Size(129, 15);
this._lblWillBeClonedInto.TabIndex = 21;
this._lblWillBeClonedInto.Text = ""%Will be cloned into%:"";
// // _chkAppendRepositoryNameFromUrl
// this._chkAppendRepositoryNameFromUrl.AutoSize = true;
this._chkAppendRepositoryNameFromUrl.Checked = true;
this._chkAppendRepositoryNameFromUrl.CheckState = System.Windows.Forms.CheckState.Checked;
this._chkAppendRepositoryNameFromUrl.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkAppendRepositoryNameFromUrl.Location = new System.Drawing.Point(94, 58);
this._chkAppendRepositoryNameFromUrl.Name = ""_chkAppendRepositoryNameFromUrl"";
this._chkAppendRepositoryNameFromUrl.Size = new System.Drawing.Size(277, 20);
this._chkAppendRepositoryNameFromUrl.TabIndex = 3;
this._chkAppendRepositoryNameFromUrl.Text = ""%Append repository name from URL to path%"";
this._chkAppendRepositoryNameFromUrl.UseVisualStyleBackColor = true;
// // _pnlOptions
// this._pnlOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlOptions.Controls.Add(this._lblDepth);
this._pnlOptions.Controls.Add(this._chkNoCheckout);
this._pnlOptions.Controls.Add(this._chkRecursive);
this._pnlOptions.Controls.Add(this._numDepth);
this._pnlOptions.Controls.Add(this._chkShallowClone);
this._pnlOptions.Controls.Add(this._txtRemoteName);
this._pnlOptions.Controls.Add(this._lblRemoteName);
this._pnlOptions.Controls.Add(this._chkMirror);
this._pnlOptions.Controls.Add(this._btnSelectTemplate);
this._pnlOptions.Controls.Add(this._grpOptions);
this._pnlOptions.Controls.Add(this._chkBare);
this._pnlOptions.Controls.Add(this._chkUseTemplate);
this._pnlOptions.Controls.Add(this._txtTemplate);
this._pnlOptions.Location = new System.Drawing.Point(0, 115);
this._pnlOptions.Name = ""_pnlOptions"";
this._pnlOptions.Size = new System.Drawing.Size(397, 181);
this._pnlOptions.TabIndex = 19;
// // _lblDepth
// this._lblDepth.AutoSize = true;
this._lblDepth.Enabled = false;
this._lblDepth.Location = new System.Drawing.Point(114, 108);
this._lblDepth.Name = ""_lblDepth"";
this._lblDepth.Size = new System.Drawing.Size(62, 15);
this._lblDepth.TabIndex = 9;
this._lblDepth.Text = ""%Depth%:"";
// // _chkNoCheckout
// this._chkNoCheckout.AutoSize = true;
this._chkNoCheckout.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkNoCheckout.Location = new System.Drawing.Point(12, 156);
this._chkNoCheckout.Name = ""_chkNoCheckout"";
this._chkNoCheckout.Size = new System.Drawing.Size(122, 20);
this._chkNoCheckout.TabIndex = 13;
this._chkNoCheckout.Text = ""%No Checkout%"";
this._chkNoCheckout.UseVisualStyleBackColor = true;
// // _chkRecursive
// this._chkRecursive.AutoSize = true;
this._chkRecursive.Checked = true;
this._chkRecursive.CheckState = System.Windows.Forms.CheckState.Checked;
this._chkRecursive.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkRecursive.Location = new System.Drawing.Point(12, 131);
this._chkRecursive.Name = ""_chkRecursive"";
this._chkRecursive.Size = new System.Drawing.Size(102, 20);
this._chkRecursive.TabIndex = 12;
this._chkRecursive.Text = ""%Recursive%"";
this._chkRecursive.UseVisualStyleBackColor = true;
// // _numDepth
// this._numDepth.Enabled = false;
this._numDepth.Location = new System.Drawing.Point(182, 106);
this._numDepth.Maximum = new decimal(new int[] {
-727379969,
232,
0,
0});
this._numDepth.Minimum = new decimal(new int[] {
1,
0,
0,
0});
this._numDepth.Name = ""_numDepth"";
this._numDepth.Size = new System.Drawing.Size(71, 23);
this._numDepth.TabIndex = 11;
this._numDepth.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
this._numDepth.Value = new decimal(new int[] {
1,
0,
0,
0});
// // _chkShallowClone
// this._chkShallowClone.AutoSize = true;
this._chkShallowClone.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkShallowClone.Location = new System.Drawing.Point(12, 106);
this._chkShallowClone.Name = ""_chkShallowClone"";
this._chkShallowClone.Size = new System.Drawing.Size(127, 20);
this._chkShallowClone.TabIndex = 10;
this._chkShallowClone.Text = ""%Shallow Clone%"";
this._chkShallowClone.UseVisualStyleBackColor = true;
this._chkShallowClone.CheckedChanged += new System.EventHandler(this._chkShallowClone_CheckedChanged);
// // _txtRemoteName
// this._txtRemoteName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtRemoteName.Location = new System.Drawing.Point(117, 25);
this._txtRemoteName.Name = ""_txtRemoteName"";
this._txtRemoteName.Size = new System.Drawing.Size(280, 23);
this._txtRemoteName.TabIndex = 4;
// // _lblRemoteName
// this._lblRemoteName.AutoSize = true;
this._lblRemoteName.Location = new System.Drawing.Point(9, 28);
this._lblRemoteName.Name = ""_lblRemoteName"";
this._lblRemoteName.Size = new System.Drawing.Size(104, 15);
this._lblRemoteName.TabIndex = 7;
this._lblRemoteName.Text = ""%Remote name%:"";
// // _chkMirror
// this._chkMirror.AutoSize = true;
this._chkMirror.Enabled = false;
this._chkMirror.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkMirror.Location = new System.Drawing.Point(117, 81);
this._chkMirror.Name = ""_chkMirror"";
this._chkMirror.Size = new System.Drawing.Size(85, 20);
this._chkMirror.TabIndex = 9;
this._chkMirror.Text = ""%Mirror%"";
this._chkMirror.UseVisualStyleBackColor = true;
// // _btnSelectTemplate
// this._btnSelectTemplate.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnSelectTemplate.Enabled = false;
this._btnSelectTemplate.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnSelectTemplate.Location = new System.Drawing.Point(368, 54);
this._btnSelectTemplate.Name = ""_btnSelectTemplate"";
this._btnSelectTemplate.Size = new System.Drawing.Size(29, 23);
this._btnSelectTemplate.TabIndex = 7;
this._btnSelectTemplate.Text = ""..."";
this._btnSelectTemplate.UseVisualStyleBackColor = true;
this._btnSelectTemplate.Click += new System.EventHandler(this._btnSelectTemplate_Click);
// // _grpOptions
// this._grpOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpOptions.Location = new System.Drawing.Point(0, 0);
this._grpOptions.Name = ""_grpOptions"";
this._grpOptions.Size = new System.Drawing.Size(397, 19);
this._grpOptions.TabIndex = 0;
this._grpOptions.Text = ""%Options%"";
// // _chkBare
// this._chkBare.AutoSize = true;
this._chkBare.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkBare.Location = new System.Drawing.Point(12, 81);
this._chkBare.Name = ""_chkBare"";
this._chkBare.Size = new System.Drawing.Size(131, 20);
this._chkBare.TabIndex = 8;
this._chkBare.Text = ""%Bare repository%"";
this._chkBare.UseVisualStyleBackColor = true;
this._chkBare.CheckedChanged += new System.EventHandler(this._chkBare_CheckedChanged);
// // _chkUseTemplate
// this._chkUseTemplate.AutoSize = true;
this._chkUseTemplate.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkUseTemplate.Location = new System.Drawing.Point(12, 56);
this._chkUseTemplate.Name = ""_chkUseTemplate"";
this._chkUseTemplate.Size = new System.Drawing.Size(105, 20);
this._chkUseTemplate.TabIndex = 5;
this._chkUseTemplate.Text = ""%Template%:"";
this._chkUseTemplate.UseVisualStyleBackColor = true;
this._chkUseTemplate.CheckedChanged += new System.EventHandler(this._chkUseTemplate_CheckedChanged);
// // _txtTemplate
// this._txtTemplate.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtTemplate.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
this._txtTemplate.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.FileSystemDirectories;
this._txtTemplate.Enabled = false;
this._txtTemplate.Location = new System.Drawing.Point(117, 54);
this._txtTemplate.Name = ""_txtTemplate"";
this._txtTemplate.Size = new System.Drawing.Size(251, 23);
this._txtTemplate.TabIndex = 6;
// // _lblUrl
// this._lblUrl.AutoSize = true;
this._lblUrl.Location = new System.Drawing.Point(0, 6);
this._lblUrl.Name = ""_lblUrl"";
this._lblUrl.Size = new System.Drawing.Size(51, 15);
this._lblUrl.TabIndex = 18;
this._lblUrl.Text = ""%URL%:"";
// // _txtUrl
// this._txtUrl.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtUrl.Location = new System.Drawing.Point(94, 3);
this._txtUrl.Name = ""_txtUrl"";
this._txtUrl.Size = new System.Drawing.Size(303, 23);
this._txtUrl.TabIndex = 0;
// // _btnSelectDirectory
// this._btnSelectDirectory.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnSelectDirectory.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnSelectDirectory.Location = new System.Drawing.Point(368, 32);
this._btnSelectDirectory.Name = ""_btnSelectDirectory"";
this._btnSelectDirectory.Size = new System.Drawing.Size(29, 23);
this._btnSelectDirectory.TabIndex = 2;
this._btnSelectDirectory.Text = ""..."";
this._btnSelectDirectory.UseVisualStyleBackColor = true;
this._btnSelectDirectory.Click += new System.EventHandler(this._btnSelectDirectory_Click);
// // _lblPath
// this._lblPath.AutoSize = true;
this._lblPath.Location = new System.Drawing.Point(0, 35);
this._lblPath.Name = ""_lblPath"";
this._lblPath.Size = new System.Drawing.Size(54, 15);
this._lblPath.TabIndex = 15;
this._lblPath.Text = ""%Path%:"";
// // _txtPath
// this._txtPath.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtPath.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
this._txtPath.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.FileSystemDirectories;
this._txtPath.Location = new System.Drawing.Point(94, 32);
this._txtPath.Name = ""_txtPath"";
this._txtPath.Size = new System.Drawing.Size(274, 23);
this._txtPath.TabIndex = 1;
// // CloneDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblRealPath);
this.Controls.Add(this._lblWillBeClonedInto);
this.Controls.Add(this._chkAppendRepositoryNameFromUrl);
this.Controls.Add(this._pnlOptions);
this.Controls.Add(this._lblUrl);
this.Controls.Add(this._txtUrl);
this.Controls.Add(this._btnSelectDirectory);
this.Controls.Add(this._lblPath);
this.Controls.Add(this._txtPath);
this.Name = ""CloneDialog"";
this.Size = new System.Drawing.Size(400, 297);
this._pnlOptions.ResumeLayout(false);
this._pnlOptions.PerformLayout();
((System.ComponentModel.ISupportInitialize)(this._numDepth)).EndInit();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2674,"private void InitializeComponent()
{
components = new System.ComponentModel.Container();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2675,"public static ColumnResizeProcess FromActiveColumn(IList<CustomListBoxColumn> columns, int activeIndex, ColumnResizeSide side, Point mouseDownLocation)
{
Assert.IsNotNull(columns);
var activeColumn = columns[activeIndex];
int autoSizeId = int.MaxValue;
for(int i = 0; i < columns.Count; ++i)
{
if(columns[i].IsVisible && columns[i].SizeMode == ColumnSizeMode.Fill)
{
autoSizeId = i;
break;
}
}
switch(side)
{
case ColumnResizeSide.Left:
var prevColumn = columns.FindPrevious(activeIndex, column => column.IsVisible);
if(prevColumn != null && activeIndex <= autoSizeId)
{
if(prevColumn.SizeMode == ColumnSizeMode.Sizeable)
{
return new ColumnResizeProcess(prevColumn, 1, mouseDownLocation);
}
}
if(activeColumn.SizeMode != ColumnSizeMode.Sizeable)
{
return null;
}
return new ColumnResizeProcess(activeColumn, -1, mouseDownLocation);
case ColumnResizeSide.Right:
if(activeColumn.SizeMode != ColumnSizeMode.Sizeable || activeIndex > autoSizeId)
{
var nextColumn = columns.FindNext(activeIndex, column => column.IsVisible);
if(nextColumn != null)
{
return new ColumnResizeProcess(nextColumn, -1, mouseDownLocation);
}
else
{
return null;
}
}
else
{
return new ColumnResizeProcess(activeColumn, 1, mouseDownLocation);
}
default:
throw new ArgumentException(""Invalid column resize side."", ""side"");
}
}","Create resize process from column list, active (hovered) column and side (left or right) of resize.",1
2676,"private void InitializeComponent()
{
this._lblVisibleColumns = new System.Windows.Forms.Label();
this._lstColumns = new gitter.Framework.Controls.CustomListBox();
this._btnHide = new System.Windows.Forms.Button();
this._btnUp = new System.Windows.Forms.Button();
this._btnShow = new System.Windows.Forms.Button();
this._btnDown = new System.Windows.Forms.Button();
this.SuspendLayout();
// // _lblVisibleColumns
// this._lblVisibleColumns.AutoSize = true;
this._lblVisibleColumns.Location = new System.Drawing.Point(0, 0);
this._lblVisibleColumns.Name = ""_lblVisibleColumns"";
this._lblVisibleColumns.Size = new System.Drawing.Size(115, 15);
this._lblVisibleColumns.TabIndex = 19;
this._lblVisibleColumns.Text = ""%Visible Columns%:"";
// // _lstColumns
// this._lstColumns.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._lstColumns.Location = new System.Drawing.Point(3, 16);
this._lstColumns.Name = ""_lstColumns"";
this._lstColumns.ShowCheckBoxes = true;
this._lstColumns.Size = new System.Drawing.Size(213, 228);
this._lstColumns.TabIndex = 18;
this._lstColumns.SelectionChanged += new System.EventHandler(this._lstColumns_SelectionChanged);
// // _btnHide
// this._btnHide.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnHide.Enabled = false;
this._btnHide.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnHide.Location = new System.Drawing.Point(222, 103);
this._btnHide.Name = ""_btnHide"";
this._btnHide.Size = new System.Drawing.Size(75, 23);
this._btnHide.TabIndex = 23;
this._btnHide.Text = ""%Hide%"";
this._btnHide.UseVisualStyleBackColor = true;
this._btnHide.Click += new System.EventHandler(this._btnHide_Click);
// // _btnUp
// this._btnUp.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnUp.Enabled = false;
this._btnUp.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnUp.Location = new System.Drawing.Point(222, 16);
this._btnUp.Name = ""_btnUp"";
this._btnUp.Size = new System.Drawing.Size(75, 23);
this._btnUp.TabIndex = 20;
this._btnUp.Text = ""%Up%"";
this._btnUp.UseVisualStyleBackColor = true;
this._btnUp.Click += new System.EventHandler(this._btnUp_Click);
// // _btnShow
// this._btnShow.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnShow.Enabled = false;
this._btnShow.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnShow.Location = new System.Drawing.Point(222, 74);
this._btnShow.Name = ""_btnShow"";
this._btnShow.Size = new System.Drawing.Size(75, 23);
this._btnShow.TabIndex = 22;
this._btnShow.Text = ""%Show%"";
this._btnShow.UseVisualStyleBackColor = true;
this._btnShow.Click += new System.EventHandler(this._btnShow_Click);
// // _btnDown
// this._btnDown.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnDown.Enabled = false;
this._btnDown.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnDown.Location = new System.Drawing.Point(222, 45);
this._btnDown.Name = ""_btnDown"";
this._btnDown.Size = new System.Drawing.Size(75, 23);
this._btnDown.TabIndex = 21;
this._btnDown.Text = ""%Down%"";
this._btnDown.UseVisualStyleBackColor = true;
this._btnDown.Click += new System.EventHandler(this._btnDown_Click);
// // ColumnsDialog
// this.Controls.Add(this._lblVisibleColumns);
this.Controls.Add(this._lstColumns);
this.Controls.Add(this._btnHide);
this.Controls.Add(this._btnUp);
this.Controls.Add(this._btnShow);
this.Controls.Add(this._btnDown);
this.Name = ""ColumnsDialog"";
this.Size = new System.Drawing.Size(300, 247);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2677,"public static ICommandArgument ReuseMessage(string commit)
{
return new CommandParameterValue(""--reuse-message"", commit);
}","Take an existing commit object, and reuse the log message and the authorship information (including the timestamp) when creating the commit.",1
2678,"private void InitializeComponent()
{
this._lstStaged = new gitter.Git.Gui.Controls.TreeListBox();
this._txtMessage = new System.Windows.Forms.TextBox();
this._lblStagedFiles = new System.Windows.Forms.Label();
this._lblMessage = new System.Windows.Forms.Label();
this._chkAmend = new System.Windows.Forms.CheckBox();
this.SuspendLayout();
// // _lstStaged
// this._lstStaged.DisableContextMenus = true;
this._lstStaged.ForeColor = System.Drawing.SystemColors.WindowText;
this._lstStaged.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstStaged.Location = new System.Drawing.Point(3, 18);
this._lstStaged.Name = ""_lstStaged"";
this._lstStaged.ShowTreeLines = true;
this._lstStaged.Size = new System.Drawing.Size(222, 338);
this._lstStaged.TabIndex = 2;
// // _txtMessage
// this._txtMessage.AcceptsReturn = true;
this._txtMessage.AcceptsTab = true;
this._txtMessage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtMessage.Location = new System.Drawing.Point(231, 18);
this._txtMessage.Multiline = true;
this._txtMessage.Name = ""_txtMessage"";
this._txtMessage.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
this._txtMessage.Size = new System.Drawing.Size(408, 316);
this._txtMessage.TabIndex = 0;
// // _lblStagedFiles
// this._lblStagedFiles.AutoSize = true;
this._lblStagedFiles.Location = new System.Drawing.Point(0, 0);
this._lblStagedFiles.Name = ""_lblStagedFiles"";
this._lblStagedFiles.Size = new System.Drawing.Size(113, 15);
this._lblStagedFiles.TabIndex = 2;
this._lblStagedFiles.Text = ""%Staged changes%:"";
// // _lblMessage
// this._lblMessage.AutoSize = true;
this._lblMessage.Location = new System.Drawing.Point(228, 0);
this._lblMessage.Name = ""_lblMessage"";
this._lblMessage.Size = new System.Drawing.Size(76, 15);
this._lblMessage.TabIndex = 3;
this._lblMessage.Text = ""%Message%:"";
// // _chkAmend
// this._chkAmend.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this._chkAmend.AutoSize = true;
this._chkAmend.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkAmend.Location = new System.Drawing.Point(231, 336);
this._chkAmend.Name = ""_chkAmend"";
this._chkAmend.Size = new System.Drawing.Size(91, 20);
this._chkAmend.TabIndex = 1;
this._chkAmend.Text = ""%Amend%"";
this._chkAmend.UseVisualStyleBackColor = true;
this._chkAmend.CheckedChanged += new System.EventHandler(this.OnAmendCheckedChanged);
// // CommitDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblMessage);
this.Controls.Add(this._lblStagedFiles);
this.Controls.Add(this._txtMessage);
this.Controls.Add(this._lstStaged);
this.Controls.Add(this._chkAmend);
this.Name = ""CommitDialog"";
this.Size = new System.Drawing.Size(642, 359);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2679,"private void InitializeComponent()
{
this._splitContainer = new System.Windows.Forms.SplitContainer();
this._tableChanges = new System.Windows.Forms.TableLayoutPanel();
this._lblUnstaged = new System.Windows.Forms.Label();
this._lblStaged = new System.Windows.Forms.Label();
this._lstUnstaged = new gitter.Git.Gui.Controls.TreeListBox();
this._lstStaged = new gitter.Git.Gui.Controls.TreeListBox();
this._lblMessage = new System.Windows.Forms.Label();
this._txtMessage = new System.Windows.Forms.TextBox();
this._chkAmend = gitter.Framework.GitterApplication.Style.CreateCheckBox();
this._btnCommit = gitter.Framework.GitterApplication.Style.CreateButton();
((System.ComponentModel.ISupportInitialize)(this._splitContainer)).BeginInit();
this._splitContainer.Panel1.SuspendLayout();
this._splitContainer.Panel2.SuspendLayout();
this._splitContainer.SuspendLayout();
this._tableChanges.SuspendLayout();
this.SuspendLayout();
// // _splitContainer
// this._splitContainer.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._splitContainer.FixedPanel = System.Windows.Forms.FixedPanel.Panel2;
this._splitContainer.Location = new System.Drawing.Point(0, 0);
this._splitContainer.Name = ""_splitContainer"";
this._splitContainer.Orientation = System.Windows.Forms.Orientation.Horizontal;
// // _splitContainer.Panel1
// this._splitContainer.Panel1.Controls.Add(this._tableChanges);
this._splitContainer.Panel1MinSize = 150;
// // _splitContainer.Panel2
// this._splitContainer.Panel2.Controls.Add(this._lblMessage);
this._splitContainer.Panel2.Controls.Add(this._txtMessage);
this._splitContainer.Size = new System.Drawing.Size(555, 362);
this._splitContainer.SplitterDistance = 239;
this._splitContainer.TabIndex = 11;
// // _tableChanges
// this._tableChanges.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._tableChanges.ColumnCount = 2;
this._tableChanges.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
this._tableChanges.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 50F));
this._tableChanges.Controls.Add(this._lblUnstaged, 0, 0);
this._tableChanges.Controls.Add(this._lblStaged, 1, 0);
this._tableChanges.Controls.Add(this._lstUnstaged, 0, 1);
this._tableChanges.Controls.Add(this._lstStaged, 1, 1);
this._tableChanges.Location = new System.Drawing.Point(3, 0);
this._tableChanges.Margin = new System.Windows.Forms.Padding(3, 0, 3, 0);
this._tableChanges.Name = ""_tableChanges"";
this._tableChanges.RowCount = 2;
this._tableChanges.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 21F));
this._tableChanges.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 100F));
this._tableChanges.Size = new System.Drawing.Size(549, 239);
this._tableChanges.TabIndex = 0;
// // _lblUnstaged
// this._lblUnstaged.Dock = System.Windows.Forms.DockStyle.Fill;
this._lblUnstaged.Location = new System.Drawing.Point(0, 0);
this._lblUnstaged.Margin = new System.Windows.Forms.Padding(0, 0, 3, 0);
this._lblUnstaged.Name = ""_lblUnstaged"";
this._lblUnstaged.Size = new System.Drawing.Size(271, 21);
this._lblUnstaged.TabIndex = 0;
this._lblUnstaged.Text = ""%Unstaged Changes%:"";
this._lblUnstaged.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
// // _lblStaged
// this._lblStaged.Dock = System.Windows.Forms.DockStyle.Fill;
this._lblStaged.Location = new System.Drawing.Point(274, 0);
this._lblStaged.Margin = new System.Windows.Forms.Padding(0, 0, 3, 0);
this._lblStaged.Name = ""_lblStaged"";
this._lblStaged.Size = new System.Drawing.Size(272, 21);
this._lblStaged.TabIndex = 1;
this._lblStaged.Text = ""%Staged Changes%:"";
this._lblStaged.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
// // _lstUnstaged
// this._lstUnstaged.Dock = System.Windows.Forms.DockStyle.Fill;
this._lstUnstaged.ForeColor = System.Drawing.SystemColors.WindowText;
this._lstUnstaged.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstUnstaged.Location = new System.Drawing.Point(0, 21);
this._lstUnstaged.Margin = new System.Windows.Forms.Padding(0, 0, 2, 4);
this._lstUnstaged.Multiselect = true;
this._lstUnstaged.Name = ""_lstUnstaged"";
this._lstUnstaged.ShowTreeLines = true;
this._lstUnstaged.Size = new System.Drawing.Size(272, 214);
this._lstUnstaged.TabIndex = 2;
this._lstUnstaged.Text = ""%No unstaged changes%"";
// // _lstStaged
// this._lstStaged.Dock = System.Windows.Forms.DockStyle.Fill;
this._lstStaged.ForeColor = System.Drawing.SystemColors.WindowText;
this._lstStaged.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstStaged.Location = new System.Drawing.Point(276, 21);
this._lstStaged.Margin = new System.Windows.Forms.Padding(2, 0, 0, 4);
this._lstStaged.Multiselect = true;
this._lstStaged.Name = ""_lstStaged"";
this._lstStaged.ShowTreeLines = true;
this._lstStaged.Size = new System.Drawing.Size(273, 214);
this._lstStaged.TabIndex = 2;
this._lstStaged.Text = ""%No staged changes%"";
// // _lblMessage
// this._lblMessage.AutoSize = true;
this._lblMessage.Location = new System.Drawing.Point(0, 0);
this._lblMessage.Name = ""_lblMessage"";
this._lblMessage.Size = new System.Drawing.Size(76, 15);
this._lblMessage.TabIndex = 13;
this._lblMessage.Text = ""%Message%:"";
// // _txtMessage
// this._txtMessage.AcceptsReturn = true;
this._txtMessage.AcceptsTab = true;
this._txtMessage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtMessage.Font = new System.Drawing.Font(""Consolas"", 10F);
this._txtMessage.Location = new System.Drawing.Point(3, 18);
this._txtMessage.Multiline = true;
this._txtMessage.Name = ""_txtMessage"";
this._txtMessage.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
this._txtMessage.Size = new System.Drawing.Size(468, 98);
this._txtMessage.TabIndex = 10;
//
// _chkAmend
//
this._chkAmend.Control.Bounds = new System.Drawing.Rectangle(477, 67, 71, 20);
this._chkAmend.Control.Anchor = System.Windows.Forms.AnchorStyles.Right | System.Windows.Forms.AnchorStyles.Bottom;
this._chkAmend.Control.Parent = _splitContainer.Panel2;
this._chkAmend.Control.Enabled = false;
this._chkAmend.Control.TabIndex = 12;
this._chkAmend.IsCheckedChanged += OnAmendCheckedChanged;
//
// _btnCommit
//
this._btnCommit.Control.Bounds = new System.Drawing.Rectangle(477, 93, 75, 23);
this._btnCommit.Control.Anchor = System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right;
this._btnCommit.Control.Parent = _splitContainer.Panel2;
this._btnCommit.Control.TabIndex = 11;
this._btnCommit.Click += OnCommitClick;
// // CommitView
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._splitContainer);
this.Name = ""CommitView"";
this._splitContainer.Panel1.ResumeLayout(false);
this._splitContainer.Panel2.ResumeLayout(false);
this._splitContainer.Panel2.PerformLayout();
((System.ComponentModel.ISupportInitialize)(this._splitContainer)).EndInit();
this._splitContainer.ResumeLayout(false);
this._tableChanges.ResumeLayout(false);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2680,"public void Refresh()
{
if(_configFile == ConfigFile.Repository)
{
Repository.Configuration.Refresh(this);
}
else
{
ConfigParameterData configParameterData;
if(_configFile == ConfigFile.Other)
{
configParameterData = _configAccessor.QueryConfigParameter.Invoke(
new QueryConfigParameterParameters(_fileName, Name));
}
else
{
configParameterData = _configAccessor.QueryConfigParameter.Invoke(
new QueryConfigParameterParameters(_configFile, Name));
}
if(configParameterData == null)
{
MarkAsDeleted();
}
else
{
ObjectFactories.UpdateConfigParameter(this, configParameterData);
}
}
}",Update parameter value.,1
2681,"public void Refresh()
{
IList<ConfigParameterData> config;
switch(_configFile)
{
case ConfigFile.Other:
config = _configAccessor.QueryConfig.Invoke(
new QueryConfigParameters(_fileName));
break;
case ConfigFile.Repository:
config = _configAccessor.QueryConfig.Invoke(
new QueryConfigParameters());
break;
case ConfigFile.System:
case ConfigFile.User:
config = _configAccessor.QueryConfig.Invoke(
new QueryConfigParameters(_configFile));
break;
default:
throw new ApplicationException(
string.Format(CultureInfo.InvariantCulture, ""Unknown ConfigFile value: {0}"", _configFile));
}
lock(SyncRoot)
{
if(_repository != null)
{
CacheUpdater.UpdateObjectDictionary<ConfigParameter, ConfigParameterData>(
_parameters,
null,
null,
config,
configParameterData => ObjectFactories.CreateConfigParameter(_repository, configParameterData),
ObjectFactories.UpdateConfigParameter,
InvokeCreated,
InvokeDeleted,
true);
}
else
{
CacheUpdater.UpdateObjectDictionary<ConfigParameter, ConfigParameterData>(
_parameters,
null,
null,
config,
configParameterData => ObjectFactories.CreateConfigParameter(_configAccessor, configParameterData),
ObjectFactories.UpdateConfigParameter,
InvokeCreated,
InvokeDeleted,
true);
}
}
}",Synchronize cached information with actual data.,1
2682,"private void InitializeComponent()
{
this._lstUserConfig = new gitter.Git.Gui.Controls.ConfigListBox();
this._tabs = new System.Windows.Forms.TabControl();
this._pageUser = new System.Windows.Forms.TabPage();
this._btnAddUserParameter = new System.Windows.Forms.Button();
this._pageSystem = new System.Windows.Forms.TabPage();
this._btnAddSystemParameter = new System.Windows.Forms.Button();
this._lstSystemConfig = new gitter.Git.Gui.Controls.ConfigListBox();
this._tabs.SuspendLayout();
this._pageUser.SuspendLayout();
this._pageSystem.SuspendLayout();
this.SuspendLayout();
// // _lstUserConfig
// this._lstUserConfig.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._lstUserConfig.Location = new System.Drawing.Point(0, 0);
this._lstUserConfig.Name = ""_lstUserConfig"";
this._lstUserConfig.Size = new System.Drawing.Size(520, 311);
this._lstUserConfig.TabIndex = 0;
// // _tabs
// this._tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._tabs.Controls.Add(this._pageUser);
this._tabs.Controls.Add(this._pageSystem);
this._tabs.Location = new System.Drawing.Point(0, 0);
this._tabs.Name = ""_tabs"";
this._tabs.SelectedIndex = 0;
this._tabs.Size = new System.Drawing.Size(528, 374);
this._tabs.TabIndex = 1;
// // _pageUser
// this._pageUser.Controls.Add(this._btnAddUserParameter);
this._pageUser.Controls.Add(this._lstUserConfig);
this._pageUser.Location = new System.Drawing.Point(4, 24);
this._pageUser.Name = ""_pageUser"";
this._pageUser.Padding = new System.Windows.Forms.Padding(3);
this._pageUser.Size = new System.Drawing.Size(520, 346);
this._pageUser.TabIndex = 0;
this._pageUser.Text = ""%Current User%"";
this._pageUser.UseVisualStyleBackColor = true;
// // _btnAddUserParameter
// this._btnAddUserParameter.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._btnAddUserParameter.Location = new System.Drawing.Point(384, 317);
this._btnAddUserParameter.Name = ""_btnAddUserParameter"";
this._btnAddUserParameter.Size = new System.Drawing.Size(130, 23);
this._btnAddUserParameter.TabIndex = 1;
this._btnAddUserParameter.Text = ""%Add Parameter%"";
this._btnAddUserParameter.UseVisualStyleBackColor = true;
this._btnAddUserParameter.Click += new System.EventHandler(this._addUserParameter_Click);
// // _pageSystem
// this._pageSystem.Controls.Add(this._btnAddSystemParameter);
this._pageSystem.Controls.Add(this._lstSystemConfig);
this._pageSystem.Location = new System.Drawing.Point(4, 24);
this._pageSystem.Name = ""_pageSystem"";
this._pageSystem.Padding = new System.Windows.Forms.Padding(3);
this._pageSystem.Size = new System.Drawing.Size(520, 346);
this._pageSystem.TabIndex = 1;
this._pageSystem.Text = ""%System%"";
this._pageSystem.UseVisualStyleBackColor = true;
// // _btnAddSystemParameter
// this._btnAddSystemParameter.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._btnAddSystemParameter.Location = new System.Drawing.Point(384, 317);
this._btnAddSystemParameter.Name = ""_btnAddSystemParameter"";
this._btnAddSystemParameter.Size = new System.Drawing.Size(130, 23);
this._btnAddSystemParameter.TabIndex = 2;
this._btnAddSystemParameter.Text = ""%Add Parameter%"";
this._btnAddSystemParameter.UseVisualStyleBackColor = true;
this._btnAddSystemParameter.Click += new System.EventHandler(this._addSystemParameter_Click);
// // _lstSystemConfig
// this._lstSystemConfig.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._lstSystemConfig.Location = new System.Drawing.Point(0, 0);
this._lstSystemConfig.Name = ""_lstSystemConfig"";
this._lstSystemConfig.Size = new System.Drawing.Size(520, 311);
this._lstSystemConfig.TabIndex = 1;
// // ConfigurationPage
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._tabs);
this.Name = ""ConfigurationPage"";
this.Size = new System.Drawing.Size(528, 374);
this._tabs.ResumeLayout(false);
this._pageUser.ResumeLayout(false);
this._pageSystem.ResumeLayout(false);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2683,"private void InitializeComponent()
{
this._lstConfig = new gitter.Git.Gui.Controls.ConfigListBox();
this.SuspendLayout();
// // _lstConfig
// this._lstConfig.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._lstConfig.Dock = System.Windows.Forms.DockStyle.Fill;
this._lstConfig.Location = new System.Drawing.Point(0, 0);
this._lstConfig.Name = ""_lstConfig"";
this._lstConfig.Size = new System.Drawing.Size(555, 362);
this._lstConfig.TabIndex = 1;
this._lstConfig.Text = ""No parameters found"";
// // ConfigView
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lstConfig);
this.Name = ""ConfigView"";
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2684,"private void InitializeComponent()
{
this._btnResolution2 = new gitter.Framework.Controls.CommandLink();
this._btnResolution1 = new gitter.Framework.Controls.CommandLink();
this.label1 = new System.Windows.Forms.Label();
this._lblFileName = new System.Windows.Forms.Label();
this.label3 = new System.Windows.Forms.Label();
this.label4 = new System.Windows.Forms.Label();
this._lblOursStatus = new System.Windows.Forms.Label();
this._lblTheirsStatus = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _btnResolution2
// this._btnResolution2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._btnResolution2.Description = null;
this._btnResolution2.Location = new System.Drawing.Point(19, 94);
this._btnResolution2.Name = ""_btnResolution2"";
this._btnResolution2.Size = new System.Drawing.Size(319, 26);
this._btnResolution2.TabIndex = 3;
this._btnResolution2.Text = ""Delete file"";
this._btnResolution2.Click += new System.EventHandler(this._btnResolution2_Click);
// // _btnResolution1
// this._btnResolution1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._btnResolution1.Description = null;
this._btnResolution1.Location = new System.Drawing.Point(19, 61);
this._btnResolution1.Name = ""_btnResolution1"";
this._btnResolution1.Size = new System.Drawing.Size(319, 26);
this._btnResolution1.TabIndex = 2;
this._btnResolution1.Text = ""Keep modified file"";
this._btnResolution1.Click += new System.EventHandler(this._btnResolution1_Click);
// // label1
// this.label1.AutoSize = true;
this.label1.Location = new System.Drawing.Point(16, 0);
this.label1.Name = ""label1"";
this.label1.Size = new System.Drawing.Size(28, 15);
this.label1.TabIndex = 4;
this.label1.Text = ""File:"";
// // _lblFileName
// this._lblFileName.AutoSize = true;
this._lblFileName.Location = new System.Drawing.Point(16, 15);
this._lblFileName.Name = ""_lblFileName"";
this._lblFileName.Size = new System.Drawing.Size(75, 15);
this._lblFileName.TabIndex = 5;
this._lblFileName.Text = ""[FILE_NAME]"";
// // label3
// this.label3.AutoSize = true;
this.label3.Location = new System.Drawing.Point(16, 35);
this.label3.Name = ""label3"";
this.label3.Size = new System.Drawing.Size(69, 15);
this.label3.TabIndex = 6;
this.label3.Text = ""Ours status:"";
// // label4
// this.label4.AutoSize = true;
this.label4.Location = new System.Drawing.Point(169, 35);
this.label4.Name = ""label4"";
this.label4.Size = new System.Drawing.Size(76, 15);
this.label4.TabIndex = 7;
this.label4.Text = ""Theirs status:"";
// // _lblOursStatus
// this._lblOursStatus.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
this._lblOursStatus.Location = new System.Drawing.Point(91, 33);
this._lblOursStatus.Name = ""_lblOursStatus"";
this._lblOursStatus.Size = new System.Drawing.Size(71, 18);
this._lblOursStatus.TabIndex = 8;
this._lblOursStatus.Text = ""modified"";
this._lblOursStatus.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
// // _lblTheirsStatus
// this._lblTheirsStatus.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
this._lblTheirsStatus.Location = new System.Drawing.Point(251, 33);
this._lblTheirsStatus.Name = ""_lblTheirsStatus"";
this._lblTheirsStatus.Size = new System.Drawing.Size(71, 18);
this._lblTheirsStatus.TabIndex = 8;
this._lblTheirsStatus.Text = ""modified"";
this._lblTheirsStatus.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
// // ConflictResolutionDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblTheirsStatus);
this.Controls.Add(this._lblOursStatus);
this.Controls.Add(this.label4);
this.Controls.Add(this.label3);
this.Controls.Add(this._lblFileName);
this.Controls.Add(this.label1);
this.Controls.Add(this._btnResolution2);
this.Controls.Add(this._btnResolution1);
this.Name = ""ConflictResolutionDialog"";
this.Size = new System.Drawing.Size(350, 133);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2685,"private void InitializeComponent()
{
this._lstConflicts = new gitter.Git.Gui.Controls.TreeListBox();
this._lblConflictingFiles = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _lstConflicts
// this._lstConflicts.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._lstConflicts.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstConflicts.Location = new System.Drawing.Point(3, 18);
this._lstConflicts.Name = ""_lstConflicts"";
this._lstConflicts.Size = new System.Drawing.Size(394, 304);
this._lstConflicts.TabIndex = 3;
// // _lblConflictingFiles
// this._lblConflictingFiles.AutoSize = true;
this._lblConflictingFiles.Location = new System.Drawing.Point(0, 0);
this._lblConflictingFiles.Name = ""_lblConflictingFiles"";
this._lblConflictingFiles.Size = new System.Drawing.Size(115, 15);
this._lblConflictingFiles.TabIndex = 4;
this._lblConflictingFiles.Text = ""%Conflicting Files%:"";
// // ConflictsDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblConflictingFiles);
this.Controls.Add(this._lstConflicts);
this.Name = ""ConflictsDialog"";
this.Size = new System.Drawing.Size(400, 325);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2686,"private void InitializeComponent()
{
this._lstUsers = new gitter.Git.Gui.Controls.UsresListBox();
this.SuspendLayout();
// // _lstUsers
// this._lstUsers.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._lstUsers.Dock = System.Windows.Forms.DockStyle.Fill;
this._lstUsers.Location = new System.Drawing.Point(0, 0);
this._lstUsers.Margin = new System.Windows.Forms.Padding(0);
this._lstUsers.Name = ""_lstUsers"";
this._lstUsers.Size = new System.Drawing.Size(555, 362);
this._lstUsers.TabIndex = 1;
this._lstUsers.Text = ""No Users"";
// // ContributorsView
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lstUsers);
this.Name = ""ContributorsView"";
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2687,"private void InitializeComponent()
{
this._pnlOptions = new System.Windows.Forms.Panel();
this._chkOrphan = new System.Windows.Forms.CheckBox();
this._chkCheckoutAfterCreation = new System.Windows.Forms.CheckBox();
this._grpOptions = new gitter.Framework.Controls.GroupSeparator();
this._chkCreateReflog = new System.Windows.Forms.CheckBox();
this._txtName = new System.Windows.Forms.TextBox();
this._lblRevision = new System.Windows.Forms.Label();
this._lblName = new System.Windows.Forms.Label();
this._txtRevision = new gitter.Git.Gui.Controls.RevisionPicker();
this.panel1 = new System.Windows.Forms.Panel();
this._trackingDoNotTrack = new System.Windows.Forms.RadioButton();
this._trackingTrack = new System.Windows.Forms.RadioButton();
this._trackingDefault = new System.Windows.Forms.RadioButton();
this._grpTracking = new gitter.Framework.Controls.GroupSeparator();
this._pnlOptions.SuspendLayout();
this.panel1.SuspendLayout();
this.SuspendLayout();
// // _pnlOptions
// this._pnlOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlOptions.Controls.Add(this._chkOrphan);
this._pnlOptions.Controls.Add(this._chkCheckoutAfterCreation);
this._pnlOptions.Controls.Add(this._grpOptions);
this._pnlOptions.Controls.Add(this._chkCreateReflog);
this._pnlOptions.Location = new System.Drawing.Point(0, 61);
this._pnlOptions.Margin = new System.Windows.Forms.Padding(0);
this._pnlOptions.Name = ""_pnlOptions"";
this._pnlOptions.Size = new System.Drawing.Size(400, 90);
this._pnlOptions.TabIndex = 8;
// // _chkOrphan
// this._chkOrphan.AutoSize = true;
this._chkOrphan.Enabled = false;
this._chkOrphan.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkOrphan.Location = new System.Drawing.Point(13, 45);
this._chkOrphan.Name = ""_chkOrphan"";
this._chkOrphan.Size = new System.Drawing.Size(162, 20);
this._chkOrphan.TabIndex = 3;
this._chkOrphan.Text = ""%Make orphan branch%"";
this._chkOrphan.UseVisualStyleBackColor = true;
// // _chkCheckoutAfterCreation
// this._chkCheckoutAfterCreation.AutoSize = true;
this._chkCheckoutAfterCreation.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkCheckoutAfterCreation.Location = new System.Drawing.Point(13, 25);
this._chkCheckoutAfterCreation.Name = ""_chkCheckoutAfterCreation"";
this._chkCheckoutAfterCreation.Size = new System.Drawing.Size(176, 20);
this._chkCheckoutAfterCreation.TabIndex = 2;
this._chkCheckoutAfterCreation.Text = ""%Checkout after creation%"";
this._chkCheckoutAfterCreation.UseVisualStyleBackColor = true;
this._chkCheckoutAfterCreation.CheckedChanged += new System.EventHandler(this.OnCheckoutAfterCreationCheckedChanged);
// // _grpOptions
// this._grpOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpOptions.Location = new System.Drawing.Point(0, 0);
this._grpOptions.Name = ""_grpOptions"";
this._grpOptions.Size = new System.Drawing.Size(397, 19);
this._grpOptions.TabIndex = 0;
this._grpOptions.Text = ""%Options%"";
// // _chkCreateReflog
// this._chkCreateReflog.AutoSize = true;
this._chkCreateReflog.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkCreateReflog.Location = new System.Drawing.Point(13, 65);
this._chkCreateReflog.Name = ""_chkCreateReflog"";
this._chkCreateReflog.Size = new System.Drawing.Size(160, 20);
this._chkCreateReflog.TabIndex = 4;
this._chkCreateReflog.Text = ""%Create branch reflog%"";
this._chkCreateReflog.UseVisualStyleBackColor = true;
// // _txtName
// this._txtName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtName.Location = new System.Drawing.Point(94, 3);
this._txtName.Name = ""_txtName"";
this._txtName.Size = new System.Drawing.Size(303, 23);
this._txtName.TabIndex = 0;
this._txtName.TextChanged += new System.EventHandler(this.OnBranchNameChanged);
// // _lblRevision
// this._lblRevision.AutoSize = true;
this._lblRevision.Location = new System.Drawing.Point(0, 35);
this._lblRevision.Name = ""_lblRevision"";
this._lblRevision.Size = new System.Drawing.Size(74, 15);
this._lblRevision.TabIndex = 4;
this._lblRevision.Text = ""%Revision%:"";
// // _lblName
// this._lblName.AutoSize = true;
this._lblName.Location = new System.Drawing.Point(0, 6);
this._lblName.Name = ""_lblName"";
this._lblName.Size = new System.Drawing.Size(62, 15);
this._lblName.TabIndex = 1;
this._lblName.Text = ""%Name%:"";
// // _txtRevision
// this._txtRevision.FormattingEnabled = true;
this._txtRevision.Location = new System.Drawing.Point(94, 32);
this._txtRevision.Name = ""_txtRevision"";
this._txtRevision.Size = new System.Drawing.Size(303, 23);
this._txtRevision.TabIndex = 1;
this._txtRevision.TextChanged += new System.EventHandler(this.OnRevisionChanged);
// // panel1
// this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.panel1.Controls.Add(this._trackingDoNotTrack);
this.panel1.Controls.Add(this._trackingTrack);
this.panel1.Controls.Add(this._trackingDefault);
this.panel1.Controls.Add(this._grpTracking);
this.panel1.Location = new System.Drawing.Point(0, 151);
this.panel1.Margin = new System.Windows.Forms.Padding(0);
this.panel1.Name = ""panel1"";
this.panel1.Size = new System.Drawing.Size(400, 49);
this.panel1.TabIndex = 9;
// // _trackingDoNotTrack
// this._trackingDoNotTrack.AutoSize = true;
this._trackingDoNotTrack.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._trackingDoNotTrack.Location = new System.Drawing.Point(108, 25);
this._trackingDoNotTrack.Name = ""_trackingDoNotTrack"";
this._trackingDoNotTrack.Size = new System.Drawing.Size(116, 20);
this._trackingDoNotTrack.TabIndex = 6;
this._trackingDoNotTrack.Text = ""%Do not track%"";
this._trackingDoNotTrack.UseVisualStyleBackColor = true;
// // _trackingTrack
// this._trackingTrack.AutoSize = true;
this._trackingTrack.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._trackingTrack.Location = new System.Drawing.Point(230, 25);
this._trackingTrack.Name = ""_trackingTrack"";
this._trackingTrack.Size = new System.Drawing.Size(80, 20);
this._trackingTrack.TabIndex = 7;
this._trackingTrack.Text = ""%Track%"";
this._trackingTrack.UseVisualStyleBackColor = true;
// // _trackingDefault
// this._trackingDefault.AutoSize = true;
this._trackingDefault.Checked = true;
this._trackingDefault.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._trackingDefault.Location = new System.Drawing.Point(13, 25);
this._trackingDefault.Name = ""_trackingDefault"";
this._trackingDefault.Size = new System.Drawing.Size(89, 20);
this._trackingDefault.TabIndex = 5;
this._trackingDefault.TabStop = true;
this._trackingDefault.Text = ""%Default%"";
this._trackingDefault.UseVisualStyleBackColor = true;
// // _grpTracking
// this._grpTracking.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpTracking.Location = new System.Drawing.Point(0, 0);
this._grpTracking.Name = ""_grpTracking"";
this._grpTracking.Size = new System.Drawing.Size(397, 19);
this._grpTracking.TabIndex = 0;
this._grpTracking.Text = ""%Tracking mode%"";
// // CreateBranchDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this.panel1);
this.Controls.Add(this._txtRevision);
this.Controls.Add(this._pnlOptions);
this.Controls.Add(this._txtName);
this.Controls.Add(this._lblRevision);
this.Controls.Add(this._lblName);
this.Name = ""CreateBranchDialog"";
this.Size = new System.Drawing.Size(400, 200);
this._pnlOptions.ResumeLayout(false);
this._pnlOptions.PerformLayout();
this.panel1.ResumeLayout(false);
this.panel1.PerformLayout();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2688,"private void InitializeComponent()
{
this.panel2 = new System.Windows.Forms.Panel();
this._txtKeyId = new System.Windows.Forms.TextBox();
this._grpSigning = new gitter.Framework.Controls.GroupSeparator();
this._radUseKeyId = new System.Windows.Forms.RadioButton();
this._radUseDefaultEmailKey = new System.Windows.Forms.RadioButton();
this.panel1 = new System.Windows.Forms.Panel();
this._grpMessage = new gitter.Framework.Controls.GroupSeparator();
this._txtMessage = new System.Windows.Forms.TextBox();
this._pnlOptions = new System.Windows.Forms.Panel();
this._radSigned = new System.Windows.Forms.RadioButton();
this._grpOptions = new gitter.Framework.Controls.GroupSeparator();
this._radSimple = new System.Windows.Forms.RadioButton();
this._radAnnotated = new System.Windows.Forms.RadioButton();
this._lblRevision = new System.Windows.Forms.Label();
this._txtName = new System.Windows.Forms.TextBox();
this._lblName = new System.Windows.Forms.Label();
this._txtRevision = new gitter.Git.Gui.Controls.RevisionPicker();
this.panel2.SuspendLayout();
this.panel1.SuspendLayout();
this._pnlOptions.SuspendLayout();
this.SuspendLayout();
// // panel2
// this.panel2.Controls.Add(this._txtKeyId);
this.panel2.Controls.Add(this._grpSigning);
this.panel2.Controls.Add(this._radUseKeyId);
this.panel2.Controls.Add(this._radUseDefaultEmailKey);
this.panel2.Location = new System.Drawing.Point(0, 289);
this.panel2.Margin = new System.Windows.Forms.Padding(0);
this.panel2.Name = ""panel2"";
this.panel2.Size = new System.Drawing.Size(397, 75);
this.panel2.TabIndex = 15;
// // _txtKeyId
// this._txtKeyId.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtKeyId.Enabled = false;
this._txtKeyId.Font = new System.Drawing.Font(""Consolas"", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(204)));
this._txtKeyId.Location = new System.Drawing.Point(142, 44);
this._txtKeyId.Name = ""_txtKeyId"";
this._txtKeyId.Size = new System.Drawing.Size(255, 23);
this._txtKeyId.TabIndex = 8;
// // _grpSigning
// this._grpSigning.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpSigning.Location = new System.Drawing.Point(0, 0);
this._grpSigning.Name = ""_grpSigning"";
this._grpSigning.Size = new System.Drawing.Size(397, 19);
this._grpSigning.TabIndex = 0;
this._grpSigning.Text = ""%Signing%"";
// // _radUseKeyId
// this._radUseKeyId.AutoSize = true;
this._radUseKeyId.Enabled = false;
this._radUseKeyId.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radUseKeyId.Location = new System.Drawing.Point(15, 45);
this._radUseKeyId.Name = ""_radUseKeyId"";
this._radUseKeyId.Size = new System.Drawing.Size(109, 20);
this._radUseKeyId.TabIndex = 7;
this._radUseKeyId.Text = ""%Use key-id%:"";
this._radUseKeyId.UseVisualStyleBackColor = true;
this._radUseKeyId.CheckedChanged += new System.EventHandler(this._radUseKeyId_CheckedChanged);
// // _radUseDefaultEmailKey
// this._radUseDefaultEmailKey.AutoSize = true;
this._radUseDefaultEmailKey.Checked = true;
this._radUseDefaultEmailKey.Enabled = false;
this._radUseDefaultEmailKey.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radUseDefaultEmailKey.Location = new System.Drawing.Point(15, 25);
this._radUseDefaultEmailKey.Name = ""_radUseDefaultEmailKey"";
this._radUseDefaultEmailKey.Size = new System.Drawing.Size(213, 20);
this._radUseDefaultEmailKey.TabIndex = 6;
this._radUseDefaultEmailKey.TabStop = true;
this._radUseDefaultEmailKey.Text = ""%Use default EMail adresse\'s key%"";
this._radUseDefaultEmailKey.UseVisualStyleBackColor = true;
// // panel1
// this.panel1.Controls.Add(this._grpMessage);
this.panel1.Controls.Add(this._txtMessage);
this.panel1.Location = new System.Drawing.Point(0, 109);
this.panel1.Margin = new System.Windows.Forms.Padding(0);
this.panel1.Name = ""panel1"";
this.panel1.Size = new System.Drawing.Size(397, 180);
this.panel1.TabIndex = 14;
// // _grpMessage
// this._grpMessage.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpMessage.Location = new System.Drawing.Point(0, 0);
this._grpMessage.Name = ""_grpMessage"";
this._grpMessage.Size = new System.Drawing.Size(397, 19);
this._grpMessage.TabIndex = 0;
this._grpMessage.Text = ""%Message%"";
// // _txtMessage
// this._txtMessage.AcceptsReturn = true;
this._txtMessage.AcceptsTab = true;
this._txtMessage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtMessage.Enabled = false;
this._txtMessage.Font = new System.Drawing.Font(""Consolas"", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(204)));
this._txtMessage.Location = new System.Drawing.Point(15, 25);
this._txtMessage.Multiline = true;
this._txtMessage.Name = ""_txtMessage"";
this._txtMessage.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
this._txtMessage.Size = new System.Drawing.Size(382, 152);
this._txtMessage.TabIndex = 5;
this._txtMessage.WordWrap = false;
// // _pnlOptions
// this._pnlOptions.Controls.Add(this._radSigned);
this._pnlOptions.Controls.Add(this._grpOptions);
this._pnlOptions.Controls.Add(this._radSimple);
this._pnlOptions.Controls.Add(this._radAnnotated);
this._pnlOptions.Location = new System.Drawing.Point(0, 61);
this._pnlOptions.Margin = new System.Windows.Forms.Padding(0);
this._pnlOptions.Name = ""_pnlOptions"";
this._pnlOptions.Size = new System.Drawing.Size(397, 48);
this._pnlOptions.TabIndex = 11;
// // _radSigned
// this._radSigned.AutoSize = true;
this._radSigned.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radSigned.Location = new System.Drawing.Point(236, 25);
this._radSigned.Name = ""_radSigned"";
this._radSigned.Size = new System.Drawing.Size(87, 20);
this._radSigned.TabIndex = 4;
this._radSigned.Text = ""%Signed%"";
this._radSigned.UseVisualStyleBackColor = true;
this._radSigned.CheckedChanged += new System.EventHandler(this._radSigned_CheckedChanged);
// // _grpOptions
// this._grpOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpOptions.Location = new System.Drawing.Point(0, 0);
this._grpOptions.Name = ""_grpOptions"";
this._grpOptions.Size = new System.Drawing.Size(397, 19);
this._grpOptions.TabIndex = 0;
this._grpOptions.Text = ""%Type%"";
// // _radSimple
// this._radSimple.AutoSize = true;
this._radSimple.Checked = true;
this._radSimple.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radSimple.Location = new System.Drawing.Point(15, 25);
this._radSimple.Name = ""_radSimple"";
this._radSimple.Size = new System.Drawing.Size(114, 20);
this._radSimple.TabIndex = 2;
this._radSimple.TabStop = true;
this._radSimple.Text = ""%Lightweight%"";
this._radSimple.UseVisualStyleBackColor = true;
this._radSimple.CheckedChanged += new System.EventHandler(this._radSimple_CheckedChanged);
// // _radAnnotated
// this._radAnnotated.AutoSize = true;
this._radAnnotated.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radAnnotated.Location = new System.Drawing.Point(129, 25);
this._radAnnotated.Name = ""_radAnnotated"";
this._radAnnotated.Size = new System.Drawing.Size(107, 20);
this._radAnnotated.TabIndex = 3;
this._radAnnotated.Text = ""%Annotated%"";
this._radAnnotated.UseVisualStyleBackColor = true;
this._radAnnotated.CheckedChanged += new System.EventHandler(this._radAnnotated_CheckedChanged);
// // _lblRevision
// this._lblRevision.AutoSize = true;
this._lblRevision.Location = new System.Drawing.Point(0, 35);
this._lblRevision.Name = ""_lblRevision"";
this._lblRevision.Size = new System.Drawing.Size(74, 15);
this._lblRevision.TabIndex = 8;
this._lblRevision.Text = ""%Revision%:"";
// // _txtName
// this._txtName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtName.Location = new System.Drawing.Point(94, 3);
this._txtName.Name = ""_txtName"";
this._txtName.Size = new System.Drawing.Size(303, 23);
this._txtName.TabIndex = 0;
// // _lblName
// this._lblName.AutoSize = true;
this._lblName.Location = new System.Drawing.Point(0, 6);
this._lblName.Name = ""_lblName"";
this._lblName.Size = new System.Drawing.Size(62, 15);
this._lblName.TabIndex = 5;
this._lblName.Text = ""%Name%:"";
// // _txtRevision
// this._txtRevision.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtRevision.FormattingEnabled = true;
this._txtRevision.Location = new System.Drawing.Point(94, 32);
this._txtRevision.Name = ""_txtRevision"";
this._txtRevision.Size = new System.Drawing.Size(303, 23);
this._txtRevision.TabIndex = 1;
// // CreateTagDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this.panel2);
this.Controls.Add(this.panel1);
this.Controls.Add(this._txtRevision);
this.Controls.Add(this._pnlOptions);
this.Controls.Add(this._lblRevision);
this.Controls.Add(this._txtName);
this.Controls.Add(this._lblName);
this.Name = ""CreateTagDialog"";
this.Size = new System.Drawing.Size(400, 364);
this.panel2.ResumeLayout(false);
this.panel2.PerformLayout();
this.panel1.ResumeLayout(false);
this.panel1.PerformLayout();
this._pnlOptions.ResumeLayout(false);
this._pnlOptions.PerformLayout();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2689,"protected override void OnListBoxAttached()
{
base.OnListBoxAttached();
ListBox.StyleChanged += OnListBoxStyleChanged;
if(ListBox.Style != GitterApplication.Style)
{
OnStyleChanged();
}
}",Called when item is attached to listbox.,1
2690,"protected override void OnListBoxDetached()
{
ListBox.StyleChanged -= OnListBoxStyleChanged;
_contentWidth = -1;
base.OnListBoxDetached();
}",Called when item is detached from listbox.,1
2691,"public void Activate()
{
OnActivate();
if(IsAttachedToListBox) ListBox.NotifyItemActivated(this);
}",Invokes item activation events.,1
2692,"public void Expand()
{
if(!_expanded)
{
_expanded = true;
if(IsAttachedToListBox && IsPresented && _items.Count != 0)
{
ListBox.ExpandItem(this);
}
}
}",Expands this item.,1
2693,"public void ExpandAll()
{
if(_items.Count == 0) return;
bool p = IsPresented;
bool hasListBox = IsAttachedToListBox;
if(hasListBox && p)
{
ListBox.BeginUpdate();
}
_expand_all(this);
if(hasListBox && p)
{
ListBox.EndUpdate();
}
}",Expands whole tree of items starting at this item.,1
2694,"public void Collapse()
{
if(_expanded)
{
_expanded = false;
if(IsAttachedToListBox && IsPresented && _items.Count != 0)
{
ListBox.CollapseItem(this);
}
}
}",Collapses this item.,1
2695,"public void CollapseAll()
{
if(_items.Count == 0) return;
bool p = IsPresented;
bool hasListBox = IsAttachedToListBox;
if(hasListBox && p)
{
ListBox.BeginUpdate();
}
_collapse_all(this);
if(hasListBox && p)
{
ListBox.EndUpdate();
}
}",Collapses whole tree of items starting at this item.,1
2696,"public void FocusAndSelect()
{
Verify.State.IsTrue(IsAttachedToListBox);
ListBox.FocusAndSelectItem(this);
}",Sets focus and selects this item.,1
2697,"public void Focus()
{
Verify.State.IsTrue(IsAttachedToListBox);
ListBox.FocusItem(this);
}",Sets focus to this item.,1
2698,"public void Present()
{
if(_parent == null) return;
_parent.IsExpanded = true;
_parent.Present();
}",Makes sure that item can be found in listbox.,1
2699,"public void Remove()
{
if(_parent == null)
{
var ctl = ListBox;
if(ctl != null)
{
ctl.Items.Remove(this);
}
}
else
{
_parent.Items.Remove(this);
}
}",Removes item from listbox.,1
2700,"public void RemoveSafe()
{
if(_parent == null)
{
var ctl = ListBox;
if(ctl != null)
{
ctl.Items.RemoveSafe(this);
}
}
else
{
_parent.Items.RemoveSafe(this);
}
}",Removes item from listbox thread-safe.,1
2701,"public void Invalidate()
{
if(IsAttachedToListBox && IsPresented)
{
ListBox.InvalidateItem(this);
}
}",Repaints item.,1
2702,"public void InvalidateSafe()
{
var listBox = ListBox;
if(listBox != null)
{
if(listBox.InvokeRequired)
{
Action<CustomListBoxItem> action = listBox.InvalidateItem;
listBox.BeginInvoke(action, new object[] { this });
}
else
{
listBox.InvalidateItem(this);
}
}
}",Repaints item in a thread-safe way.,1
2703,"public void InvalidateSubItem(int id)
{
if(IsAttachedToListBox && IsPresented)
{
ListBox.InvalidateSubItem(this, id);
}
}",Repaints subitem.,1
2704,"public void InvalidateSubItemSafe(int id)
{
var listBox = ListBox;
if(listBox != null && IsPresented)
{
if(listBox.InvokeRequired)
{
Action<CustomListBoxItem, int> action = listBox.InvalidateSubItem;
listBox.BeginInvoke(action, this, id);
}
else
{
listBox.InvalidateSubItem(this, id);
}
}
}",Repaints subitem in a thread-safe way.,1
2705,"private void Reinsert()
{
var items = ParentItems;
if(items != null)
{
items.Remove(this);
items.Add(this);
}
}",Reinserts this item.,1
2706,"protected virtual void OnCheckedStateChanged()
{
CheckedStateChanged.Raise(this);
var lb = ListBox;
if(lb != null)
{
lb.NotifyItemCheckedChanged(this);
}
}",Called when M:CheckedState property value changes.,1
2707,"protected override void OnListBoxAttached()
{
base.OnListBoxAttached();
_items.ListBox = ListBox;
}",Called when item is attached to listbox.,1
2708,"protected override void OnListBoxDetached()
{
_items.ListBox = null;
base.OnListBoxDetached();
}",Called when item is detached from listbox.,1
2709,"protected override void OnListBoxAttached()
{
base.OnListBoxAttached();
_extender = new DateColumnExtender(this);
Extender = new Popup(_extender);
}",Called when item is attached to listbox.,1
2710,"protected override void OnListBoxDetached()
{
Extender.Dispose();
Extender = null;
_extender.Dispose();
_extender = null;
base.OnListBoxDetached();
}",Called when item is detached from listbox.,1
2711,"private void InitializeComponent()
{
this._radUnixTimestamp = new System.Windows.Forms.RadioButton();
this._radRelative = new System.Windows.Forms.RadioButton();
this._radSystemDefault = new System.Windows.Forms.RadioButton();
this._radISO8601 = new System.Windows.Forms.RadioButton();
this._radRFC2822 = new System.Windows.Forms.RadioButton();
this._lblUnixTimestamp = new System.Windows.Forms.Label();
this._lblRelative = new System.Windows.Forms.Label();
this._lblSystemDefault = new System.Windows.Forms.Label();
this._lblISO8601 = new System.Windows.Forms.Label();
this._lblRFC2822 = new System.Windows.Forms.Label();
this._lblDateFormat = new System.Windows.Forms.Label();
this._lblExample = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _radUnixTimestamp
// this._radUnixTimestamp.AutoSize = true;
this._radUnixTimestamp.Location = new System.Drawing.Point(6, 22);
this._radUnixTimestamp.Name = ""_radUnixTimestamp"";
this._radUnixTimestamp.Size = new System.Drawing.Size(94, 19);
this._radUnixTimestamp.TabIndex = 0;
this._radUnixTimestamp.TabStop = true;
this._radUnixTimestamp.Text = ""radioButton1"";
this._radUnixTimestamp.UseVisualStyleBackColor = true;
this._radUnixTimestamp.CheckedChanged += new System.EventHandler(this.OnCheckedChanged);
// // _radRelative
// this._radRelative.AutoSize = true;
this._radRelative.Location = new System.Drawing.Point(6, 42);
this._radRelative.Name = ""_radRelative"";
this._radRelative.Size = new System.Drawing.Size(94, 19);
this._radRelative.TabIndex = 1;
this._radRelative.TabStop = true;
this._radRelative.Text = ""radioButton2"";
this._radRelative.UseVisualStyleBackColor = true;
this._radRelative.CheckedChanged += new System.EventHandler(this.OnCheckedChanged);
// // _radSystemDefault
// this._radSystemDefault.AutoSize = true;
this._radSystemDefault.Checked = true;
this._radSystemDefault.Location = new System.Drawing.Point(6, 62);
this._radSystemDefault.Name = ""_radSystemDefault"";
this._radSystemDefault.Size = new System.Drawing.Size(94, 19);
this._radSystemDefault.TabIndex = 2;
this._radSystemDefault.TabStop = true;
this._radSystemDefault.Text = ""radioButton3"";
this._radSystemDefault.UseVisualStyleBackColor = true;
this._radSystemDefault.CheckedChanged += new System.EventHandler(this.OnCheckedChanged);
// // _radISO8601
// this._radISO8601.AutoSize = true;
this._radISO8601.Location = new System.Drawing.Point(6, 82);
this._radISO8601.Name = ""_radISO8601"";
this._radISO8601.Size = new System.Drawing.Size(94, 19);
this._radISO8601.TabIndex = 3;
this._radISO8601.TabStop = true;
this._radISO8601.Text = ""radioButton4"";
this._radISO8601.UseVisualStyleBackColor = true;
this._radISO8601.CheckedChanged += new System.EventHandler(this.OnCheckedChanged);
// // _radRFC2822
// this._radRFC2822.AutoSize = true;
this._radRFC2822.Location = new System.Drawing.Point(6, 102);
this._radRFC2822.Name = ""_radRFC2822"";
this._radRFC2822.Size = new System.Drawing.Size(94, 19);
this._radRFC2822.TabIndex = 4;
this._radRFC2822.TabStop = true;
this._radRFC2822.Text = ""radioButton5"";
this._radRFC2822.UseVisualStyleBackColor = true;
this._radRFC2822.CheckedChanged += new System.EventHandler(this.OnCheckedChanged);
// // _lblUnixTimestamp
// this._lblUnixTimestamp.AutoSize = true;
this._lblUnixTimestamp.Location = new System.Drawing.Point(137, 24);
this._lblUnixTimestamp.Name = ""_lblUnixTimestamp"";
this._lblUnixTimestamp.Size = new System.Drawing.Size(38, 15);
this._lblUnixTimestamp.TabIndex = 5;
this._lblUnixTimestamp.Text = ""label1"";
// // _lblRelative
// this._lblRelative.AutoSize = true;
this._lblRelative.Location = new System.Drawing.Point(137, 44);
this._lblRelative.Name = ""_lblRelative"";
this._lblRelative.Size = new System.Drawing.Size(38, 15);
this._lblRelative.TabIndex = 6;
this._lblRelative.Text = ""label2"";
// // _lblSystemDefault
// this._lblSystemDefault.AutoSize = true;
this._lblSystemDefault.Location = new System.Drawing.Point(137, 64);
this._lblSystemDefault.Name = ""_lblSystemDefault"";
this._lblSystemDefault.Size = new System.Drawing.Size(38, 15);
this._lblSystemDefault.TabIndex = 7;
this._lblSystemDefault.Text = ""label3"";
// // _lblISO8601
// this._lblISO8601.AutoSize = true;
this._lblISO8601.Location = new System.Drawing.Point(137, 84);
this._lblISO8601.Name = ""_lblISO8601"";
this._lblISO8601.Size = new System.Drawing.Size(38, 15);
this._lblISO8601.TabIndex = 8;
this._lblISO8601.Text = ""label4"";
// // _lblRFC2822
// this._lblRFC2822.AutoSize = true;
this._lblRFC2822.Location = new System.Drawing.Point(137, 104);
this._lblRFC2822.Name = ""_lblRFC2822"";
this._lblRFC2822.Size = new System.Drawing.Size(38, 15);
this._lblRFC2822.TabIndex = 9;
this._lblRFC2822.Text = ""label5"";
// // _lblDateFormat
// this._lblDateFormat.AutoSize = true;
this._lblDateFormat.Location = new System.Drawing.Point(3, 4);
this._lblDateFormat.Name = ""_lblDateFormat"";
this._lblDateFormat.Size = new System.Drawing.Size(95, 15);
this._lblDateFormat.TabIndex = 10;
this._lblDateFormat.Text = ""%Date Format%:"";
// // _lblExample
// this._lblExample.AutoSize = true;
this._lblExample.Location = new System.Drawing.Point(137, 4);
this._lblExample.Name = ""_lblExample"";
this._lblExample.Size = new System.Drawing.Size(74, 15);
this._lblExample.TabIndex = 11;
this._lblExample.Text = ""%Example%:"";
// // DateColumnExtender
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblExample);
this.Controls.Add(this._lblDateFormat);
this.Controls.Add(this._lblRFC2822);
this.Controls.Add(this._lblISO8601);
this.Controls.Add(this._lblSystemDefault);
this.Controls.Add(this._lblRelative);
this.Controls.Add(this._lblUnixTimestamp);
this.Controls.Add(this._radRFC2822);
this.Controls.Add(this._radISO8601);
this.Controls.Add(this._radSystemDefault);
this.Controls.Add(this._radRelative);
this.Controls.Add(this._radUnixTimestamp);
this.Name = ""DateColumnExtender"";
this.Size = new System.Drawing.Size(327, 127);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2712,"private void InitializeComponent()
{
this._pnlContainer = new System.Windows.Forms.Panel();
this._pnlLine = new System.Windows.Forms.Panel();
this._btnCancel = new System.Windows.Forms.Button();
this._btnOK = new System.Windows.Forms.Button();
this._picAdvanced = new System.Windows.Forms.PictureBox();
this._btnApply = new System.Windows.Forms.Button();
this._pnlContainer.SuspendLayout();
((System.ComponentModel.ISupportInitialize)(this._picAdvanced)).BeginInit();
this.SuspendLayout();
// // _pnlContainer
// this._pnlContainer.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._pnlContainer.BackColor = System.Drawing.SystemColors.Window;
this._pnlContainer.Controls.Add(this._pnlLine);
this._pnlContainer.Location = new System.Drawing.Point(0, 0);
this._pnlContainer.Name = ""_pnlContainer"";
this._pnlContainer.Size = new System.Drawing.Size(423, 137);
this._pnlContainer.TabIndex = 0;
// // _pnlLine
// this._pnlLine.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._pnlLine.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(223)))), ((int)(((byte)(223)))), ((int)(((byte)(223)))));
this._pnlLine.Location = new System.Drawing.Point(0, 136);
this._pnlLine.Name = ""_pnlLine"";
this._pnlLine.Size = new System.Drawing.Size(423, 1);
this._pnlLine.TabIndex = 1;
// // _btnCancel
// this._btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
this._btnCancel.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnCancel.Location = new System.Drawing.Point(260, 145);
this._btnCancel.Name = ""_btnCancel"";
this._btnCancel.Size = new System.Drawing.Size(75, 23);
this._btnCancel.TabIndex = 2;
this._btnCancel.Text = global::gitter.Framework.Properties.Resources.StrCancel;
this._btnCancel.UseVisualStyleBackColor = true;
this._btnCancel.Click += new System.EventHandler(this._btnCancel_Click);
// // _btnOK
// this._btnOK.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._btnOK.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnOK.Location = new System.Drawing.Point(179, 145);
this._btnOK.Name = ""_btnOK"";
this._btnOK.Size = new System.Drawing.Size(75, 23);
this._btnOK.TabIndex = 2;
this._btnOK.Text = global::gitter.Framework.Properties.Resources.StrOk;
this._btnOK.UseVisualStyleBackColor = true;
this._btnOK.Click += new System.EventHandler(this._btnOK_Click);
// // _picAdvanced
// this._picAdvanced.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this._picAdvanced.Cursor = System.Windows.Forms.Cursors.Hand;
this._picAdvanced.Location = new System.Drawing.Point(7, 146);
this._picAdvanced.Name = ""_picAdvanced"";
this._picAdvanced.Size = new System.Drawing.Size(150, 21);
this._picAdvanced.TabIndex = 3;
this._picAdvanced.TabStop = false;
this._picAdvanced.Visible = false;
this._picAdvanced.Click += new System.EventHandler(this._picAdvanced_Click);
this._picAdvanced.MouseEnter += new System.EventHandler(this._picAdvanced_MouseEnter);
this._picAdvanced.MouseLeave += new System.EventHandler(this._picAdvanced_MouseLeave);
// // _btnApply
// this._btnApply.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._btnApply.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnApply.Location = new System.Drawing.Point(341, 145);
this._btnApply.Name = ""_btnApply"";
this._btnApply.Size = new System.Drawing.Size(75, 23);
this._btnApply.TabIndex = 4;
this._btnApply.Text = global::gitter.Framework.Properties.Resources.StrApply;
this._btnApply.UseVisualStyleBackColor = true;
this._btnApply.Click += new System.EventHandler(this._btnApply_Click);
// // DialogForm
// this.AcceptButton = this._btnOK;
this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.CancelButton = this._btnCancel;
this.ClientSize = new System.Drawing.Size(423, 176);
this.Controls.Add(this._btnApply);
this.Controls.Add(this._picAdvanced);
this.Controls.Add(this._btnOK);
this.Controls.Add(this._btnCancel);
this.Controls.Add(this._pnlContainer);
this.Font = gitter.Framework.GitterApplication.FontManager.UIFont;
this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
this.MaximizeBox = false;
this.MinimizeBox = false;
this.Name = ""DialogForm"";
this.ShowIcon = false;
this.ShowInTaskbar = false;
this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
this.Text = ""DialogForm"";
this._pnlContainer.ResumeLayout(false);
((System.ComponentModel.ISupportInitialize)(this._picAdvanced)).EndInit();
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2713,"public static ICommandArgument ZeroLineTermination()
{
return new CommandFlag(""-z"");
}",\0 line termination on output.,1
2714,"public void Dispose()
{
if(!IsDisposed)
{
GC.SuppressFinalize(this);
Dispose(true);
IsDisposed = true;
}
}",Releases unmanaged and - optionally - managed resources.,1
2715,"private void InitializeComponent()
{
this._diffViewer = new gitter.Git.Gui.Controls.DiffViewer();
this.SuspendLayout();
// // _diffViewer
// this._diffViewer.Dock = System.Windows.Forms.DockStyle.Fill;
this._diffViewer.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._diffViewer.Location = new System.Drawing.Point(0, 0);
this._diffViewer.Name = ""_diffViewer"";
this._diffViewer.Size = new System.Drawing.Size(555, 362);
this._diffViewer.TabIndex = 0;
this._diffViewer.Text = ""diffViewer1"";
// // DiffView
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._diffViewer);
this.Name = ""DiffView"";
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2716,"public new void Show()
{
User32.ShowWindow(this.Handle, 8);
}",Displays the control to the user.,1
2717,"public void Unhover()
{
if(MarkersVisible)
{
for(int i = 0; i < _markers.Length; ++i)
{
_markers[i].Unhover();
}
}
}",Notifies that mouse no longer hovers any docking markers associated with this instance.,1
2718,"public void Hide()
{
if(MarkersVisible)
{
for(int i = 0; i < _markers.Length; ++i)
{
_markers[i].Dispose();
}
_markers = null;
}
}",Hides and disposes all dock markers.,1
2719,"public void Dispose()
{
Hide();
}","Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.",1
2720,"private void InitializeComponent()
{
this._lblExceptionName = new System.Windows.Forms.Label();
this._lblMessage = new System.Windows.Forms.Label();
this._txtStack = new System.Windows.Forms.TextBox();
this._lblSTack = new System.Windows.Forms.Label();
this._lnkCopyToClipboard = new System.Windows.Forms.LinkLabel();
this._lnkSendBugReport = new System.Windows.Forms.LinkLabel();
this.SuspendLayout();
// // _lblExceptionName
// this._lblExceptionName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._lblExceptionName.Location = new System.Drawing.Point(0, 0);
this._lblExceptionName.Name = ""_lblExceptionName"";
this._lblExceptionName.Size = new System.Drawing.Size(490, 32);
this._lblExceptionName.TabIndex = 0;
this._lblExceptionName.Text = ""%EXCEPTION_NAME%"";
this._lblExceptionName.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
// // _lblMessage
// this._lblMessage.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._lblMessage.Location = new System.Drawing.Point(0, 32);
this._lblMessage.Name = ""_lblMessage"";
this._lblMessage.Size = new System.Drawing.Size(490, 65);
this._lblMessage.TabIndex = 1;
this._lblMessage.Text = ""%Message%"";
// // _txtStack
// this._txtStack.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtStack.BackColor = System.Drawing.SystemColors.Window;
this._txtStack.Location = new System.Drawing.Point(0, 115);
this._txtStack.Multiline = true;
this._txtStack.Name = ""_txtStack"";
this._txtStack.ReadOnly = true;
this._txtStack.ScrollBars = System.Windows.Forms.ScrollBars.Both;
this._txtStack.Size = new System.Drawing.Size(490, 268);
this._txtStack.TabIndex = 2;
this._txtStack.WordWrap = false;
// // _lblSTack
// this._lblSTack.AutoSize = true;
this._lblSTack.Location = new System.Drawing.Point(0, 97);
this._lblSTack.Name = ""_lblSTack"";
this._lblSTack.Size = new System.Drawing.Size(58, 15);
this._lblSTack.TabIndex = 3;
this._lblSTack.Text = ""%Stack%:"";
// // _lnkCopyToClipboard
// this._lnkCopyToClipboard.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._lnkCopyToClipboard.AutoSize = true;
this._lnkCopyToClipboard.Location = new System.Drawing.Point(249, 386);
this._lnkCopyToClipboard.Name = ""_lnkCopyToClipboard"";
this._lnkCopyToClipboard.Size = new System.Drawing.Size(122, 15);
this._lnkCopyToClipboard.TabIndex = 4;
this._lnkCopyToClipboard.TabStop = true;
this._lnkCopyToClipboard.Text = ""%Copy to clipboard%"";
this._lnkCopyToClipboard.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.OnCopyToClipboardLinkClicked);
// // _lnkSendBugReport
// this._lnkSendBugReport.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._lnkSendBugReport.AutoSize = true;
this._lnkSendBugReport.Location = new System.Drawing.Point(378, 386);
this._lnkSendBugReport.Name = ""_lnkSendBugReport"";
this._lnkSendBugReport.Size = new System.Drawing.Size(109, 15);
this._lnkSendBugReport.TabIndex = 5;
this._lnkSendBugReport.TabStop = true;
this._lnkSendBugReport.Text = ""%Send bugreport%"";
this._lnkSendBugReport.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.OnSendBugReportLinkClicked);
// // ExceptionDialog
// this.Controls.Add(this._lnkSendBugReport);
this.Controls.Add(this._lnkCopyToClipboard);
this.Controls.Add(this._lblSTack);
this.Controls.Add(this._txtStack);
this.Controls.Add(this._lblMessage);
this.Controls.Add(this._lblExceptionName);
this.Name = ""ExceptionDialog"";
this.Size = new System.Drawing.Size(490, 401);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2721,"public static ICommandArgument UpdateHeadOk()
{
return new CommandFlag(""--update-head-ok"");
}","By default git-fetch refuses to update the head which corresponds to the current branch. This flag disables the check. This is purely for the internal use for git-pull to communicate with git-fetch, and unless you are implementing your own Porcelain you are not supposed to use it.",1
2722,"private void InitializeComponent()
{
this._lblFonts = new System.Windows.Forms.Label();
this._lstFonts = new gitter.Framework.Options.FontsListBox();
this._lblName = new System.Windows.Forms.Label();
this._lblSize = new System.Windows.Forms.Label();
this._lblStyle = new System.Windows.Forms.Label();
this._lblSample = new System.Windows.Forms.Label();
this._cmbFonts = new System.Windows.Forms.ComboBox();
this._numSize = new System.Windows.Forms.NumericUpDown();
this._cmbStyle = new System.Windows.Forms.ComboBox();
this._pnlSelectedFont = new System.Windows.Forms.Panel();
((System.ComponentModel.ISupportInitialize)(this._numSize)).BeginInit();
this._pnlSelectedFont.SuspendLayout();
this.SuspendLayout();
// // _lblFonts
// this._lblFonts.AutoSize = true;
this._lblFonts.Location = new System.Drawing.Point(-3, 0);
this._lblFonts.Name = ""_lblFonts"";
this._lblFonts.Size = new System.Drawing.Size(59, 15);
this._lblFonts.TabIndex = 0;
this._lblFonts.Text = ""%Fonts%:"";
// // _lstFonts
// this._lstFonts.AllowColumnReorder = false;
this._lstFonts.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstFonts.ForeColor = System.Drawing.SystemColors.WindowText;
this._lstFonts.ItemActivation = gitter.Framework.Controls.ItemActivation.SingleClick;
this._lstFonts.Location = new System.Drawing.Point(0, 18);
this._lstFonts.Name = ""_lstFonts"";
this._lstFonts.Size = new System.Drawing.Size(448, 245);
this._lstFonts.TabIndex = 1;
// // _lblName
// this._lblName.AutoSize = true;
this._lblName.Location = new System.Drawing.Point(-3, 3);
this._lblName.Name = ""_lblName"";
this._lblName.Size = new System.Drawing.Size(62, 15);
this._lblName.TabIndex = 2;
this._lblName.Text = ""%Name%:"";
// // _lblSize
// this._lblSize.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._lblSize.AutoSize = true;
this._lblSize.Location = new System.Drawing.Point(305, 3);
this._lblSize.Name = ""_lblSize"";
this._lblSize.Size = new System.Drawing.Size(50, 15);
this._lblSize.TabIndex = 3;
this._lblSize.Text = ""%Size%:"";
// // _lblStyle
// this._lblStyle.AutoSize = true;
this._lblStyle.Location = new System.Drawing.Point(-3, 30);
this._lblStyle.Name = ""_lblStyle"";
this._lblStyle.Size = new System.Drawing.Size(55, 15);
this._lblStyle.TabIndex = 4;
this._lblStyle.Text = ""%Style%:"";
// // _lblSample
// this._lblSample.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lblSample.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
this._lblSample.Location = new System.Drawing.Point(0, 56);
this._lblSample.Name = ""_lblSample"";
this._lblSample.Size = new System.Drawing.Size(448, 50);
this._lblSample.TabIndex = 5;
this._lblSample.Text = ""%Sample%"";
this._lblSample.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
// // _cmbFonts
// this._cmbFonts.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._cmbFonts.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this._cmbFonts.FormattingEnabled = true;
this._cmbFonts.Location = new System.Drawing.Point(82, 0);
this._cmbFonts.Name = ""_cmbFonts"";
this._cmbFonts.Size = new System.Drawing.Size(217, 23);
this._cmbFonts.TabIndex = 6;
this._cmbFonts.SelectedIndexChanged += new System.EventHandler(this.OnFontFamilySelected);
// // _numSize
// this._numSize.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._numSize.Location = new System.Drawing.Point(361, 0);
this._numSize.Name = ""_numSize"";
this._numSize.Size = new System.Drawing.Size(87, 23);
this._numSize.TabIndex = 7;
this._numSize.Value = new decimal(new int[] {
9,
0,
0,
0});
this._numSize.ValueChanged += new System.EventHandler(this.OnFontSizeChanged);
// // _cmbStyle
// this._cmbStyle.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._cmbStyle.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this._cmbStyle.FormattingEnabled = true;
this._cmbStyle.Location = new System.Drawing.Point(82, 27);
this._cmbStyle.Name = ""_cmbStyle"";
this._cmbStyle.Size = new System.Drawing.Size(217, 23);
this._cmbStyle.TabIndex = 6;
this._cmbStyle.SelectedIndexChanged += new System.EventHandler(this.OnFontStyleChanged);
// // _pnlSelectedFont
// this._pnlSelectedFont.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlSelectedFont.Controls.Add(this._lblName);
this._pnlSelectedFont.Controls.Add(this._numSize);
this._pnlSelectedFont.Controls.Add(this._lblSize);
this._pnlSelectedFont.Controls.Add(this._cmbStyle);
this._pnlSelectedFont.Controls.Add(this._lblStyle);
this._pnlSelectedFont.Controls.Add(this._cmbFonts);
this._pnlSelectedFont.Controls.Add(this._lblSample);
this._pnlSelectedFont.Enabled = false;
this._pnlSelectedFont.Location = new System.Drawing.Point(0, 269);
this._pnlSelectedFont.Name = ""_pnlSelectedFont"";
this._pnlSelectedFont.Size = new System.Drawing.Size(448, 106);
this._pnlSelectedFont.TabIndex = 8;
// // FontsPage
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._pnlSelectedFont);
this.Controls.Add(this._lstFonts);
this.Controls.Add(this._lblFonts);
this.Name = ""FontsPage"";
this.Size = new System.Drawing.Size(448, 375);
((System.ComponentModel.ISupportInitialize)(this._numSize)).EndInit();
this._pnlSelectedFont.ResumeLayout(false);
this._pnlSelectedFont.PerformLayout();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2723,"public void InvalidateGitVersion()
{
_gitVersion = null;
}",Forces re-check of git version.,1
2724,"public static readonly DateTime UnixEraStart = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);",1 Jan 1970,0
2725,"protected virtual void OnDeleted()
{
}",Called after marking as deleted.,1
2726,"protected virtual void OnRevived()
{
}",Called after reviving.,1
2727,"internal void Revive()
{
if(IsDeleted)
{
IsDeleted = false;
OnRevived();
Revived?.Invoke(this, EventArgs.Empty);
}
}",Makes object alive again.,1
2728,"private void InitializeComponent()
{
this._grpRepositoryAccessor = new gitter.Framework.Controls.GroupSeparator();
this._cmbAccessorProvider = new System.Windows.Forms.ComboBox();
this._lblAccessmethod = new System.Windows.Forms.Label();
this._openFileDialog = new System.Windows.Forms.OpenFileDialog();
this.SuspendLayout();
// // _grpRepositoryAccessor
// this._grpRepositoryAccessor.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpRepositoryAccessor.Location = new System.Drawing.Point(0, 0);
this._grpRepositoryAccessor.Name = ""_grpRepositoryAccessor"";
this._grpRepositoryAccessor.Size = new System.Drawing.Size(476, 19);
this._grpRepositoryAccessor.TabIndex = 0;
this._grpRepositoryAccessor.Text = ""%Repository access method%"";
// // _cmbAccessorProvider
// this._cmbAccessorProvider.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._cmbAccessorProvider.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this._cmbAccessorProvider.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._cmbAccessorProvider.FormattingEnabled = true;
this._cmbAccessorProvider.Location = new System.Drawing.Point(117, 25);
this._cmbAccessorProvider.Name = ""_cmbAccessorProvider"";
this._cmbAccessorProvider.Size = new System.Drawing.Size(359, 23);
this._cmbAccessorProvider.TabIndex = 4;
// // _lblAccessmethod
// this._lblAccessmethod.AutoSize = true;
this._lblAccessmethod.Location = new System.Drawing.Point(0, 28);
this._lblAccessmethod.Name = ""_lblAccessmethod"";
this._lblAccessmethod.Size = new System.Drawing.Size(111, 15);
this._lblAccessmethod.TabIndex = 8;
this._lblAccessmethod.Text = ""%Access Method%:"";
// // GitOptionsPage
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblAccessmethod);
this.Controls.Add(this._cmbAccessorProvider);
this.Controls.Add(this._grpRepositoryAccessor);
this.Name = ""GitOptionsPage"";
this.Size = new System.Drawing.Size(479, 218);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2729,"public void Update()
{
var command = FormatUpdaterCommand();
HelperExecutables.LaunchUpdater(command);
}",Update gitter using this channel.,1
2730,"private void InitializeComponent()
{
this.SuspendLayout();
// // GitView
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Name = ""GitView"";
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2731,"public struct GraphAtom
{
public GraphElement Elements;
public int[] ElementColors;
public void Paint(GraphElement element, int color)
{
Elements |= element;
if(element != GraphElement.Space)
{
if(ElementColors == null) ElementColors = new int[13];
int pos = (int)element;
int offset = 0;
while(pos != 0)
{
if((pos & 1) != 0) ElementColors[offset] = color;
pos >>= 1;
++offset;
}
}
}
public bool IsEmpty => Elements == GraphElement.Space;
public bool HasElement(GraphElement element)
{
return (Elements & element) == element;
}
public void Paint(int elementid, int color)
{
Elements |= (GraphElement)(1<<elementid);
if(elementid != 0)
{
if(ElementColors == null) ElementColors = new int[12];
ElementColors[elementid] = color;
}
}
public void Erase(GraphElement element)
{
Elements &= ~element;
if(Elements == GraphElement.Space)
ElementColors = null;
}
public void Erase()
{
Elements = GraphElement.Space;
ElementColors = null;
}
}",Graph consists of list of arrays of atoms.,1
2732,"protected override void OnListBoxAttached()
{
base.OnListBoxAttached();
_extender = new GraphColumnExtender(this);
Extender = new Popup(_extender);
}",Called when item is attached to listbox.,1
2733,"private void InitializeComponent()
{
this.SuspendLayout();
// // GraphColumnExtender
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Name = ""GraphColumnExtender"";
this.Size = new System.Drawing.Size(148, 28);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2734,"private void InitializeComponent()
{
this._line = new System.Windows.Forms.Panel();
this._lblText = new System.Windows.Forms.Label();
this._picChevron = new System.Windows.Forms.PictureBox();
((System.ComponentModel.ISupportInitialize)(this._picChevron)).BeginInit();
this.SuspendLayout();
// // _line
// this._line.BackColor = System.Drawing.SystemColors.ControlDark;
this._line.Name = ""_line"";
this._line.Size = new System.Drawing.Size(340, 1);
this._line.TabIndex = 1;
this._line.Click += new System.EventHandler(this.OnClick);
this._line.MouseEnter += new System.EventHandler(this.OnHostedControlMouseEnter);
this._line.MouseLeave += new System.EventHandler(this.OnHostedControlMouseLeave);
// // _lblText
// this._lblText.AutoSize = true;
this._lblText.Location = new System.Drawing.Point(0, 3);
this._lblText.Name = ""_lblText"";
this._lblText.Size = new System.Drawing.Size(49, 15);
this._lblText.TabIndex = 0;
this._lblText.Text = ""%Text%"";
this._lblText.Click += new System.EventHandler(this.OnClick);
this._lblText.MouseEnter += new System.EventHandler(this.OnHostedControlMouseEnter);
this._lblText.MouseLeave += new System.EventHandler(this.OnHostedControlMouseLeave);
this._lblText.Resize += new System.EventHandler(this._lblText_Resize);
// // _picChevron
// this._picChevron.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._picChevron.Cursor = System.Windows.Forms.Cursors.Hand;
this._picChevron.Location = new System.Drawing.Point(388, 0);
this._picChevron.Name = ""_picChevron"";
this._picChevron.Size = new System.Drawing.Size(19, 19);
this._picChevron.TabIndex = 2;
this._picChevron.TabStop = false;
this._picChevron.Visible = false;
this._picChevron.Click += new System.EventHandler(this.OnClick);
this._picChevron.MouseEnter += new System.EventHandler(this.OnHostedControlMouseEnter);
// // GroupSeparator
// this.Controls.Add(this._picChevron);
this.Controls.Add(this._lblText);
this.Controls.Add(this._line);
this.MaximumSize = new System.Drawing.Size(9999, System.Windows.Forms.SystemInformation.SmallIconSize.Height + 3);
this.MinimumSize = new System.Drawing.Size(0, System.Windows.Forms.SystemInformation.SmallIconSize.Height + 3);
this.Name = ""GroupSeparator"";
this.Size = new System.Drawing.Size(407, 19);
this.Click += new System.EventHandler(this.OnClick);
((System.ComponentModel.ISupportInitialize)(this._picChevron)).EndInit();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2735,"protected override void OnListBoxAttached()
{
base.OnListBoxAttached();
_extender = new HashColumnExtender(this);
Extender = new Popup(_extender);
}",Called when item is attached to listbox.,1
2736,"private void InitializeComponent()
{
this.SuspendLayout();
// // HashColumnExtender
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Name = ""HashColumnExtender"";
this.Size = new System.Drawing.Size(140, 28);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2737,"internal override void NotifyRelogRecordAdded()
{
base.NotifyRelogRecordAdded();
var reference = Pointer as Reference;
if(reference != null) reference.NotifyRelogRecordAdded();
}",Notifies about reflog modification.,1
2738,"public void Refresh()
{
Pointer = GetHeadPointer(Repository);
}",Updates cached information.,1
2739,"private void InitializeComponent()
{
this.radioButton1 = new System.Windows.Forms.RadioButton();
this.radioButton2 = new System.Windows.Forms.RadioButton();
this.radioButton3 = new System.Windows.Forms.RadioButton();
this._lstReferences = new gitter.Git.Gui.Controls.ReferencesListBox();
this.SuspendLayout();
// // radioButton1
// this.radioButton1.AutoSize = true;
this.radioButton1.Checked = true;
this.radioButton1.Location = new System.Drawing.Point(3, 3);
this.radioButton1.Name = ""radioButton1"";
this.radioButton1.Size = new System.Drawing.Size(89, 17);
this.radioButton1.TabIndex = 1;
this.radioButton1.TabStop = true;
this.radioButton1.Text = ""All references"";
this.radioButton1.UseVisualStyleBackColor = true;
this.radioButton1.CheckedChanged += new System.EventHandler(this.OnFilterTypeCheckedChanged);
// // radioButton2
// this.radioButton2.AutoSize = true;
this.radioButton2.Location = new System.Drawing.Point(142, 3);
this.radioButton2.Name = ""radioButton2"";
this.radioButton2.Size = new System.Drawing.Size(55, 17);
this.radioButton2.TabIndex = 2;
this.radioButton2.Text = ""HEAD"";
this.radioButton2.UseVisualStyleBackColor = true;
this.radioButton2.CheckedChanged += new System.EventHandler(this.OnFilterTypeCheckedChanged);
// // radioButton3
// this.radioButton3.AutoSize = true;
this.radioButton3.Location = new System.Drawing.Point(3, 25);
this.radioButton3.Name = ""radioButton3"";
this.radioButton3.Size = new System.Drawing.Size(145, 17);
this.radioButton3.TabIndex = 3;
this.radioButton3.Text = ""Only selected references:"";
this.radioButton3.UseVisualStyleBackColor = true;
this.radioButton3.CheckedChanged += new System.EventHandler(this.OnFilterTypeCheckedChanged);
// // _lstReferences
// this._lstReferences.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstReferences.DisableContextMenus = true;
this._lstReferences.ForeColor = System.Drawing.SystemColors.WindowText;
this._lstReferences.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstReferences.Location = new System.Drawing.Point(3, 49);
this._lstReferences.Name = ""_lstReferences"";
this._lstReferences.ShowCheckBoxes = true;
this._lstReferences.ShowTreeLines = true;
this._lstReferences.Size = new System.Drawing.Size(233, 196);
this._lstReferences.TabIndex = 0;
// // HistoryFilterDropDown
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.BackColor = System.Drawing.SystemColors.Window;
this.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
this.Controls.Add(this.radioButton3);
this.Controls.Add(this.radioButton2);
this.Controls.Add(this.radioButton1);
this.Controls.Add(this._lstReferences);
this.MaximumSize = new System.Drawing.Size(241, 500);
this.MinimumSize = new System.Drawing.Size(241, 250);
this.Name = ""HistoryFilterDropDown"";
this.Size = new System.Drawing.Size(239, 250);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2740,"public override void RefreshContent()
{
if(InvokeRequired)
{
BeginInvoke(new MethodInvoker(RefreshContentSync));
}
else
{
RefreshContentSync();
}
}",Refreshes the content.,1
2741,"protected struct HitTestResult
{
public HitTestArea Area;
public int ItemIndex;
public int ItemPart;
public HitTestResult(HitTestArea area, int itemIndex, int itemPart)
{
Area = area;
ItemIndex = itemIndex;
ItemPart = itemPart;
}
public bool Check(HitTestArea area, int itemIndex, int itemPart)
{
return ItemIndex == itemIndex && Area == area && ItemPart == itemPart;
}
public bool Check(HitTestArea area, int itemPart)
{
return Area == area && ItemPart == itemPart;
}
}",Result of hit-testing.,1
2742,"public interface IBackgroundStyle
{
/// <summary>Draw item background.</summary>
/// <param name=""graphics""><see cref=""Graphics""/> surface to draw on.</param>
/// <param name=""rect"">Item rectangle.</param>
void Draw(Graphics graphics, Rectangle rect);
}",Item background style.,1
2743,"public interface IColorTable
{
Color Background { get; }
Color ArrowNormal { get; }
Color ArrowHover { get; }
Color ArrowPressed { get; }
Color ArrowDisabled { get; }
Color ThumbNormal { get; }
Color ThumbHover { get; }
Color ThumbPressed { get; }
Color ThumbDisabled { get; }
}",Defines colors for renderer.,1
2744,"public interface IConfigAccessor
{
/// <summary>Query configuration parameter list.</summary>
IGitFunction<QueryConfigParameters, IList<ConfigParameterData>> QueryConfig { get; }
/// <summary>Query config parameter.</summary>
IGitFunction<QueryConfigParameterParameters, ConfigParameterData> QueryConfigParameter { get; }
/// <summary>Add config value.</summary>
IGitAction<AddConfigValueParameters> AddConfigValue { get; }
/// <summary>Set config value.</summary>
IGitAction<SetConfigValueParameters> SetConfigValue { get; }
/// <summary>Unset config parameter value.</summary>
IGitAction<UnsetConfigValueParameters> UnsetConfigValue { get; }
/// <summary>Rename configuration section.</summary>
IGitAction<RenameConfigSectionParameters> RenameConfigSection { get; }
/// <summary>Delete configuration section.</summary>
IGitAction<DeleteConfigSectionParameters> DeleteConfigSection { get; }
}",Object which can perform various operations on git configuration.,1
2745,"public interface IDockMarkerProvider : IEnumerable<DockMarker>
{
/// <summary>Gets a value indicating whether markers are visible.</summary>
/// <value><c>true</c> if markers are visible; otherwise, <c>false</c>.</value>
bool MarkersVisible { get; }
/// <summary>Shows markers to assist docking process.</summary>
/// <param name=""dockClient"">Tool host which is being docked.</param>
void Show(ViewHost dockClient);
/// <summary>Hides and disposes all dock markers associated with this instance.</summary>
void Hide();
/// <summary>Updates hover status of dock markers.</summary>
/// <returns>true if mouse is hovering docking button.</returns>
bool UpdateHover();
/// <summary>Updates hover status of dock markers.</summary>
/// <param name=""position"">Mouse position.</param>
/// <returns>true if mouse is hovering docking button.</returns>
bool UpdateHover(Point position);
/// <summary>Notifies that mouse no longer hovers any docking markers associated with this instance.</summary>
void Unhover();
/// <summary>Checks docking position at current mose position.</summary>
/// <returns>Position for docking client control.</returns>
DockResult HitTest();
/// <summary>Checks docking position at specified <paramref name=""position""/>.</summary>
/// <param name=""position"">Mouse position.</param>
/// <returns>Position for docking client control.</returns>
DockResult HitTest(Point position);
}",Interface for interacting with dock markers.,1
2746,"public interface IElevatedExecutableDialog
{
/// <summary><see cref=""RequireElevation""/> property value changed.</summary>
event EventHandler RequireElevationChanged;
/// <summary>Elevation is required to execute dialog in its current state.</summary>
bool RequireElevation { get; }
/// <summary>Action which performs operations requiring elevation.</summary>
Action ElevatedExecutionAction { get; }
}",Dialog that may require elevated privileges to execute.,1
2747,"public interface IExecutableDialog
{
/// <summary>Execute dialog associated action.</summary>
/// <returns><c>true</c>, if action succeded</returns>
bool Execute();
}",Interface for dialog that can perform requested operation itself.,1
2748,"public interface IExpandableDialog
{
/// <summary>Text, displayed on show/hide button.</summary>
string ExpansionName { get; }
/// <summary>Control, which contains hideable part.</summary>
Control ExpansionControl { get; }
}",Interface of dialog which can show/hide its part.,1
2749,"public interface IGitAccessor : IConfigAccessor
{
#region Properties
/// <summary>Returns provider of this accessor.</summary>
/// <value>Provider of this accessor</value>
IGitAccessorProvider Provider { get; }
/// <summary>Returns git version.</summary>
/// <value>git version.</value>
Version GitVersion { get; }
/// <summary>Create an empty git repository or reinitialize an existing one.</summary>
IGitAction<InitRepositoryParameters> InitRepository { get; }
/// <summary>Clone existing repository.</summary>
IGitAction<CloneRepositoryParameters> CloneRepository { get; }
#endregion
#region Methods
/// <summary>Forces re-check of git version.</summary>
void InvalidateGitVersion();
/// <summary>Create <see cref=""IRepositoryAccessor""/> for specified <paramref name=""repository""/>.</summary>
/// <param name=""repository"">git repository to get accessor for.</param>
/// <returns>git repository accessor.</returns>
/// <exception cref=""ArgumentNullException""><paramref name=""repository""/> == <c>null</c>.</exception>
IRepositoryAccessor CreateRepositoryAccessor(IGitRepository repository);
/// <summary>Checks if specified path is a valid repository.</summary>
/// <param name=""path"">Path to check.</param>
/// <returns><c>true</c> if specified path is a valid repository, <c>false</c> otherwise.</returns>
bool IsValidRepository(string path);
/// <summary>Save parameters to the specified <paramref name=""section""/>.</summary>
/// <param name=""section"">Section to store parameters.</param>
void SaveTo(Section section);
/// <summary>Load parameters from the specified <paramref name=""section""/>.</summary>
/// <param name=""section"">Section to look for parameters.</param>
void LoadFrom(Section section);
#endregion
}",Defines repository-independent git operations.,1
2750,"public interface IGraphColorProvider
{
int AcquireColor();
void ReleaseColor(int color);
}",Object for unique color allocation.,1
2751,"public interface IGraphStyle
{
void DrawGraph(Graphics graphics, GraphAtom[] graphLine, Rectangle bounds, int cellWidth, RevisionGraphItemType type, bool useColors);
void DrawReferenceConnector(Graphics graphics, GraphAtom[] graphLine, int graphX, int cellWidth, int refX, int y, int h);
void DrawReferencePresenceIndicator(Graphics graphics, GraphAtom[] graphLine, int graphX, int cellWidth, int y, int h);
int DrawTag(Graphics graphics, Font font, StringFormat format, int x, int y, int right, int h, bool hovered, Tag tag);
int DrawBranch(Graphics graphics, Font font, StringFormat format, int x, int y, int right, int h, bool hovered, BranchBase branch);
int DrawStash(Graphics graphics, Font font, StringFormat format, int x, int y, int right, int h, bool hovered, StashedState stash);
int MeasureTag(Graphics graphics, Font font, StringFormat format, Tag tag);
int MeasureBranch(Graphics graphics, Font font, StringFormat format, Branch branch);
int MeasureStash(Graphics graphics, Font font, StringFormat format, StashedState stash);
}",Graph painter.,1
2752,"public interface IGuiProvider
{
/// <summary>Build gui inside supplied <paramref name=""IWorkingEnvironment""/>.</summary>
/// <param name=""environment"">Environment for gui elements hosting.</param>
void AttachToEnvironment(IWorkingEnvironment environment);
/// <summary>Remove gui, created by this provider from <paramref name=""IWorkingEnvironment""/>.</summary>
/// <param name=""environment"">Environment for gui elements hosting.</param>
void DetachFromEnvironment(IWorkingEnvironment environment);
void SaveTo(Section section);
void LoadFrom(Section section);
}",Interface for gui provider/builder.,1
2753,"public interface IMouseDragProcess
{
/// <summary>Action is in process.</summary>
bool IsActive { get; }
/// <summary>Start drag process.</summary>
/// <param name=""location"">Mouse coordinates.</param>
/// <returns>True if process started successfully.</returns>
bool Start(Point location);
/// <summary>Update process status.</summary>
/// <param name=""location"">Mouse cordinates.</param>
void Update(Point location);
/// <summary>Perform action associated with this process and complete operation.</summary>
/// <param name=""location"">Mouse coordinates.</param>
void Commit(Point location);
/// <summary>Cancel process without applying any changes.</summary>
void Cancel();
}",Represents continious drag-by-mouse process.,1
2754,"private void InitializeComponent()
{
this._pnlOptions = new System.Windows.Forms.Panel();
this._btnSelectTemplate = new System.Windows.Forms.Button();
this._grpOptions = new gitter.Framework.Controls.GroupSeparator();
this._chkBare = new System.Windows.Forms.CheckBox();
this._chkUseTemplate = new System.Windows.Forms.CheckBox();
this._txtTemplate = new System.Windows.Forms.TextBox();
this._btnSelectDirectory = new System.Windows.Forms.Button();
this._lblPath = new System.Windows.Forms.Label();
this._txtPath = new System.Windows.Forms.TextBox();
this._pnlOptions.SuspendLayout();
this.SuspendLayout();
// // _pnlOptions
// this._pnlOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlOptions.Controls.Add(this._btnSelectTemplate);
this._pnlOptions.Controls.Add(this._grpOptions);
this._pnlOptions.Controls.Add(this._chkBare);
this._pnlOptions.Controls.Add(this._txtTemplate);
this._pnlOptions.Controls.Add(this._chkUseTemplate);
this._pnlOptions.Location = new System.Drawing.Point(0, 29);
this._pnlOptions.Name = ""_pnlOptions"";
this._pnlOptions.Size = new System.Drawing.Size(382, 69);
this._pnlOptions.TabIndex = 14;
// // _btnSelectTemplate
// this._btnSelectTemplate.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnSelectTemplate.Enabled = false;
this._btnSelectTemplate.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnSelectTemplate.Location = new System.Drawing.Point(353, 23);
this._btnSelectTemplate.Name = ""_btnSelectTemplate"";
this._btnSelectTemplate.Size = new System.Drawing.Size(29, 23);
this._btnSelectTemplate.TabIndex = 4;
this._btnSelectTemplate.Text = ""..."";
this._btnSelectTemplate.UseVisualStyleBackColor = true;
this._btnSelectTemplate.Click += new System.EventHandler(this._btnSelectTemplate_Click);
// // _grpOptions
// this._grpOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpOptions.Location = new System.Drawing.Point(0, 0);
this._grpOptions.Name = ""_grpOptions"";
this._grpOptions.Size = new System.Drawing.Size(382, 19);
this._grpOptions.TabIndex = 0;
this._grpOptions.Text = ""%Options%"";
// // _chkBare
// this._chkBare.AutoSize = true;
this._chkBare.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkBare.Location = new System.Drawing.Point(12, 45);
this._chkBare.Name = ""_chkBare"";
this._chkBare.Size = new System.Drawing.Size(131, 20);
this._chkBare.TabIndex = 5;
this._chkBare.Text = ""%Bare repository%"";
this._chkBare.UseVisualStyleBackColor = true;
// // _chkUseTemplate
// this._chkUseTemplate.AutoSize = true;
this._chkUseTemplate.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkUseTemplate.Location = new System.Drawing.Point(12, 25);
this._chkUseTemplate.Name = ""_chkUseTemplate"";
this._chkUseTemplate.Size = new System.Drawing.Size(105, 20);
this._chkUseTemplate.TabIndex = 2;
this._chkUseTemplate.Text = ""%Template%:"";
this._chkUseTemplate.UseVisualStyleBackColor = true;
this._chkUseTemplate.CheckedChanged += new System.EventHandler(this._chkUseTemplate_CheckedChanged);
// // _txtTemplate
// this._txtTemplate.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtTemplate.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
this._txtTemplate.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.FileSystemDirectories;
this._txtTemplate.Enabled = false;
this._txtTemplate.Location = new System.Drawing.Point(94, 23);
this._txtTemplate.Name = ""_txtTemplate"";
this._txtTemplate.Size = new System.Drawing.Size(259, 23);
this._txtTemplate.TabIndex = 3;
// // _btnSelectDirectory
// this._btnSelectDirectory.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._btnSelectDirectory.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnSelectDirectory.Location = new System.Drawing.Point(353, 3);
this._btnSelectDirectory.Name = ""_btnSelectDirectory"";
this._btnSelectDirectory.Size = new System.Drawing.Size(29, 23);
this._btnSelectDirectory.TabIndex = 1;
this._btnSelectDirectory.Text = ""..."";
this._btnSelectDirectory.UseVisualStyleBackColor = true;
this._btnSelectDirectory.Click += new System.EventHandler(this._btnSelectDirectory_Click);
// // _lblPath
// this._lblPath.AutoSize = true;
this._lblPath.Location = new System.Drawing.Point(0, 6);
this._lblPath.Name = ""_lblPath"";
this._lblPath.Size = new System.Drawing.Size(54, 15);
this._lblPath.TabIndex = 10;
this._lblPath.Text = ""%Path%:"";
// // _txtPath
// this._txtPath.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtPath.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
this._txtPath.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.FileSystemDirectories;
this._txtPath.Location = new System.Drawing.Point(94, 3);
this._txtPath.Name = ""_txtPath"";
this._txtPath.Size = new System.Drawing.Size(259, 23);
this._txtPath.TabIndex = 0;
// // InitDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._pnlOptions);
this.Controls.Add(this._btnSelectDirectory);
this.Controls.Add(this._lblPath);
this.Controls.Add(this._txtPath);
this.Name = ""InitDialog"";
this.Size = new System.Drawing.Size(385, 98);
this._pnlOptions.ResumeLayout(false);
this._pnlOptions.PerformLayout();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2755,"public interface INotificationService : IDisposable
{
void Notify(Control control, string title, string message);
void Notify(ToolStripItem control, string title, string message);
void Notify(Control control, NotificationType type, string title, string message);
void Notify(ToolStripItem control, NotificationType type, string title, string message);
void NotifyInputError(Control control, string title, string message);
void NotifyInputError(Control control, NotificationType type, string title, string message);
}",Event Notification Service.,1
2756,"private void InitializeComponent()
{
this._lstFeatures = new gitter.Framework.Controls.CustomListBox();
this._lblIntegrationFeatures = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _lstFeatures
// this._lstFeatures.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstFeatures.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstFeatures.Location = new System.Drawing.Point(0, 18);
this._lstFeatures.Name = ""_lstFeatures"";
this._lstFeatures.ShowCheckBoxes = true;
this._lstFeatures.Size = new System.Drawing.Size(447, 336);
this._lstFeatures.TabIndex = 0;
// // _lblIntegrationFeatures
// this._lblIntegrationFeatures.AutoSize = true;
this._lblIntegrationFeatures.Location = new System.Drawing.Point(-3, 0);
this._lblIntegrationFeatures.Name = ""_lblIntegrationFeatures"";
this._lblIntegrationFeatures.Size = new System.Drawing.Size(133, 15);
this._lblIntegrationFeatures.TabIndex = 1;
this._lblIntegrationFeatures.Text = ""%Integration features%:"";
// // IntegrationOptionsPage
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblIntegrationFeatures);
this.Controls.Add(this._lstFeatures);
this.Name = ""IntegrationOptionsPage"";
this.Size = new System.Drawing.Size(447, 354);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2757,"public interface IOutputReceiver
{
/// <summary>Gets a value indicating whether this instance is initialized.</summary>
/// <value><c>true</c> if this instance is initialized; otherwise, <c>false</c>.</value>
bool IsInitialized { get; }
/// <summary>Initializes output reader.</summary>
/// <param name=""process"">Process to read from.</param>
/// <param name=""reader"">StreamReader to read from.</param>
void Initialize(Process process, StreamReader reader);
/// <summary>Notifies receiver that output is no longer required.</summary>
/// <remarks>Reader should still receive bytes, but disable any stream processing.</remarks>
void NotifyCanceled();
/// <summary>Waits for outpuit stream end.</summary>
void WaitForEndOfStream();
}",Receives output from stderr/stdout.,1
2758,"public interface IPatchFile : IDisposable
{
/// <summary>Returns patch file name.</summary>
string FileName { get; }
}",Represents patch file.,1
2759,"public interface IPatchSource
{
/// <summary>Prepare patch before 'git apply'.</summary>
/// <returns>Patch file.</returns>
IPatchFile PreparePatchFile();
/// <summary>Returns patch source display name.</summary>
/// <value>Patch source display name.</value>
string DisplayName { get; }
}",Represents patch source.,1
2760,"public interface IRemoteReference
{
event EventHandler Deleted;
/// <summary>Remote repository.</summary>
Remote Remote { get; }
/// <summary>Reference name.</summary>
string Name { get; }
/// <summary>Commit hash.</summary>
Hash Hash { get; }
ReferenceType ReferenceType { get; }
/// <summary>Remove reference from remote repository.</summary>
void Delete();
Task DeleteAsync(IProgress<OperationProgress> progress, CancellationToken cancellationToken);
bool IsDeleted { get; }
}",Represents a reference on remote repository.,1
2761,"public interface IRepository
{
/// <summary>Repository deleted.</summary>
event EventHandler Deleted;
/// <summary>Working path of repository.</summary>
string WorkingDirectory { get; }
/// <summary>Returns repository configuration section.</summary>
/// <value>Repository configuration section.</value>
Section ConfigSection { get; }
}",Abstract repository.,1
2762,"IGitFunction<QueryRevisionsParameters, IList<RevisionData>> QueryRevisions { get; }",Get revision list.,1
2763,"IGitFunction<QueryRemoteReferencesParameters, IList<RemoteReferenceData>> QueryRemoteReferences { get; }",Get list of references on remote repository.,1
2764,"IGitFunction<QuerySymbolicReferenceParameters, SymbolicReferenceData> QuerySymbolicReference { get; }",Get symbolic reference target.,1
2765,"public interface IRepositoryAccessor : IConfigAccessor
{
/// <summary>Returns git accessor.</summary>
/// <value>git accessor.</value>
IGitAccessor GitAccessor { get; }
/// <summary>Add file to index.</summary>
IGitAction<AddFilesParameters> AddFiles { get; }
/// <summary>Add remote repository.</summary>
IGitAction<AddRemoteParameters> AddRemote { get; }
/// <summary>Add new submodule.</summary>
IGitAction<AddSubmoduleParameters> AddSubmodule { get; }
/// <summary>Append new note to object.</summary>
IGitAction<AppendNoteParameters> AppendNote { get; }
/// <summary>Apply patches to working directory and/or index.</summary>
IGitAction<ApplyPatchParameters> ApplyPatch { get; }
/// <summary>Create an archive of files from a named tree.</summary>
IGitAction<ArchiveParameters> Archive { get; }
/// <summary>Remove untracked files from the working tree.</summary>
IGitAction<CleanFilesParameters> CleanFiles { get; }
/// <summary>Checkout branch/revision.</summary>
IGitAction<CheckoutParameters> Checkout { get; }
/// <summary>Checkout files from tree object to working directory.</summary>
IGitAction<CheckoutFilesParameters> CheckoutFiles { get; }
/// <summary>Performs a cherry-pick operation.</summary>
IGitAction<CherryPickParameters> CherryPick { get; }
/// <summary>Commit changes.</summary>
IGitFunction<CommitParameters, string> Commit { get; }
/// <summary>Calculate object count.</summary>
IGitFunction<CountObjectsParameters, ObjectCountData> CountObjects { get; }
/// <summary>Create local branch.</summary>
IGitAction<CreateBranchParameters> CreateBranch { get; }
/// <summary>Create new tag object.</summary>
IGitAction<CreateTagParameters> CreateTag { get; }
/// <summary>Remove local branch.</summary>
IGitAction<DeleteBranchParameters> DeleteBranch { get; }
/// <summary>Delete tag.</summary>
IGitAction<DeleteTagParameters> DeleteTag { get; }
/// <summary>Dereference valid ref.</summary>
IGitFunction<DereferenceParameters, RevisionData> Dereference { get; }
/// <summary>Describe revision.</summary>
IGitFunction<DescribeParameters, string> Describe { get; }
/// <summary>Download objects and refs from another repository.</summary>
IGitAction<FetchParameters> Fetch { get; }
/// <summary>Formats merge message using commit messages.</summary>
IGitFunction<FormatMergeMessageParameters, string> FormatMergeMessage { get; }
/// <summary>Cleanup unnecessary files and optimize the local repository.</summary>
IGitAction<GarbageCollectParameters> GarbageCollect { get; }
/// <summary>Merge development histories together.</summary>
IGitAction<MergeParameters> Merge { get; }
/// <summary>Remove stale remote tracking branches.</summary>
IGitAction<PruneRemoteParameters> PruneRemote { get; }
/// <summary>Download objects and refs from another repository and merge with local branches configured for this.</summary>
IGitAction<PullParameters> Pull { get; }
/// <summary>Update remote refs along with associated objects.</summary>
IGitFunction<PushParameters, IList<ReferencePushResult>> Push { get; }
/// <summary>Annotate each line of file with commit information.</summary>
IGitFunction<QueryBlameParameters, BlameFile> QueryBlame { get; }
/// <summary>Queries the BLOB bytes.</summary>
IGitFunction<QueryBlobBytesParameters, byte[]> QueryBlobBytes { get; }
/// <summary>Check if branch exists and get its position.</summary>
IGitFunction<QueryBranchParameters, BranchData> QueryBranch { get; }
/// <summary>Query branch list.</summary>
IGitFunction<QueryBranchesParameters, BranchesData> QueryBranches { get; }
/// <summary>Get list of stale remote tracking branches that are subject to pruninig.</summary>
IGitFunction<PruneRemoteParameters, IList<string>> QueryBranchesToPrune { get; }
/// <summary>Get <see cref=""Diff""/>, representing difference between specified objects.</summary>
IGitFunction<QueryDiffParameters, Diff> QueryDiff { get; }
/// <summary>Get the list of files that can be added.</summary>
IGitFunction<AddFilesParameters, IList<TreeFileData>> QueryFilesToAdd { get; }
/// <summary>Get list of files which will be removed by a remove files call.</summary>
IGitFunction<RemoveFilesParameters, IList<string>> QueryFilesToRemove { get; }
/// <summary>Get list of files and directories which will be removed by a clean call.</summary>
IGitFunction<CleanFilesParameters, IList<string>> QueryFilesToClean { get; }
/// <summary>Get list of all note objects.</summary>
IGitFunction<QueryNotesParameters, IList<NoteData>> QueryNotes { get; }
/// <summary>Get contents of requested objects.</summary>
IGitFunction<QueryObjectsParameters, string> QueryObjects { get; }
/// <summary>Get revision information.</summary>
IGitFunction<QueryRevisionParameters, RevisionData> QueryRevision { get; }
/// <summary>Get revision list.</summary>
IGitFunction<QueryRevisionsParameters, IList<RevisionData>> QueryRevisions { get; }
/// <summary>Get <see cref=""Diff""/>, representing changes made by specified commit.</summary>
IGitFunction<QueryRevisionDiffParameters, Diff> QueryRevisionDiff { get; }
/// <summary>Get revision graph.</summary>
IGitFunction<QueryRevisionsParameters, IList<RevisionGraphData>> QueryRevisionGraph { get; }
/// <summary>Get patch representing changes made by specified commit.</summary>
IGitFunction<QueryRevisionDiffParameters, byte[]> QueryRevisionPatch { get; }
/// <summary>Get list of references.</summary>
IGitFunction<QueryReferencesParameters, ReferencesData> QueryReferences { get; }
/// <summary>Get reference reflog.</summary>
IGitFunction<QueryReflogParameters, IList<ReflogRecordData>> QueryReflog { get; }
/// <summary>Get information about remote.</summary>
IGitFunction<QueryRemoteParameters, RemoteData> QueryRemote { get; }
/// <summary>Get list of references on remote repository.</summary>
IGitFunction<QueryRemoteReferencesParameters, IList<RemoteReferenceData>> QueryRemoteReferences { get; }
/// <summary>Query list of remotes.</summary>
IGitFunction<QueryRemotesParameters, IList<RemoteData>> QueryRemotes { get; }
/// <summary>Query all stashed states.</summary>
IGitFunction<QueryStashParameters, IList<StashedStateData>> QueryStash { get; }
/// <summary>Get patch representing stashed changes.</summary>
IGitFunction<QueryRevisionDiffParameters, byte[]> QueryStashPatch { get; }
/// <summary>Query most recent stashed state.</summary>
IGitFunction<QueryStashTopParameters, RevisionData> QueryStashTop { get; }
/// <summary>Get patch representing stashed changes.</summary>
IGitFunction<QueryRevisionDiffParameters, Diff> QueryStashDiff { get; }
/// <summary>Get working directory status information.</summary>
IGitFunction<QueryStatusParameters, StatusData> QueryStatus { get; }
/// <summary>Get symbolic reference target.</summary>
IGitFunction<QuerySymbolicReferenceParameters, SymbolicReferenceData> QuerySymbolicReference { get; }
/// <summary>Get objects contained in a tree.</summary>
IGitFunction<QueryTreeContentParameters, IList<TreeContentData>> QueryTreeContent { get; }
/// <summary>Check if tag exists and get its position.</summary>
IGitFunction<QueryTagParameters, TagData> QueryTag { get; }
/// <summary>Query tag message.</summary>
IGitFunction<QueryTagMessageParameters, string> QueryTagMessage { get; }
/// <summary>Query tag list.</summary>
IGitFunction<QueryTagsParameters, IList<TagData>> QueryTags { get; }
/// <summary>Get user list.</summary>
IGitFunction<QueryUsersParameters, IList<UserData>> QueryUsers { get; }
/// <summary>Remove file from index and/or working directory.</summary>
IGitAction<RemoveFilesParameters> RemoveFiles { get; }
/// <summary>Remove reference on remote repository.</summary>
IGitAction<RemoveRemoteReferencesParameters> RemoveRemoteReferences { get; }
/// <summary>Forward-port local commits to the updated upstream head.</summary>
IGitAction<RebaseParameters> Rebase { get; }
/// <summary>Remove remote repository.</summary>
IGitAction<RemoveRemoteParameters> RemoveRemote { get; }
/// <summary>Rename local branch.</summary>
IGitAction<RenameBranchParameters> RenameBranch { get; }
/// <summary>Rename remote repository.</summary>
IGitAction<RenameRemoteParameters> RenameRemote { get; }
/// <summary>Reset HEAD.</summary>
IGitAction<ResetParameters> Reset { get; }
/// <summary>Resets files.</summary>
IGitAction<ResetFilesParameters> ResetFiles { get; }
/// <summary>Reset local branch.</summary>
IGitAction<ResetBranchParameters> ResetBranch { get; }
/// <summary>Performs a revert operation.</summary>
IGitAction<RevertParameters> Revert { get; }
/// <summary>Run merge tool to resolve conflicts.</summary>
IGitAction<RunMergeToolParameters> RunMergeTool { get; }
/// <summary>Apply stashed changes and do not remove stashed state.</summary>
IGitAction<StashApplyParameters> StashApply { get; }
/// <summary>Remove stashed state.</summary>
IGitAction<StashDropParameters> StashDrop { get; }
/// <summary>Clear stash.</summary>
IGitAction<StashClearParameters> StashClear { get; }
/// <summary>Apply stashed changes and remove stashed state.</summary>
IGitAction<StashPopParameters> StashPop { get; }
/// <summary>Stash changes in working directory.</summary>
IGitFunction<StashSaveParameters, bool> StashSave { get; }
/// <summary>Create new branch, checkout that branch and pop stashed state.</summary>
IGitAction<StashToBranchParameters> StashToBranch { get; }
/// <summary>Updates submodule.</summary>
IGitAction<SubmoduleUpdateParameters> UpdateSubmodule { get; }
/// <summary>Verify tags GPG signatures.</summary>
IGitAction<VerifyTagsParameters> VerifyTags { get; }
}",Interface of repository accessor object.,1
2766,"public interface IRepositoryGuiProvider : IGuiProvider
{
void ActivateDefaultView();
/// <summary>Repository which is currently active.</summary>
IRepository Repository { get; set; }
}",Interface for gui provider/builder.,1
2767,"public interface IRepositoryProvider : INamedObject
{
#region Properties
/// <summary>Returns provider display name.</summary>
/// <value>Provider display name.</value>
string DisplayName { get; }
/// <summary>Returns provider icon.</summary>
/// <value>Provider icon.</value>
Image Icon { get; }
/// <summary>Returns GUI provider.</summary>
/// <value>GUI provider.</value>
IRepositoryGuiProvider GuiProvider { get; }
/// <summary>Gets a value indicating whether this provider is loaded.</summary>
/// <value><c>true</c> if this provider is loaded; otherwise, <c>false</c>.</value>
bool IsLoaded { get; }
#endregion
#region Methods
/// <summary>Prepare to work in context of specified <paramref name=""environment""/>.</summary>
/// <param name=""environment""><see cref=""IWorkingEnvironment""/> to work in.</param>
/// <param name=""section"">Provider configuration section.</param>
bool LoadFor(IWorkingEnvironment environment, Section section);
/// <summary>Save configuration to <paramref name=""section""/>.</summary>
/// <param name=""section""><see cref=""Section""/> for storing configuration.</param>
void SaveTo(Section section);
/// <summary>Checks if provider can create repository for <paramref name=""workingDirectory""/>.</summary>
/// <param name=""workingDirectory"">Repository working directory.</param>
/// <returns>true, if <see cref=""OpenRepository()""/> can succeed for <paramref name=""workingDirectory""/>.</returns>
bool IsValidFor(string workingDirectory);
/// <summary>Opens repository specified by <paramref name=""workingDirectory""/>.</summary>
/// <param name=""workingDirectory"">Working directory of repository.</param>
/// <returns>Opened repository.</returns>
/// <exception cref=""ArgumentNullException""><paramref name=""workingDirectory""/> == <c>null</c>.</exception>
IRepository OpenRepository(string workingDirectory);
/// <summary>Opens repository specified by <paramref name=""workingDirectory""/>.</summary>
/// <param name=""workingDirectory"">Working directory of repository.</param>
/// <returns>Opened repository.</returns>
/// <exception cref=""ArgumentNullException""><paramref name=""workingDirectory""/> == <c>null</c>.</exception>
Task<IRepository> OpenRepositoryAsync(string workingDirectory, IProgress<OperationProgress> progress, CancellationToken cancellationToken);
/// <summary>Called after repository is successfully loaded by environment.</summary>
/// <param name=""repository"">Loaded repository.</param>
void OnRepositoryLoaded(IRepository repository);
/// <summary>Releases all resources allocated by repository if applicable.</summary>
/// <param name=""repository"">Repository to close.</param>
/// <exception cref=""ArgumentNullException""><paramref name=""repository""/> == <c>null</c>.</exception>
void CloseRepository(IRepository repository);
/// <summary>Creates control to initialize new repository.</summary>
/// <returns>Control to initialize new repository.</returns>
Control CreateInitDialog();
/// <summary>Creates control to clone existing repository.</summary>
/// <returns>Control to clone existing repository.</returns>
Control CreateCloneDialog();
/// <summary>Get list of repository operations.</summary>
/// <param name=""workingDirectory"">Repository working directory.</param>
IEnumerable<GuiCommand> GetRepositoryCommands(string workingDirectory);
#endregion
}",Repository provider.,1
2768,"public interface IRepositoryServiceProvider : INamedObject
{
#region Properties
/// <summary>Returns service display name.</summary>
/// <value>Service display name.</value>
string DisplayName { get; }
/// <summary>Returns service icon.</summary>
/// <value>Service icon.</value>
Image Icon { get; }
#endregion
#region Methods
/// <summary>Prepare for working inside specified <paramref name=""environment""/>.</summary>
/// <param name=""environment""><see cref=""IWorkingEnvironment""/> to work in.</param>
/// <param name=""section"">Provider configuration section.</param>
bool LoadFor(IWorkingEnvironment environment, Section section);
/// <summary>Save configuration to <paramref name=""node""/>.</summary>
/// <param name=""section""><see cref=""Section""/> for storing configuration.</param>
void SaveTo(Section section);
/// <summary>Checks if service is configured for specified repository.</summary>
/// <param name=""repository"">Repository to check.</param>
/// <returns><c>true</c>, if service is configured for the specified repository, otherwise <c>false</c>.</returns>
bool IsValidFor(IRepository repository);
/// <summary>Creates service setup control for the specified repository.</summary>
/// <param name=""repository"">Repository to configure service for.</param>
/// <returns>Setup control for the service.</returns>
Control CreateSetupDialog(IRepository repository);
/// <summary>Creates GUI provider to modify application UI.</summary>
/// <param name=""repository"">Specifies repository.</param>
/// <returns>GUI provider for the service.</returns>
IGuiProvider CreateGuiProvider(IRepository repository);
#endregion
}",Provides additional services for repository.,1
2769,"public interface IRevisionGraphListItem
{
/// <summary>Graph data of this item.</summary>
GraphAtom[] Graph { get; set; }
}",List item which has attached revision graph data.,1
2770,"interface IRevisionHeaderElement
{
event EventHandler InvalidateRequired;
event EventHandler<CursorChangedEventArgs> CursorChangeRequired;
/// <summary>Displayed data.</summary>
Element Element { get; }
bool IsAvailableFor(Revision revision);
ContextMenuStrip CreateContextMenu(Revision revision);
Size Measure(Graphics graphics, Revision revision, int width);
void Paint(Graphics graphics, Revision revision, Rectangle rect);
void MouseMove(Rectangle rect, Point point);
void MouseLeave();
void MouseDown(Rectangle rect, MouseButtons button, int x, int y);
}",Interface for a single data field.,1
2771,"public interface IRevisionPointer
{
/// <summary>Host repository. Never null.</summary>
Repository Repository { get; }
/// <summary><see cref=""ReferenceType""/>.</summary>
ReferenceType Type { get; }
/// <summary>Revision expression (reference name, sha1, relative expression, etc.).</summary>
string Pointer { get; }
/// <summary>Returns full non-ambiguous revision name.</summary>
string FullName { get; }
/// <summary>Evaluate commit which is targeted by this <see cref=""IRevisionPointer""/>.</summary>
/// <returns>Commit which is pointed by this <see cref=""IRevisionPointer""/>.</returns>
Revision Dereference();
/// <summary>Object is deleted and not valid anymore.</summary>
bool IsDeleted { get; }
}",Object which points to commit.,1
2772,"private void InitializeComponent()
{
this._lstIssues = new gitter.Redmine.Gui.ListBoxes.IssuesListBox();
this.SuspendLayout();
// // _lstIssues
// this._lstIssues.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstIssues.Location = new System.Drawing.Point(0, 0);
this._lstIssues.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._lstIssues.Name = ""_lstIssues"";
this._lstIssues.Size = new System.Drawing.Size(615, 407);
this._lstIssues.TabIndex = 0;
this._lstIssues.Text = ""No issues to display"";
// // IssuesView
// this.Controls.Add(this._lstIssues);
this.Name = ""IssuesView"";
this.Size = new System.Drawing.Size(615, 407);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2773,"public interface IUpdateChannel
{
/// <summary>Check latest gitter version on this chanel.</summary>
/// <returns>Latest gitter version.</returns>
Version CheckVersion();
/// <summary>Update gitter using this channel.</summary>
void Update();
}",gitter update channel.,1
2774,"public static ICommandArgument Delete { get; } = new CommandFlag(""-d"", ""--delete"");",Delete a branch. The branch must be fully merged in HEAD.,1
2775,"public static ICommandArgument DeleteForce { get; } = new CommandFlag(""-D"");",Delete a branch irrespective of its merged status.,1
2776,"public static ICommandArgument CreateReflog { get; } = new CommandFlag(""--create-reflog"");","Create the branch's reflog. This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as ""branchname@{yesterday}"".",1
2777,"public static ICommandArgument CreateReflogOld { get; } = new CommandFlag(""-l"");","Create the branch's reflog. This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as ""branchname@{yesterday}"".",1
2778,"public static ICommandArgument Force { get; } = new CommandFlag(""-f"", ""--force"");",Reset branchname to startpoint if branchname exists already. Without -f git-branch refuses to change an existing branch.,1
2779,"public static ICommandArgument Move { get; } = new CommandFlag(""-m"", ""--move"");",Move/rename a branch and the corresponding reflog.,1
2780,"public static ICommandArgument Copy { get; } = new CommandFlag(""-c"", ""--copy"");",Move/rename a branch and the corresponding reflog.,1
2781,"public static ICommandArgument ColorAlways { get; } = new CommandParameterValue(""--color"", ""always"", ' ');","Color branches to highlight current, local, and remote-tracking branches.",1
2782,"public static ICommandArgument ColorNever { get; } = new CommandParameterValue(""--color"", ""never"", ' ');","Color branches to highlight current, local, and remote-tracking branches.",1
2783,"public static ICommandArgument ColorAuto { get; } = new CommandParameterValue(""--color"", ""auto"", ' ');","Color branches to highlight current, local, and remote-tracking branches.",1
2784,"public static ICommandArgument IgnoreCase { get; } = new CommandFlag(""-i"", ""--ignore-case"");",Sorting and filtering branches are case insensitive.,1
2785,"public static ICommandArgument Remotes { get; } = new CommandFlag(""-r"", ""--remotes"");",List or delete (if used with -d) the remote-tracking branches.,1
2786,"public static ICommandArgument All { get; } = new CommandFlag(""-a"", ""--all"");",List both remote-tracking branches and local branches.,1
2787,"public static ICommandArgument Track { get; } = new CommandFlag(""-t"", ""--track"");","When creating a new branch, set up branch.name.remote and branch.name.merge configuration entries to mark the start-point branch as ""upstream"" from the new branch.",1
2788,"public static ICommandArgument NoAbbrev { get; } = new CommandFlag(""--no-abbrev"");",Display the full sha1s in the output listing rather than abbreviating them.,1
2789,public static ICommandArgument Verbose => CommonArguments.Verbose;,"When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the name of the upstream branch, as well.",1
2790,public static ICommandArgument Quiet => CommonArguments.Quiet;,"Be more quiet when creating or deleting a branch, suppressing non-error messages.",1
2791,"public static ICommandArgument CreateReflog { get; } = new CommandFlag(""-l"");","Create the branch's reflog. This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as ""branchname@{yesterday}"".",1
2792,"private void InitializeComponent()
{
this._lblText = new System.Windows.Forms.Label();
this._picImage = new System.Windows.Forms.PictureBox();
((System.ComponentModel.ISupportInitialize)(this._picImage)).BeginInit();
this.SuspendLayout();
// // _lblText
// this._lblText.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lblText.AutoSize = true;
this._lblText.Cursor = System.Windows.Forms.Cursors.Hand;
this._lblText.Location = new System.Drawing.Point(27, 0);
this._lblText.Name = ""_lblText"";
this._lblText.Size = new System.Drawing.Size(41, 13);
this._lblText.TabIndex = 1;
this._lblText.Text = ""[TEXT]"";
this._lblText.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
this._lblText.Click += new System.EventHandler(this.OnTextLabelClick);
this._lblText.MouseEnter += new System.EventHandler(this.OnInteractivePartMouseEnter);
this._lblText.MouseLeave += new System.EventHandler(this.OnInteractivePartMouseLeave);
// // _picImage
// this._picImage.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left)));
this._picImage.Cursor = System.Windows.Forms.Cursors.Hand;
this._picImage.Location = new System.Drawing.Point(0, 0);
this._picImage.Margin = new System.Windows.Forms.Padding(0);
this._picImage.Name = ""_picImage"";
this._picImage.Size = new System.Drawing.Size(24, 26);
this._picImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
this._picImage.TabIndex = 0;
this._picImage.TabStop = false;
this._picImage.Click += new System.EventHandler(this.OnImageClick);
this._picImage.MouseEnter += new System.EventHandler(this.OnInteractivePartMouseEnter);
this._picImage.MouseLeave += new System.EventHandler(this.OnInteractivePartMouseLeave);
// // LinkButton
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.Controls.Add(this._lblText);
this.Controls.Add(this._picImage);
this.Name = ""LinkButton"";
this.Size = new System.Drawing.Size(256, 26);
((System.ComponentModel.ISupportInitialize)(this._picImage)).EndInit();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2793,"public static ICommandArgument FirstParent()
{
return new CommandFlag(""--first-parent"");
}",Follow only the first parent commit upon seeing a merge commit.,1
2794,"public static ICommandArgument Merges()
{
return new CommandFlag(""--merges"");
}",Print only merge commits.,1
2795,"public static ICommandArgument NoMerges()
{
return new CommandFlag(""--no-merges"");
}",Do not print commits with more than one parent.,1
2796,"public static ICommandArgument Follow()
{
return new CommandFlag(""--follow"");
}",Continue listing the history of a file beyond renames (works only for a single file).,1
2797,"public static ICommandArgument RemoveEmpty()
{
return new CommandFlag(""--remove-empty"");
}",Stop when a given path disappears from the tree.,1
2798,"public LogView(IWorkingEnvironment environment)
: base(LogViewFactory.Guid, environment)
{
Height = 200;
_logListBox = new LogListBox()
{
BorderStyle = BorderStyle.None,
Dock = DockStyle.Fill,
Parent = this,
};
Text = Resources.StrLog;
}",Initializes a new instance of the LogView class.,1
2799,"public static ICommandArgument Cached()
{
return new CommandFlag(""--cached"");
}",Show cached files in the output (default).,1
2800,"public static ICommandArgument Deleted()
{
return new CommandFlag(""--deleted"");
}",Show deleted files in the output.,1
2801,"public static ICommandArgument Modified()
{
return new CommandFlag(""--modified"");
}",Show modified files in the output.,1
2802,"public static ICommandArgument Others()
{
return new CommandFlag(""--others"");
}",Show other files in the output.,1
2803,"public static ICommandArgument Stage()
{
return new CommandFlag(""--stage"");
}","Show staged contents' object name, mode bits and stage number in the output.",1
2804,"public static ICommandArgument Directory()
{
return new CommandFlag(""--directory"");
}","If a whole directory is classified as ""other"", show just its name (with a trailing slash) and not its whole contents.",1
2805,"public static ICommandArgument Killed()
{
return new CommandFlag(""--killed"");
}",Show files on the filesystem that need to be removed due to file/directory conflicts for checkout-index to succeed.,1
2806,"public static ICommandArgument ExcludeStandard()
{
return new CommandFlag(""--exclude-standard"");
}","Add the standard git exclusions: .git/info/exclude, .gitignore in each directory, and the user's global exclusion file.",1
2807,"public static ICommandArgument ErrorUnmatch()
{
return new CommandFlag(""--error-unmatch"");
}","If any file does not appear in the index, treat this as an error (return 1).",1
2808,"public static ICommandArgument ShowStatus()
{
return new CommandFlag(""-t"");
}",Identify the file status with tags (followed by a space) at the start of each line.,1
2809,"public static ICommandArgument FullName()
{
return new CommandFlag(""--full-name"");
}","When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.",1
2810,"public static ICommandArgument NoMoreOptions()
{
return CommandFlag.NoMoreOptions();
}",Do not interpret any more arguments as options.,1
2811,"private void InitializeComponent()
{
this._lblField = new System.Windows.Forms.Label();
this._lblPrompt = new System.Windows.Forms.Label();
this._txtPassword = new System.Windows.Forms.TextBox();
this._btnCancel = new System.Windows.Forms.Button();
this._btnOk = new System.Windows.Forms.Button();
this._pnlContainer = new System.Windows.Forms.Panel();
this.pictureBox1 = new System.Windows.Forms.PictureBox();
this._pnlLine = new System.Windows.Forms.Panel();
this._pnlContainer.SuspendLayout();
((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
this.SuspendLayout();
// // _lblField
// this._lblField.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this._lblField.AutoSize = true;
this._lblField.Location = new System.Drawing.Point(49, 51);
this._lblField.Name = ""_lblField"";
this._lblField.Size = new System.Drawing.Size(56, 13);
this._lblField.TabIndex = 0;
this._lblField.Text = ""Password:"";
// // _lblPrompt
// this._lblPrompt.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lblPrompt.Location = new System.Drawing.Point(49, 12);
this._lblPrompt.Name = ""_lblPrompt"";
this._lblPrompt.Size = new System.Drawing.Size(341, 33);
this._lblPrompt.TabIndex = 1;
this._lblPrompt.Text = ""Requested operation requires your password."";
// // _txtPassword
// this._txtPassword.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtPassword.Location = new System.Drawing.Point(111, 48);
this._txtPassword.Name = ""_txtPassword"";
this._txtPassword.PasswordChar = '*';
this._txtPassword.Size = new System.Drawing.Size(279, 20);
this._txtPassword.TabIndex = 2;
this._txtPassword.UseSystemPasswordChar = true;
// // _btnCancel
// this._btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
this._btnCancel.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnCancel.Location = new System.Drawing.Point(321, 91);
this._btnCancel.Name = ""_btnCancel"";
this._btnCancel.Size = new System.Drawing.Size(75, 23);
this._btnCancel.TabIndex = 8;
this._btnCancel.Text = ""Cancel"";
this._btnCancel.UseVisualStyleBackColor = true;
this._btnCancel.Click += new System.EventHandler(this._btnCancel_Click);
// // _btnOk
// this._btnOk.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._btnOk.DialogResult = System.Windows.Forms.DialogResult.OK;
this._btnOk.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnOk.Location = new System.Drawing.Point(240, 91);
this._btnOk.Name = ""_btnOk"";
this._btnOk.Size = new System.Drawing.Size(75, 23);
this._btnOk.TabIndex = 6;
this._btnOk.Text = ""OK"";
this._btnOk.UseVisualStyleBackColor = true;
this._btnOk.Click += new System.EventHandler(this._btnOk_Click);
// // _pnlContainer
// this._pnlContainer.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlContainer.BackColor = System.Drawing.SystemColors.Window;
this._pnlContainer.Controls.Add(this.pictureBox1);
this._pnlContainer.Controls.Add(this._pnlLine);
this._pnlContainer.Controls.Add(this._lblPrompt);
this._pnlContainer.Controls.Add(this._lblField);
this._pnlContainer.Controls.Add(this._txtPassword);
this._pnlContainer.Location = new System.Drawing.Point(1, 0);
this._pnlContainer.Name = ""_pnlContainer"";
this._pnlContainer.Size = new System.Drawing.Size(402, 83);
this._pnlContainer.TabIndex = 5;
// // pictureBox1
// this.pictureBox1.Image = global::gitter.Properties.Resources.ImgLock;
this.pictureBox1.Location = new System.Drawing.Point(11, 12);
this.pictureBox1.Name = ""pictureBox1"";
this.pictureBox1.Size = new System.Drawing.Size(32, 32);
this.pictureBox1.TabIndex = 9;
this.pictureBox1.TabStop = false;
// // _pnlLine
// this._pnlLine.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlLine.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(223)))), ((int)(((byte)(223)))), ((int)(((byte)(223)))));
this._pnlLine.Location = new System.Drawing.Point(0, 82);
this._pnlLine.Name = ""_pnlLine"";
this._pnlLine.Size = new System.Drawing.Size(402, 1);
this._pnlLine.TabIndex = 1;
// // MainForm
// this.AcceptButton = this._btnOk;
this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.CancelButton = this._btnCancel;
this.ClientSize = new System.Drawing.Size(403, 122);
this.Controls.Add(this._btnCancel);
this.Controls.Add(this._btnOk);
this.Controls.Add(this._pnlContainer);
this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
this.MaximizeBox = false;
this.MinimizeBox = false;
this.Name = ""MainForm"";
this.ShowIcon = false;
this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
this.Text = ""gitter"";
this._pnlContainer.ResumeLayout(false);
this._pnlContainer.PerformLayout();
((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2812,"private void InitializeComponent()
{
System.Windows.Forms.ToolStripSeparator _separator1;
System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
this._toolStripContainer = new System.Windows.Forms.ToolStripContainer();
this._statusStrip = new System.Windows.Forms.StatusStrip();
this._statusSeparator = new System.Windows.Forms.ToolStripStatusLabel();
this._toolDockGrid = new gitter.Framework.Controls.ViewDockGrid();
this._menuStrip = new System.Windows.Forms.MenuStrip();
this._mnuRepository = new System.Windows.Forms.ToolStripMenuItem();
this._mnuOpenRepository = new System.Windows.Forms.ToolStripMenuItem();
this._mnuRecentRepositories = new System.Windows.Forms.ToolStripMenuItem();
this._mnuDummy = new System.Windows.Forms.ToolStripMenuItem();
this._mnuExit = new System.Windows.Forms.ToolStripMenuItem();
this._mnuView = new System.Windows.Forms.ToolStripMenuItem();
this._mnuToolbars = new System.Windows.Forms.ToolStripMenuItem();
this._mnuTools = new System.Windows.Forms.ToolStripMenuItem();
this._mnuOptions = new System.Windows.Forms.ToolStripMenuItem();
this._mnuHelp = new System.Windows.Forms.ToolStripMenuItem();
this._mnuAbout = new System.Windows.Forms.ToolStripMenuItem();
_separator1 = new System.Windows.Forms.ToolStripSeparator();
this._toolStripContainer.BottomToolStripPanel.SuspendLayout();
this._toolStripContainer.ContentPanel.SuspendLayout();
this._toolStripContainer.TopToolStripPanel.SuspendLayout();
this._toolStripContainer.SuspendLayout();
this._statusStrip.SuspendLayout();
this._menuStrip.SuspendLayout();
this.SuspendLayout();
// // _separator1
// _separator1.Name = ""_separator1"";
_separator1.Size = new System.Drawing.Size(172, 6);
// // _toolStripContainer
// // // _toolStripContainer.BottomToolStripPanel
// this._toolStripContainer.BottomToolStripPanel.Controls.Add(this._statusStrip);
// // _toolStripContainer.ContentPanel
// this._toolStripContainer.ContentPanel.Controls.Add(this._toolDockGrid);
this._toolStripContainer.ContentPanel.RenderMode = System.Windows.Forms.ToolStripRenderMode.ManagerRenderMode;
this._toolStripContainer.ContentPanel.Size = new System.Drawing.Size(795, 450);
this._toolStripContainer.Dock = System.Windows.Forms.DockStyle.Fill;
this._toolStripContainer.Location = new System.Drawing.Point(0, 0);
this._toolStripContainer.Name = ""_toolStripContainer"";
this._toolStripContainer.Size = new System.Drawing.Size(795, 496);
this._toolStripContainer.TabIndex = 6;
this._toolStripContainer.Text = ""toolStripContainer1"";
// // _toolStripContainer.TopToolStripPanel
// this._toolStripContainer.TopToolStripPanel.Controls.Add(this._menuStrip);
// // _statusStrip
// this._statusStrip.Dock = System.Windows.Forms.DockStyle.None;
this._statusStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
this._statusSeparator});
this._statusStrip.LayoutStyle = System.Windows.Forms.ToolStripLayoutStyle.HorizontalStackWithOverflow;
this._statusStrip.Location = new System.Drawing.Point(0, 0);
this._statusStrip.Name = ""_statusStrip"";
this._statusStrip.RenderMode = System.Windows.Forms.ToolStripRenderMode.ManagerRenderMode;
this._statusStrip.Size = new System.Drawing.Size(795, 22);
this._statusStrip.TabIndex = 0;
// // _statusSeparator
// this._statusSeparator.Name = ""_statusSeparator"";
this._statusSeparator.Size = new System.Drawing.Size(0, 17);
this._statusSeparator.Spring = true;
// // _toolDockGrid
// this._toolDockGrid.Dock = System.Windows.Forms.DockStyle.Fill;
this._toolDockGrid.Location = new System.Drawing.Point(0, 0);
this._toolDockGrid.Name = ""_toolDockGrid"";
this._toolDockGrid.Size = new System.Drawing.Size(795, 450);
this._toolDockGrid.TabIndex = 0;
// // _menuStrip
// this._menuStrip.Dock = System.Windows.Forms.DockStyle.None;
this._menuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
this._mnuRepository,
this._mnuView,
this._mnuTools,
this._mnuHelp});
this._menuStrip.Location = new System.Drawing.Point(0, 0);
this._menuStrip.Name = ""_menuStrip"";
this._menuStrip.Size = new System.Drawing.Size(795, 24);
this._menuStrip.TabIndex = 0;
// // _mnuRepository
// this._mnuRepository.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
this._mnuOpenRepository,
this._mnuRecentRepositories,
_separator1,
this._mnuExit});
this._mnuRepository.Name = ""_mnuRepository"";
this._mnuRepository.Size = new System.Drawing.Size(95, 20);
this._mnuRepository.Text = ""%Repository%"";
// // _mnuOpenRepository
// this._mnuOpenRepository.Image = global::gitter.Properties.Resources.ImgRepositoryOpen;
this._mnuOpenRepository.Name = ""_mnuOpenRepository"";
this._mnuOpenRepository.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.O)));
this._mnuOpenRepository.Size = new System.Drawing.Size(175, 22);
this._mnuOpenRepository.Text = ""%Open%..."";
this._mnuOpenRepository.Click += new System.EventHandler(this._mnuOpen_Click);
// // _mnuRecentRepositories
// this._mnuRecentRepositories.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
this._mnuDummy});
this._mnuRecentRepositories.Name = ""_mnuRecentRepositories"";
this._mnuRecentRepositories.Size = new System.Drawing.Size(175, 22);
this._mnuRecentRepositories.Text = ""%Recent%"";
// // _mnuDummy
// this._mnuDummy.Enabled = false;
this._mnuDummy.Name = ""_mnuDummy"";
this._mnuDummy.Size = new System.Drawing.Size(153, 22);
this._mnuDummy.Text = ""<no available>"";
// // _mnuExit
// this._mnuExit.Name = ""_mnuExit"";
this._mnuExit.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Alt | System.Windows.Forms.Keys.F4)));
this._mnuExit.Size = new System.Drawing.Size(175, 22);
this._mnuExit.Text = ""%Exit%"";
this._mnuExit.Click += new System.EventHandler(this._mnuExit_Click);
// // _mnuView
// this._mnuView.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
this._mnuToolbars});
this._mnuView.Name = ""_mnuView"";
this._mnuView.Size = new System.Drawing.Size(64, 20);
this._mnuView.Text = ""%View%"";
// // _mnuToolbars
// this._mnuToolbars.Enabled = false;
this._mnuToolbars.Name = ""_mnuToolbars"";
this._mnuToolbars.Size = new System.Drawing.Size(140, 22);
this._mnuToolbars.Text = ""%Toolbars%"";
// // _mnuTools
// this._mnuTools.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
this._mnuOptions});
this._mnuTools.Name = ""_mnuTools"";
this._mnuTools.Size = new System.Drawing.Size(68, 20);
this._mnuTools.Text = ""%Tools%"";
// // _mnuOptions
// this._mnuOptions.Name = ""_mnuOptions"";
this._mnuOptions.Size = new System.Drawing.Size(145, 22);
this._mnuOptions.Text = ""%Options%..."";
this._mnuOptions.Click += new System.EventHandler(this._mnuOptions_Click);
// // _mnuHelp
// this._mnuHelp.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
this._mnuAbout});
this._mnuHelp.Name = ""_mnuHelp"";
this._mnuHelp.Size = new System.Drawing.Size(64, 20);
this._mnuHelp.Text = ""%Help%"";
// // _mnuAbout
// this._mnuAbout.Name = ""_mnuAbout"";
this._mnuAbout.Size = new System.Drawing.Size(136, 22);
this._mnuAbout.Text = ""%About%..."";
this._mnuAbout.Click += new System.EventHandler(this._mnuAbout_Click);
// // MainForm
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.ClientSize = new System.Drawing.Size(795, 496);
this.Controls.Add(this._toolStripContainer);
this.Icon = ((System.Drawing.Icon)(resources.GetObject(""$this.Icon"")));
this.MainMenuStrip = this._menuStrip;
this.Name = ""MainForm"";
this.Text = ""gitter"";
this._toolStripContainer.BottomToolStripPanel.ResumeLayout(false);
this._toolStripContainer.BottomToolStripPanel.PerformLayout();
this._toolStripContainer.ContentPanel.ResumeLayout(false);
this._toolStripContainer.TopToolStripPanel.ResumeLayout(false);
this._toolStripContainer.TopToolStripPanel.PerformLayout();
this._toolStripContainer.ResumeLayout(false);
this._toolStripContainer.PerformLayout();
this._statusStrip.ResumeLayout(false);
this._statusStrip.PerformLayout();
this._menuStrip.ResumeLayout(false);
this._menuStrip.PerformLayout();
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2813,"private void InitializeComponent()
{
System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
this._btnCancel = new System.Windows.Forms.Button();
this._updateProgress = new System.Windows.Forms.ProgressBar();
this._lblStage = new System.Windows.Forms.Label();
this._pnlContainer = new System.Windows.Forms.Panel();
this._pnlLine = new System.Windows.Forms.Panel();
this._pnlContainer.SuspendLayout();
this.SuspendLayout();
// // _btnCancel
// this._btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
this._btnCancel.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnCancel.Location = new System.Drawing.Point(371, 84);
this._btnCancel.Name = ""_btnCancel"";
this._btnCancel.Size = new System.Drawing.Size(75, 23);
this._btnCancel.TabIndex = 0;
this._btnCancel.Text = ""Cancel"";
this._btnCancel.UseVisualStyleBackColor = true;
this._btnCancel.Click += new System.EventHandler(this.OnCancelClick);
// // _updateProgress
// this._updateProgress.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._updateProgress.Location = new System.Drawing.Point(15, 33);
this._updateProgress.Name = ""_updateProgress"";
this._updateProgress.Size = new System.Drawing.Size(426, 23);
this._updateProgress.TabIndex = 1;
// // _lblStage
// this._lblStage.AutoSize = true;
this._lblStage.Location = new System.Drawing.Point(12, 14);
this._lblStage.Margin = new System.Windows.Forms.Padding(3, 0, 3, 3);
this._lblStage.Name = ""_lblStage"";
this._lblStage.Size = new System.Drawing.Size(0, 13);
this._lblStage.TabIndex = 2;
// // _pnlContainer
// this._pnlContainer.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlContainer.BackColor = System.Drawing.SystemColors.Window;
this._pnlContainer.Controls.Add(this._pnlLine);
this._pnlContainer.Controls.Add(this._lblStage);
this._pnlContainer.Controls.Add(this._updateProgress);
this._pnlContainer.Location = new System.Drawing.Point(0, 0);
this._pnlContainer.Margin = new System.Windows.Forms.Padding(0);
this._pnlContainer.Name = ""_pnlContainer"";
this._pnlContainer.Size = new System.Drawing.Size(455, 76);
this._pnlContainer.TabIndex = 3;
// // _pnlLine
// this._pnlLine.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlLine.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(223)))), ((int)(((byte)(223)))), ((int)(((byte)(223)))));
this._pnlLine.Location = new System.Drawing.Point(0, 75);
this._pnlLine.Name = ""_pnlLine"";
this._pnlLine.Size = new System.Drawing.Size(455, 1);
this._pnlLine.TabIndex = 1;
// // MainForm
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.CancelButton = this._btnCancel;
this.ClientSize = new System.Drawing.Size(453, 115);
this.Controls.Add(this._pnlContainer);
this.Controls.Add(this._btnCancel);
this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
this.Icon = ((System.Drawing.Icon)(resources.GetObject(""$this.Icon"")));
this.MaximizeBox = false;
this.Name = ""MainForm"";
this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
this.Text = ""gitter Update"";
this._pnlContainer.ResumeLayout(false);
this._pnlContainer.PerformLayout();
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2814,"private void InitializeComponent()
{
this._pnlOptions = new System.Windows.Forms.Panel();
this._chkNoFF = new System.Windows.Forms.CheckBox();
this._chkNoCommit = new System.Windows.Forms.CheckBox();
this._grpOptions = new gitter.Framework.Controls.GroupSeparator();
this._chkSquash = new System.Windows.Forms.CheckBox();
this._lnkAutoFormat = new System.Windows.Forms.LinkLabel();
this._lblMessage = new System.Windows.Forms.Label();
this._txtMessage = new System.Windows.Forms.TextBox();
this._lblMergeWith = new System.Windows.Forms.Label();
this._references = new gitter.Git.Gui.Controls.ReferencesListBox();
this._pnlOptions.SuspendLayout();
this.SuspendLayout();
// // _pnlOptions
// this._pnlOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlOptions.Controls.Add(this._chkNoFF);
this._pnlOptions.Controls.Add(this._chkNoCommit);
this._pnlOptions.Controls.Add(this._grpOptions);
this._pnlOptions.Controls.Add(this._chkSquash);
this._pnlOptions.Location = new System.Drawing.Point(228, 270);
this._pnlOptions.Name = ""_pnlOptions"";
this._pnlOptions.Size = new System.Drawing.Size(411, 86);
this._pnlOptions.TabIndex = 14;
// // _chkNoFF
// this._chkNoFF.AutoSize = true;
this._chkNoFF.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkNoFF.Location = new System.Drawing.Point(13, 25);
this._chkNoFF.Name = ""_chkNoFF"";
this._chkNoFF.Size = new System.Drawing.Size(136, 20);
this._chkNoFF.TabIndex = 4;
this._chkNoFF.Text = ""%No fast-forward%"";
this._chkNoFF.UseVisualStyleBackColor = true;
// // _chkNoCommit
// this._chkNoCommit.AutoSize = true;
this._chkNoCommit.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkNoCommit.Location = new System.Drawing.Point(13, 45);
this._chkNoCommit.Name = ""_chkNoCommit"";
this._chkNoCommit.Size = new System.Drawing.Size(113, 20);
this._chkNoCommit.TabIndex = 5;
this._chkNoCommit.Text = ""%No commit%"";
this._chkNoCommit.UseVisualStyleBackColor = true;
// // _grpOptions
// this._grpOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpOptions.Location = new System.Drawing.Point(0, 0);
this._grpOptions.Name = ""_grpOptions"";
this._grpOptions.Size = new System.Drawing.Size(411, 19);
this._grpOptions.TabIndex = 0;
this._grpOptions.Text = ""%Options%"";
// // _chkSquash
// this._chkSquash.AutoSize = true;
this._chkSquash.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkSquash.Location = new System.Drawing.Point(13, 65);
this._chkSquash.Name = ""_chkSquash"";
this._chkSquash.Size = new System.Drawing.Size(90, 20);
this._chkSquash.TabIndex = 6;
this._chkSquash.Text = ""%Squash%"";
this._chkSquash.UseVisualStyleBackColor = true;
// // _lnkAutoFormat
// this._lnkAutoFormat.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
this._lnkAutoFormat.Location = new System.Drawing.Point(484, 0);
this._lnkAutoFormat.Name = ""_lnkAutoFormat"";
this._lnkAutoFormat.Size = new System.Drawing.Size(155, 15);
this._lnkAutoFormat.TabIndex = 3;
this._lnkAutoFormat.TabStop = true;
this._lnkAutoFormat.Text = ""%Auto%"";
this._lnkAutoFormat.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
this._lnkAutoFormat.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.OnAutoFormatLinkClicked);
// // _lblMessage
// this._lblMessage.AutoSize = true;
this._lblMessage.Location = new System.Drawing.Point(228, 0);
this._lblMessage.Name = ""_lblMessage"";
this._lblMessage.Size = new System.Drawing.Size(76, 15);
this._lblMessage.TabIndex = 11;
this._lblMessage.Text = ""%Message%:"";
// // _txtMessage
// this._txtMessage.AcceptsReturn = true;
this._txtMessage.AcceptsTab = true;
this._txtMessage.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtMessage.Location = new System.Drawing.Point(231, 18);
this._txtMessage.Multiline = true;
this._txtMessage.Name = ""_txtMessage"";
this._txtMessage.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
this._txtMessage.Size = new System.Drawing.Size(408, 246);
this._txtMessage.TabIndex = 2;
this._txtMessage.WordWrap = false;
// // _lblMergeWith
// this._lblMergeWith.AutoSize = true;
this._lblMergeWith.Location = new System.Drawing.Point(0, 0);
this._lblMergeWith.Name = ""_lblMergeWith"";
this._lblMergeWith.Size = new System.Drawing.Size(90, 15);
this._lblMergeWith.TabIndex = 7;
this._lblMergeWith.Text = ""%Merge with%:"";
// // _references
// this._references.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left)));
this._references.ForeColor = System.Drawing.SystemColors.WindowText;
this._references.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._references.ItemActivation = gitter.Framework.Controls.ItemActivation.SingleClick;
this._references.Location = new System.Drawing.Point(3, 18);
this._references.Name = ""_references"";
this._references.ShowTreeLines = true;
this._references.Size = new System.Drawing.Size(222, 338);
this._references.TabIndex = 1;
// // MergeDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._pnlOptions);
this.Controls.Add(this._lblMessage);
this.Controls.Add(this._txtMessage);
this.Controls.Add(this._lblMergeWith);
this.Controls.Add(this._references);
this.Controls.Add(this._lnkAutoFormat);
this.Name = ""MergeDialog"";
this.Size = new System.Drawing.Size(642, 359);
this._pnlOptions.ResumeLayout(false);
this._pnlOptions.PerformLayout();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2815,"private void InitializeComponent()
{
this.SuspendLayout();
// // MergeToolDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Name = ""MergeToolDialog"";
this.Size = new System.Drawing.Size(556, 353);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2816,"private void InitializeComponent()
{
this._pnlContainer = new System.Windows.Forms.Panel();
this._lblMessage = new System.Windows.Forms.Label();
this._picIcon = new System.Windows.Forms.PictureBox();
this.panel1 = new System.Windows.Forms.Panel();
this._pnlContainer.SuspendLayout();
((System.ComponentModel.ISupportInitialize)(this._picIcon)).BeginInit();
this.SuspendLayout();
// // _pnlContainer
// this._pnlContainer.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlContainer.BackColor = System.Drawing.SystemColors.Window;
this._pnlContainer.Controls.Add(this._lblMessage);
this._pnlContainer.Controls.Add(this._picIcon);
this._pnlContainer.Controls.Add(this.panel1);
this._pnlContainer.Location = new System.Drawing.Point(0, 0);
this._pnlContainer.Name = ""_pnlContainer"";
this._pnlContainer.Size = new System.Drawing.Size(481, 137);
this._pnlContainer.TabIndex = 0;
// // _lblMessage
// this._lblMessage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lblMessage.Location = new System.Drawing.Point(62, 26);
this._lblMessage.Name = ""_lblMessage"";
this._lblMessage.Size = new System.Drawing.Size(386, 84);
this._lblMessage.TabIndex = 4;
// // _picIcon
// this._picIcon.Location = new System.Drawing.Point(25, 26);
this._picIcon.Name = ""_picIcon"";
this._picIcon.Size = new System.Drawing.Size(32, 32);
this._picIcon.TabIndex = 3;
this._picIcon.TabStop = false;
this._picIcon.Paint += new System.Windows.Forms.PaintEventHandler(this.OnIconPaint);
// // panel1
// this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.panel1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(223)))), ((int)(((byte)(223)))), ((int)(((byte)(223)))));
this.panel1.Location = new System.Drawing.Point(0, 136);
this.panel1.Name = ""panel1"";
this.panel1.Size = new System.Drawing.Size(481, 1);
this.panel1.TabIndex = 2;
// // MessageBoxForm
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.ClientSize = new System.Drawing.Size(481, 176);
this.Controls.Add(this._pnlContainer);
this.Font = new System.Drawing.Font(""Segoe UI"", 9F);
this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
this.KeyPreview = true;
this.MaximizeBox = false;
this.MinimizeBox = false;
this.Name = ""MessageBoxForm"";
this.ShowIcon = false;
this.ShowInTaskbar = false;
this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
this.Text = ""MessageBoxForm"";
this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.MessageBoxForm_KeyDown);
this._pnlContainer.ResumeLayout(false);
((System.ComponentModel.ISupportInitialize)(this._picIcon)).EndInit();
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2817,"public static ICommandArgument DryRun()
{
return CommandFlag.DryRun();
}",Do nothing; only show what would happen.,0
2818,"private void InitializeComponent()
{
this._lstNews = new gitter.Redmine.Gui.ListBoxes.NewsListBox();
this.SuspendLayout();
// // _lstIssues
// this._lstNews.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstNews.Location = new System.Drawing.Point(0, 0);
this._lstNews.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._lstNews.Name = ""_lstNews"";
this._lstNews.Size = new System.Drawing.Size(615, 407);
this._lstNews.TabIndex = 0;
this._lstNews.Text = ""No news to display"";
// // IssuesView
// this.Controls.Add(this._lstNews);
this.Name = ""NewsView"";
this.Size = new System.Drawing.Size(615, 407);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2819,"private void InitializeComponent()
{
this.SuspendLayout();
// // NotificationBase
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.BackColor = System.Drawing.SystemColors.Window;
this.Name = ""NotificationBase"";
this.Size = new System.Drawing.Size(345, 156);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2820,"private void InitializeComponent()
{
this.SuspendLayout();
// // NotificationForm
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.BackColor = System.Drawing.SystemColors.Window;
this.ClientSize = new System.Drawing.Size(284, 262);
this.ControlBox = false;
this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
this.Name = ""NotificationForm"";
this.ShowIcon = false;
this.ShowInTaskbar = false;
this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2821,"private void InvertOrder()
{
var items = Items.Count;
var arr = new T[items];
RaiseChanging(0, items - 1, NotifyEvent.Clear);
Items.CopyTo(arr, 0);
Items.Clear();
RaiseChanged(0, items, NotifyEvent.Clear);
RaiseChanging(0, items - 1, NotifyEvent.Insert);
for(int i = items - 1; i >= 0; --i)
{
Items.Add(arr[i]);
}
RaiseChanged(0, items - 1, NotifyEvent.Insert);
}",Inverts item order in collection.,1
2822,"public void NotifyCanceled()
{
Verify.State.IsTrue(IsInitialized);
var eof = _eof;
if(eof != null)
{
_eof = null;
eof.Dispose();
}
}","Reader should still receive bytes, but disable any stream processing.",1
2823,"public void WaitForEndOfStream()
{
Verify.State.IsTrue(IsInitialized);
var eof = _eof;
if(eof != null)
{
try
{
var test = eof.WaitOne(0);
eof.WaitOne();
eof.Dispose();
}
catch(ObjectDisposedException)
{
}
}
_stream = null;
_eof = null;
}",Waits for outpuit stream end.,1
2824,"private void InitializeComponent()
{
this._lstOptions = new gitter.Framework.Options.OptionsListBox();
this._pnlPageContainer = new System.Windows.Forms.Panel();
this.SuspendLayout();
// // _lstOptions
// this._lstOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)));
this._lstOptions.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstOptions.ItemActivation = gitter.Framework.Controls.ItemActivation.SingleClick;
this._lstOptions.Location = new System.Drawing.Point(3, 3);
this._lstOptions.Name = ""_lstOptions"";
this._lstOptions.ShowTreeLines = true;
this._lstOptions.Size = new System.Drawing.Size(162, 375);
this._lstOptions.TabIndex = 0;
this._lstOptions.ItemActivated += new System.EventHandler<gitter.Framework.Controls.ItemEventArgs>(this.OnItemActivated);
// // _pnlPageContainer
// this._pnlPageContainer.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._pnlPageContainer.Location = new System.Drawing.Point(171, 3);
this._pnlPageContainer.Name = ""_pnlPageContainer"";
this._pnlPageContainer.Size = new System.Drawing.Size(445, 375);
this._pnlPageContainer.TabIndex = 1;
// // OptionsDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._pnlPageContainer);
this.Controls.Add(this._lstOptions);
this.Name = ""OptionsDialog"";
this.Size = new System.Drawing.Size(619, 381);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2825,"public static ICommandArgument All()
{
return new CommandFlag(""--all"");
}","The command by default packs all tags and refs that are already packed, and leaves other refs alone. This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes branch tips to be packed as well. Useful for a repository with many branches of historical interests.",1
2826,"public static ICommandArgument NoPrune()
{
return new CommandFlag(""--no-prune"");
}",The command usually removes loose refs under $GIT_DIR/refs hierarchy after packing them. This option tells it not to.,1
2827,"public void FindSpaceAndSkip()
{
int pos = _string.IndexOf(' ', _position);
if(pos == -1)
_position = _string.Length;
else
_position = pos + 1;
}",Find next space character.,1
2828,"public void SkipLine()
{
int pos = _string.IndexOf('\n', _position);
if(pos == -1)
{
_position = _string.Length;
}
else
{
_position = pos + 1;
}
}",Skip current line.,1
2829,"public override void RefreshContent()
{
if(InvokeRequired)
{
BeginInvoke(new MethodInvoker(ReloadRevisionLog));
}
else
{
ReloadRevisionLog();
}
}",Refreshes the content.,1
2830,"public void Show(Control control, Rectangle area)
{
Verify.Argument.IsNotNull(control, nameof(control));
SetOwnerItem(control);
_resizableTop = _resizableLeft = false;
var location = control.PointToScreen(new Point(area.Left, area.Top + area.Height));
var screen = Screen.FromControl(control).WorkingArea;
if(location.X + Size.Width > (screen.Left + screen.Width))
{
_resizableLeft = true;
location.X = (screen.Left + screen.Width) - Size.Width;
}
if(location.Y + Size.Height > (screen.Top + screen.Height))
{
_resizableTop = true;
location.Y -= Size.Height + area.Height;
}
location = control.PointToClient(location);
Show(control, location, ToolStripDropDownDirection.BelowRight);
}","When there is no space below specified area, the pop-up control is shown above it.",1
2831,"private void InitializeComponent()
{
components = new System.ComponentModel.Container();
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2832,"static void Main()
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new MainForm());
}",The main entry point for the application.,1
2833,"static void Main()
{
var cmdline = new CommandLine();
bool singleInstance;
Semaphore s = null;
if(!cmdline.IsDefined(""forcenewinstance""))
{
s = new Semaphore(0, 1, ""gitter-updater"", out singleInstance);
}
else
{
singleInstance = true;
}
try
{
if(singleInstance)
{
var driverName = cmdline[""driver""];
if(!string.IsNullOrEmpty(driverName))
{
var driver = UpdateDrivers.FirstOrDefault(d => d.Name == driverName);
if(driver != null)
{
var process = driver.CreateProcess(cmdline);
if(process != null)
{
if(cmdline.IsDefined(""hidden""))
{
var monitor = new UpdateProcessMonitor();
process.Update(monitor);
}
else
{
Application.EnableVisualStyles();
Application.SetCompatibleTextRenderingDefault(false);
Application.Run(new MainForm(process));
}
}
}
}
}
}
finally
{
if(s != null)
{
s.Dispose();
}
}
}",The main entry point for the application.,1
2834,"private static void Main()
{
bool isFirstInstance;
using(var mutex = new Mutex(true, ""gitter-uac-instance"", out isFirstInstance))
{
if(isFirstInstance)
{
var args = Environment.GetCommandLineArgs();
if(args == null || args.Length < 2 || args[1] != ""--remoting"")
return;
ChannelServices.RegisterChannel(
new IpcChannel(
new Dictionary<string, string>
{
{ ""portName"", RemotingChannelName }
},
new BinaryClientFormatterSinkProvider(),
new BinaryServerFormatterSinkProvider()
{
TypeFilterLevel = System.Runtime.Serialization.Formatters.TypeFilterLevel.Full,
}),
false);
RemotingConfiguration.RegisterWellKnownServiceType(
typeof(RemoteExecutor), RemotingObjectName, WellKnownObjectMode.Singleton);
_executor = (RemoteExecutor)Activator.GetObject(typeof(RemoteExecutor),
string.Format(@""ipc://{0}/{1}"", RemotingChannelName, RemotingObjectName));
_executor.ExitEvent.WaitOne();
_executor.ExitEvent.Close();
}
}
}",The main entry point for the application.,1
2835,"public static void SetStyleEx(this ProgressBar progressBar, ProgressBarStyleEx style)
{
Verify.Argument.IsNotNull(progressBar, nameof(progressBar));
const uint TDM_SET_PROGRESS_BAR_STATE = 0x400 + 16;
User32.SendMessage(progressBar.Handle, TDM_SET_PROGRESS_BAR_STATE, (IntPtr)style, (IntPtr)0);
}",WinVista+ required.,0
2836,"public void SetProgressIndeterminate()
{
if(!IsDisposed)
{
if(InvokeRequired)
{
try
{
BeginInvoke(new Action(SetProgressIndeterminateCore));
}
catch(ObjectDisposedException)
{
}
}
else
{
SetProgressIndeterminateCore();
}
}
}",Sets progress as unknown.,1
2837,"public void ProcessCompleted()
{
_context = null;
if(!IsDisposed)
{
if(InvokeRequired)
{
try
{
BeginInvoke(new Action(ProcessCompleted));
}
catch(ObjectDisposedException)
{
}
}
else
{
Close();
}
}
}",Notifies that action is completed or cancelled and monitor must be shut down.,1
2838,"private void InitializeComponent()
{
this.panel1 = new System.Windows.Forms.Panel();
this._btnCancel = new System.Windows.Forms.Button();
this._pnlLine = new System.Windows.Forms.Panel();
this._progressBar = new System.Windows.Forms.ProgressBar();
this._lblAction = new System.Windows.Forms.Label();
this._pnlContainer = new System.Windows.Forms.Panel();
this.panel1.SuspendLayout();
this._pnlContainer.SuspendLayout();
this.SuspendLayout();
// // panel1
// this.panel1.Controls.Add(this._btnCancel);
this.panel1.Dock = System.Windows.Forms.DockStyle.Bottom;
this.panel1.Location = new System.Drawing.Point(0, 64);
this.panel1.Name = ""panel1"";
this.panel1.Size = new System.Drawing.Size(389, 40);
this.panel1.TabIndex = 4;
// // _btnCancel
// this._btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
this._btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
this._btnCancel.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnCancel.Location = new System.Drawing.Point(307, 9);
this._btnCancel.Name = ""_btnCancel"";
this._btnCancel.Size = new System.Drawing.Size(75, 23);
this._btnCancel.TabIndex = 3;
this._btnCancel.Text = ""Cancel"";
this._btnCancel.UseVisualStyleBackColor = true;
this._btnCancel.Click += new System.EventHandler(this.OnCancelClick);
// // _pnlLine
// this._pnlLine.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlLine.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(223)))), ((int)(((byte)(223)))), ((int)(((byte)(223)))));
this._pnlLine.Location = new System.Drawing.Point(0, 64);
this._pnlLine.Name = ""_pnlLine"";
this._pnlLine.Size = new System.Drawing.Size(389, 1);
this._pnlLine.TabIndex = 2;
// // _progressBar
// this._progressBar.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._progressBar.Location = new System.Drawing.Point(12, 31);
this._progressBar.Name = ""_progressBar"";
this._progressBar.Size = new System.Drawing.Size(365, 18);
this._progressBar.TabIndex = 0;
// // _lblAction
// this._lblAction.AutoSize = true;
this._lblAction.Location = new System.Drawing.Point(10, 10);
this._lblAction.Name = ""_lblAction"";
this._lblAction.Size = new System.Drawing.Size(48, 13);
this._lblAction.TabIndex = 1;
this._lblAction.Text = ""<action>"";
// // _pnlContainer
// this._pnlContainer.BackColor = System.Drawing.SystemColors.Window;
this._pnlContainer.Controls.Add(this._pnlLine);
this._pnlContainer.Controls.Add(this._lblAction);
this._pnlContainer.Controls.Add(this._progressBar);
this._pnlContainer.Dock = System.Windows.Forms.DockStyle.Top;
this._pnlContainer.Location = new System.Drawing.Point(0, 0);
this._pnlContainer.Name = ""_pnlContainer"";
this._pnlContainer.Size = new System.Drawing.Size(389, 65);
this._pnlContainer.TabIndex = 3;
// // ProgressForm
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.CancelButton = this._btnCancel;
this.ClientSize = new System.Drawing.Size(389, 104);
this.ControlBox = false;
this.Controls.Add(this._pnlContainer);
this.Controls.Add(this.panel1);
this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
this.MaximizeBox = false;
this.MinimizeBox = false;
this.Name = ""ProgressForm"";
this.ShowIcon = false;
this.ShowInTaskbar = false;
this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
this.Text = ""Progress"";
this.panel1.ResumeLayout(false);
this._pnlContainer.ResumeLayout(false);
this._pnlContainer.PerformLayout();
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2839,"private void InitializeComponent()
{
this._lblServiceUri = new System.Windows.Forms.Label();
this._txtServiceUri = new System.Windows.Forms.TextBox();
this._lblApiKey = new System.Windows.Forms.Label();
this._lblProject = new System.Windows.Forms.Label();
this._cmbProject = new System.Windows.Forms.ComboBox();
this._txtApiKey = new System.Windows.Forms.TextBox();
this.SuspendLayout();
// // _lblServiceUri
// this._lblServiceUri.AutoSize = true;
this._lblServiceUri.Location = new System.Drawing.Point(0, 6);
this._lblServiceUri.Name = ""_lblServiceUri"";
this._lblServiceUri.Size = new System.Drawing.Size(71, 15);
this._lblServiceUri.TabIndex = 0;
this._lblServiceUri.Text = ""Service URL:"";
// // _txtServiceUri
// this._txtServiceUri.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtServiceUri.Location = new System.Drawing.Point(94, 3);
this._txtServiceUri.MinimumSize = new System.Drawing.Size(4, 23);
this._txtServiceUri.Name = ""_txtServiceUri"";
this._txtServiceUri.Size = new System.Drawing.Size(303, 23);
this._txtServiceUri.TabIndex = 0;
// // _lblApiKey
// this._lblApiKey.AutoSize = true;
this._lblApiKey.Location = new System.Drawing.Point(0, 35);
this._lblApiKey.Name = ""_lblApiKey"";
this._lblApiKey.Size = new System.Drawing.Size(50, 15);
this._lblApiKey.TabIndex = 2;
this._lblApiKey.Text = ""API Key:"";
// // _lblProject
// this._lblProject.AutoSize = true;
this._lblProject.Location = new System.Drawing.Point(0, 64);
this._lblProject.Name = ""_lblProject"";
this._lblProject.Size = new System.Drawing.Size(47, 15);
this._lblProject.TabIndex = 3;
this._lblProject.Text = ""Project:"";
// // _cmbProject
// this._cmbProject.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._cmbProject.FormattingEnabled = true;
this._cmbProject.Location = new System.Drawing.Point(94, 61);
this._cmbProject.Name = ""_cmbProject"";
this._cmbProject.Size = new System.Drawing.Size(303, 23);
this._cmbProject.TabIndex = 2;
// // _txtApiKey
// this._txtApiKey.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtApiKey.Location = new System.Drawing.Point(94, 32);
this._txtApiKey.MinimumSize = new System.Drawing.Size(4, 23);
this._txtApiKey.Name = ""_txtApiKey"";
this._txtApiKey.Size = new System.Drawing.Size(303, 23);
this._txtApiKey.TabIndex = 1;
// // ProviderSetupControl
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.Controls.Add(this._cmbProject);
this.Controls.Add(this._lblProject);
this.Controls.Add(this._lblApiKey);
this.Controls.Add(this._txtApiKey);
this.Controls.Add(this._txtServiceUri);
this.Controls.Add(this._lblServiceUri);
this.Name = ""ProviderSetupControl"";
this.Size = new System.Drawing.Size(400, 87);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2840,"private void InitializeComponent()
{
this._lblServiceUri = new System.Windows.Forms.Label();
this._txtServiceUri = new System.Windows.Forms.TextBox();
this._lblUsername = new System.Windows.Forms.Label();
this._lblProject = new System.Windows.Forms.Label();
this._cmbProject = new System.Windows.Forms.ComboBox();
this._txtUsername = new System.Windows.Forms.TextBox();
this._txtPassword = new System.Windows.Forms.TextBox();
this._lblPassword = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _lblServiceUri
// this._lblServiceUri.AutoSize = true;
this._lblServiceUri.Location = new System.Drawing.Point(0, 6);
this._lblServiceUri.Name = ""_lblServiceUri"";
this._lblServiceUri.Size = new System.Drawing.Size(71, 15);
this._lblServiceUri.TabIndex = 0;
this._lblServiceUri.Text = ""Service URL:"";
// // _txtServiceUri
// this._txtServiceUri.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtServiceUri.Location = new System.Drawing.Point(94, 3);
this._txtServiceUri.MinimumSize = new System.Drawing.Size(4, 23);
this._txtServiceUri.Name = ""_txtServiceUri"";
this._txtServiceUri.Size = new System.Drawing.Size(303, 23);
this._txtServiceUri.TabIndex = 0;
// // _lblUsername
// this._lblUsername.AutoSize = true;
this._lblUsername.Location = new System.Drawing.Point(0, 35);
this._lblUsername.Name = ""_lblUsername"";
this._lblUsername.Size = new System.Drawing.Size(63, 15);
this._lblUsername.TabIndex = 2;
this._lblUsername.Text = ""Username:"";
// // _lblProject
// this._lblProject.AutoSize = true;
this._lblProject.Location = new System.Drawing.Point(0, 93);
this._lblProject.Name = ""_lblProject"";
this._lblProject.Size = new System.Drawing.Size(47, 15);
this._lblProject.TabIndex = 3;
this._lblProject.Text = ""Project:"";
// // _cmbProject
// this._cmbProject.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._cmbProject.FormattingEnabled = true;
this._cmbProject.Location = new System.Drawing.Point(94, 90);
this._cmbProject.Name = ""_cmbProject"";
this._cmbProject.Size = new System.Drawing.Size(303, 23);
this._cmbProject.TabIndex = 3;
// // _txtUsername
// this._txtUsername.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtUsername.Location = new System.Drawing.Point(94, 32);
this._txtUsername.MinimumSize = new System.Drawing.Size(4, 23);
this._txtUsername.Name = ""_txtUsername"";
this._txtUsername.Size = new System.Drawing.Size(303, 23);
this._txtUsername.TabIndex = 1;
// // _txtPassword
// this._txtPassword.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtPassword.Location = new System.Drawing.Point(94, 61);
this._txtPassword.MinimumSize = new System.Drawing.Size(4, 23);
this._txtPassword.Name = ""_txtPassword"";
this._txtPassword.Size = new System.Drawing.Size(303, 23);
this._txtPassword.TabIndex = 2;
this._txtPassword.UseSystemPasswordChar = true;
// // _lblPassword
// this._lblPassword.AutoSize = true;
this._lblPassword.Location = new System.Drawing.Point(0, 64);
this._lblPassword.Name = ""_lblPassword"";
this._lblPassword.Size = new System.Drawing.Size(60, 15);
this._lblPassword.TabIndex = 2;
this._lblPassword.Text = ""Password:"";
// // ProviderSetupControl
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Dpi;
this.Controls.Add(this._cmbProject);
this.Controls.Add(this._lblProject);
this.Controls.Add(this._lblPassword);
this.Controls.Add(this._lblUsername);
this.Controls.Add(this._txtPassword);
this.Controls.Add(this._txtUsername);
this.Controls.Add(this._txtServiceUri);
this.Controls.Add(this._lblServiceUri);
this.Name = ""ProviderSetupControl"";
this.Size = new System.Drawing.Size(400, 117);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2841,"private void InitializeComponent()
{
this._pnlOptions = new System.Windows.Forms.Panel();
this._pnlWarning = new System.Windows.Forms.Panel();
this._lblUseWithCaution = new System.Windows.Forms.Label();
this._picWarning = new System.Windows.Forms.PictureBox();
this._grpOptions = new gitter.Framework.Controls.GroupSeparator();
this._chkUseThinPack = new System.Windows.Forms.CheckBox();
this._chkForceOverwriteBranches = new System.Windows.Forms.CheckBox();
this._chkSendTags = new System.Windows.Forms.CheckBox();
this._lblBranches = new System.Windows.Forms.Label();
this._remotePicker = new gitter.Git.Gui.Controls.RemotePicker();
this._lstReferences = new gitter.Git.Gui.Controls.ReferencesListBox();
this._grpPushTo = new gitter.Framework.Controls.GroupSeparator();
this._pnlPushTo = new System.Windows.Forms.Panel();
this._txtUrl = new System.Windows.Forms.TextBox();
this._radUrl = new System.Windows.Forms.RadioButton();
this._radRemote = new System.Windows.Forms.RadioButton();
this._pnlOptions.SuspendLayout();
this._pnlWarning.SuspendLayout();
((System.ComponentModel.ISupportInitialize)(this._picWarning)).BeginInit();
this._pnlPushTo.SuspendLayout();
this.SuspendLayout();
// // _pnlOptions
// this._pnlOptions.Controls.Add(this._pnlWarning);
this._pnlOptions.Controls.Add(this._grpOptions);
this._pnlOptions.Controls.Add(this._chkUseThinPack);
this._pnlOptions.Controls.Add(this._chkForceOverwriteBranches);
this._pnlOptions.Controls.Add(this._chkSendTags);
this._pnlOptions.Location = new System.Drawing.Point(0, 290);
this._pnlOptions.Name = ""_pnlOptions"";
this._pnlOptions.Size = new System.Drawing.Size(382, 89);
this._pnlOptions.TabIndex = 20;
// // _pnlWarning
// this._pnlWarning.BackColor = System.Drawing.SystemColors.Info;
this._pnlWarning.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
this._pnlWarning.Controls.Add(this._lblUseWithCaution);
this._pnlWarning.Controls.Add(this._picWarning);
this._pnlWarning.ForeColor = System.Drawing.SystemColors.InfoText;
this._pnlWarning.Location = new System.Drawing.Point(229, 24);
this._pnlWarning.Name = ""_pnlWarning"";
this._pnlWarning.Size = new System.Drawing.Size(153, 20);
this._pnlWarning.TabIndex = 6;
this._pnlWarning.Visible = false;
// // _lblUseWithCaution
// this._lblUseWithCaution.AutoSize = true;
this._lblUseWithCaution.Location = new System.Drawing.Point(17, 3);
this._lblUseWithCaution.Name = ""_lblUseWithCaution"";
this._lblUseWithCaution.Size = new System.Drawing.Size(115, 15);
this._lblUseWithCaution.TabIndex = 1;
this._lblUseWithCaution.Text = ""%Use with caution%"";
// // _picWarning
// this._picWarning.Location = new System.Drawing.Point(1, 1);
this._picWarning.Name = ""_picWarning"";
this._picWarning.Size = new System.Drawing.Size(16, 16);
this._picWarning.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
this._picWarning.TabIndex = 0;
this._picWarning.TabStop = false;
// // _grpOptions
// this._grpOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpOptions.Location = new System.Drawing.Point(0, 0);
this._grpOptions.Name = ""_grpOptions"";
this._grpOptions.Size = new System.Drawing.Size(382, 19);
this._grpOptions.TabIndex = 0;
this._grpOptions.Text = ""%Options%"";
// // _chkUseThinPack
// this._chkUseThinPack.AutoSize = true;
this._chkUseThinPack.Checked = true;
this._chkUseThinPack.CheckState = System.Windows.Forms.CheckState.Checked;
this._chkUseThinPack.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkUseThinPack.Location = new System.Drawing.Point(13, 45);
this._chkUseThinPack.Name = ""_chkUseThinPack"";
this._chkUseThinPack.Size = new System.Drawing.Size(123, 20);
this._chkUseThinPack.TabIndex = 6;
this._chkUseThinPack.Text = ""%Use thin pack%"";
this._chkUseThinPack.UseVisualStyleBackColor = true;
// // _chkForceOverwriteBranches
// this._chkForceOverwriteBranches.AutoSize = true;
this._chkForceOverwriteBranches.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkForceOverwriteBranches.Location = new System.Drawing.Point(13, 25);
this._chkForceOverwriteBranches.Name = ""_chkForceOverwriteBranches"";
this._chkForceOverwriteBranches.Size = new System.Drawing.Size(225, 20);
this._chkForceOverwriteBranches.TabIndex = 5;
this._chkForceOverwriteBranches.Text = ""%Force overwrite remote branches%"";
this._chkForceOverwriteBranches.UseVisualStyleBackColor = true;
this._chkForceOverwriteBranches.CheckedChanged += new System.EventHandler(this.OnForceOverwriteCheckedChanged);
// // _chkSendTags
// this._chkSendTags.AutoSize = true;
this._chkSendTags.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkSendTags.Location = new System.Drawing.Point(13, 65);
this._chkSendTags.Name = ""_chkSendTags"";
this._chkSendTags.Size = new System.Drawing.Size(103, 20);
this._chkSendTags.TabIndex = 7;
this._chkSendTags.Text = ""%Send tags%"";
this._chkSendTags.UseVisualStyleBackColor = true;
// // _lblBranches
// this._lblBranches.AutoSize = true;
this._lblBranches.Location = new System.Drawing.Point(0, 0);
this._lblBranches.Name = ""_lblBranches"";
this._lblBranches.Size = new System.Drawing.Size(121, 15);
this._lblBranches.TabIndex = 2;
this._lblBranches.Text = ""%Branches to push%:"";
// // _remotePicker
// this._remotePicker.DrawMode = System.Windows.Forms.DrawMode.OwnerDrawFixed;
this._remotePicker.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
this._remotePicker.FormattingEnabled = true;
this._remotePicker.Location = new System.Drawing.Point(104, 24);
this._remotePicker.Name = ""_remotePicker"";
this._remotePicker.Size = new System.Drawing.Size(278, 23);
this._remotePicker.TabIndex = 2;
this._remotePicker.SelectedIndexChanged += new System.EventHandler(this.OnRemotePickerSelectedIndexChanged);
// // _lstReferences
// this._lstReferences.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstReferences.DisableContextMenus = true;
this._lstReferences.ForeColor = System.Drawing.SystemColors.WindowText;
this._lstReferences.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstReferences.Location = new System.Drawing.Point(3, 18);
this._lstReferences.Name = ""_lstReferences"";
this._lstReferences.ShowTreeLines = true;
this._lstReferences.Size = new System.Drawing.Size(379, 183);
this._lstReferences.TabIndex = 0;
// // _grpPushTo
// this._grpPushTo.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpPushTo.Location = new System.Drawing.Point(0, 0);
this._grpPushTo.Name = ""_grpPushTo"";
this._grpPushTo.Size = new System.Drawing.Size(382, 19);
this._grpPushTo.TabIndex = 0;
this._grpPushTo.Text = ""%Push to%"";
// // _pnlPushTo
// this._pnlPushTo.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._pnlPushTo.Controls.Add(this._txtUrl);
this._pnlPushTo.Controls.Add(this._radUrl);
this._pnlPushTo.Controls.Add(this._remotePicker);
this._pnlPushTo.Controls.Add(this._radRemote);
this._pnlPushTo.Controls.Add(this._grpPushTo);
this._pnlPushTo.Location = new System.Drawing.Point(0, 207);
this._pnlPushTo.Name = ""_pnlPushTo"";
this._pnlPushTo.Size = new System.Drawing.Size(382, 80);
this._pnlPushTo.TabIndex = 10;
// // _txtUrl
// this._txtUrl.Location = new System.Drawing.Point(104, 53);
this._txtUrl.Name = ""_txtUrl"";
this._txtUrl.Size = new System.Drawing.Size(278, 23);
this._txtUrl.TabIndex = 4;
this._txtUrl.TextChanged += new System.EventHandler(this.OnUrlTextChanged);
// // _radUrl
// this._radUrl.AutoSize = true;
this._radUrl.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radUrl.Location = new System.Drawing.Point(12, 54);
this._radUrl.Name = ""_radUrl"";
this._radUrl.Size = new System.Drawing.Size(72, 20);
this._radUrl.TabIndex = 3;
this._radUrl.Text = ""%URL%"";
this._radUrl.UseVisualStyleBackColor = true;
// // _radRemote
// this._radRemote.AutoSize = true;
this._radRemote.Checked = true;
this._radRemote.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radRemote.Location = new System.Drawing.Point(12, 26);
this._radRemote.Name = ""_radRemote"";
this._radRemote.Size = new System.Drawing.Size(92, 20);
this._radRemote.TabIndex = 1;
this._radRemote.TabStop = true;
this._radRemote.Text = ""%Remote%"";
this._radRemote.UseVisualStyleBackColor = true;
// // PushDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._pnlPushTo);
this.Controls.Add(this._pnlOptions);
this.Controls.Add(this._lblBranches);
this.Controls.Add(this._lstReferences);
this.Name = ""PushDialog"";
this.Size = new System.Drawing.Size(385, 379);
this._pnlOptions.ResumeLayout(false);
this._pnlOptions.PerformLayout();
this._pnlWarning.ResumeLayout(false);
this._pnlWarning.PerformLayout();
((System.ComponentModel.ISupportInitialize)(this._picWarning)).EndInit();
this._pnlPushTo.ResumeLayout(false);
this._pnlPushTo.PerformLayout();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2842,"internal virtual void NotifyRelogRecordAdded()
{
lock(_reflogSync)
{
if(_reflogRef != null)
{
var obj = _reflogRef.Target;
if(obj == null)
{
_reflogRef = null;
}
else
{
var reflog = (Reflog)obj;
reflog.NotifyRecordAdded();
}
}
}
}",Notifies about reflog modification.,1
2843,"private void InitializeComponent()
{
this._lstReferences = new gitter.Git.Gui.Controls.ReferencesListBox();
this.SuspendLayout();
// // _lstReferences
// this._lstReferences.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._lstReferences.Dock = System.Windows.Forms.DockStyle.Fill;
this._lstReferences.Location = new System.Drawing.Point(0, 0);
this._lstReferences.Name = ""_lstReferences"";
this._lstReferences.ShowTreeLines = true;
this._lstReferences.Size = new System.Drawing.Size(555, 362);
this._lstReferences.TabIndex = 1;
this._lstReferences.Text = ""referencesListBox1"";
// // ReferencesView
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lstReferences);
this.Name = ""ReferencesView"";
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2844,"public string FullName => _reference.FullName + ""@{"" + ReflogSelector + ""}"";",Returns full non-ambiguous revision name.,1
2845,"private void InitializeComponent()
{
this._lstReflog = new gitter.Git.Gui.Controls.ReflogListBox();
this.SuspendLayout();
// // _lstReflog
// this._lstReflog.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
| System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._lstReflog.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._lstReflog.Location = new System.Drawing.Point(0, 0);
this._lstReflog.Name = ""_lstReflog"";
this._lstReflog.Size = new System.Drawing.Size(555, 362);
this._lstReflog.TabIndex = 0;
this._lstReflog.Text = ""Reflog is empty"";
// // ReflogView
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lstReflog);
this.Name = ""ReflogView"";
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2846,"public void Refresh()
{
var refs = Repository.Accessor.QueryReferences.Invoke(
new QueryReferencesParameters(
ReferenceType.LocalBranch |
ReferenceType.RemoteBranch |
ReferenceType.Tag));
Heads.Refresh(refs.Heads);
Remotes.Refresh(refs.Remotes);
Tags.Refresh(refs.Tags);
}",Updates all cached references.,1
2847,"internal void Refresh(IEnumerable<BranchData> branches)
{
Verify.Argument.IsNotNull(branches, nameof(branches));
RefreshInternal(branches);
}",Refresh local branches.,1
2848,"public void Refresh()
{
var refs = Repository.Accessor.QueryBranches.Invoke(
new QueryBranchesParameters(QueryBranchRestriction.Local));
RefreshInternal(refs.Heads);
}",Refresh local branches.,1
2849,"public void Refresh()
{
var refs = Repository.Accessor.QueryBranches.Invoke(
new QueryBranchesParameters(QueryBranchRestriction.Remote));
RefreshInternal(refs.Remotes);
}",Refresh remote branches.,1
2850,"public void Refresh()
{
var tags = Repository.Accessor.QueryTags.Invoke(
new QueryTagsParameters());
RefreshInternal(tags);
}","Sync information on tags: removes non-existent, adds new, verifies positions.",1
2851,"public void Fetch()
{
Verify.State.IsNotDeleted(this);
RemotesUtility.FetchOrPull(Repository, this, false);
}",Download new objects from remote repository.,1
2852,"public Task FetchAsync(IProgress<OperationProgress> progress, CancellationToken cancellationToken)
{
Verify.State.IsNotDeleted(this);
return RemotesUtility.FetchOrPullAsync(Repository, this, false, progress, cancellationToken);
}",Download new objects from remote repository.,1
2853,"public void Pull()
{
Verify.State.IsNotDeleted(this);
RemotesUtility.FetchOrPull(Repository, this, true);
}",Download new objects from remote repository and merge tracking branches.,1
2854,"public Task PullAsync(IProgress<OperationProgress> progress, CancellationToken cancellationToken)
{
Verify.State.IsNotDeleted(this);
return RemotesUtility.FetchOrPullAsync(Repository, this, true, progress, cancellationToken);
}",Download new objects from remote repository and merge tracking branches.,1
2855,"public void Push(ICollection<Branch> branches, bool forceOverwrite, bool thinPack, bool sendTags)
{
Verify.State.IsNotDeleted(this);
Verify.Argument.IsValidRevisionPointerSequence(branches, Repository, ""branches"");
Verify.Argument.IsTrue(branches.Count != 0, ""branches"",
Resources.ExcCollectionMustContainAtLeastOneObject.UseAsFormat(""branch""));
var names = new List<string>(branches.Count);
foreach(var branch in branches)
{
names.Add(branch.Name);
}
IList<ReferencePushResult> res;
using(Repository.Monitor.BlockNotifications(
RepositoryNotifications.BranchChanged))
{
res = Repository.Accessor.Push.Invoke(
new PushParameters(Name, sendTags?PushMode.Tags:PushMode.Default, names)
{
Force = forceOverwrite,
ThinPack = thinPack,
});
}
bool changed = false;
for(int i = 0; i < res.Count; ++i)
{
if(res[i].Type != PushResultType.UpToDate && res[i].Type != PushResultType.Rejected)
{
changed = true;
break;
}
}
if(changed)
{
Repository.Refs.Remotes.Refresh();
}
}",Send local objects to remote repository.,1
2856,"public void Prune()
{
Verify.State.IsNotDeleted(this);
var state1 = RefsState.Capture(Repository, ReferenceType.RemoteBranch);
using(Repository.Monitor.BlockNotifications(
RepositoryNotifications.BranchChanged))
{
var parameters = GetPruneParameters();
Repository.Accessor.PruneRemote.Invoke(parameters);
}
Repository.Refs.Remotes.Refresh();
var state2 = RefsState.Capture(Repository, ReferenceType.RemoteBranch);
var changes = RefsDiff.Calculate(state1, state2);
Repository.Remotes.OnPruneCompleted(this, changes);
}",Deletes all stale tracking branches.,1
2857,"public Task PruneAsync(IProgress<OperationProgress> progress, CancellationToken cancellationToken)
{
Verify.State.IsNotDeleted(this);
if(progress != null)
{
progress.Report(new OperationProgress(Resources.StrsSearchingStaleBranches.AddEllipsis()));
}
var state1 = RefsState.Capture(Repository, ReferenceType.RemoteBranch);
var block = Repository.Monitor.BlockNotifications(RepositoryNotifications.BranchChanged);
var parameters = GetPruneParameters();
return Repository.Accessor.PruneRemote.InvokeAsync(parameters, progress, cancellationToken)
.ContinueWith(
t =>
{
block.Dispose();
Repository.Refs.Remotes.Refresh();
var state2 = RefsState.Capture(Repository, ReferenceType.RemoteBranch);
var changes = RefsDiff.Calculate(state1, state2);
Repository.Remotes.OnPruneCompleted(this, changes);
TaskUtility.PropagateFaultedStates(t);
},
CancellationToken.None,
TaskContinuationOptions.ExecuteSynchronously,
TaskScheduler.Default);
}",Deletes all stale tracking branches.,1
2858,"public void DeleteFromRemote()
{
Verify.State.IsNotDeleted(this);
var remote = Remote;
if(remote == null) throw new GitException(string.Format(CultureInfo.InvariantCulture, ""Unable to find remote for branch '{0}'"", Name));
string branchName = Name.Substring(remote.Name.Length + 1);
string remoteRefName = GitConstants.LocalBranchPrefix + branchName;
using(Repository.Monitor.BlockNotifications(
RepositoryNotifications.BranchChanged))
{
Repository.Accessor.RemoveRemoteReferences.Invoke(
new AccessLayer.RemoveRemoteReferencesParameters(
remote.Name,
remoteRefName));
}
Refresh();
}",Delete branch from remote and local repository.,1
2859,"public Task DeleteFromRemoteAsync(CancellationToken cancellationToken)
{
Verify.State.IsNotDeleted(this);
var remote = Remote;
if(remote == null)
{
throw new GitException(string.Format(CultureInfo.InvariantCulture, ""Unable to find remote for branch '{0}'"", Name));
}
string branchName = Name.Substring(remote.Name.Length + 1);
string remoteRefName = GitConstants.LocalBranchPrefix + branchName;
var notificationsBlock = Repository.Monitor.BlockNotifications(
RepositoryNotifications.BranchChanged);
var parameters = new AccessLayer.RemoveRemoteReferencesParameters(
remote.Name, remoteRefName);
return
Repository.Accessor.RemoveRemoteReferences.InvokeAsync(parameters, null, cancellationToken)
.ContinueWith(t =>
{
notificationsBlock.Dispose();
TaskUtility.PropagateFaultedStates(t);
Refresh();
});
}",Delete branch from remote and local repository.,1
2860,"private void InitializeComponent()
{
this._radFetchNone = new System.Windows.Forms.RadioButton();
this._radFetchAll = new System.Windows.Forms.RadioButton();
this._radNormal = new System.Windows.Forms.RadioButton();
this._lblFetchTags = new System.Windows.Forms.Label();
this._lblUploadPack = new System.Windows.Forms.Label();
this._lblReceivePack = new System.Windows.Forms.Label();
this._lblVCS = new System.Windows.Forms.Label();
this._chkSkipFetchAll = new System.Windows.Forms.CheckBox();
this._chkMirror = new System.Windows.Forms.CheckBox();
this._grpOptions = new gitter.Framework.Controls.GroupSeparator();
this._grpUpdatedReferences = new gitter.Framework.Controls.GroupSeparator();
this._txtUploadPack = new System.Windows.Forms.TextBox();
this._txtReceivePack = new System.Windows.Forms.TextBox();
this._txtVCS = new System.Windows.Forms.TextBox();
this._txtProxy = new System.Windows.Forms.TextBox();
this._txtPushURL = new System.Windows.Forms.TextBox();
this._txtFetchURL = new System.Windows.Forms.TextBox();
this._lblProxy = new System.Windows.Forms.Label();
this._lblPushURL = new System.Windows.Forms.Label();
this._lblFetchURL = new System.Windows.Forms.Label();
this._lstUpdatedReferences = new gitter.Framework.Controls.CustomListBox();
this._btnAddRefspec = new System.Windows.Forms.Button();
this._lblRefspec = new System.Windows.Forms.Label();
this._txtRefspec = new System.Windows.Forms.TextBox();
this._radFetch = new System.Windows.Forms.RadioButton();
this._radPush = new System.Windows.Forms.RadioButton();
this.panel1 = new System.Windows.Forms.Panel();
this.panel1.SuspendLayout();
this.SuspendLayout();
// // _radFetchNone
// this._radFetchNone.AutoSize = true;
this._radFetchNone.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radFetchNone.Location = new System.Drawing.Point(272, 202);
this._radFetchNone.Name = ""_radFetchNone"";
this._radFetchNone.Size = new System.Drawing.Size(80, 20);
this._radFetchNone.TabIndex = 10;
this._radFetchNone.Text = ""%None%"";
this._radFetchNone.UseVisualStyleBackColor = true;
// // _radFetchAll
// this._radFetchAll.AutoSize = true;
this._radFetchAll.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radFetchAll.Location = new System.Drawing.Point(201, 202);
this._radFetchAll.Name = ""_radFetchAll"";
this._radFetchAll.Size = new System.Drawing.Size(65, 20);
this._radFetchAll.TabIndex = 9;
this._radFetchAll.Text = ""%All%"";
this._radFetchAll.UseVisualStyleBackColor = true;
// // _radNormal
// this._radNormal.AutoSize = true;
this._radNormal.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radNormal.Location = new System.Drawing.Point(106, 202);
this._radNormal.Name = ""_radNormal"";
this._radNormal.Size = new System.Drawing.Size(89, 20);
this._radNormal.TabIndex = 8;
this._radNormal.Text = ""%Default%"";
this._radNormal.UseVisualStyleBackColor = true;
// // _lblFetchTags
// this._lblFetchTags.AutoSize = true;
this._lblFetchTags.Location = new System.Drawing.Point(0, 204);
this._lblFetchTags.Name = ""_lblFetchTags"";
this._lblFetchTags.Size = new System.Drawing.Size(87, 15);
this._lblFetchTags.TabIndex = 10;
this._lblFetchTags.Text = ""%Fetch Tags%:"";
// // _lblUploadPack
// this._lblUploadPack.AutoSize = true;
this._lblUploadPack.Location = new System.Drawing.Point(0, 176);
this._lblUploadPack.Name = ""_lblUploadPack"";
this._lblUploadPack.Size = new System.Drawing.Size(96, 15);
this._lblUploadPack.TabIndex = 9;
this._lblUploadPack.Text = ""%Upload Pack%:"";
// // _lblReceivePack
// this._lblReceivePack.AutoSize = true;
this._lblReceivePack.Location = new System.Drawing.Point(0, 147);
this._lblReceivePack.Name = ""_lblReceivePack"";
this._lblReceivePack.Size = new System.Drawing.Size(98, 15);
this._lblReceivePack.TabIndex = 9;
this._lblReceivePack.Text = ""%Receive Pack%:"";
// // _lblVCS
// this._lblVCS.AutoSize = true;
this._lblVCS.Location = new System.Drawing.Point(0, 93);
this._lblVCS.Name = ""_lblVCS"";
this._lblVCS.Size = new System.Drawing.Size(51, 15);
this._lblVCS.TabIndex = 8;
this._lblVCS.Text = ""%VCS%:"";
// // _chkSkipFetchAll
// this._chkSkipFetchAll.AutoSize = true;
this._chkSkipFetchAll.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkSkipFetchAll.Location = new System.Drawing.Point(3, 251);
this._chkSkipFetchAll.Name = ""_chkSkipFetchAll"";
this._chkSkipFetchAll.Size = new System.Drawing.Size(119, 20);
this._chkSkipFetchAll.TabIndex = 12;
this._chkSkipFetchAll.Text = ""%Skip fetch all%"";
this._chkSkipFetchAll.UseVisualStyleBackColor = true;
// // _chkMirror
// this._chkMirror.AutoSize = true;
this._chkMirror.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkMirror.Location = new System.Drawing.Point(3, 226);
this._chkMirror.Name = ""_chkMirror"";
this._chkMirror.Size = new System.Drawing.Size(85, 20);
this._chkMirror.TabIndex = 11;
this._chkMirror.Text = ""%Mirror%"";
this._chkMirror.UseVisualStyleBackColor = true;
// // _grpOptions
// this._grpOptions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpOptions.Location = new System.Drawing.Point(0, 119);
this._grpOptions.Name = ""_grpOptions"";
this._grpOptions.Size = new System.Drawing.Size(397, 19);
this._grpOptions.TabIndex = 5;
this._grpOptions.Text = ""%Default Bahaviour%"";
// // _grpUpdatedReferences
// this._grpUpdatedReferences.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._grpUpdatedReferences.Location = new System.Drawing.Point(0, 0);
this._grpUpdatedReferences.Name = ""_grpUpdatedReferences"";
this._grpUpdatedReferences.Size = new System.Drawing.Size(397, 19);
this._grpUpdatedReferences.TabIndex = 4;
this._grpUpdatedReferences.Text = ""%Updated References%"";
// // _txtUploadPack
// this._txtUploadPack.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtUploadPack.Location = new System.Drawing.Point(106, 173);
this._txtUploadPack.Name = ""_txtUploadPack"";
this._txtUploadPack.Size = new System.Drawing.Size(291, 23);
this._txtUploadPack.TabIndex = 7;
// // _txtReceivePack
// this._txtReceivePack.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtReceivePack.Location = new System.Drawing.Point(106, 144);
this._txtReceivePack.Name = ""_txtReceivePack"";
this._txtReceivePack.Size = new System.Drawing.Size(291, 23);
this._txtReceivePack.TabIndex = 6;
// // _txtVCS
// this._txtVCS.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtVCS.Location = new System.Drawing.Point(106, 90);
this._txtVCS.Name = ""_txtVCS"";
this._txtVCS.Size = new System.Drawing.Size(291, 23);
this._txtVCS.TabIndex = 5;
// // _txtProxy
// this._txtProxy.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtProxy.Location = new System.Drawing.Point(106, 61);
this._txtProxy.Name = ""_txtProxy"";
this._txtProxy.Size = new System.Drawing.Size(291, 23);
this._txtProxy.TabIndex = 4;
// // _txtPushURL
// this._txtPushURL.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtPushURL.Location = new System.Drawing.Point(106, 32);
this._txtPushURL.Name = ""_txtPushURL"";
this._txtPushURL.Size = new System.Drawing.Size(291, 23);
this._txtPushURL.TabIndex = 3;
// // _txtFetchURL
// this._txtFetchURL.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._txtFetchURL.Location = new System.Drawing.Point(106, 3);
this._txtFetchURL.Name = ""_txtFetchURL"";
this._txtFetchURL.Size = new System.Drawing.Size(291, 23);
this._txtFetchURL.TabIndex = 2;
// // _lblProxy
// this._lblProxy.AutoSize = true;
this._lblProxy.Location = new System.Drawing.Point(0, 64);
this._lblProxy.Name = ""_lblProxy"";
this._lblProxy.Size = new System.Drawing.Size(59, 15);
this._lblProxy.TabIndex = 1;
this._lblProxy.Text = ""%Proxy%:"";
// // _lblPushURL
// this._lblPushURL.AutoSize = true;
this._lblPushURL.Location = new System.Drawing.Point(0, 35);
this._lblPushURL.Name = ""_lblPushURL"";
this._lblPushURL.Size = new System.Drawing.Size(80, 15);
this._lblPushURL.TabIndex = 1;
this._lblPushURL.Text = ""%Push URL%:"";
// // _lblFetchURL
// this._lblFetchURL.AutoSize = true;
this._lblFetchURL.Location = new System.Drawing.Point(0, 6);
this._lblFetchURL.Name = ""_lblFetchURL"";
this._lblFetchURL.Size = new System.Drawing.Size(83, 15);
this._lblFetchURL.TabIndex = 0;
this._lblFetchURL.Text = ""%Fetch URL%:"";
// // _lstUpdatedReferences
// this._lstUpdatedReferences.AllowColumnReorder = false;
this._lstUpdatedReferences.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstUpdatedReferences.ForeColor = System.Drawing.SystemColors.WindowText;
this._lstUpdatedReferences.Location = new System.Drawing.Point(3, 25);
this._lstUpdatedReferences.Multiselect = true;
this._lstUpdatedReferences.Name = ""_lstUpdatedReferences"";
this._lstUpdatedReferences.Size = new System.Drawing.Size(394, 100);
this._lstUpdatedReferences.TabIndex = 13;
// // _btnAddRefspec
// this._btnAddRefspec.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._btnAddRefspec.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._btnAddRefspec.Location = new System.Drawing.Point(322, 132);
this._btnAddRefspec.Name = ""_btnAddRefspec"";
this._btnAddRefspec.Size = new System.Drawing.Size(75, 23);
this._btnAddRefspec.TabIndex = 15;
this._btnAddRefspec.Text = ""%Add%"";
this._btnAddRefspec.UseVisualStyleBackColor = true;
this._btnAddRefspec.Click += new System.EventHandler(this._btnAddRefspec_Click);
// // _lblRefspec
// this._lblRefspec.AutoSize = true;
this._lblRefspec.Location = new System.Drawing.Point(0, 135);
this._lblRefspec.Name = ""_lblRefspec"";
this._lblRefspec.Size = new System.Drawing.Size(71, 15);
this._lblRefspec.TabIndex = 14;
this._lblRefspec.Text = ""%Refspec%:"";
// // _txtRefspec
// this._txtRefspec.Location = new System.Drawing.Point(106, 132);
this._txtRefspec.Name = ""_txtRefspec"";
this._txtRefspec.Size = new System.Drawing.Size(210, 23);
this._txtRefspec.TabIndex = 14;
// // _radFetch
// this._radFetch.AutoSize = true;
this._radFetch.Checked = true;
this._radFetch.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radFetch.Location = new System.Drawing.Point(106, 156);
this._radFetch.Name = ""_radFetch"";
this._radFetch.Size = new System.Drawing.Size(80, 20);
this._radFetch.TabIndex = 16;
this._radFetch.TabStop = true;
this._radFetch.Text = ""%Fetch%"";
this._radFetch.UseVisualStyleBackColor = true;
// // _radPush
// this._radPush.AutoSize = true;
this._radPush.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._radPush.Location = new System.Drawing.Point(186, 156);
this._radPush.Name = ""_radPush"";
this._radPush.Size = new System.Drawing.Size(77, 20);
this._radPush.TabIndex = 17;
this._radPush.TabStop = true;
this._radPush.Text = ""%Push%"";
this._radPush.UseVisualStyleBackColor = true;
// // panel1
// this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this.panel1.Controls.Add(this._grpUpdatedReferences);
this.panel1.Controls.Add(this._lstUpdatedReferences);
this.panel1.Controls.Add(this._btnAddRefspec);
this.panel1.Controls.Add(this._txtRefspec);
this.panel1.Controls.Add(this._lblRefspec);
this.panel1.Controls.Add(this._radPush);
this.panel1.Controls.Add(this._radFetch);
this.panel1.Location = new System.Drawing.Point(0, 274);
this.panel1.Margin = new System.Windows.Forms.Padding(0);
this.panel1.Name = ""panel1"";
this.panel1.Size = new System.Drawing.Size(397, 177);
this.panel1.TabIndex = 19;
// // RemotePropertiesDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this.panel1);
this.Controls.Add(this._radFetchNone);
this.Controls.Add(this._radFetchAll);
this.Controls.Add(this._radNormal);
this.Controls.Add(this._lblFetchTags);
this.Controls.Add(this._lblUploadPack);
this.Controls.Add(this._lblReceivePack);
this.Controls.Add(this._lblVCS);
this.Controls.Add(this._chkSkipFetchAll);
this.Controls.Add(this._chkMirror);
this.Controls.Add(this._grpOptions);
this.Controls.Add(this._txtUploadPack);
this.Controls.Add(this._txtReceivePack);
this.Controls.Add(this._txtVCS);
this.Controls.Add(this._txtProxy);
this.Controls.Add(this._txtPushURL);
this.Controls.Add(this._txtFetchURL);
this.Controls.Add(this._lblProxy);
this.Controls.Add(this._lblPushURL);
this.Controls.Add(this._lblFetchURL);
this.Name = ""RemotePropertiesDialog"";
this.Size = new System.Drawing.Size(400, 452);
this.panel1.ResumeLayout(false);
this.panel1.PerformLayout();
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2861,"public void Refresh()
{
var remotes = Repository.Accessor.QueryRemotes.Invoke(
new QueryRemotesParameters());
lock(SyncRoot)
{
CacheUpdater.UpdateObjectDictionary<Remote, RemoteData>(
ObjectStorage,
null,
null,
remotes,
remoteData => ObjectFactories.CreateRemote(Repository, remoteData),
ObjectFactories.UpdateRemote,
InvokeObjectAdded,
InvokeObjectRemoved,
true);
}
}","Sync information on remotes: removes non-existent, adds new, updates url.",1
2862,"public void PushTo(string url, ICollection<Branch> branches, bool forceOverwrite, bool thinPack, bool sendTags)
{
Verify.Argument.IsNeitherNullNorWhitespace(url, nameof(url));
Verify.Argument.IsValidRevisionPointerSequence(branches, Repository, nameof(branches));
Verify.Argument.IsTrue(branches.Count != 0, nameof(branches),
Resources.ExcCollectionMustContainAtLeastOneObject.UseAsFormat(""branch""));
var branchNames = new List<string>(branches.Count);
foreach(var branch in branches)
{
branchNames.Add(branch.Name);
}
IList<ReferencePushResult> res;
using(Repository.Monitor.BlockNotifications(
RepositoryNotifications.BranchChanged))
{
res = Repository.Accessor.Push.Invoke(
new PushParameters(url, sendTags ? PushMode.Tags : PushMode.Default, branchNames)
{
Force = forceOverwrite,
ThinPack = thinPack,
});
}
bool changed = false;
for(int i = 0; i < res.Count; ++i)
{
if(res[i].Type != PushResultType.UpToDate && res[i].Type != PushResultType.Rejected)
{
changed = true;
break;
}
}
if(changed)
{
Repository.Refs.Remotes.Refresh();
}
}",Send local objects to remote repository.,1
2863,"public Task PushToAsync(string url, ICollection<Branch> branches, bool forceOverwrite, bool thinPack, bool sendTags, IProgress<OperationProgress> progress, CancellationToken cancellationToken)
{
Verify.Argument.IsNeitherNullNorWhitespace(url, nameof(url));
return RemotesUtility.PushAsync(Repository, url, branches, forceOverwrite, thinPack, sendTags, progress, cancellationToken);
}",Send local objects to remote repository.,1
2864,"private void InitializeComponent()
{
this._lstRemotes = new gitter.Git.Gui.Controls.RemoteListBox();
this.SuspendLayout();
// // _lstRemotes
// this._lstRemotes.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._lstRemotes.Dock = System.Windows.Forms.DockStyle.Fill;
this._lstRemotes.Location = new System.Drawing.Point(0, 0);
this._lstRemotes.Margin = new System.Windows.Forms.Padding(0);
this._lstRemotes.Name = ""_lstRemotes"";
this._lstRemotes.Size = new System.Drawing.Size(555, 160);
this._lstRemotes.TabIndex = 1;
this._lstRemotes.Text = ""No Remotes"";
// // RemotesView
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lstRemotes);
this.Name = ""RemotesView"";
this.Size = new System.Drawing.Size(555, 160);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2865,"private void InitializeComponent()
{
this._lstRemoteReferences = new gitter.Git.Gui.Controls.RemoteReferencesListBox();
this.SuspendLayout();
// // _lstRemoteReferences
// this._lstRemoteReferences.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)));
this._lstRemoteReferences.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._lstRemoteReferences.ForeColor = System.Drawing.SystemColors.WindowText;
this._lstRemoteReferences.Location = new System.Drawing.Point(0, 0);
this._lstRemoteReferences.Name = ""_lstRemoteReferences"";
this._lstRemoteReferences.ShowTreeLines = true;
this._lstRemoteReferences.Size = new System.Drawing.Size(555, 362);
this._lstRemoteReferences.TabIndex = 0;
// // RemoteView
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lstRemoteReferences);
this.Name = ""RemoteView"";
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2866,"private void InitializeComponent()
{
this._cmdRemoveLocalOnly = new gitter.Framework.Controls.CommandLink();
this._cmdRemoveFromRemote = new gitter.Framework.Controls.CommandLink();
this._lblRemoveBranch = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _cmdRemoveLocalOnly
// this._cmdRemoveLocalOnly.Description = ""%Remove tracking branch from local repository without touching real branch on rem"" +
""ote repository%"";
this._cmdRemoveLocalOnly.Location = new System.Drawing.Point(15, 38);
this._cmdRemoveLocalOnly.Name = ""_cmdRemoveLocalOnly"";
this._cmdRemoveLocalOnly.Size = new System.Drawing.Size(319, 66);
this._cmdRemoveLocalOnly.TabIndex = 0;
this._cmdRemoveLocalOnly.Text = ""%Local repository only%"";
this._cmdRemoveLocalOnly.Click += new System.EventHandler(this.OnRemoveLocalOnlyClick);
// // _cmdRemoveFromRemote
// this._cmdRemoveFromRemote.Description = ""Remove branch from \'{0}\' and local repository (this is a potentially dangerous op"" +
""eration)"";
this._cmdRemoveFromRemote.Location = new System.Drawing.Point(15, 120);
this._cmdRemoveFromRemote.Name = ""_cmdRemoveFromRemote"";
this._cmdRemoveFromRemote.Size = new System.Drawing.Size(319, 66);
this._cmdRemoveFromRemote.TabIndex = 1;
this._cmdRemoveFromRemote.Text = ""%Local and remote repository%"";
this._cmdRemoveFromRemote.Click += new System.EventHandler(this.OnRemoveFromRemoteClick);
// // _lblRemoveBranch
// this._lblRemoveBranch.AutoSize = true;
this._lblRemoveBranch.Location = new System.Drawing.Point(12, 10);
this._lblRemoveBranch.Name = ""_lblRemoveBranch"";
this._lblRemoveBranch.Size = new System.Drawing.Size(165, 15);
this._lblRemoveBranch.TabIndex = 2;
this._lblRemoveBranch.Text = ""%Remove branch \'{0}\' from%:"";
// // RemoveRemoteBranchDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblRemoveBranch);
this.Controls.Add(this._cmdRemoveFromRemote);
this.Controls.Add(this._cmdRemoveLocalOnly);
this.Name = ""RemoveRemoteBranchDialog"";
this.Size = new System.Drawing.Size(350, 202);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2867,"private void InitializeComponent()
{
this._txtOldName = new System.Windows.Forms.TextBox();
this._txtNewName = new System.Windows.Forms.TextBox();
this._lblOldName = new System.Windows.Forms.Label();
this._lblNewName = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _txtOldName
// this._txtOldName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtOldName.Location = new System.Drawing.Point(94, 3);
this._txtOldName.Name = ""_txtOldName"";
this._txtOldName.ReadOnly = true;
this._txtOldName.Size = new System.Drawing.Size(288, 20);
this._txtOldName.TabIndex = 1;
// // _txtNewName
// this._txtNewName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtNewName.Location = new System.Drawing.Point(94, 29);
this._txtNewName.Name = ""_txtNewName"";
this._txtNewName.Size = new System.Drawing.Size(288, 20);
this._txtNewName.TabIndex = 0;
// // _lblOldName
// this._lblOldName.AutoSize = true;
this._lblOldName.Location = new System.Drawing.Point(0, 6);
this._lblOldName.Name = ""_lblOldName"";
this._lblOldName.Size = new System.Drawing.Size(60, 13);
this._lblOldName.TabIndex = 2;
this._lblOldName.Text = ""%Branch%:"";
// // _lblNewName
// this._lblNewName.AutoSize = true;
this._lblNewName.Location = new System.Drawing.Point(0, 32);
this._lblNewName.Name = ""_lblNewName"";
this._lblNewName.Size = new System.Drawing.Size(79, 13);
this._lblNewName.TabIndex = 3;
this._lblNewName.Text = ""%New Name%:"";
// // RenameBranchDialog
// this.Controls.Add(this._lblNewName);
this.Controls.Add(this._lblOldName);
this.Controls.Add(this._txtNewName);
this.Controls.Add(this._txtOldName);
this.Name = ""RenameBranchDialog"";
this.Size = new System.Drawing.Size(385, 53);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2868,"private void InitializeComponent()
{
this._lblNewName = new System.Windows.Forms.Label();
this._lblOldName = new System.Windows.Forms.Label();
this._txtNewName = new System.Windows.Forms.TextBox();
this._txtOldName = new System.Windows.Forms.TextBox();
this.SuspendLayout();
// // _lblNewName
// this._lblNewName.AutoSize = true;
this._lblNewName.Location = new System.Drawing.Point(0, 32);
this._lblNewName.Name = ""_lblNewName"";
this._lblNewName.Size = new System.Drawing.Size(79, 13);
this._lblNewName.TabIndex = 7;
this._lblNewName.Text = ""%New Name%:"";
// // _lblOldName
// this._lblOldName.AutoSize = true;
this._lblOldName.Location = new System.Drawing.Point(0, 6);
this._lblOldName.Name = ""_lblOldName"";
this._lblOldName.Size = new System.Drawing.Size(63, 13);
this._lblOldName.TabIndex = 6;
this._lblOldName.Text = ""%Remote%:"";
// // _txtNewName
// this._txtNewName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtNewName.Location = new System.Drawing.Point(94, 29);
this._txtNewName.Name = ""_txtNewName"";
this._txtNewName.Size = new System.Drawing.Size(288, 20);
this._txtNewName.TabIndex = 4;
// // _txtOldName
// this._txtOldName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._txtOldName.Location = new System.Drawing.Point(94, 3);
this._txtOldName.Name = ""_txtOldName"";
this._txtOldName.ReadOnly = true;
this._txtOldName.Size = new System.Drawing.Size(288, 20);
this._txtOldName.TabIndex = 5;
// // RenameRemoteDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblNewName);
this.Controls.Add(this._lblOldName);
this.Controls.Add(this._txtNewName);
this.Controls.Add(this._txtOldName);
this.Name = ""RenameRemoteDialog"";
this.Size = new System.Drawing.Size(385, 53);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2869,"public void GarbageCollect()
{
Verify.State.IsFalse(IsDisposed, ""Repository is disposed."");
var parameters = GetGarbageCollectParameters();
Accessor.GarbageCollect.Invoke(parameters);
}",Perform garbage collection.,1
2870,"public Task GarbageCollectAsync(IProgress<OperationProgress> progress)
{
Verify.State.IsFalse(IsDisposed, ""Repository is disposed."");
progress?.Report(new OperationProgress(Resources.StrOptimizingRepository.AddEllipsis()));
var parameters = GetGarbageCollectParameters();
return Accessor.GarbageCollect.InvokeAsync(parameters, progress, CancellationToken.None);
}",Perform garbage collection.,1
2871,"public void Dispose()
{
if(!IsDisposed)
{
GC.SuppressFinalize(this);
Dispose(true);
IsDisposed = true;
}
}","Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.",1
2872,"private void InitializeComponent()
{
this._lstRepositoryExplorer = new gitter.RepositoryExplorerListBox();
this.SuspendLayout();
// // _lstTools
// this._lstRepositoryExplorer.BorderStyle = System.Windows.Forms.BorderStyle.None;
this._lstRepositoryExplorer.Dock = System.Windows.Forms.DockStyle.Fill;
this._lstRepositoryExplorer.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._lstRepositoryExplorer.Location = new System.Drawing.Point(0, 0);
this._lstRepositoryExplorer.Name = ""_lstRepositoryExplorer"";
this._lstRepositoryExplorer.ShowTreeLines = true;
this._lstRepositoryExplorer.Size = new System.Drawing.Size(153, 449);
this._lstRepositoryExplorer.TabIndex = 0;
this._lstRepositoryExplorer.ItemActivated += new System.EventHandler<gitter.Framework.Controls.ItemEventArgs>(this.OnItemActivated);
// // ToolboxTool
// this.Controls.Add(this._lstRepositoryExplorer);
this.Name = ""ToolboxTool"";
this.Size = new System.Drawing.Size(153, 449);
this.ResumeLayout(false);
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2873,"protected override void OnListBoxAttached()
{
base.OnListBoxAttached();
if(Repository != null)
{
DataSource = new AsyncTreeDataSource(Repository.Head, Items, OnItemActivated, OnItemContextMenuRequested);
}
}",Called when item is attached to listbox.,1
2874,"protected override void OnListBoxDetached()
{
DataSource = null;
base.OnListBoxDetached();
}",Called when item is detached from listbox.,1
2875,"public static ICommandArgument Soft()
{
return new CommandFlag(""--soft"");
}","Does not touch the index file nor the working tree at all, but requires them to be in a good order. This leaves all your changed files ""Changes to be committed"", as git-status would put it",1
2876,"public static ICommandArgument Hard()
{
return new CommandFlag(""--hard"");
}","Matches the working tree and index to that of the tree being switched to. Any changes to tracked files in the working tree since ""commit"" are lost.",1
2877,"public static ICommandArgument Merge()
{
return new CommandFlag(""--merge"");
}","Resets the index to match the tree recorded by the named commit, and updates the files that are different between the named commit and the current commit in the working tree.",1
2878,"public static ICommandArgument Quiet()
{
return new CommandFlag(""-q"");
}","Be quiet, only report errors.",1
2879,"private void InitializeComponent()
{
this._chkDontShowAgain = new System.Windows.Forms.CheckBox();
this._btnCheckoutCommit = new gitter.Framework.Controls.CommandLink();
this._btnCheckoutBranch = new gitter.Framework.Controls.CommandLink();
this._references = new gitter.Git.Gui.Controls.ReferencesListBox();
this._lblSelectOther = new System.Windows.Forms.Label();
this.SuspendLayout();
// // _chkDontShowAgain
// this._chkDontShowAgain.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
this._chkDontShowAgain.AutoSize = true;
this._chkDontShowAgain.FlatStyle = System.Windows.Forms.FlatStyle.System;
this._chkDontShowAgain.Location = new System.Drawing.Point(16, 261);
this._chkDontShowAgain.Name = ""_chkDontShowAgain"";
this._chkDontShowAgain.Size = new System.Drawing.Size(256, 20);
this._chkDontShowAgain.TabIndex = 3;
this._chkDontShowAgain.Text = ""Don\'t ask again, always checkout commits"";
this._chkDontShowAgain.UseVisualStyleBackColor = true;
// // _btnCheckoutCommit
// this._btnCheckoutCommit.Description = ""This will detach HEAD and make you unable to create new commits, merge, revert, e"" +
""tc."";
this._btnCheckoutCommit.Location = new System.Drawing.Point(16, 16);
this._btnCheckoutCommit.Name = ""_btnCheckoutCommit"";
this._btnCheckoutCommit.Size = new System.Drawing.Size(319, 66);
this._btnCheckoutCommit.TabIndex = 0;
this._btnCheckoutCommit.Text = ""Checkout commit"";
this._btnCheckoutCommit.Click += new System.EventHandler(this._btnCheckoutCommit_Click);
// // _btnCheckoutBranch
// this._btnCheckoutBranch.Description = ""This will bring working tree to the same state, but HEAD will point to selected b"" +
""ranch."";
this._btnCheckoutBranch.Location = new System.Drawing.Point(16, 98);
this._btnCheckoutBranch.Name = ""_btnCheckoutBranch"";
this._btnCheckoutBranch.Size = new System.Drawing.Size(319, 66);
this._btnCheckoutBranch.TabIndex = 1;
this._btnCheckoutBranch.Text = ""Checkout \'%BRANCH NAME%\'"";
this._btnCheckoutBranch.Click += new System.EventHandler(this._btnCheckoutBranch_Click);
// // _references
// this._references.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
| System.Windows.Forms.AnchorStyles.Right)));
this._references.HeaderStyle = gitter.Framework.Controls.HeaderStyle.Hidden;
this._references.ItemActivation = gitter.Framework.Controls.ItemActivation.SingleClick;
this._references.Location = new System.Drawing.Point(16, 193);
this._references.Name = ""_references"";
this._references.ShowTreeLines = true;
this._references.Size = new System.Drawing.Size(319, 65);
this._references.TabIndex = 2;
this._references.ItemActivated += new System.EventHandler<gitter.Framework.Controls.ItemEventArgs>(this.OnItemActivated);
// // _lblSelectOther
// this._lblSelectOther.AutoSize = true;
this._lblSelectOther.Location = new System.Drawing.Point(13, 177);
this._lblSelectOther.Name = ""_lblSelectOther"";
this._lblSelectOther.Size = new System.Drawing.Size(112, 15);
this._lblSelectOther.TabIndex = 4;
this._lblSelectOther.Text = ""Select other branch:"";
// // ResolveCheckoutDialog
// this.AutoScaleDimensions = new System.Drawing.SizeF(96F, 96F);
this.Controls.Add(this._lblSelectOther);
this.Controls.Add(this._references);
this.Controls.Add(this._btnCheckoutBranch);
this.Controls.Add(this._btnCheckoutCommit);
this.Controls.Add(this._chkDontShowAgain);
this.Name = ""ResolveCheckoutDialog"";
this.Size = new System.Drawing.Size(350, 284);
this.ResumeLayout(false);
this.PerformLayout();
}",Required method for Designer support - do not modify the contents of this method with the code editor.,1
2880,internal static string StrAutodetect {,Looks up a localized string similar to Autodetect.,0
2881,internal static string StrBrowse {,Looks up a localized string similar to Browse.,0
2882,internal static string StrDownload {,Looks up a localized string similar to Download.,0
2883,internal static string StrFoundVersion {,Looks up a localized string similar to Found Version.,0
2884,internal static string StrInstall {,Looks up a localized string similar to Install.,0
2885,internal static string StrLatestVersion {,Looks up a localized string similar to Latest Version.,0
2886,internal static string StrlRestartRequired {,Looks up a localized string similar to restart required.,0
2887,internal static string StrlUnavailable {,Looks up a localized string similar to unavailable.,0
2888,internal static string StrPathToGitExe {,Looks up a localized string similar to Path to git.exe.,0
2889,internal static string StrProviderName {,Looks up a localized string similar to MSysGit command line interface.,0
2890,internal static string StrRefresh {,Looks up a localized string similar to Refresh.,0
2891,internal static string StrsAlwaysAutodetect {,Looks up a localized string similar to Always autodetect.,0
2892,internal static string StrsConnectingToRemoteHost {,Looks up a localized string similar to Connecting to remote host.,0
2893,internal static string StrsFallbackToAnsi {,Looks up a localized string similar to Fallback to ANSI codepage if UTF-8 fails to decode characters.,0
2894,internal static string StrsLogCLICalls {,Looks up a localized string similar to Log command line interface calls.,0
2895,internal static string StrsSearching {,Looks up a localized string similar to searching.,0
2896,internal static string StrsSpecifyManually {,Looks up a localized string similar to Specify manually.,0
2897,internal static string StrsUnknown {,Looks up a localized string similar to unknown.,0
2898,internal static string ErrCannotCreateHeadManually {,Looks up a localized string similar to You cannot create HEAD manually.,0
2899,internal static string ErrCherryPickIsNotPossibleWithConflicts {,Looks up a localized string similar to Unable to cherry-pick when you have unresolved conflicts. Resolve conflicts and try again..,0
2900,internal static string ErrCherryPickIsNotPossibleWithLocalChnges {,Looks up a localized string similar to Unable to cherry-pick when you have local changes. Commit or stash them and try again..,0
2901,internal static string ErrCleanFailed {,Looks up a localized string similar to Unable to clean.,0
2902,internal static string ErrEmailCannotBeEmpty {,Looks up a localized string similar to Email cannot be empty.,0
2903,internal static string ErrEmptyCommitMessage {,Looks up a localized string similar to Empty commit message.,0
2904,internal static string ErrEnterCommitMessage {,Looks up a localized string similar to You must enter a commit message.,0
2905,internal static string ErrEnterLongerCommitMessage {,Looks up a localized string similar to Enter at least {0} symbols as commit message.,0
2906,internal static string ErrFailedToAddNote {,Looks up a localized string similar to Unable to add note.,0
2907,internal static string ErrFailedToAddRemote {,Looks up a localized string similar to Unable to add remote.,0
2908,internal static string ErrFailedToAddSubmodule {,Looks up a localized string similar to Unable to add submodule.,0
2909,internal static string ErrFailedToApplyPatch {,Looks up a localized string similar to Unable to apply patch.,0
2910,internal static string ErrFailedToArchive {,Looks up a localized string similar to Unable to create archive.,0
2911,internal static string ErrFailedToCheckout {,Looks up a localized string similar to Unable to checkout '{0}'.,0
2912,internal static string ErrFailedToCherryPick {,Looks up a localized string similar to Unable to cherry-pick '{0}'.,0
2913,internal static string ErrFailedToClone {,Looks up a localized string similar to Unable to clone '{0}'.,0
2914,internal static string ErrFailedToCommit {,Looks up a localized string similar to Unable to commit.,0
2915,internal static string ErrFailedToCompressRepository {,Looks up a localized string similar to Unable to compress repository.,0
2916,internal static string ErrFailedToCreateBranch {,Looks up a localized string similar to Unable to create branch '{0}'.,0
2917,internal static string ErrFailedToCreateDirectory {,Looks up a localized string similar to Unable to create directory.,0
2918,internal static string ErrFailedToCreateTag {,Looks up a localized string similar to Unable to create tag '{0}'.,0
2919,internal static string ErrFailedToDeletePath {,Looks up a localized string similar to Unable to delete '{0}'.,0
2920,internal static string ErrFailedToFetch {,Looks up a localized string similar to Unable to fetch.,0
2921,internal static string ErrFailedToFetchFrom {,Looks up a localized string similar to Unable to fetch from '{0}'.,0
2922,internal static string ErrFailedToFormatPatch {,Looks up a localized string similar to Unable to format patch.,0
2923,internal static string ErrFailedToInit {,Looks up a localized string similar to Unable to init repository.,0
2924,internal static string ErrFailedToMerge {,Looks up a localized string similar to Unable to merge.,0
2925,internal static string ErrFailedToMergeWith {,Looks up a localized string similar to Unable to merge '{0}'.,0
2926,internal static string ErrFailedToPrune {,Looks up a localized string similar to Unable to prune '{0}'.,0
2927,internal static string ErrFailedToPull {,Looks up a localized string similar to Unable to pull.,0
2928,internal static string ErrFailedToPullFrom {,Looks up a localized string similar to Unable to pull from '{0}'.,0
2929,internal static string ErrFailedToRebase {,Looks up a localized string similar to Unable to rebase.,0
2930,internal static string ErrFailedToRemoveBranch {,Looks up a localized string similar to Unable to remove branch '{0}'.,0
2931,internal static string ErrFailedToRemoveBranchFrom {,Looks up a localized string similar to Unable to remove branch '{0}' from '{1}'.,0
2932,internal static string ErrFailedToRemoveRemote {,Looks up a localized string similar to Unable to remove remote '{0}'.,0
2933,internal static string ErrFailedToRemoveTag {,Looks up a localized string similar to Unable to remove tag '{0}'.,0
2934,internal static string ErrFailedToRenameBranch {,Looks up a localized string similar to Unable to rename branch '{0}'.,0
2935,internal static string ErrFailedToRenameRemote {,Looks up a localized string similar to Unable to rename remote '{0}'.,0
2936,internal static string ErrFailedToReset {,Looks up a localized string similar to Unable to reset.,0
2937,internal static string ErrFailedToResolve {,Looks up a localized string similar to Unable to apply conflict resolution.,0
2938,internal static string ErrFailedToResolveConflict {,Looks up a localized string similar to Unable to resolve conflict.,0
2939,internal static string ErrFailedToRevert {,Looks up a localized string similar to Unable to revert.,0
2940,internal static string ErrFailedToRevertPath {,Looks up a localized string similar to Unable to revert '{0}'.,0
2941,internal static string ErrFailedToRevertPaths {,Looks up a localized string similar to Unable to revert selected files..,0
2942,internal static string ErrFailedToRunMergeTool {,Looks up a localized string similar to Unable to run merge tool.,0
2943,internal static string ErrFailedToSavePatch {,Looks up a localized string similar to Unable to save patch.,0
2944,internal static string ErrFailedToSetParameter {,Looks up a localized string similar to Unable to set parameter value.,0
2945,internal static string ErrFailedToSetRemoteProperties {,Looks up a localized string similar to Unable to set remote parameters.,0
2946,internal static string ErrFailedToStage {,Looks up a localized string similar to Unable to stage.,0
2947,internal static string ErrFailedToStash {,Looks up a localized string similar to Unable to stash.,0
2948,internal static string ErrFailedToStashApply {,Looks up a localized string similar to Unable to apply stash.,0
2949,internal static string ErrFailedToStashApplyState {,Looks up a localized string similar to Unable to apply '{0}'.,0
2950,internal static string ErrFailedToStashClear {,Looks up a localized string similar to Unable to clear stash.,0
2951,internal static string ErrFailedToStashDrop {,Looks up a localized string similar to Unable to drop stashed changes.,0
2952,internal static string ErrFailedToStashDropState {,Looks up a localized string similar to Unable to drop '{0}'.,0
2953,internal static string ErrFailedToStashPop {,Looks up a localized string similar to Unable to pop stashed state.,0
2954,internal static string ErrFailedToStashPopState {,Looks up a localized string similar to Unable to pop '{0}'.,0
2955,internal static string ErrFailedToUnsetParameter {,Looks up a localized string similar to Unable to unset parameter.,0
2956,internal static string ErrFailedToUnstage {,Looks up a localized string similar to Unable to unstage.,0
2957,internal static string ErrFailedToUpdateSubmodule {,Looks up a localized string similar to Unable to update submodule.,0
2958,internal static string ErrfFailedToQueryBlob {,Looks up a localized string similar to Unable to extract file '{0}'.,0
2959,internal static string ErrInvalidBranchName {,Looks up a localized string similar to Invalid branch name.,0
2960,internal static string ErrInvalidEmail {,Looks up a localized string similar to Invalid email.,0
2961,internal static string ErrInvalidMessage {,Looks up a localized string similar to Invalid message.,0
2962,internal static string ErrInvalidParameterName {,Looks up a localized string similar to Invalid parameter name.,0
2963,internal static string ErrInvalidReferenceName {,Looks up a localized string similar to Invalid reference name.,0
2964,internal static string ErrInvalidRefspec {,Looks up a localized string similar to Invalid refspec.,0
2965,internal static string ErrInvalidRemoteName {,Looks up a localized string similar to Invalid remote name.,0
2966,internal static string ErrInvalidRevisionExpression {,Looks up a localized string similar to Invalid revision expression.,0
2967,internal static string ErrInvalidTagName {,Looks up a localized string similar to Invalid tag name.,0
2968,internal static string ErrInvalidUrl {,Looks up a localized string similar to Invalid URL.,0
2969,internal static string ErrInvalidUserName {,Looks up a localized string similar to Invalid user name.,0
2970,internal static string ErrKeyIdCannotBeEmpty {,Looks up a localized string similar to You must specify a valid GPG key ID.,0
2971,internal static string ErrMessageCannotBeEmpty {,Looks up a localized string similar to Message cannot be empty.,0
2972,internal static string ErrNameCannotBeEmpty {,Looks up a localized string similar to {0} name cannot not be empty.,0
2973,internal static string ErrNameCannotBeginWithCharacter {,Looks up a localized string similar to {0} name cannot begin with '{1}' character.,0
2974,internal static string ErrNameCannotBeginWithSequence {,Looks up a localized string similar to {0} name cannot begin with '{1}' sequence.,0
2975,internal static string ErrNameCannotContainASCIIControlCharacters {,Looks up a localized string similar to {0} name cannot contain ASCII control characters.,0
2976,internal static string ErrNameCannotContainCharacter {,Looks up a localized string similar to {0} name cannot contain '{1}' character.,0
2977,internal static string ErrNameCannotContainSequence {,Looks up a localized string similar to {0} name cannot contain '{1}' sequence.,0
2978,internal static string ErrNameCannotEndWithCharacter {,Looks up a localized string similar to {0} name cannot end with '{1}' character.,0
2979,internal static string ErrNameCannotEndWithSequence {,Looks up a localized string similar to {0} name cannot end with '{1}' sequence.,0
2980,internal static string ErrNoBranchesSelected {,Looks up a localized string similar to No branches selected.,0
2981,internal static string ErrNoBranchNameSpecified {,Looks up a localized string similar to No branch name specified.,0
2982,internal static string ErrNofilesStagedForCommit {,Looks up a localized string similar to No files staged for commit.,0
2983,internal static string ErrNoKeyIdSpecified {,Looks up a localized string similar to No key ID specified.,0
2984,internal static string ErrNoMessageSpecified {,Looks up a localized string similar to No message specified.,0
2985,internal static string ErrNoPathSpecified {,Looks up a localized string similar to No path specified.,0
2986,internal static string ErrNoRemoteNameSpecified {,Looks up a localized string similar to No remote name specified.,0
2987,internal static string ErrNoTagNameSpecified {,Looks up a localized string similar to No tag name specified.,0
2988,internal static string ErrNothingToCommit {,Looks up a localized string similar to Nothing to commit.,0
2989,internal static string ErrNoUrlSpecified {,Looks up a localized string similar to No URL Specified.,0
2990,internal static string ErrParameterNameCannotBeEmpty {,Looks up a localized string similar to Parameter name cannot be empty.,0
2991,internal static string ErrPathCannotBeEmpty {,Looks up a localized string similar to Path cannot be empty.,0
2992,internal static string ErrPushFailed {,Looks up a localized string similar to Push to '{0}' failed.,0
2993,internal static string ErrRefspecCannotBeEmpty {,Looks up a localized string similar to Refspec cannot be empty.,0
2994,internal static string ErrRefspecCannotContainSpaces {,Looks up a localized string similar to Refspec cannot contain spaces.,0
2995,internal static string ErrShortCommitMessage {,Looks up a localized string similar to Message is too short.,0
2996,internal static string ErrSlashSeparatedComponentCannotBeginWithCharacter {,Looks up a localized string similar to Slash-separated component cannot begin with '{0}' character.,0
2997,internal static string ErrStartingRevisionCannotBeEmpty {,Looks up a localized string similar to Starting revision cannot be empty.,0
2998,internal static string ErrUrlCannotBeEmpty {,Looks up a localized string similar to URL cannot be empty.,0
2999,internal static string ErrYouMustSelectBranchesToPush {,Looks up a localized string similar to You must select at least 1 branch to push.,0
3000,internal static string ErrYouMustSpecifyBranchToMergeWith {,Looks up a localized string similar to You must specify a valid branch to merge with.,0
3001,internal static string ExcAllObjectsMustBeHandledByThisRepository {,Looks up a localized string similar to All {0} must be handled by this repository..,0
3002,internal static string ExcAtLeastOneOfSuppliedObjectIsDeleted {,Looks up a localized string similar to At least one of supplied {0} is deleted..,0
3003,internal static string ExcCantDoOnDetachedHead {,Looks up a localized string similar to Can't {0} on detached HEAD..,0
3004,internal static string ExcCantDoOnEmptyRepository {,Looks up a localized string similar to Can't {0} on empty repository..,0
3005,internal static string ExcCollectionMustContainAtLeastOneObject {,Looks up a localized string similar to Collection must contain at least 1 {0}..,0
3006,internal static string ExcCollectionMustNotContainNullElements {,Looks up a localized string similar to Collection must not contain null elements..,0
3007,internal static string ExcObjectIsDeleted {,Looks up a localized string similar to {0} is deleted..,0
3008,internal static string ExcObjectWithThisNameAlreadyExists {,Looks up a localized string similar to {0} with this name already exists..,0
3009,internal static string ExcStashIsEmpty {,Looks up a localized string similar to Stash is empty..,0
3010,internal static string ExcSuppliedObjectIsDeleted {,Looks up a localized string similar to Supplied {0} is deleted..,0
3011,internal static string ExcSuppliedObjectIsNotHandledByThisRepository {,Looks up a localized string similar to Supplied {0} is not handled by this repository..,0
3012,internal static string ExcSuppliedRevisionIsDeleted {,Looks up a localized string similar to Supplied revision pointer is deleted..,0
3013,internal static string ExcSuppliedRevisionIsNotHandledByThisRepository {,Looks up a localized string similar to Supplied revision pointer is not handled by this repository..,0
3014,internal static string StrArchive {,Looks up a localized string similar to Archive.,0
3015,internal static string StrBranches {,Looks up a localized string similar to Branches.,0
3016,internal static string StrChangedFiles {,Looks up a localized string similar to Changed Files.,0
3017,internal static string StrChangeIdentity {,Looks up a localized string similar to Change Identity.,0
3018,internal static string StrCheckout {,Looks up a localized string similar to Checkout.,0
3019,internal static string StrCheckoutAfterCreation {,Looks up a localized string similar to Checkout after creation.,0
3020,internal static string StrCherryPick {,Looks up a localized string similar to Cherry-Pick.,0
3021,internal static string StrClean {,Looks up a localized string similar to Clean.,0
3022,internal static string StrCleanIgnored {,Looks up a localized string similar to Clean Ignored.,0
3023,internal static string StrCleanUntracked {,Looks up a localized string similar to Clean Untracked.,0
3024,internal static string StrClear {,Looks up a localized string similar to Clear.,0
3025,internal static string StrClone {,Looks up a localized string similar to Clone.,0
3026,internal static string StrClose {,Looks up a localized string similar to Close.,0
3027,internal static string StrCollapseAll {,Looks up a localized string similar to Collapse All.,0
3028,internal static string StrCommit {,Looks up a localized string similar to Commit.,0
3029,internal static string StrCommitDate {,Looks up a localized string similar to Commit Date.,0
3030,internal static string StrCommits {,Looks up a localized string similar to Commits.,0
3031,internal static string StrCommitter {,Looks up a localized string similar to Committer.,0
3032,internal static string StrCommitterEmail {,Looks up a localized string similar to Committer Email.,0
3033,internal static string StrCommitters {,Looks up a localized string similar to Committers.,0
3034,internal static string StrCompare {,Looks up a localized string similar to Compare.,0
3035,internal static string StrCompareWith {,Looks up a localized string similar to Compare With.,0
3036,internal static string StrCompleted {,Looks up a localized string similar to Completed.,0
3037,internal static string StrConfig {,Looks up a localized string similar to Configuration.,0
3038,internal static string StrConflictingFiles {,Looks up a localized string similar to Conflicting Files.,0
3039,internal static string StrConflictResolution {,Looks up a localized string similar to Conflict Resolution.,0
3040,internal static string StrConflicts {,Looks up a localized string similar to Conflicts.,0
3041,internal static string StrContext {,Looks up a localized string similar to Context.,0
3042,internal static string StrContinue {,Looks up a localized string similar to Continue.,0
3043,internal static string StrContributors {,Looks up a localized string similar to Contributors.,0
3044,internal static string StrCopy {,Looks up a localized string similar to Copy.,0
3045,internal static string StrCopyAsPatch {,Looks up a localized string similar to Copy as Patch.,0
3046,internal static string StrCopyNewVersion {,Looks up a localized string similar to Copy New Version.,0
3047,internal static string StrCopyOldVersion {,Looks up a localized string similar to Copy Old Version.,0
3048,internal static string StrCopyToClipboard {,Looks up a localized string similar to Copy to Clipboard.,0
3049,internal static string StrCreate {,Looks up a localized string similar to Create.,0
3050,internal static string StrCreateBranchReflog {,Looks up a localized string similar to Create branch reflog.,0
3051,internal static string StrDate {,Looks up a localized string similar to Date.,0
3052,internal static string StrDateFormat {,Looks up a localized string similar to Date Format.,0
3053,internal static string StrDateOrder {,Looks up a localized string similar to Date Order.,0
3054,internal static string StrDefault {,Looks up a localized string similar to Default.,0
3055,internal static string StrDefaultBehavior {,Looks up a localized string similar to Default Behavior.,0
3056,internal static string StrDefaultFormat {,Looks up a localized string similar to Default Format.,0
3057,internal static string StrDelete {,Looks up a localized string similar to Delete.,0
3058,internal static string StrDeleteFile {,Looks up a localized string similar to Delete File.,0
3059,internal static string StrDepth {,Looks up a localized string similar to Depth.,0
3060,internal static string StrDontFetchTags {,Looks up a localized string similar to Don't fetch tags.,0
3061,internal static string StrDontTrack {,Looks up a localized string similar to Don't Track.,0
3062,internal static string StrDrop {,Looks up a localized string similar to Drop.,0
3063,internal static string StrEdit {,Looks up a localized string similar to Edit.,0
3064,internal static string StrEditValue {,Looks up a localized string similar to Edit Value.,0
3065,internal static string StrEmail {,Looks up a localized string similar to Email.,0
3066,internal static string StrExample {,Looks up a localized string similar to Example.,0
3067,internal static string StrExcludePattern {,Looks up a localized string similar to Exclude Pattern.,0
3068,internal static string StrExpandAll {,Looks up a localized string similar to Expand All.,0
3069,internal static string StrfCloning {,Looks up a localized string similar to Cloning {0}.,0
3070,internal static string StrfCreatingArchiveFrom {,Looks up a localized string similar to Creating archive from '{0}'.,0
3071,internal static string StrFetch {,Looks up a localized string similar to Fetch.,0
3072,internal static string StrFetchAll {,Looks up a localized string similar to Fetch All.,0
3073,internal static string StrFetchingDataFrom {,Looks up a localized string similar to Fetching data from '{0}'....,0
3074,internal static string StrFetchingDataFromRemoteRepository {,Looks up a localized string similar to Fetching data from remote repository....,0
3075,internal static string StrFetchNone {,Looks up a localized string similar to Fetch None.,0
3076,internal static string StrFetchTags {,Looks up a localized string similar to Fetch Tags.,0
3077,internal static string StrFetchUrl {,Looks up a localized string similar to Fetch Url.,0
3078,internal static string StrFileName {,Looks up a localized string similar to File Name.,0
3079,internal static string StrFiles {,Looks up a localized string similar to Files.,0
3080,internal static string StrFilter {,Looks up a localized string similar to Filter.,0
3081,internal static string StrFind {,Looks up a localized string similar to Find.,0
3082,internal static string StrForceOverwriteRemoteBranches {,Looks up a localized string similar to Force overwrite remote branches.,0
3083,internal static string StrFrom {,Looks up a localized string similar to From.,0
3084,internal static string StrFullName {,Looks up a localized string similar to Full Name.,0
3085,internal static string StrFullPath {,Looks up a localized string similar to Full Path.,0
3086,internal static string StrfVersionRequired {,Looks up a localized string similar to v.{0} is required.,0
3087,internal static string StrGoUpOneLevel {,Looks up a localized string similar to Go Up One Level.,0
3088,internal static string StrGraph {,Looks up a localized string similar to Graph.,0
3089,internal static string StrHard {,Looks up a localized string similar to Hard.,0
3090,internal static string StrHardReset {,Looks up a localized string similar to Hard Reset.,0
3091,internal static string StrHeads {,Looks up a localized string similar to Heads.,0
3092,internal static string StrHideDetails {,Looks up a localized string similar to Hide Details.,0
3093,internal static string StrHistory {,Looks up a localized string similar to History.,0
3094,internal static string StrHorizontalSplit {,Looks up a localized string similar to Horizontal Split.,0
3095,internal static string StrHousekeeping {,Looks up a localized string similar to Housekeeping.,0
3096,internal static string StrIgnored {,Looks up a localized string similar to Ignored.,0
3097,internal static string StrIgnoreWhitespaces {,Looks up a localized string similar to Ignore Whitespaces.,0
3098,internal static string StrIncludeIgnored {,Looks up a localized string similar to Include ignored.,0
3099,internal static string StrIncludePattern {,Looks up a localized string similar to Include Pattern.,0
3100,internal static string StrIncludeUntracked {,Looks up a localized string similar to Include untracked.,0
3101,internal static string StrIntegration {,Looks up a localized string similar to Integration.,0
3102,internal static string StrKeep {,Looks up a localized string similar to Keep.,0
3103,internal static string StrKeepFile {,Looks up a localized string similar to Keep File.,0
3104,internal static string StrKeepIndex {,Looks up a localized string similar to Keep index.,0
3105,internal static string StrlAdded {,Looks up a localized string similar to added.,0
3106,internal static string StrlBash {,Looks up a localized string similar to bash.,0
3107,internal static string StrlBinary {,Looks up a localized string similar to binary.,0
3108,internal static string StrlBlame {,Looks up a localized string similar to blame.,0
3109,internal static string StrlCommits {,Looks up a localized string similar to commits.,0
3110,internal static string StrlConfigure {,Looks up a localized string similar to configure.,0
3111,internal static string StrlCopied {,Looks up a localized string similar to copied.,0
3112,internal static string StrlCopy {,Looks up a localized string similar to copy.,0
3113,internal static string StrlDeleted {,Looks up a localized string similar to deleted.,0
3114,internal static string StrlDoNotTrack {,Looks up a localized string similar to Do not track.,0
3115,internal static string StrlDownload {,Looks up a localized string similar to download.,0
3116,internal static string StrLessContext {,Looks up a localized string similar to Less Context.,0
3117,internal static string StrlGitk {,Looks up a localized string similar to gitk.,0
3118,internal static string StrlGoToDownloadPage {,Looks up a localized string similar to go to download page.,0
3119,internal static string StrlGui {,Looks up a localized string similar to gui.,0
3120,internal static string StrLinesOfContext {,Looks up a localized string similar to Lines of Context.,0
3121,internal static string StrlMakeOrphanBranch {,Looks up a localized string similar to Make orphan branch.,0
3122,internal static string StrlModified {,Looks up a localized string similar to modified.,0
3123,internal static string StrlNone {,Looks up a localized string similar to none.,0
3124,internal static string StrlNoPathSpecified {,Looks up a localized string similar to no path specified.,0
3125,internal static string StrlNoSubdirectories {,Looks up a localized string similar to no subdirectories.,0
3126,internal static string StrlNotInstalled {,Looks up a localized string similar to not installed.,0
3127,internal static string StrLoadingBranches {,Looks up a localized string similar to Loading branches.,0
3128,internal static string StrLoadingConfiguration {,Looks up a localized string similar to Loading configuration.,0
3129,internal static string StrLoadingHEAD {,Looks up a localized string similar to Loading HEAD.,0
3130,internal static string StrLoadingHistory {,Looks up a localized string similar to Loading history.,0
3131,internal static string StrLoadingNotes {,Looks up a localized string similar to Loading Notes.,0
3132,internal static string StrLoadingReferences {,Looks up a localized string similar to Loading refrerences.,0
3133,internal static string StrLoadingRemotes {,Looks up a localized string similar to Loading remotes.,0
3134,internal static string StrLoadingRepository {,Looks up a localized string similar to Loading repository.,0
3135,internal static string StrLoadingStash {,Looks up a localized string similar to Loading stash.,0
3136,internal static string StrLoadingStatus {,Looks up a localized string similar to Loading status.,0
3137,internal static string StrLoadingSubmodules {,Looks up a localized string similar to Loading Submodules.,0
3138,internal static string StrLoadingTags {,Looks up a localized string similar to Loading tags.,0
3139,internal static string StrLoadingUsers {,Looks up a localized string similar to Loading users.,0
3140,internal static string StrLocalBranches {,Looks up a localized string similar to Local Branches.,0
3141,internal static string StrLookingForFiles {,Looks up a localized string similar to Looking for files.,0
3142,internal static string StrlRenamed {,Looks up a localized string similar to renamed.,0
3143,internal static string StrlRequiredVersionIs {,Looks up a localized string similar to required git version {0}.,0
3144,internal static string StrlTrackSpecifiedBranches {,Looks up a localized string similar to Specified branches.,0
3145,internal static string StrlUnlimited {,Looks up a localized string similar to unlimited.,0
3146,internal static string StrlUnmerged {,Looks up a localized string similar to unmerged.,0
3147,internal static string StrlUnmergedFilesPresent {,Looks up a localized string similar to unresolved conflicts.,0
3148,internal static string StrlUnstagedRemovedFiles {,Looks up a localized string similar to unstaged removed files.,0
3149,internal static string StrlUnstagedUntrackedFiles {,Looks up a localized string similar to untracked files.,0
3150,internal static string StrlUpdate {,Looks up a localized string similar to update.,0
3151,internal static string StrlUserIdentityNotConfigured {,Looks up a localized string similar to user identity is not configured.,0
3152,internal static string StrMaintenance {,Looks up a localized string similar to Maintenance.,0
3153,internal static string StrManage {,Looks up a localized string similar to Manage.,0
3154,internal static string StrManageRemotes {,Looks up a localized string similar to Manage Remotes.,0
3155,internal static string StrManageSubmodules {,Looks up a localized string similar to Manage Submodules.,0
3156,internal static string StrManual {,Looks up a localized string similar to Manual.,0
3157,internal static string StrManualStage {,Looks up a localized string similar to Manual Stage.,0
3158,internal static string StrMarkAsResolved {,Looks up a localized string similar to Mark as Resolved.,0
3159,internal static string StrMatchCase {,Looks up a localized string similar to Match Case.,0
3160,internal static string StrMessage {,Looks up a localized string similar to Message.,0
3161,internal static string StrMirror {,Looks up a localized string similar to Mirror.,0
3162,internal static string StrMixed {,Looks up a localized string similar to Mixed.,0
3163,internal static string StrModified {,Looks up a localized string similar to Modified.,0
3164,internal static string StrModifiedFiles {,Looks up a localized string similar to Modified Files.,0
3165,internal static string StrMoreContext {,Looks up a localized string similar to More Context.,0
3166,internal static string StrName {,Looks up a localized string similar to Name.,0
3167,internal static string StrNewName {,Looks up a localized string similar to New name.,0
3168,internal static string StrNext {,Looks up a localized string similar to Next.,0
3169,internal static string StrNoBranch {,Looks up a localized string similar to (no branch).,0
3170,internal static string StrNoBranchesToMergeWith {,Looks up a localized string similar to No branches to merge with.,0
3171,internal static string StrNoChangedFiles {,Looks up a localized string similar to No changed files.,0
3172,internal static string StrNoCheckout {,Looks up a localized string similar to No Checkout.,0
3173,internal static string StrNoCommit {,Looks up a localized string similar to No commit.,0
3174,internal static string StrNoCommitsToDisplay {,Looks up a localized string similar to No commits to display.,0
3175,internal static string StrNoFastForward {,Looks up a localized string similar to No fast-forward.,0
3176,internal static string StrNoLocalBranches {,Looks up a localized string similar to No local branches.,0
3177,internal static string StrNone {,Looks up a localized string similar to None.,0
3178,internal static string StrNoRemotes {,Looks up a localized string similar to No remotes.,0
3179,internal static string StrNormal {,Looks up a localized string similar to Normal.,0
3180,internal static string StrNoStagedChanges {,Looks up a localized string similar to No staged changes.,0
3181,internal static string StrNoSubmodules {,Looks up a localized string similar to No submodules.,0
3182,internal static string StrNothingStashed {,Looks up a localized string similar to Nothing stashed.,0
3183,internal static string StrNoUnstagedChanges {,Looks up a localized string similar to No unstaged changes.,0
3184,internal static string StrOpen {,Looks up a localized string similar to Open.,0
3185,internal static string StrOpenCommandLine {,Looks up a localized string similar to Open Command Line.,0
3186,internal static string StrOpenContainingFolder {,Looks up a localized string similar to Open Containing Folder.,0
3187,internal static string StrOpenInWindowsExplorer {,Looks up a localized string similar to Open in Windows Explorer.,0
3188,internal static string StrOpenWith {,Looks up a localized string similar to Open With.,0
3189,internal static string StrOpenWithGitter {,Looks up a localized string similar to Open with gitter.,0
3190,internal static string StrOptimizingRepository {,Looks up a localized string similar to Optimizing repository.,0
3191,internal static string StrOptionalMessage {,Looks up a localized string similar to Message (optional).,0
3192,internal static string StrOptions {,Looks up a localized string similar to Options.,0
3193,internal static string StrOrphan {,Looks up a localized string similar to Orphan.,0
3194,internal static string StrParameter {,Looks up a localized string similar to Parameter.,0
3195,internal static string StrParent {,Looks up a localized string similar to Parent.,0
3196,internal static string StrParents {,Looks up a localized string similar to Parents.,0
3197,internal static string StrPatch {,Looks up a localized string similar to Patch.,0
3198,internal static string StrPatches {,Looks up a localized string similar to Patches.,0
3199,internal static string StrPath {,Looks up a localized string similar to Path.,0
3200,internal static string StrPattern {,Looks up a localized string similar to Pattern.,0
3201,internal static string StrPerformingStashApply {,Looks up a localized string similar to Applying stashed changes.,0
3202,internal static string StrPerformingStashDrop {,Looks up a localized string similar to Removing stashed changes.,0
3203,internal static string StrPerformingStashPop {,Looks up a localized string similar to Applying stashed changes.,0
3204,internal static string StrPerformingStashSave {,Looks up a localized string similar to Stashing working directory changes.,0
3205,internal static string StrPop {,Looks up a localized string similar to Pop.,0
3206,internal static string StrPosition {,Looks up a localized string similar to Position.,0
3207,internal static string StrPrevious {,Looks up a localized string similar to Previous.,0
3208,internal static string StrProceed {,Looks up a localized string similar to Proceed.,0
3209,internal static string StrProxy {,Looks up a localized string similar to Proxy.,0
3210,internal static string StrPruneRemote {,Looks up a localized string similar to Prune.,0
3211,internal static string StrPull {,Looks up a localized string similar to Pull.,0
3212,internal static string StrPush {,Looks up a localized string similar to Push.,0
3213,internal static string StrPushTo {,Looks up a localized string similar to Push to.,0
3214,internal static string StrPushUrl {,Looks up a localized string similar to Push Url.,0
3215,internal static string StrRebase {,Looks up a localized string similar to Rebase.,0
3216,internal static string StrRebaseBranchHere {,Looks up a localized string similar to Rebase '{0}' Here.,0
3217,internal static string StrRebaseHere {,Looks up a localized string similar to Rebase Here.,0
3218,internal static string StrReceivePack {,Looks up a localized string similar to Receive Pack.,0
3219,internal static string StrRecursive {,Looks up a localized string similar to Recursive.,0
3220,internal static string StrReferences {,Looks up a localized string similar to References.,0
3221,internal static string StrRefreshingBranches {,Looks up a localized string similar to Refreshing branches.,0
3222,internal static string StrRefreshingReferences {,Looks up a localized string similar to Refreshing references.,0
3223,internal static string StrRefreshingTags {,Looks up a localized string similar to Refreshing tags.,0
3224,internal static string StrRefs {,Looks up a localized string similar to Refs.,0
3225,internal static string StrRefspec {,Looks up a localized string similar to Refspec.,0
3226,internal static string StrRelative {,Looks up a localized string similar to Relative.,0
3227,internal static string StrRelativePath {,Looks up a localized string similar to Relative Path.,0
3228,internal static string StrRemotes {,Looks up a localized string similar to Remotes.,0
3229,internal static string StrRemove {,Looks up a localized string similar to Remove.,0
3230,internal static string StrRemoved {,Looks up a localized string similar to Removed.,0
3231,internal static string StrRemovedFiles {,Looks up a localized string similar to Removed Files.,0
3232,internal static string StrRemoveObject {,Looks up a localized string similar to Remove '{0}'.,0
3233,internal static string StrRemovingStashedChanges {,Looks up a localized string similar to Removing stashed changes.,0
3234,internal static string StrRename {,Looks up a localized string similar to Rename.,0
3235,internal static string StrRequiredVersion {,Looks up a localized string similar to Required git Version.,0
3236,internal static string StrReset {,Looks up a localized string similar to Reset.,0
3237,internal static string StrResetBranchHere {,Looks up a localized string similar to Reset '{0}' Here.,0
3238,internal static string StrResetHere {,Looks up a localized string similar to Reset Here.,0
3239,internal static string StrResolveConflict {,Looks up a localized string similar to Resolve Conflict.,0
3240,internal static string StrResolveConflicts {,Looks up a localized string similar to Resolve Conflicts.,0
3241,internal static string StrReverse {,Looks up a localized string similar to Reverse.,0
3242,internal static string StrRevert {,Looks up a localized string similar to Revert.,0
3243,internal static string StrRevertCommit {,Looks up a localized string similar to Revert Commit.,0
3244,internal static string StrRevisions {,Looks up a localized string similar to Revisions.,0
3245,internal static string StrRFC2822 {,Looks up a localized string similar to RFC2822.,0
3246,internal static string StrRightAlignedDetails {,Looks up a localized string similar to Right-aligned Details.,0
3247,internal static string StrRun {,Looks up a localized string similar to Run.,0
3248,internal static string StrRunMergeTool {,Looks up a localized string similar to Run Merge Tool.,0
3249,internal static string StrRunningMergeTool {,Looks up a localized string similar to Merge tool is running.,0
3250,internal static string StrsAbortingCherryPick {,Looks up a localized string similar to Aboring cherry-pick.,0
3251,internal static string StrsAbortingRebase {,Looks up a localized string similar to Aborting rebase.,0
3252,internal static string StrsAbortingRevert {,Looks up a localized string similar to Aborting revert.,0
3253,internal static string StrsAlsoRemoveDirectories {,Looks up a localized string similar to Also remove directories.,0
3254,internal static string StrsAppendRepositoryNameFromURL {,Looks up a localized string similar to Append repository name from URL to path.,0
3255,internal static string StrSave {,Looks up a localized string similar to Save.,0
3256,internal static string StrSavePatch {,Looks up a localized string similar to Save Patch.,0
3257,internal static string StrsCheckoutPathWarning {,"Looks up a localized string similar to You have unstaged changes to file '{0}'. If you continue, these changes will be lost. Proceed?.",0
3258,internal static string StrsCherryPickIsInProcess {,Looks up a localized string similar to Cherry-pick is in process.,0
3259,internal static string StrsCleaningStash {,Looks up a localized string similar to Cleaning stash.,0
3260,internal static string StrsContinuingCherryPick {,Looks up a localized string similar to Continuing cherry-pick.,0
3261,internal static string StrsContinuingRebase {,Looks up a localized string similar to Continuing rebase.,0
3262,internal static string StrsContinuingRevert {,Looks up a localized string similar to Continuing revert.,0
3263,internal static string StrsDeleteFile {,Looks up a localized string similar to Delete file.,0
3264,internal static string StrSearch {,Looks up a localized string similar to Search.,0
3265,internal static string StrSelect {,Looks up a localized string similar to Select.,0
3266,internal static string StrSelectRepositoryPath {,Looks up a localized string similar to Select repository path.,0
3267,internal static string StrSelectTemplateDirectory {,Looks up a localized string similar to Select template directory.,0
3268,internal static string StrSendEmail {,Looks up a localized string similar to Send Email.,0
3269,internal static string StrSendingDataTo {,Looks up a localized string similar to Sending data to '{0}'.,0
3270,internal static string StrSendTags {,Looks up a localized string similar to Send tags.,0
3271,internal static string StrsFetchingBlame {,Looks up a localized string similar to Fetching blame.,0
3272,internal static string StrsFetchingBlob {,Looks up a localized string similar to Fetching blob object from the tree.,0
3273,internal static string StrsFetchingLog {,Looks up a localized string similar to Fetching log.,0
3274,internal static string StrsFetchingPatch {,Looks up a localized string similar to Fetching patch.,0
3275,internal static string StrsFetchingTree {,Looks up a localized string similar to Fetching tree.,0
3276,internal static string StrsForCurrentRepositoryOnly {,Looks up a localized string similar to For current repository only.,0
3277,internal static string StrsForCurrentWindowsUser {,Looks up a localized string similar to For current Windows user.,0
3278,internal static string StrsGravatarDisplayText {,Looks up a localized string similar to Download and show user avatars using gravatar.com.,0
3279,internal static string StrSHA {,Looks up a localized string similar to SHA.,0
3280,internal static string StrShallowClone {,Looks up a localized string similar to Shallow Clone.,0
3281,internal static string StrShowAll {,Looks up a localized string similar to Show All.,0
3282,internal static string StrShowColors {,Looks up a localized string similar to Show Colors.,0
3283,internal static string StrShowCommitDetails {,Looks up a localized string similar to Show Commit Details.,0
3284,internal static string StrShowEmail {,Looks up a localized string similar to Show Email.,0
3285,internal static string StrShowLocalBranches {,Looks up a localized string similar to Show Local Branches.,0
3286,internal static string StrShowStash {,Looks up a localized string similar to Show Stash.,0
3287,internal static string StrShowTags {,Looks up a localized string similar to Show Tags.,0
3288,internal static string StrSigned {,Looks up a localized string similar to Signed.,0
3289,internal static string StrSigning {,Looks up a localized string similar to Signing.,0
3290,internal static string StrsIgnoreWhitespace {,Looks up a localized string similar to Ignore whitespace.,0
3291,internal static string StrSimpleTag {,Looks up a localized string similar to Lightweight.,0
3292,internal static string StrsImportTags {,Looks up a localized string similar to Import tags.,0
3293,internal static string StrsIncludeUntrackedFiles {,Looks up a localized string similar to Include untracked files.,0
3294,internal static string StrSize {,Looks up a localized string similar to Size.,0
3295,internal static string StrsKeepModifiedFile {,Looks up a localized string similar to Keep modified file.,0
3296,internal static string StrSkip {,Looks up a localized string similar to Skip.,0
3297,internal static string StrSkipFetchAll {,Looks up a localized string similar to Skip fetch all.,0
3298,internal static string StrsLookingForFiles {,Looks up a localized string similar to Looking for files.,0
3299,internal static string StrsMergeIsInProcess {,Looks up a localized string similar to Merge is in process.,0
3300,internal static string StrsNoContributorsToDisplay {,Looks up a localized string similar to No contributors to display.,0
3301,internal static string StrsNoFilesToRemove {,Looks up a localized string similar to No files to remove.,0
3302,internal static string StrsNoPatchesToApply {,Looks up a localized string similar to No patches to apply.,0
3303,internal static string StrsObjectsThatWillBeRemoved {,Looks up a localized string similar to Objects that will be removed.,0
3304,internal static string StrSoft {,Looks up a localized string similar to Soft.,0
3305,internal static string StrsQuitingCherryPick {,Looks up a localized string similar to Quiting cherry-pick.,0
3306,internal static string StrsQuitingRevert {,Looks up a localized string similar to Quiting revert.,0
3307,internal static string StrsRebaseIsInProcess {,Looks up a localized string similar to Rebase is in process.,0
3308,internal static string StrsRemovingStashedChanges {,Looks up a localized string similar to Removing stashed changes.,0
3309,internal static string StrsSearchingStaleBranches {,Looks up a localized string similar to Searching stale branches.,0
3310,internal static string StrsSkippingCommit {,Looks up a localized string similar to Skipping commit.,0
3311,internal static string StrStage {,Looks up a localized string similar to Stage.,0
3312,internal static string StrStageAll {,Looks up a localized string similar to Stage All.,0
3313,internal static string StrStagedChanges {,Looks up a localized string similar to Staged Changes.,0
3314,internal static string StrStageFiles {,Looks up a localized string similar to Stage Files.,0
3315,internal static string StrStageSelection {,Looks up a localized string similar to Stage Selection.,0
3316,internal static string StrStartingRevision {,Looks up a localized string similar to Starting revision.,0
3317,internal static string StrStash {,Looks up a localized string similar to Stash.,0
3318,internal static string StrStashApply {,Looks up a localized string similar to Stash Apply.,0
3319,internal static string StrStashClear {,Looks up a localized string similar to Stash Clear.,0
3320,internal static string StrStashDrop {,Looks up a localized string similar to Stash Drop.,0
3321,internal static string StrStashPop {,Looks up a localized string similar to Stash Pop.,0
3322,internal static string StrStashSave {,Looks up a localized string similar to Stash Save.,0
3323,internal static string StrSubject {,Looks up a localized string similar to Subject.,0
3324,internal static string StrSubmodules {,Looks up a localized string similar to Submodules.,0
3325,internal static string StrSummary {,Looks up a localized string similar to Summary.,0
3326,internal static string StrsUpdatingSubmodule {,Looks up a localized string similar to Updating submodule.,0
3327,internal static string StrsUpdatingSubmodules {,Looks up a localized string similar to Updating submodules.,0
3328,internal static string StrsUseOursVersion {,Looks up a localized string similar to Use ours version.,0
3329,internal static string StrsUsePatienceDiffAlgorithm {,Looks up a localized string similar to Use patience diff algorithm.,0
3330,internal static string StrsUseTheirsVersion {,Looks up a localized string similar to Use theirs version.,0
3331,internal static string StrsUseThisUserNameAndEmail {,Looks up a localized string similar to Use this user name and email.,0
3332,internal static string StrsWillBeClonedInto {,Looks up a localized string similar to Will be cloned into.,0
3333,internal static string StrsWorkingDirectory {,Looks up a localized string similar to Working directory.,0
3334,internal static string StrsWorkingDirectoryClean {,Looks up a localized string similar to Working directory clean.,0
3335,internal static string StrSystem {,Looks up a localized string similar to System.,0
3336,internal static string StrTags {,Looks up a localized string similar to Tags.,0
3337,internal static string StrTemplate {,Looks up a localized string similar to Template.,0
3338,internal static string StrTo {,Looks up a localized string similar to To.,0
3339,internal static string StrTopoOrder {,Looks up a localized string similar to Topological Order.,0
3340,internal static string StrTrack {,Looks up a localized string similar to Track.,0
3341,internal static string StrTracking {,Looks up a localized string similar to Tracking.,0
3342,internal static string StrTrackingBranch {,Looks up a localized string similar to Tracking branch.,0
3343,internal static string StrTrackingBranches {,Looks up a localized string similar to Tracking Branches.,0
3344,internal static string StrTrackingMode {,Looks up a localized string similar to Tracking Mode.,0
3345,internal static string StrType {,Looks up a localized string similar to Type.,0
3346,internal static string StrUncommitted {,Looks up a localized string similar to uncommitted.,0
3347,internal static string StrUncommittedLocalChanges {,Looks up a localized string similar to uncommitted staged changes.,0
3348,internal static string StrUNIXTimestamp {,Looks up a localized string similar to UNIX Timestamp.,0
3349,internal static string StrUnresolvedConflictsPresent {,Looks up a localized string similar to unresolved conflicts present.,0
3350,internal static string StrUnset {,Looks up a localized string similar to Unset.,0
3351,internal static string StrUnstage {,Looks up a localized string similar to Unstage.,0
3352,internal static string StrUnstageAll {,Looks up a localized string similar to Unstage All.,0
3353,internal static string StrUnstagedChanges {,Looks up a localized string similar to Unstaged Changes.,0
3354,internal static string StrUnstagedLocalChanges {,Looks up a localized string similar to unstaged local changes.,0
3355,internal static string StrUnstageSelection {,Looks up a localized string similar to Unstage Selection.,0
3356,internal static string StrUntracked {,Looks up a localized string similar to Untracked.,0
3357,internal static string StrUntrackedFiles {,Looks up a localized string similar to Untracked Files.,0
3358,internal static string StrUntrackedFilesPresent {,Looks up a localized string similar to untracked files are present.,0
3359,internal static string StrUpdate {,Looks up a localized string similar to Update.,0
3360,internal static string StrUpdatedReferences {,Looks up a localized string similar to Updated References.,0
3361,internal static string StrUploadPack {,Looks up a localized string similar to Upload Pack.,0
3362,internal static string StrUrl {,Looks up a localized string similar to URL.,0
3363,internal static string StrUseOurs {,Looks up a localized string similar to Use Ours.,0
3364,internal static string StrUsername {,Looks up a localized string similar to Username.,0
3365,internal static string StrUsers {,Looks up a localized string similar to Users.,0
3366,internal static string StrUseTemplateDirectory {,Looks up a localized string similar to Use template directory.,0
3367,internal static string StrUseTheirs {,Looks up a localized string similar to Use Theirs.,0
3368,internal static string StrUseThinPack {,Looks up a localized string similar to Use thin pack.,0
3369,internal static string StrUseWithCaution {,Looks up a localized string similar to Use with caution.,0
3370,internal static string StrValue {,Looks up a localized string similar to Value.,0
3371,internal static string StrVCS {,Looks up a localized string similar to VCS.,0
3372,internal static string StrVerticalSplit {,Looks up a localized string similar to Vertical Split.,0
3373,internal static string StrVisibleReferences {,Looks up a localized string similar to Visible References.,0
3374,internal static string StrWaitingMergeTool {,Looks up a localized string similar to Waiting for merge tool to close.,0
3375,internal static string StrWorkingDirectory {,Looks up a localized string similar to Working Directory.,0
3376,internal static string ErrFailedToOpenRepository {,Looks up a localized string similar to Unable to open repository.,0
3377,internal static string ErrInvalidPath {,Looks up a localized string similar to Invalid path.,0
3378,internal static string ErrPathIsNotValidRepository {,Looks up a localized string similar to '{0}' is not a valid repository..,0
3379,internal static string ErrSpecifiedPathIsNotValidRepository {,Looks up a localized string similar to Specified path is not a valid repository.,0
3380,internal static System.Drawing.Bitmap ImgRepoAddMedium {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3381,internal static System.Drawing.Bitmap ImgRepoCloneMedium {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3382,internal static System.Drawing.Bitmap ImgRepoInitMedium {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3383,internal static System.Drawing.Bitmap ImgRepoScanMedium {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3384,internal static System.Drawing.Bitmap ImgRepositories {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3385,internal static System.Drawing.Bitmap ImgRepository {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3386,internal static System.Drawing.Bitmap ImgRepositoryAdd {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3387,internal static System.Drawing.Bitmap ImgRepositoryCloneSmall {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3388,internal static System.Drawing.Bitmap ImgRepositoryExplorer {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3389,internal static System.Drawing.Bitmap ImgRepositoryInitSmall {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3390,internal static System.Drawing.Bitmap ImgRepositoryLarge {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3391,internal static System.Drawing.Bitmap ImgRepositoryOpen {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3392,internal static System.Drawing.Bitmap ImgRepositoryRemove {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3393,internal static System.Drawing.Bitmap ImgStartPage {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3394,internal static System.Drawing.Bitmap ImgStartPageLogo {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3395,internal static System.Drawing.Bitmap ImgStartPageLogoDark {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3396,internal static System.Drawing.Bitmap ImgStartPageLogoGradient {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3397,internal static System.Drawing.Bitmap ImgStartPageLogoGradientDark {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3398,internal static string StrAbout {,Looks up a localized string similar to About.,0
3399,internal static string StrAdd {,Looks up a localized string similar to Add.,0
3400,internal static string StrAddRepository {,Looks up a localized string similar to Add Repository.,0
3401,internal static string StrAddService {,Looks up a localized string similar to Add Service.,0
3402,internal static string StrCloneRepository {,Looks up a localized string similar to Clone Repository.,0
3403,internal static string StrDescription {,Looks up a localized string similar to Description.,0
3404,internal static string StrExit {,Looks up a localized string similar to Exit.,0
3405,internal static string StrHelp {,Looks up a localized string similar to Help.,0
3406,internal static string StrInit {,Looks up a localized string similar to Init.,0
3407,internal static string StrInitRepository {,Looks up a localized string similar to Init Repository.,0
3408,internal static string StrlNoAvailable {,Looks up a localized string similar to no available.,0
3409,internal static string StrLoadingRepository {,Looks up a localized string similar to Loading Repository.,0
3410,internal static string StrProvider {,Looks up a localized string similar to Provider.,0
3411,internal static string StrRecent {,Looks up a localized string similar to Recent.,0
3412,internal static string StrRemoveRepository {,Looks up a localized string similar to Remove From List.,0
3413,internal static string StrRepositories {,Looks up a localized string similar to Repositories.,0
3414,internal static string StrRepository {,Looks up a localized string similar to Repository.,0
3415,internal static string StrRepositoryExplorer {,Looks up a localized string similar to Repository Explorer.,0
3416,internal static string StrsCheckFailed {,Looks up a localized string similar to Check failed.,0
3417,internal static string StrsCheckingForUpdates {,Looks up a localized string similar to Checking for updates.,0
3418,internal static string StrsClosePageAfterRepositoryLoad {,Looks up a localized string similar to Close page after repository load.,0
3419,internal static string StrStandard {,Looks up a localized string similar to Standard.,0
3420,internal static string StrsShowPageOnStartup {,Looks up a localized string similar to Show page on startup.,0
3421,internal static string StrStartPage {,Looks up a localized string similar to Start Page.,0
3422,internal static string StrsVersionIsAvailable {,Looks up a localized string similar to v{0} is available.,0
3423,internal static string StrsYourVersionIsUpToDate {,Looks up a localized string similar to Your version is up to date.,0
3424,internal static string StrToolbars {,Looks up a localized string similar to Toolbars.,0
3425,internal static string StrTools {,Looks up a localized string similar to Tools.,0
3426,internal static string StrUrl {,Looks up a localized string similar to Url.,0
3427,internal static string StrVersion {,Looks up a localized string similar to Version.,0
3428,internal static string StrView {,Looks up a localized string similar to View.,0
3429,internal static string TipClone {,Looks up a localized string similar to Clone a repository into a new directory.,0
3430,internal static string TipInit {,Looks up a localized string similar to Create an empty repository.,0
3431,internal static string ErrApiKeyCannotBeEmpty {,Looks up a localized string similar to API key cannot be empty.,0
3432,internal static string ErrApiKeyContainsInvalidCharacters {,Looks up a localized string similar to API key contains invalid characters.,0
3433,internal static string ErrApiKeyMustContain40Characters {,Looks up a localized string similar to API key must contain 40 characters.,0
3434,internal static string ErrInvalidApiKey {,Looks up a localized string similar to Invalid API key.,0
3435,internal static string ErrInvalidServiceUri {,Looks up a localized string similar to Invalid service URL.,0
3436,internal static string ErrNoApiKeySpecified {,Looks up a localized string similar to No API key specified.,0
3437,internal static string ErrNoProjectNameSpecified {,Looks up a localized string similar to No project name specified.,0
3438,internal static string ErrNoServiceUriSpecified {,Looks up a localized string similar to No service URL specified.,0
3439,internal static string ErrServiceUriCannotBeEmpty {,Looks up a localized string similar to Service URL cannot be empty.,0
3440,internal static string ErrServiceUriIsNotValid {,Looks up a localized string similar to Specified service URL is not valid.,0
3441,internal static string StrApiKey {,Looks up a localized string similar to API Key.,0
3442,internal static string StrAssignedTo {,Looks up a localized string similar to Assigned To.,0
3443,internal static string StrAuthor {,Looks up a localized string similar to Author.,0
3444,internal static string StrCategory {,Looks up a localized string similar to Category.,0
3445,internal static string StrCreated {,Looks up a localized string similar to Created.,0
3446,internal static string StrCreatedOn {,Looks up a localized string similar to Created On.,0
3447,internal static string StrDoneRation {,Looks up a localized string similar to % Done.,0
3448,internal static string StrDueDate {,Looks up a localized string similar to Due Date.,0
3449,internal static string StrId {,Looks up a localized string similar to Id.,0
3450,internal static string StrIdentifier {,Looks up a localized string similar to Identifier.,0
3451,internal static string StrIssues {,Looks up a localized string similar to Issues.,0
3452,internal static string StrPriority {,Looks up a localized string similar to Priority.,0
3453,internal static string StrRedmineUrl {,Looks up a localized string similar to www.redmine.org.,0
3454,internal static string StrServiceUri {,Looks up a localized string similar to Service URL.,0
3455,internal static string StrsFailedToFetchIssues {,Looks up a localized string similar to Unable to fetch issues.,0
3456,internal static string StrsFailedToFetchNews {,Looks up a localized string similar to Unable to fetch news.,0
3457,internal static string StrsFailedToFetchVersions {,Looks up a localized string similar to Unable to fetch versions.,0
3458,internal static string StrsFetchingIssues {,Looks up a localized string similar to Fetching issues.,0
3459,internal static string StrsFetchingNews {,Looks up a localized string similar to Fetching news.,0
3460,internal static string StrsFetchingVersions {,Looks up a localized string similar to Fetching versions.,0
3461,internal static string StrsNoIssuesToDisplay {,Looks up a localized string similar to No issues to display.,0
3462,internal static string StrsNoNewsToDisplay {,Looks up a localized string similar to No news to display.,0
3463,internal static string StrsNoVersionsToDisplay {,Looks up a localized string similar to No versions to display.,0
3464,internal static string StrStartDate {,Looks up a localized string similar to Start Date.,0
3465,internal static string StrStatus {,Looks up a localized string similar to Status.,0
3466,internal static string StrsUnassigned {,Looks up a localized string similar to unassigned.,0
3467,internal static string StrTitle {,Looks up a localized string similar to Title.,0
3468,internal static string StrTracker {,Looks up a localized string similar to Tracker.,0
3469,internal static string StrUpdated {,Looks up a localized string similar to Updated.,0
3470,internal static string StrUpdatedOn {,Looks up a localized string similar to Updated On.,0
3471,internal static string StrVersions {,Looks up a localized string similar to Versions.,0
3472,internal static string StrInitializing {,Looks up a localized string similar to Initializing.,0
3473,internal static string ErrFailedToRunElevatedProcess {,Looks up a localized string similar to Unable to execute some actions.,0
3474,internal static string ErrSomeOptionsCouldNotBeApplied {,Looks up a localized string similar to Some options could not be applied because gitter was uable to start an elevated process..,0
3475,internal static System.Drawing.Bitmap IcoApplication {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3476,internal static System.Drawing.Bitmap IcoApplicationTerminal {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3477,internal static System.Drawing.Bitmap IcoDocument {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3478,internal static System.Drawing.Bitmap IcoDocumentAccess {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3479,internal static System.Drawing.Bitmap IcoDocumentBinary {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3480,internal static System.Drawing.Bitmap IcoDocumentCode {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3481,internal static System.Drawing.Bitmap IcoDocumentExcel {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3482,internal static System.Drawing.Bitmap IcoDocumentExcelCsv {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3483,internal static System.Drawing.Bitmap IcoDocumentFilm {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3484,internal static System.Drawing.Bitmap IcoDocumentFlashMovie {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3485,internal static System.Drawing.Bitmap IcoDocumentGlobe {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3486,internal static System.Drawing.Bitmap IcoDocumentImage {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3487,internal static System.Drawing.Bitmap IcoDocumentMusic {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3488,internal static System.Drawing.Bitmap IcoDocumentOffice {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3489,internal static System.Drawing.Bitmap IcoDocumentOutlook {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3490,internal static System.Drawing.Bitmap IcoDocumentPdf {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3491,internal static System.Drawing.Bitmap IcoDocumentPhotoshop {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3492,internal static System.Drawing.Bitmap IcoDocumentPhp {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3493,internal static System.Drawing.Bitmap IcoDocumentPowerpoint {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3494,internal static System.Drawing.Bitmap IcoDocumentText {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3495,internal static System.Drawing.Bitmap IcoDocumentVisualStudio {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3496,internal static System.Drawing.Bitmap IcoDocumentWord {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3497,internal static System.Drawing.Bitmap IcoDocumentXaml {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3498,internal static System.Drawing.Bitmap ImgAction {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3499,internal static System.Drawing.Bitmap ImgActionHover {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3500,internal static System.Drawing.Bitmap ImgChecked {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3501,internal static System.Drawing.Bitmap ImgCheckedHover {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3502,internal static System.Drawing.Bitmap ImgCheckIndeterminate {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3503,internal static System.Drawing.Bitmap ImgCheckIndeterminateHover {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3504,internal static System.Drawing.Bitmap ImgChevronCollapse {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3505,internal static System.Drawing.Bitmap ImgChevronCollapseHover {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3506,internal static System.Drawing.Bitmap ImgChevronExpand {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3507,internal static System.Drawing.Bitmap ImgChevronExpandHover {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3508,internal static System.Drawing.Bitmap ImgColumnExtender {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3509,internal static System.Drawing.Bitmap ImgFolder {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3510,internal static System.Drawing.Bitmap ImgGoBack {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3511,internal static System.Drawing.Bitmap ImgGoForward {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3512,internal static System.Drawing.Bitmap ImgGravatar {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3513,internal static System.Drawing.Bitmap ImgLog {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3514,internal static System.Drawing.Bitmap ImgLogDebug {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3515,internal static System.Drawing.Bitmap ImgLogError {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3516,internal static System.Drawing.Bitmap ImgLogInfo {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3517,internal static System.Drawing.Bitmap ImgLogWarning {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3518,internal static System.Drawing.Bitmap ImgMaximize {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3519,internal static System.Drawing.Bitmap ImgMenuCheck {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3520,internal static System.Drawing.Bitmap ImgMinus {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3521,internal static System.Drawing.Bitmap ImgMinusHovered {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3522,internal static System.Drawing.Bitmap ImgNormalize {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3523,internal static System.Drawing.Bitmap ImgPlus {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3524,internal static System.Drawing.Bitmap ImgPlusHovered {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3525,internal static System.Drawing.Bitmap ImgTabMenu {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3526,internal static System.Drawing.Bitmap ImgTabMenuExtends {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3527,internal static System.Drawing.Bitmap ImgTabScrollLeft {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3528,internal static System.Drawing.Bitmap ImgTabScrollRight {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3529,internal static System.Drawing.Bitmap ImgUnchecked {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3530,internal static System.Drawing.Bitmap ImgUncheckedHover {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3531,internal static System.Drawing.Bitmap ImgViewHostClose {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3532,internal static System.Drawing.Bitmap ImgViewHostMenu {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3533,internal static System.Drawing.Bitmap ImgViewHostPin {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3534,internal static System.Drawing.Bitmap ImgWebBrowser {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3535,internal static string StrAbort {,Looks up a localized string similar to Abort.,0
3536,internal static string StrAddColon {,Looks up a localized string similar to {0}:.,0
3537,internal static string StrAddComma {,"Looks up a localized string similar to {0},.",0
3538,internal static string StrAddEllipsis {,Looks up a localized string similar to {0}....,0
3539,internal static string StrAddPeriod {,Looks up a localized string similar to {0}..,0
3540,internal static string StrAntiAlias {,Looks up a localized string similar to AntiAlias.,0
3541,internal static string StrAppearance {,Looks up a localized string similar to Appearance.,0
3542,internal static string StrApply {,Looks up a localized string similar to Apply.,0
3543,internal static string StrBack {,Looks up a localized string similar to Back.,0
3544,internal static string StrBehavior {,Looks up a localized string similar to Behavior.,0
3545,internal static string StrBold {,Looks up a localized string similar to Bold.,0
3546,internal static string StrBottom {,Looks up a localized string similar to Bottom.,0
3547,internal static string StrCancel {,Looks up a localized string similar to Cancel.,0
3548,internal static string StrClearType {,Looks up a localized string similar to ClearType.,0
3549,internal static string StrColors {,Looks up a localized string similar to Colors.,0
3550,internal static string StrColumns {,Looks up a localized string similar to Columns.,0
3551,internal static string StrContrast {,Looks up a localized string similar to Contrast.,0
3552,internal static string StrDefaultFormat {,Looks up a localized string similar to Default.,0
3553,internal static string StrDown {,Looks up a localized string similar to Down.,0
3554,internal static string StrError {,Looks up a localized string similar to Error.,0
3555,internal static string StrException {,Looks up a localized string similar to Exception.,0
3556,internal static string StrFamily {,Looks up a localized string similar to Family.,0
3557,internal static string StrFont {,Looks up a localized string similar to Font.,0
3558,internal static string StrFonts {,Looks up a localized string similar to Fonts.,0
3559,internal static string StrForward {,Looks up a localized string similar to Forward.,0
3560,internal static string StrHide {,Looks up a localized string similar to Hide.,0
3561,internal static string StrIgnore {,Looks up a localized string similar to Ignore.,0
3562,internal static string StrInputFont {,Looks up a localized string similar to Input Font.,0
3563,internal static string StrISO8601 {,Looks up a localized string similar to ISO 8601.,0
3564,internal static string StrItalic {,Looks up a localized string similar to Italic.,0
3565,internal static string StrLeftEdge {,Looks up a localized string similar to Left Edge.,0
3566,internal static string StrLog {,Looks up a localized string similar to Log.,0
3567,internal static string StrNo {,Looks up a localized string similar to No.,0
3568,internal static string StrOk {,Looks up a localized string similar to OK.,0
3569,internal static string StrPageDown {,Looks up a localized string similar to Page Down.,0
3570,internal static string StrPageLeft {,Looks up a localized string similar to Page Left.,0
3571,internal static string StrPageRight {,Looks up a localized string similar to Page Right.,0
3572,internal static string StrPageUp {,Looks up a localized string similar to Page Up.,0
3573,internal static string StrRenderingQuality {,Looks up a localized string similar to Rendering Quality.,0
3574,internal static string StrRetry {,Looks up a localized string similar to Retry.,0
3575,internal static string StrRFC2822 {,Looks up a localized string similar to RFC 2822.,0
3576,internal static string StrRightEdge {,Looks up a localized string similar to Right Edge.,0
3577,internal static string StrSample {,Looks up a localized string similar to Sample.,0
3578,internal static string StrScrollDown {,Looks up a localized string similar to Scroll Down.,0
3579,internal static string StrScrollHere {,Looks up a localized string similar to Scroll Here.,0
3580,internal static string StrScrollLeft {,Looks up a localized string similar to Scroll Left.,0
3581,internal static string StrScrollRight {,Looks up a localized string similar to Scroll Right.,0
3582,internal static string StrScrollUp {,Looks up a localized string similar to Scroll Up.,0
3583,internal static string StrSendBugreport {,Looks up a localized string similar to Send Bugreport.,0
3584,internal static string StrsExplorerContextMenuFeature {,"Looks up a localized string similar to Add ""Run gitter"" item to folder menu in Windows Explorer.",0
3585,internal static string StrShow {,Looks up a localized string similar to Show.,0
3586,internal static string StrsIntegrationFeatures {,Looks up a localized string similar to Integration features.,0
3587,internal static string StrSource {,Looks up a localized string similar to Source.,0
3588,internal static string StrSpelling {,Looks up a localized string similar to Spell Checking.,0
3589,internal static string StrStack {,Looks up a localized string similar to Stack.,0
3590,internal static string StrStop {,Looks up a localized string similar to Stop.,0
3591,internal static string StrStrikeout {,Looks up a localized string similar to Strikeout.,0
3592,internal static string StrStyle {,Looks up a localized string similar to Style.,0
3593,internal static string StrSurroundWithDoubleQuotes {,"Looks up a localized string similar to ""{0}"".",0
3594,internal static string StrSurroundWithSingleQuotes {,Looks up a localized string similar to '{0}'.,0
3595,internal static string StrSystemDefault {,Looks up a localized string similar to System Default.,0
3596,internal static string StrTimestamp {,Looks up a localized string similar to Timestamp.,0
3597,internal static string StrTop {,Looks up a localized string similar to Top.,0
3598,internal static string StrUIFont {,Looks up a localized string similar to UI Font.,0
3599,internal static string StrUnderline {,Looks up a localized string similar to Underline.,0
3600,internal static string StrUp {,Looks up a localized string similar to Up.,0
3601,internal static string StrViewerFont {,Looks up a localized string similar to Text Viewer Font.,0
3602,internal static string StrVisibleColumns {,Looks up a localized string similar to Visible Columns.,0
3603,internal static string StrWebBrowser {,Looks up a localized string similar to Web Browser.,0
3604,internal static string StrYes {,Looks up a localized string similar to Yes.,0
3605,internal static string ErrNoUsernameSpecified {,Looks up a localized string similar to No username specified.,0
3606,internal static string ErrUsernameCannotBeEmpty {,Looks up a localized string similar to Username cannot be empty.,0
3607,internal static System.Drawing.Bitmap ImgBuildType {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3608,internal static System.Drawing.Bitmap ImgStatusError {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3609,internal static System.Drawing.Bitmap ImgStatusFailure {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3610,internal static System.Drawing.Bitmap ImgStatusSuccess {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3611,internal static System.Drawing.Bitmap ImgTeamCity {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3612,internal static string StrBuilds {,Looks up a localized string similar to Builds.,0
3613,internal static string StrNumber {,Looks up a localized string similar to Number.,0
3614,internal static string StrPassword {,Looks up a localized string similar to Password.,0
3615,internal static string StrWebUrl {,Looks up a localized string similar to Web URL.,0
3616,internal static string ExcAutomaticCherryPickFailed {,Looks up a localized string similar to Automatic cherry-pick failed; fix conflicts and then commit the result..,0
3617,internal static string ExcAutomaticMergeFailed {,Looks up a localized string similar to Automatic merge failed; fix conflicts and then commit the result..,0
3618,internal static string ExcCannotWriteConfigFile {,Looks up a localized string similar to Cannot write to the config file..,0
3619,internal static string ExcCommitIsMerge {,Looks up a localized string similar to Commit is a merge..,0
3620,internal static string ExcConfigParameterDoesNotExist {,Looks up a localized string similar to Config parameter does not exist..,0
3621,internal static string ExcConnectionFailure {,Looks up a localized string similar to Unable to establish connection to remote repository..,0
3622,internal static string ExcDirtyWorkingDirectory {,Looks up a localized string similar to Operation cannot be executed on dirty working directory..,0
3623,internal static string ExcHaveConflicts {,Looks up a localized string similar to You have unresolved conflicts..,0
3624,internal static string ExcInvalidBranchName {,Looks up a localized string similar to '{0}' is not a valid branch name..,0
3625,internal static string ExcInvalidConfigFile {,Looks up a localized string similar to Invalid config file..,0
3626,internal static string ExcInvalidSectionOrKey {,Looks up a localized string similar to Section or key is invalid..,0
3627,internal static string ExcInvalidTagName {,Looks up a localized string similar to '{0}' is not a valid tag name..,0
3628,internal static string ExcNoSectionProvided {,Looks up a localized string similar to No section was provided..,0
3629,internal static string ExcUnknownRevision {,Looks up a localized string similar to Unknown revision: '{0}'..,0
3630,internal static string ExcUntrackedFileWouldBeOverwrittenException {,Looks up a localized string similar to Untracked file '{0}' would be overwritten..,0
3631,internal static string ExcYouHaveLocalChanges {,Looks up a localized string similar to You have local changes to '{0}'..,0
3632,internal static string TipRemoteFetchURL {,Looks up a localized string similar to The URL of a remote repository..,0
3633,internal static string TipRemoteProxy {,"Looks up a localized string similar to For remotes that require curl (http, https and ftp), the URL to the proxy to use for that remote. Set to the empty string to disable proxying for this remote..",0
3634,internal static string TipRemotePushURL {,Looks up a localized string similar to The push URL of a remote repository..,0
3635,internal static string TipRemoteReceivePack {,Looks up a localized string similar to The default program to execute on the remote side when pushing..,0
3636,internal static string TipRemoteSkipFetchAll {,"Looks up a localized string similar to If enabled, this remote will be skipped by default when updating using git-fetch or the update subcommand of git-remote..",0
3637,internal static string TipRemoteUploadPack {,Looks up a localized string similar to The default program to execute on the remote side when fetching..,0
3638,internal static string TipRemoteVCS {,Looks up a localized string similar to Setting this to a value <vcs> will cause git to interact with the remote with the git-remote-<vcs> helper..,0
3639,internal static string TipRevertAbort {,Looks up a localized string similar to Cancel the operation and return to the pre-sequence state..,0
3640,internal static string TipRevertContinue {,Looks up a localized string similar to Continue the operation in progress using the information in .git/sequencer. Can be used to continue after resolving conflicts in a failed revert..,0
3641,internal static string TipRevertNoCommit {,Looks up a localized string similar to The revert is done against the beginning state of your index and no commit is created in process..,0
3642,internal static string TipRevertQuit {,Looks up a localized string similar to Forget about the current operation in progress. Can be used to clear the sequencer state after a failed revert..,0
3643,internal static string TipSendTags {,Looks up a localized string similar to All refs under refs/tags are pushed..,0
3644,internal static string TipSoftReset {,"Looks up a localized string similar to Does not touch the index file nor the working tree at all, but requires them to be in a good order..",0
3645,internal static string TipSquash {,"Looks up a localized string similar to Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit or move the HEAD, nor record $GIT_DIR/MERGE_HEAD to cause the next git commit command to create a merge commit..",0
3646,internal static string TipStash {,Looks up a localized string similar to Stash the changes in a dirty working directory away.,0
3647,internal static string TipStashKeepIndex {,Looks up a localized string similar to Do not stash any staged changes.,0
3648,internal static string TipUseTinPack {,Looks up a localized string similar to A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. Enabled by default..,0
3649,internal static string AskOverwriteUntracked {,"Looks up a localized string similar to You have untracked files, which will be overwritten by checking out '{0}'. Proceed?.",0
3650,internal static string AskRemoveConfigParameter {,Looks up a localized string similar to Removing parameter '{0}'.,0
3651,internal static string AskRemoveConfigParameterFromAllFiles {,"Looks up a localized string similar to This parameter is not present in repository's config file, but it is inherited from your user's git config file and/or system config file. Do you want to remove this parameter from all files?.",0
3652,internal static string AskRemoveRemoteReference {,Looks up a localized string similar to Removing remote reference can be dangerous and lead to loss of data. Proceed?.,0
3653,internal static string AskThrowAwayConflictedChanges {,Looks up a localized string similar to You have conflicted files in index. Checking out '{0}' will throw them away. Proceed?.,0
3654,internal static string AskThrowAwayLocalChanges {,Looks up a localized string similar to You have uncommitted local changes. Checking out '{0}' will throw them away. Proceed?.,0
3655,internal static string ErrDirectoryNameCannotEndWithWhitespace {,Looks up a localized string similar to Directory name cannot end with whitespace.,0
3656,internal static string ErrDirectoryNameCannotStartWithWhitespace {,Looks up a localized string similar to Directory name cannot start with whitespace.,0
3657,internal static string ErrfFailedToSaveFile {,Looks up a localized string similar to Unable to save file '{0}'.,0
3658,internal static string ErrPathCannotContainCharacter {,Looks up a localized string similar to Path cannot contain '{0}' character.,0
3659,internal static string ErrPathCannotContainEmptyDirectoryName {,Looks up a localized string similar to Path cannot contain empty directory name.,0
3660,internal static string ErrPathIsTooShort {,Looks up a localized string similar to Path is too short.,0
3661,internal static string ErrPathUnknownSchema {,Looks up a localized string similar to Unknown path schema.,0
3662,internal static System.Drawing.Icon IcoStatusGreen1 {,Looks up a localized resource of type System.Drawing.Icon similar to (Icon).,0
3663,internal static System.Drawing.Icon IcoStatusGreen2 {,Looks up a localized resource of type System.Drawing.Icon similar to (Icon).,0
3664,internal static System.Drawing.Icon IcoStatusGreen3 {,Looks up a localized resource of type System.Drawing.Icon similar to (Icon).,0
3665,internal static System.Drawing.Icon IcoStatusGreen4 {,Looks up a localized resource of type System.Drawing.Icon similar to (Icon).,0
3666,internal static System.Drawing.Icon IcoStatusGreen5 {,Looks up a localized resource of type System.Drawing.Icon similar to (Icon).,0
3667,internal static System.Drawing.Icon IcoStatusGreen6 {,Looks up a localized resource of type System.Drawing.Icon similar to (Icon).,0
3668,internal static System.Drawing.Icon IcoStatusGreen7 {,Looks up a localized resource of type System.Drawing.Icon similar to (Icon).,0
3669,internal static System.Drawing.Icon IcoStatusGreen8 {,Looks up a localized resource of type System.Drawing.Icon similar to (Icon).,0
3670,internal static System.Drawing.Icon IcoStatusGreen9 {,Looks up a localized resource of type System.Drawing.Icon similar to (Icon).,0
3671,internal static System.Drawing.Icon IcoStatusGreen9p {,Looks up a localized resource of type System.Drawing.Icon similar to (Icon).,0
3672,internal static System.Drawing.Bitmap ImgAlignToGraph {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3673,internal static System.Drawing.Bitmap ImgArchive {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3674,internal static System.Drawing.Bitmap ImgBinary {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3675,internal static System.Drawing.Bitmap ImgBlame {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3676,internal static System.Drawing.Bitmap ImgBranch {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3677,internal static System.Drawing.Bitmap ImgBranchAdd {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3678,internal static System.Drawing.Bitmap ImgBranchDel {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3679,internal static System.Drawing.Bitmap ImgBranchProperties {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3680,internal static System.Drawing.Bitmap ImgBranchRemote {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3681,internal static System.Drawing.Bitmap ImgBranchRemoteDel {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3682,internal static System.Drawing.Bitmap ImgBranchRename {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3683,internal static System.Drawing.Bitmap ImgCheckout {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3684,internal static System.Drawing.Bitmap ImgCherryPick {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3685,internal static System.Drawing.Bitmap ImgCherryPickAbort {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3686,internal static System.Drawing.Bitmap ImgCherryPickContinue {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3687,internal static System.Drawing.Bitmap ImgCherryPickQuit {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3688,internal static System.Drawing.Bitmap ImgClean {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3689,internal static System.Drawing.Bitmap ImgClear {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3690,internal static System.Drawing.Bitmap ImgClone {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3691,internal static System.Drawing.Bitmap ImgCommit {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3692,internal static System.Drawing.Bitmap ImgCompress {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3693,internal static System.Drawing.Bitmap ImgConfig {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3694,internal static System.Drawing.Bitmap ImgConfigAdd {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3695,internal static System.Drawing.Bitmap ImgConfigEdit {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3696,internal static System.Drawing.Bitmap ImgConfigRemove {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3697,internal static System.Drawing.Bitmap ImgConfiguration {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3698,internal static System.Drawing.Bitmap ImgCopyToClipboard {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3699,internal static System.Drawing.Bitmap ImgDateOrder {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3700,internal static System.Drawing.Bitmap ImgDelete {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3701,internal static System.Drawing.Bitmap ImgDiff {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3702,internal static System.Drawing.Bitmap ImgDiffSingleView {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3703,internal static System.Drawing.Bitmap ImgDiffSplitView {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3704,internal static System.Drawing.Bitmap ImgDocument {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3705,internal static System.Drawing.Bitmap ImgFetch {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3706,internal static System.Drawing.Bitmap ImgFileDelete {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3707,internal static System.Drawing.Bitmap ImgFileHistory {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3708,internal static System.Drawing.Bitmap ImgFileRevert {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3709,internal static System.Drawing.Bitmap ImgFileStage {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3710,internal static System.Drawing.Bitmap ImgFileUnstage {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3711,internal static System.Drawing.Bitmap ImgFilter {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3712,internal static System.Drawing.Bitmap ImgFolderHistory {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3713,internal static System.Drawing.Bitmap ImgFolderStage {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3714,internal static System.Drawing.Bitmap ImgFolderTree {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3715,internal static System.Drawing.Bitmap ImgFolderUnstage {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3716,internal static System.Drawing.Bitmap ImgFolderUp {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3717,internal static System.Drawing.Bitmap ImgGC {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3718,internal static System.Drawing.Bitmap ImgGit {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3719,internal static System.Drawing.Bitmap ImgGraph {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3720,internal static System.Drawing.Bitmap ImgGraphChildren {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3721,internal static System.Drawing.Bitmap ImgHistory {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3722,internal static System.Drawing.Bitmap ImgInfo48 {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3723,internal static System.Drawing.Bitmap ImgInit {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3724,internal static System.Drawing.Bitmap ImgLessContext {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3725,internal static System.Drawing.Bitmap ImgLinesAdded {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3726,internal static System.Drawing.Bitmap ImgLinesRemoved {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3727,internal static System.Drawing.Bitmap ImgMail {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3728,internal static System.Drawing.Bitmap ImgMailSend {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3729,internal static System.Drawing.Bitmap ImgMarkAsResolved {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3730,internal static System.Drawing.Bitmap ImgMerge {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3731,internal static System.Drawing.Bitmap ImgMoreContext {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3732,internal static System.Drawing.Bitmap ImgNote {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3733,internal static System.Drawing.Bitmap ImgNoteAdd {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3734,internal static System.Drawing.Bitmap ImgNoteDel {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3735,internal static System.Drawing.Bitmap ImgNoteEdit {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3736,internal static System.Drawing.Bitmap ImgOverlayAdd {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3737,internal static System.Drawing.Bitmap ImgOverlayAddStaged {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3738,internal static System.Drawing.Bitmap ImgOverlayCancel {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3739,internal static System.Drawing.Bitmap ImgOverlayChmod {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3740,internal static System.Drawing.Bitmap ImgOverlayConflict {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3741,internal static System.Drawing.Bitmap ImgOverlayCopy {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3742,internal static System.Drawing.Bitmap ImgOverlayDel {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3743,internal static System.Drawing.Bitmap ImgOverlayDelStaged {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3744,internal static System.Drawing.Bitmap ImgOverlayEdit {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3745,internal static System.Drawing.Bitmap ImgOverlayEditStaged {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3746,internal static System.Drawing.Bitmap ImgOverlayOk {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3747,internal static System.Drawing.Bitmap ImgOverlayRename {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3748,internal static System.Drawing.Bitmap ImgPanel {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3749,internal static System.Drawing.Bitmap ImgPatch {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3750,internal static System.Drawing.Bitmap ImgPatchApply {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3751,internal static System.Drawing.Bitmap ImgPatchSave {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3752,internal static System.Drawing.Bitmap ImgPull {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3753,internal static System.Drawing.Bitmap ImgPush {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3754,internal static System.Drawing.Bitmap ImgRebase {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3755,internal static System.Drawing.Bitmap ImgRebaseAbort {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3756,internal static System.Drawing.Bitmap ImgRebaseContinue {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3757,internal static System.Drawing.Bitmap ImgRebaseSkip {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3758,internal static System.Drawing.Bitmap ImgRefresh {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3759,internal static System.Drawing.Bitmap ImgRefsHeads {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3760,internal static System.Drawing.Bitmap ImgRefsRemotes {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3761,internal static System.Drawing.Bitmap ImgRefsTags {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3762,internal static System.Drawing.Bitmap ImgRemote {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3763,internal static System.Drawing.Bitmap ImgRemoteAdd {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3764,internal static System.Drawing.Bitmap ImgRemoteProperties {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3765,internal static System.Drawing.Bitmap ImgRemoteRemove {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3766,internal static System.Drawing.Bitmap ImgRemoteRename {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3767,internal static System.Drawing.Bitmap ImgRemotes {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3768,internal static System.Drawing.Bitmap ImgReset {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3769,internal static System.Drawing.Bitmap ImgRevert {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3770,internal static System.Drawing.Bitmap ImgRevertAbort {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3771,internal static System.Drawing.Bitmap ImgRevertContinue {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3772,internal static System.Drawing.Bitmap ImgRevertQuit {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3773,internal static System.Drawing.Bitmap ImgSearch {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3774,internal static System.Drawing.Bitmap ImgSearchClose {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3775,internal static System.Drawing.Bitmap ImgSearchNext {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3776,internal static System.Drawing.Bitmap ImgSearchPrevious {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3777,internal static System.Drawing.Bitmap ImgSplitPanelHorizontal {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3778,internal static System.Drawing.Bitmap ImgSplitPanelVertical {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3779,internal static System.Drawing.Bitmap ImgStage {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3780,internal static System.Drawing.Bitmap ImgStageAll {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3781,internal static System.Drawing.Bitmap ImgStash {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3782,internal static System.Drawing.Bitmap ImgStashAdd {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3783,internal static System.Drawing.Bitmap ImgStashApply {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3784,internal static System.Drawing.Bitmap ImgStashClear {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3785,internal static System.Drawing.Bitmap ImgStashDel {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3786,internal static System.Drawing.Bitmap ImgStashPop {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3787,internal static System.Drawing.Bitmap ImgStashSave {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3788,internal static System.Drawing.Bitmap ImgStatusClean {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3789,internal static System.Drawing.Bitmap ImgSubmodule {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3790,internal static System.Drawing.Bitmap ImgSubmoduleAdd {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3791,internal static System.Drawing.Bitmap ImgSubmoduleDel {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3792,internal static System.Drawing.Bitmap ImgSubmodules {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3793,internal static System.Drawing.Bitmap ImgTag {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3794,internal static System.Drawing.Bitmap ImgTagAdd {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3795,internal static System.Drawing.Bitmap ImgTagAnnotated {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3796,internal static System.Drawing.Bitmap ImgTagDel {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3797,internal static System.Drawing.Bitmap ImgTerminal {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3798,internal static System.Drawing.Bitmap ImgTopoOrder {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3799,internal static System.Drawing.Bitmap ImgUnstage {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3800,internal static System.Drawing.Bitmap ImgUnstageAll {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3801,internal static System.Drawing.Bitmap ImgUser {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3802,internal static System.Drawing.Bitmap ImgUsers {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3803,internal static System.Drawing.Bitmap ImgUserUnknown {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3804,internal static System.Drawing.Bitmap ImgViewReflog {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3805,internal static System.Drawing.Bitmap ImgViewReflogRemote {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3806,internal static System.Drawing.Bitmap ImgWarning {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3807,internal static System.Drawing.Bitmap ImgWarning48 {,Looks up a localized resource of type System.Drawing.Bitmap.,0
3808,internal static string MsgGitIsNotInstalled {,Looks up a localized string similar to You have no git installed. Please install required minimum version or newer to proceed..,0
3809,internal static string MsgGitSupportWillBeDisabled {,Looks up a localized string similar to git support will be disabled until at least the required version is installed..,0
3810,internal static string MsgGitVersionIsOutdated {,Looks up a localized string similar to Your git version is older than required minimum version. Please install required minimum version or newer to proceed..,0
3811,internal static string MsgGitVersionOk {,"Looks up a localized string similar to Required git version is detected, you may proceed now..",0
3812,internal static string SrtQuit {,Looks up a localized string similar to Quit.,0
3813,internal static string StrAbbreviate {,Looks up a localized string similar to Abbreviate.,0
3814,internal static string StrAccessMethod {,Looks up a localized string similar to Access Method.,0
3815,internal static string StrAdded {,Looks up a localized string similar to Added.,0
3816,internal static string StrAddedFiles {,Looks up a localized string similar to Added Files.,0
3817,internal static string StrAddFiles {,Looks up a localized string similar to Add Files.,0
3818,internal static string StrAddFromClipboard {,Looks up a localized string similar to Add From Clipboard.,0
3819,internal static string StrAddParameter {,Looks up a localized string similar to Add Parameter.,0
3820,internal static string StrAdvancedOptions {,Looks up a localized string similar to Advanced Options.,0
3821,internal static string StrAlignToGraph {,Looks up a localized string similar to Align to Graph.,0
3822,internal static string StrAll {,Looks up a localized string similar to All.,0
3823,internal static string StrAmend {,Looks up a localized string similar to Amend.,0
3824,internal static string StrAnnotatedTag {,Looks up a localized string similar to Annotated.,0
3825,internal static string StrApplyPatches {,Looks up a localized string similar to Apply Patches.,0
3826,internal static string StrApplyTo {,Looks up a localized string similar to Apply to.,0
3827,internal static string StrAskBranchIsNotFullyMerged {,Looks up a localized string similar to The branch '{0}' is not fully merged. Are you sure you want to delete it?.,0
3828,internal static string StrAskDeletePath {,Looks up a localized string similar to You are about to delete '{0}'. Proceed?.,0
3829,internal static string StrAskHardReset {,Looks up a localized string similar to All your changes (both staged and unstaged) will be lost. This operation cannot be undone. Proceed?.,0